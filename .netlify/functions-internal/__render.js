var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[Object.keys(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// node_modules/@sveltejs/kit/dist/install-fetch.js
function dataUriToBuffer(uri) {
  if (!/^data:/i.test(uri)) {
    throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
  }
  uri = uri.replace(/\r?\n/g, "");
  const firstComma = uri.indexOf(",");
  if (firstComma === -1 || firstComma <= 4) {
    throw new TypeError("malformed data: URI");
  }
  const meta = uri.substring(5, firstComma).split(";");
  let charset = "";
  let base64 = false;
  const type = meta[0] || "text/plain";
  let typeFull = type;
  for (let i = 1; i < meta.length; i++) {
    if (meta[i] === "base64") {
      base64 = true;
    } else {
      typeFull += `;${meta[i]}`;
      if (meta[i].indexOf("charset=") === 0) {
        charset = meta[i].substring(8);
      }
    }
  }
  if (!meta[0] && !charset.length) {
    typeFull += ";charset=US-ASCII";
    charset = "US-ASCII";
  }
  const encoding = base64 ? "base64" : "ascii";
  const data = unescape(uri.substring(firstComma + 1));
  const buffer = Buffer.from(data, encoding);
  buffer.type = type;
  buffer.typeFull = typeFull;
  buffer.charset = charset;
  return buffer;
}
async function* toIterator(parts, clone2 = true) {
  for (let part of parts) {
    if ("stream" in part) {
      yield* part.stream();
    } else if (ArrayBuffer.isView(part)) {
      if (clone2) {
        let position = part.byteOffset;
        let end = part.byteOffset + part.byteLength;
        while (position !== end) {
          const size = Math.min(end - position, POOL_SIZE);
          const chunk = part.buffer.slice(position, position + size);
          position += chunk.byteLength;
          yield new Uint8Array(chunk);
        }
      } else {
        yield part;
      }
    } else {
      let position = 0;
      while (position !== part.size) {
        const chunk = part.slice(position, Math.min(part.size, position + POOL_SIZE));
        const buffer = await chunk.arrayBuffer();
        position += buffer.byteLength;
        yield new Uint8Array(buffer);
      }
    }
  }
}
function isFormData(object2) {
  return typeof object2 === "object" && typeof object2.append === "function" && typeof object2.set === "function" && typeof object2.get === "function" && typeof object2.getAll === "function" && typeof object2.delete === "function" && typeof object2.keys === "function" && typeof object2.values === "function" && typeof object2.entries === "function" && typeof object2.constructor === "function" && object2[NAME] === "FormData";
}
function getHeader(boundary, name, field) {
  let header = "";
  header += `${dashes}${boundary}${carriage}`;
  header += `Content-Disposition: form-data; name="${name}"`;
  if (isBlob(field)) {
    header += `; filename="${field.name}"${carriage}`;
    header += `Content-Type: ${field.type || "application/octet-stream"}`;
  }
  return `${header}${carriage.repeat(2)}`;
}
async function* formDataIterator(form, boundary) {
  for (const [name, value] of form) {
    yield getHeader(boundary, name, value);
    if (isBlob(value)) {
      yield* value.stream();
    } else {
      yield value;
    }
    yield carriage;
  }
  yield getFooter(boundary);
}
function getFormDataLength(form, boundary) {
  let length = 0;
  for (const [name, value] of form) {
    length += Buffer.byteLength(getHeader(boundary, name, value));
    length += isBlob(value) ? value.size : Buffer.byteLength(String(value));
    length += carriageLength;
  }
  length += Buffer.byteLength(getFooter(boundary));
  return length;
}
async function consumeBody(data) {
  if (data[INTERNALS$2].disturbed) {
    throw new TypeError(`body used already for: ${data.url}`);
  }
  data[INTERNALS$2].disturbed = true;
  if (data[INTERNALS$2].error) {
    throw data[INTERNALS$2].error;
  }
  let { body } = data;
  if (body === null) {
    return Buffer.alloc(0);
  }
  if (isBlob(body)) {
    body = import_stream.default.Readable.from(body.stream());
  }
  if (Buffer.isBuffer(body)) {
    return body;
  }
  if (!(body instanceof import_stream.default)) {
    return Buffer.alloc(0);
  }
  const accum = [];
  let accumBytes = 0;
  try {
    for await (const chunk of body) {
      if (data.size > 0 && accumBytes + chunk.length > data.size) {
        const error2 = new FetchError(`content size at ${data.url} over limit: ${data.size}`, "max-size");
        body.destroy(error2);
        throw error2;
      }
      accumBytes += chunk.length;
      accum.push(chunk);
    }
  } catch (error2) {
    const error_ = error2 instanceof FetchBaseError ? error2 : new FetchError(`Invalid response body while trying to fetch ${data.url}: ${error2.message}`, "system", error2);
    throw error_;
  }
  if (body.readableEnded === true || body._readableState.ended === true) {
    try {
      if (accum.every((c) => typeof c === "string")) {
        return Buffer.from(accum.join(""));
      }
      return Buffer.concat(accum, accumBytes);
    } catch (error2) {
      throw new FetchError(`Could not create Buffer from response body for ${data.url}: ${error2.message}`, "system", error2);
    }
  } else {
    throw new FetchError(`Premature close of server response while trying to fetch ${data.url}`);
  }
}
function fromRawHeaders(headers = []) {
  return new Headers(headers.reduce((result, value, index2, array) => {
    if (index2 % 2 === 0) {
      result.push(array.slice(index2, index2 + 2));
    }
    return result;
  }, []).filter(([name, value]) => {
    try {
      validateHeaderName(name);
      validateHeaderValue(name, String(value));
      return true;
    } catch {
      return false;
    }
  }));
}
async function fetch(url, options_) {
  return new Promise((resolve2, reject) => {
    const request = new Request(url, options_);
    const options2 = getNodeRequestOptions(request);
    if (!supportedSchemas.has(options2.protocol)) {
      throw new TypeError(`node-fetch cannot load ${url}. URL scheme "${options2.protocol.replace(/:$/, "")}" is not supported.`);
    }
    if (options2.protocol === "data:") {
      const data = dataUriToBuffer$1(request.url);
      const response2 = new Response(data, { headers: { "Content-Type": data.typeFull } });
      resolve2(response2);
      return;
    }
    const send = (options2.protocol === "https:" ? import_https.default : import_http.default).request;
    const { signal } = request;
    let response = null;
    const abort = () => {
      const error2 = new AbortError("The operation was aborted.");
      reject(error2);
      if (request.body && request.body instanceof import_stream.default.Readable) {
        request.body.destroy(error2);
      }
      if (!response || !response.body) {
        return;
      }
      response.body.emit("error", error2);
    };
    if (signal && signal.aborted) {
      abort();
      return;
    }
    const abortAndFinalize = () => {
      abort();
      finalize();
    };
    const request_ = send(options2);
    if (signal) {
      signal.addEventListener("abort", abortAndFinalize);
    }
    const finalize = () => {
      request_.abort();
      if (signal) {
        signal.removeEventListener("abort", abortAndFinalize);
      }
    };
    request_.on("error", (error2) => {
      reject(new FetchError(`request to ${request.url} failed, reason: ${error2.message}`, "system", error2));
      finalize();
    });
    fixResponseChunkedTransferBadEnding(request_, (error2) => {
      response.body.destroy(error2);
    });
    if (process.version < "v14") {
      request_.on("socket", (s2) => {
        let endedWithEventsCount;
        s2.prependListener("end", () => {
          endedWithEventsCount = s2._eventsCount;
        });
        s2.prependListener("close", (hadError) => {
          if (response && endedWithEventsCount < s2._eventsCount && !hadError) {
            const error2 = new Error("Premature close");
            error2.code = "ERR_STREAM_PREMATURE_CLOSE";
            response.body.emit("error", error2);
          }
        });
      });
    }
    request_.on("response", (response_) => {
      request_.setTimeout(0);
      const headers = fromRawHeaders(response_.rawHeaders);
      if (isRedirect(response_.statusCode)) {
        const location2 = headers.get("Location");
        const locationURL = location2 === null ? null : new URL(location2, request.url);
        switch (request.redirect) {
          case "error":
            reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
            finalize();
            return;
          case "manual":
            if (locationURL !== null) {
              headers.set("Location", locationURL);
            }
            break;
          case "follow": {
            if (locationURL === null) {
              break;
            }
            if (request.counter >= request.follow) {
              reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
              finalize();
              return;
            }
            const requestOptions = {
              headers: new Headers(request.headers),
              follow: request.follow,
              counter: request.counter + 1,
              agent: request.agent,
              compress: request.compress,
              method: request.method,
              body: request.body,
              signal: request.signal,
              size: request.size
            };
            if (response_.statusCode !== 303 && request.body && options_.body instanceof import_stream.default.Readable) {
              reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
              finalize();
              return;
            }
            if (response_.statusCode === 303 || (response_.statusCode === 301 || response_.statusCode === 302) && request.method === "POST") {
              requestOptions.method = "GET";
              requestOptions.body = void 0;
              requestOptions.headers.delete("content-length");
            }
            resolve2(fetch(new Request(locationURL, requestOptions)));
            finalize();
            return;
          }
          default:
            return reject(new TypeError(`Redirect option '${request.redirect}' is not a valid value of RequestRedirect`));
        }
      }
      if (signal) {
        response_.once("end", () => {
          signal.removeEventListener("abort", abortAndFinalize);
        });
      }
      let body = (0, import_stream.pipeline)(response_, new import_stream.PassThrough(), reject);
      if (process.version < "v12.10") {
        response_.on("aborted", abortAndFinalize);
      }
      const responseOptions = {
        url: request.url,
        status: response_.statusCode,
        statusText: response_.statusMessage,
        headers,
        size: request.size,
        counter: request.counter,
        highWaterMark: request.highWaterMark
      };
      const codings = headers.get("Content-Encoding");
      if (!request.compress || request.method === "HEAD" || codings === null || response_.statusCode === 204 || response_.statusCode === 304) {
        response = new Response(body, responseOptions);
        resolve2(response);
        return;
      }
      const zlibOptions = {
        flush: import_zlib.default.Z_SYNC_FLUSH,
        finishFlush: import_zlib.default.Z_SYNC_FLUSH
      };
      if (codings === "gzip" || codings === "x-gzip") {
        body = (0, import_stream.pipeline)(body, import_zlib.default.createGunzip(zlibOptions), reject);
        response = new Response(body, responseOptions);
        resolve2(response);
        return;
      }
      if (codings === "deflate" || codings === "x-deflate") {
        const raw = (0, import_stream.pipeline)(response_, new import_stream.PassThrough(), reject);
        raw.once("data", (chunk) => {
          body = (chunk[0] & 15) === 8 ? (0, import_stream.pipeline)(body, import_zlib.default.createInflate(), reject) : (0, import_stream.pipeline)(body, import_zlib.default.createInflateRaw(), reject);
          response = new Response(body, responseOptions);
          resolve2(response);
        });
        return;
      }
      if (codings === "br") {
        body = (0, import_stream.pipeline)(body, import_zlib.default.createBrotliDecompress(), reject);
        response = new Response(body, responseOptions);
        resolve2(response);
        return;
      }
      response = new Response(body, responseOptions);
      resolve2(response);
    });
    writeToStream(request_, request);
  });
}
function fixResponseChunkedTransferBadEnding(request, errorCallback) {
  const LAST_CHUNK = Buffer.from("0\r\n\r\n");
  let isChunkedTransfer = false;
  let properLastChunkReceived = false;
  let previousChunk;
  request.on("response", (response) => {
    const { headers } = response;
    isChunkedTransfer = headers["transfer-encoding"] === "chunked" && !headers["content-length"];
  });
  request.on("socket", (socket) => {
    const onSocketClose = () => {
      if (isChunkedTransfer && !properLastChunkReceived) {
        const error2 = new Error("Premature close");
        error2.code = "ERR_STREAM_PREMATURE_CLOSE";
        errorCallback(error2);
      }
    };
    socket.prependListener("close", onSocketClose);
    request.on("abort", () => {
      socket.removeListener("close", onSocketClose);
    });
    socket.on("data", (buf) => {
      properLastChunkReceived = Buffer.compare(buf.slice(-5), LAST_CHUNK) === 0;
      if (!properLastChunkReceived && previousChunk) {
        properLastChunkReceived = Buffer.compare(previousChunk.slice(-3), LAST_CHUNK.slice(0, 3)) === 0 && Buffer.compare(buf.slice(-2), LAST_CHUNK.slice(3)) === 0;
      }
      previousChunk = buf;
    });
  });
}
var import_http, import_https, import_zlib, import_stream, import_util, import_crypto, import_url, commonjsGlobal, src, dataUriToBuffer$1, ponyfill_es2018, POOL_SIZE$1, POOL_SIZE, _Blob, Blob2, Blob$1, FetchBaseError, FetchError, NAME, isURLSearchParameters, isBlob, isAbortSignal, carriage, dashes, carriageLength, getFooter, getBoundary, INTERNALS$2, Body, clone, extractContentType, getTotalBytes, writeToStream, validateHeaderName, validateHeaderValue, Headers, redirectStatus, isRedirect, INTERNALS$1, Response, getSearch, INTERNALS, isRequest, Request, getNodeRequestOptions, AbortError, supportedSchemas;
var init_install_fetch = __esm({
  "node_modules/@sveltejs/kit/dist/install-fetch.js"() {
    init_shims();
    import_http = __toModule(require("http"));
    import_https = __toModule(require("https"));
    import_zlib = __toModule(require("zlib"));
    import_stream = __toModule(require("stream"));
    import_util = __toModule(require("util"));
    import_crypto = __toModule(require("crypto"));
    import_url = __toModule(require("url"));
    commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    src = dataUriToBuffer;
    dataUriToBuffer$1 = src;
    ponyfill_es2018 = { exports: {} };
    (function(module2, exports) {
      (function(global2, factory) {
        factory(exports);
      })(commonjsGlobal, function(exports2) {
        const SymbolPolyfill = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol : (description) => `Symbol(${description})`;
        function noop2() {
          return void 0;
        }
        function getGlobals() {
          if (typeof self !== "undefined") {
            return self;
          } else if (typeof window !== "undefined") {
            return window;
          } else if (typeof commonjsGlobal !== "undefined") {
            return commonjsGlobal;
          }
          return void 0;
        }
        const globals = getGlobals();
        function typeIsObject(x) {
          return typeof x === "object" && x !== null || typeof x === "function";
        }
        const rethrowAssertionErrorRejection = noop2;
        const originalPromise = Promise;
        const originalPromiseThen = Promise.prototype.then;
        const originalPromiseResolve = Promise.resolve.bind(originalPromise);
        const originalPromiseReject = Promise.reject.bind(originalPromise);
        function newPromise(executor) {
          return new originalPromise(executor);
        }
        function promiseResolvedWith(value) {
          return originalPromiseResolve(value);
        }
        function promiseRejectedWith(reason) {
          return originalPromiseReject(reason);
        }
        function PerformPromiseThen(promise, onFulfilled, onRejected) {
          return originalPromiseThen.call(promise, onFulfilled, onRejected);
        }
        function uponPromise(promise, onFulfilled, onRejected) {
          PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), void 0, rethrowAssertionErrorRejection);
        }
        function uponFulfillment(promise, onFulfilled) {
          uponPromise(promise, onFulfilled);
        }
        function uponRejection(promise, onRejected) {
          uponPromise(promise, void 0, onRejected);
        }
        function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {
          return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);
        }
        function setPromiseIsHandledToTrue(promise) {
          PerformPromiseThen(promise, void 0, rethrowAssertionErrorRejection);
        }
        const queueMicrotask = (() => {
          const globalQueueMicrotask = globals && globals.queueMicrotask;
          if (typeof globalQueueMicrotask === "function") {
            return globalQueueMicrotask;
          }
          const resolvedPromise = promiseResolvedWith(void 0);
          return (fn) => PerformPromiseThen(resolvedPromise, fn);
        })();
        function reflectCall(F, V, args) {
          if (typeof F !== "function") {
            throw new TypeError("Argument is not a function");
          }
          return Function.prototype.apply.call(F, V, args);
        }
        function promiseCall(F, V, args) {
          try {
            return promiseResolvedWith(reflectCall(F, V, args));
          } catch (value) {
            return promiseRejectedWith(value);
          }
        }
        const QUEUE_MAX_ARRAY_SIZE = 16384;
        class SimpleQueue {
          constructor() {
            this._cursor = 0;
            this._size = 0;
            this._front = {
              _elements: [],
              _next: void 0
            };
            this._back = this._front;
            this._cursor = 0;
            this._size = 0;
          }
          get length() {
            return this._size;
          }
          push(element) {
            const oldBack = this._back;
            let newBack = oldBack;
            if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {
              newBack = {
                _elements: [],
                _next: void 0
              };
            }
            oldBack._elements.push(element);
            if (newBack !== oldBack) {
              this._back = newBack;
              oldBack._next = newBack;
            }
            ++this._size;
          }
          shift() {
            const oldFront = this._front;
            let newFront = oldFront;
            const oldCursor = this._cursor;
            let newCursor = oldCursor + 1;
            const elements = oldFront._elements;
            const element = elements[oldCursor];
            if (newCursor === QUEUE_MAX_ARRAY_SIZE) {
              newFront = oldFront._next;
              newCursor = 0;
            }
            --this._size;
            this._cursor = newCursor;
            if (oldFront !== newFront) {
              this._front = newFront;
            }
            elements[oldCursor] = void 0;
            return element;
          }
          forEach(callback) {
            let i = this._cursor;
            let node = this._front;
            let elements = node._elements;
            while (i !== elements.length || node._next !== void 0) {
              if (i === elements.length) {
                node = node._next;
                elements = node._elements;
                i = 0;
                if (elements.length === 0) {
                  break;
                }
              }
              callback(elements[i]);
              ++i;
            }
          }
          peek() {
            const front = this._front;
            const cursor = this._cursor;
            return front._elements[cursor];
          }
        }
        function ReadableStreamReaderGenericInitialize(reader, stream) {
          reader._ownerReadableStream = stream;
          stream._reader = reader;
          if (stream._state === "readable") {
            defaultReaderClosedPromiseInitialize(reader);
          } else if (stream._state === "closed") {
            defaultReaderClosedPromiseInitializeAsResolved(reader);
          } else {
            defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);
          }
        }
        function ReadableStreamReaderGenericCancel(reader, reason) {
          const stream = reader._ownerReadableStream;
          return ReadableStreamCancel(stream, reason);
        }
        function ReadableStreamReaderGenericRelease(reader) {
          if (reader._ownerReadableStream._state === "readable") {
            defaultReaderClosedPromiseReject(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));
          } else {
            defaultReaderClosedPromiseResetToRejected(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));
          }
          reader._ownerReadableStream._reader = void 0;
          reader._ownerReadableStream = void 0;
        }
        function readerLockException(name) {
          return new TypeError("Cannot " + name + " a stream using a released reader");
        }
        function defaultReaderClosedPromiseInitialize(reader) {
          reader._closedPromise = newPromise((resolve2, reject) => {
            reader._closedPromise_resolve = resolve2;
            reader._closedPromise_reject = reject;
          });
        }
        function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {
          defaultReaderClosedPromiseInitialize(reader);
          defaultReaderClosedPromiseReject(reader, reason);
        }
        function defaultReaderClosedPromiseInitializeAsResolved(reader) {
          defaultReaderClosedPromiseInitialize(reader);
          defaultReaderClosedPromiseResolve(reader);
        }
        function defaultReaderClosedPromiseReject(reader, reason) {
          if (reader._closedPromise_reject === void 0) {
            return;
          }
          setPromiseIsHandledToTrue(reader._closedPromise);
          reader._closedPromise_reject(reason);
          reader._closedPromise_resolve = void 0;
          reader._closedPromise_reject = void 0;
        }
        function defaultReaderClosedPromiseResetToRejected(reader, reason) {
          defaultReaderClosedPromiseInitializeAsRejected(reader, reason);
        }
        function defaultReaderClosedPromiseResolve(reader) {
          if (reader._closedPromise_resolve === void 0) {
            return;
          }
          reader._closedPromise_resolve(void 0);
          reader._closedPromise_resolve = void 0;
          reader._closedPromise_reject = void 0;
        }
        const AbortSteps = SymbolPolyfill("[[AbortSteps]]");
        const ErrorSteps = SymbolPolyfill("[[ErrorSteps]]");
        const CancelSteps = SymbolPolyfill("[[CancelSteps]]");
        const PullSteps = SymbolPolyfill("[[PullSteps]]");
        const NumberIsFinite = Number.isFinite || function(x) {
          return typeof x === "number" && isFinite(x);
        };
        const MathTrunc = Math.trunc || function(v) {
          return v < 0 ? Math.ceil(v) : Math.floor(v);
        };
        function isDictionary(x) {
          return typeof x === "object" || typeof x === "function";
        }
        function assertDictionary(obj, context) {
          if (obj !== void 0 && !isDictionary(obj)) {
            throw new TypeError(`${context} is not an object.`);
          }
        }
        function assertFunction(x, context) {
          if (typeof x !== "function") {
            throw new TypeError(`${context} is not a function.`);
          }
        }
        function isObject(x) {
          return typeof x === "object" && x !== null || typeof x === "function";
        }
        function assertObject(x, context) {
          if (!isObject(x)) {
            throw new TypeError(`${context} is not an object.`);
          }
        }
        function assertRequiredArgument(x, position, context) {
          if (x === void 0) {
            throw new TypeError(`Parameter ${position} is required in '${context}'.`);
          }
        }
        function assertRequiredField(x, field, context) {
          if (x === void 0) {
            throw new TypeError(`${field} is required in '${context}'.`);
          }
        }
        function convertUnrestrictedDouble(value) {
          return Number(value);
        }
        function censorNegativeZero(x) {
          return x === 0 ? 0 : x;
        }
        function integerPart(x) {
          return censorNegativeZero(MathTrunc(x));
        }
        function convertUnsignedLongLongWithEnforceRange(value, context) {
          const lowerBound = 0;
          const upperBound = Number.MAX_SAFE_INTEGER;
          let x = Number(value);
          x = censorNegativeZero(x);
          if (!NumberIsFinite(x)) {
            throw new TypeError(`${context} is not a finite number`);
          }
          x = integerPart(x);
          if (x < lowerBound || x > upperBound) {
            throw new TypeError(`${context} is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`);
          }
          if (!NumberIsFinite(x) || x === 0) {
            return 0;
          }
          return x;
        }
        function assertReadableStream(x, context) {
          if (!IsReadableStream(x)) {
            throw new TypeError(`${context} is not a ReadableStream.`);
          }
        }
        function AcquireReadableStreamDefaultReader(stream) {
          return new ReadableStreamDefaultReader(stream);
        }
        function ReadableStreamAddReadRequest(stream, readRequest) {
          stream._reader._readRequests.push(readRequest);
        }
        function ReadableStreamFulfillReadRequest(stream, chunk, done) {
          const reader = stream._reader;
          const readRequest = reader._readRequests.shift();
          if (done) {
            readRequest._closeSteps();
          } else {
            readRequest._chunkSteps(chunk);
          }
        }
        function ReadableStreamGetNumReadRequests(stream) {
          return stream._reader._readRequests.length;
        }
        function ReadableStreamHasDefaultReader(stream) {
          const reader = stream._reader;
          if (reader === void 0) {
            return false;
          }
          if (!IsReadableStreamDefaultReader(reader)) {
            return false;
          }
          return true;
        }
        class ReadableStreamDefaultReader {
          constructor(stream) {
            assertRequiredArgument(stream, 1, "ReadableStreamDefaultReader");
            assertReadableStream(stream, "First parameter");
            if (IsReadableStreamLocked(stream)) {
              throw new TypeError("This stream has already been locked for exclusive reading by another reader");
            }
            ReadableStreamReaderGenericInitialize(this, stream);
            this._readRequests = new SimpleQueue();
          }
          get closed() {
            if (!IsReadableStreamDefaultReader(this)) {
              return promiseRejectedWith(defaultReaderBrandCheckException("closed"));
            }
            return this._closedPromise;
          }
          cancel(reason = void 0) {
            if (!IsReadableStreamDefaultReader(this)) {
              return promiseRejectedWith(defaultReaderBrandCheckException("cancel"));
            }
            if (this._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("cancel"));
            }
            return ReadableStreamReaderGenericCancel(this, reason);
          }
          read() {
            if (!IsReadableStreamDefaultReader(this)) {
              return promiseRejectedWith(defaultReaderBrandCheckException("read"));
            }
            if (this._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("read from"));
            }
            let resolvePromise;
            let rejectPromise;
            const promise = newPromise((resolve2, reject) => {
              resolvePromise = resolve2;
              rejectPromise = reject;
            });
            const readRequest = {
              _chunkSteps: (chunk) => resolvePromise({ value: chunk, done: false }),
              _closeSteps: () => resolvePromise({ value: void 0, done: true }),
              _errorSteps: (e) => rejectPromise(e)
            };
            ReadableStreamDefaultReaderRead(this, readRequest);
            return promise;
          }
          releaseLock() {
            if (!IsReadableStreamDefaultReader(this)) {
              throw defaultReaderBrandCheckException("releaseLock");
            }
            if (this._ownerReadableStream === void 0) {
              return;
            }
            if (this._readRequests.length > 0) {
              throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
            }
            ReadableStreamReaderGenericRelease(this);
          }
        }
        Object.defineProperties(ReadableStreamDefaultReader.prototype, {
          cancel: { enumerable: true },
          read: { enumerable: true },
          releaseLock: { enumerable: true },
          closed: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStreamDefaultReader.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStreamDefaultReader",
            configurable: true
          });
        }
        function IsReadableStreamDefaultReader(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_readRequests")) {
            return false;
          }
          return x instanceof ReadableStreamDefaultReader;
        }
        function ReadableStreamDefaultReaderRead(reader, readRequest) {
          const stream = reader._ownerReadableStream;
          stream._disturbed = true;
          if (stream._state === "closed") {
            readRequest._closeSteps();
          } else if (stream._state === "errored") {
            readRequest._errorSteps(stream._storedError);
          } else {
            stream._readableStreamController[PullSteps](readRequest);
          }
        }
        function defaultReaderBrandCheckException(name) {
          return new TypeError(`ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);
        }
        const AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function* () {
        }).prototype);
        class ReadableStreamAsyncIteratorImpl {
          constructor(reader, preventCancel) {
            this._ongoingPromise = void 0;
            this._isFinished = false;
            this._reader = reader;
            this._preventCancel = preventCancel;
          }
          next() {
            const nextSteps = () => this._nextSteps();
            this._ongoingPromise = this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) : nextSteps();
            return this._ongoingPromise;
          }
          return(value) {
            const returnSteps = () => this._returnSteps(value);
            return this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) : returnSteps();
          }
          _nextSteps() {
            if (this._isFinished) {
              return Promise.resolve({ value: void 0, done: true });
            }
            const reader = this._reader;
            if (reader._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("iterate"));
            }
            let resolvePromise;
            let rejectPromise;
            const promise = newPromise((resolve2, reject) => {
              resolvePromise = resolve2;
              rejectPromise = reject;
            });
            const readRequest = {
              _chunkSteps: (chunk) => {
                this._ongoingPromise = void 0;
                queueMicrotask(() => resolvePromise({ value: chunk, done: false }));
              },
              _closeSteps: () => {
                this._ongoingPromise = void 0;
                this._isFinished = true;
                ReadableStreamReaderGenericRelease(reader);
                resolvePromise({ value: void 0, done: true });
              },
              _errorSteps: (reason) => {
                this._ongoingPromise = void 0;
                this._isFinished = true;
                ReadableStreamReaderGenericRelease(reader);
                rejectPromise(reason);
              }
            };
            ReadableStreamDefaultReaderRead(reader, readRequest);
            return promise;
          }
          _returnSteps(value) {
            if (this._isFinished) {
              return Promise.resolve({ value, done: true });
            }
            this._isFinished = true;
            const reader = this._reader;
            if (reader._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("finish iterating"));
            }
            if (!this._preventCancel) {
              const result = ReadableStreamReaderGenericCancel(reader, value);
              ReadableStreamReaderGenericRelease(reader);
              return transformPromiseWith(result, () => ({ value, done: true }));
            }
            ReadableStreamReaderGenericRelease(reader);
            return promiseResolvedWith({ value, done: true });
          }
        }
        const ReadableStreamAsyncIteratorPrototype = {
          next() {
            if (!IsReadableStreamAsyncIterator(this)) {
              return promiseRejectedWith(streamAsyncIteratorBrandCheckException("next"));
            }
            return this._asyncIteratorImpl.next();
          },
          return(value) {
            if (!IsReadableStreamAsyncIterator(this)) {
              return promiseRejectedWith(streamAsyncIteratorBrandCheckException("return"));
            }
            return this._asyncIteratorImpl.return(value);
          }
        };
        if (AsyncIteratorPrototype !== void 0) {
          Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);
        }
        function AcquireReadableStreamAsyncIterator(stream, preventCancel) {
          const reader = AcquireReadableStreamDefaultReader(stream);
          const impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);
          const iterator = Object.create(ReadableStreamAsyncIteratorPrototype);
          iterator._asyncIteratorImpl = impl;
          return iterator;
        }
        function IsReadableStreamAsyncIterator(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_asyncIteratorImpl")) {
            return false;
          }
          try {
            return x._asyncIteratorImpl instanceof ReadableStreamAsyncIteratorImpl;
          } catch (_a) {
            return false;
          }
        }
        function streamAsyncIteratorBrandCheckException(name) {
          return new TypeError(`ReadableStreamAsyncIterator.${name} can only be used on a ReadableSteamAsyncIterator`);
        }
        const NumberIsNaN = Number.isNaN || function(x) {
          return x !== x;
        };
        function CreateArrayFromList(elements) {
          return elements.slice();
        }
        function CopyDataBlockBytes(dest, destOffset, src2, srcOffset, n) {
          new Uint8Array(dest).set(new Uint8Array(src2, srcOffset, n), destOffset);
        }
        function TransferArrayBuffer(O) {
          return O;
        }
        function IsDetachedBuffer(O) {
          return false;
        }
        function ArrayBufferSlice(buffer, begin, end) {
          if (buffer.slice) {
            return buffer.slice(begin, end);
          }
          const length = end - begin;
          const slice = new ArrayBuffer(length);
          CopyDataBlockBytes(slice, 0, buffer, begin, length);
          return slice;
        }
        function IsNonNegativeNumber(v) {
          if (typeof v !== "number") {
            return false;
          }
          if (NumberIsNaN(v)) {
            return false;
          }
          if (v < 0) {
            return false;
          }
          return true;
        }
        function CloneAsUint8Array(O) {
          const buffer = ArrayBufferSlice(O.buffer, O.byteOffset, O.byteOffset + O.byteLength);
          return new Uint8Array(buffer);
        }
        function DequeueValue(container) {
          const pair = container._queue.shift();
          container._queueTotalSize -= pair.size;
          if (container._queueTotalSize < 0) {
            container._queueTotalSize = 0;
          }
          return pair.value;
        }
        function EnqueueValueWithSize(container, value, size) {
          if (!IsNonNegativeNumber(size) || size === Infinity) {
            throw new RangeError("Size must be a finite, non-NaN, non-negative number.");
          }
          container._queue.push({ value, size });
          container._queueTotalSize += size;
        }
        function PeekQueueValue(container) {
          const pair = container._queue.peek();
          return pair.value;
        }
        function ResetQueue(container) {
          container._queue = new SimpleQueue();
          container._queueTotalSize = 0;
        }
        class ReadableStreamBYOBRequest {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get view() {
            if (!IsReadableStreamBYOBRequest(this)) {
              throw byobRequestBrandCheckException("view");
            }
            return this._view;
          }
          respond(bytesWritten) {
            if (!IsReadableStreamBYOBRequest(this)) {
              throw byobRequestBrandCheckException("respond");
            }
            assertRequiredArgument(bytesWritten, 1, "respond");
            bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, "First parameter");
            if (this._associatedReadableByteStreamController === void 0) {
              throw new TypeError("This BYOB request has been invalidated");
            }
            if (IsDetachedBuffer(this._view.buffer))
              ;
            ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);
          }
          respondWithNewView(view) {
            if (!IsReadableStreamBYOBRequest(this)) {
              throw byobRequestBrandCheckException("respondWithNewView");
            }
            assertRequiredArgument(view, 1, "respondWithNewView");
            if (!ArrayBuffer.isView(view)) {
              throw new TypeError("You can only respond with array buffer views");
            }
            if (this._associatedReadableByteStreamController === void 0) {
              throw new TypeError("This BYOB request has been invalidated");
            }
            if (IsDetachedBuffer(view.buffer))
              ;
            ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);
          }
        }
        Object.defineProperties(ReadableStreamBYOBRequest.prototype, {
          respond: { enumerable: true },
          respondWithNewView: { enumerable: true },
          view: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStreamBYOBRequest.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStreamBYOBRequest",
            configurable: true
          });
        }
        class ReadableByteStreamController {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get byobRequest() {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("byobRequest");
            }
            return ReadableByteStreamControllerGetBYOBRequest(this);
          }
          get desiredSize() {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("desiredSize");
            }
            return ReadableByteStreamControllerGetDesiredSize(this);
          }
          close() {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("close");
            }
            if (this._closeRequested) {
              throw new TypeError("The stream has already been closed; do not close it again!");
            }
            const state = this._controlledReadableByteStream._state;
            if (state !== "readable") {
              throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);
            }
            ReadableByteStreamControllerClose(this);
          }
          enqueue(chunk) {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("enqueue");
            }
            assertRequiredArgument(chunk, 1, "enqueue");
            if (!ArrayBuffer.isView(chunk)) {
              throw new TypeError("chunk must be an array buffer view");
            }
            if (chunk.byteLength === 0) {
              throw new TypeError("chunk must have non-zero byteLength");
            }
            if (chunk.buffer.byteLength === 0) {
              throw new TypeError(`chunk's buffer must have non-zero byteLength`);
            }
            if (this._closeRequested) {
              throw new TypeError("stream is closed or draining");
            }
            const state = this._controlledReadableByteStream._state;
            if (state !== "readable") {
              throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);
            }
            ReadableByteStreamControllerEnqueue(this, chunk);
          }
          error(e = void 0) {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("error");
            }
            ReadableByteStreamControllerError(this, e);
          }
          [CancelSteps](reason) {
            ReadableByteStreamControllerClearPendingPullIntos(this);
            ResetQueue(this);
            const result = this._cancelAlgorithm(reason);
            ReadableByteStreamControllerClearAlgorithms(this);
            return result;
          }
          [PullSteps](readRequest) {
            const stream = this._controlledReadableByteStream;
            if (this._queueTotalSize > 0) {
              const entry = this._queue.shift();
              this._queueTotalSize -= entry.byteLength;
              ReadableByteStreamControllerHandleQueueDrain(this);
              const view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);
              readRequest._chunkSteps(view);
              return;
            }
            const autoAllocateChunkSize = this._autoAllocateChunkSize;
            if (autoAllocateChunkSize !== void 0) {
              let buffer;
              try {
                buffer = new ArrayBuffer(autoAllocateChunkSize);
              } catch (bufferE) {
                readRequest._errorSteps(bufferE);
                return;
              }
              const pullIntoDescriptor = {
                buffer,
                bufferByteLength: autoAllocateChunkSize,
                byteOffset: 0,
                byteLength: autoAllocateChunkSize,
                bytesFilled: 0,
                elementSize: 1,
                viewConstructor: Uint8Array,
                readerType: "default"
              };
              this._pendingPullIntos.push(pullIntoDescriptor);
            }
            ReadableStreamAddReadRequest(stream, readRequest);
            ReadableByteStreamControllerCallPullIfNeeded(this);
          }
        }
        Object.defineProperties(ReadableByteStreamController.prototype, {
          close: { enumerable: true },
          enqueue: { enumerable: true },
          error: { enumerable: true },
          byobRequest: { enumerable: true },
          desiredSize: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableByteStreamController.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableByteStreamController",
            configurable: true
          });
        }
        function IsReadableByteStreamController(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_controlledReadableByteStream")) {
            return false;
          }
          return x instanceof ReadableByteStreamController;
        }
        function IsReadableStreamBYOBRequest(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_associatedReadableByteStreamController")) {
            return false;
          }
          return x instanceof ReadableStreamBYOBRequest;
        }
        function ReadableByteStreamControllerCallPullIfNeeded(controller) {
          const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);
          if (!shouldPull) {
            return;
          }
          if (controller._pulling) {
            controller._pullAgain = true;
            return;
          }
          controller._pulling = true;
          const pullPromise = controller._pullAlgorithm();
          uponPromise(pullPromise, () => {
            controller._pulling = false;
            if (controller._pullAgain) {
              controller._pullAgain = false;
              ReadableByteStreamControllerCallPullIfNeeded(controller);
            }
          }, (e) => {
            ReadableByteStreamControllerError(controller, e);
          });
        }
        function ReadableByteStreamControllerClearPendingPullIntos(controller) {
          ReadableByteStreamControllerInvalidateBYOBRequest(controller);
          controller._pendingPullIntos = new SimpleQueue();
        }
        function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {
          let done = false;
          if (stream._state === "closed") {
            done = true;
          }
          const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
          if (pullIntoDescriptor.readerType === "default") {
            ReadableStreamFulfillReadRequest(stream, filledView, done);
          } else {
            ReadableStreamFulfillReadIntoRequest(stream, filledView, done);
          }
        }
        function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {
          const bytesFilled = pullIntoDescriptor.bytesFilled;
          const elementSize = pullIntoDescriptor.elementSize;
          return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);
        }
        function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {
          controller._queue.push({ buffer, byteOffset, byteLength });
          controller._queueTotalSize += byteLength;
        }
        function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {
          const elementSize = pullIntoDescriptor.elementSize;
          const currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;
          const maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);
          const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;
          const maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;
          let totalBytesToCopyRemaining = maxBytesToCopy;
          let ready = false;
          if (maxAlignedBytes > currentAlignedBytes) {
            totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;
            ready = true;
          }
          const queue = controller._queue;
          while (totalBytesToCopyRemaining > 0) {
            const headOfQueue = queue.peek();
            const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);
            const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
            CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);
            if (headOfQueue.byteLength === bytesToCopy) {
              queue.shift();
            } else {
              headOfQueue.byteOffset += bytesToCopy;
              headOfQueue.byteLength -= bytesToCopy;
            }
            controller._queueTotalSize -= bytesToCopy;
            ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);
            totalBytesToCopyRemaining -= bytesToCopy;
          }
          return ready;
        }
        function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {
          pullIntoDescriptor.bytesFilled += size;
        }
        function ReadableByteStreamControllerHandleQueueDrain(controller) {
          if (controller._queueTotalSize === 0 && controller._closeRequested) {
            ReadableByteStreamControllerClearAlgorithms(controller);
            ReadableStreamClose(controller._controlledReadableByteStream);
          } else {
            ReadableByteStreamControllerCallPullIfNeeded(controller);
          }
        }
        function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {
          if (controller._byobRequest === null) {
            return;
          }
          controller._byobRequest._associatedReadableByteStreamController = void 0;
          controller._byobRequest._view = null;
          controller._byobRequest = null;
        }
        function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {
          while (controller._pendingPullIntos.length > 0) {
            if (controller._queueTotalSize === 0) {
              return;
            }
            const pullIntoDescriptor = controller._pendingPullIntos.peek();
            if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
              ReadableByteStreamControllerShiftPendingPullInto(controller);
              ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
            }
          }
        }
        function ReadableByteStreamControllerPullInto(controller, view, readIntoRequest) {
          const stream = controller._controlledReadableByteStream;
          let elementSize = 1;
          if (view.constructor !== DataView) {
            elementSize = view.constructor.BYTES_PER_ELEMENT;
          }
          const ctor = view.constructor;
          const buffer = TransferArrayBuffer(view.buffer);
          const pullIntoDescriptor = {
            buffer,
            bufferByteLength: buffer.byteLength,
            byteOffset: view.byteOffset,
            byteLength: view.byteLength,
            bytesFilled: 0,
            elementSize,
            viewConstructor: ctor,
            readerType: "byob"
          };
          if (controller._pendingPullIntos.length > 0) {
            controller._pendingPullIntos.push(pullIntoDescriptor);
            ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
            return;
          }
          if (stream._state === "closed") {
            const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);
            readIntoRequest._closeSteps(emptyView);
            return;
          }
          if (controller._queueTotalSize > 0) {
            if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
              const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
              ReadableByteStreamControllerHandleQueueDrain(controller);
              readIntoRequest._chunkSteps(filledView);
              return;
            }
            if (controller._closeRequested) {
              const e = new TypeError("Insufficient bytes to fill elements in the given buffer");
              ReadableByteStreamControllerError(controller, e);
              readIntoRequest._errorSteps(e);
              return;
            }
          }
          controller._pendingPullIntos.push(pullIntoDescriptor);
          ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
        function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {
          const stream = controller._controlledReadableByteStream;
          if (ReadableStreamHasBYOBReader(stream)) {
            while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {
              const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);
              ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);
            }
          }
        }
        function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {
          ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);
          if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {
            return;
          }
          ReadableByteStreamControllerShiftPendingPullInto(controller);
          const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;
          if (remainderSize > 0) {
            const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
            const remainder = ArrayBufferSlice(pullIntoDescriptor.buffer, end - remainderSize, end);
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);
          }
          pullIntoDescriptor.bytesFilled -= remainderSize;
          ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
          ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
        }
        function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {
          const firstDescriptor = controller._pendingPullIntos.peek();
          ReadableByteStreamControllerInvalidateBYOBRequest(controller);
          const state = controller._controlledReadableByteStream._state;
          if (state === "closed") {
            ReadableByteStreamControllerRespondInClosedState(controller);
          } else {
            ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);
          }
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
        function ReadableByteStreamControllerShiftPendingPullInto(controller) {
          const descriptor = controller._pendingPullIntos.shift();
          return descriptor;
        }
        function ReadableByteStreamControllerShouldCallPull(controller) {
          const stream = controller._controlledReadableByteStream;
          if (stream._state !== "readable") {
            return false;
          }
          if (controller._closeRequested) {
            return false;
          }
          if (!controller._started) {
            return false;
          }
          if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
            return true;
          }
          if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {
            return true;
          }
          const desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);
          if (desiredSize > 0) {
            return true;
          }
          return false;
        }
        function ReadableByteStreamControllerClearAlgorithms(controller) {
          controller._pullAlgorithm = void 0;
          controller._cancelAlgorithm = void 0;
        }
        function ReadableByteStreamControllerClose(controller) {
          const stream = controller._controlledReadableByteStream;
          if (controller._closeRequested || stream._state !== "readable") {
            return;
          }
          if (controller._queueTotalSize > 0) {
            controller._closeRequested = true;
            return;
          }
          if (controller._pendingPullIntos.length > 0) {
            const firstPendingPullInto = controller._pendingPullIntos.peek();
            if (firstPendingPullInto.bytesFilled > 0) {
              const e = new TypeError("Insufficient bytes to fill elements in the given buffer");
              ReadableByteStreamControllerError(controller, e);
              throw e;
            }
          }
          ReadableByteStreamControllerClearAlgorithms(controller);
          ReadableStreamClose(stream);
        }
        function ReadableByteStreamControllerEnqueue(controller, chunk) {
          const stream = controller._controlledReadableByteStream;
          if (controller._closeRequested || stream._state !== "readable") {
            return;
          }
          const buffer = chunk.buffer;
          const byteOffset = chunk.byteOffset;
          const byteLength = chunk.byteLength;
          const transferredBuffer = TransferArrayBuffer(buffer);
          if (controller._pendingPullIntos.length > 0) {
            const firstPendingPullInto = controller._pendingPullIntos.peek();
            if (IsDetachedBuffer(firstPendingPullInto.buffer))
              ;
            firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);
          }
          ReadableByteStreamControllerInvalidateBYOBRequest(controller);
          if (ReadableStreamHasDefaultReader(stream)) {
            if (ReadableStreamGetNumReadRequests(stream) === 0) {
              ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
            } else {
              const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);
              ReadableStreamFulfillReadRequest(stream, transferredView, false);
            }
          } else if (ReadableStreamHasBYOBReader(stream)) {
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
            ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
          } else {
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
          }
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
        function ReadableByteStreamControllerError(controller, e) {
          const stream = controller._controlledReadableByteStream;
          if (stream._state !== "readable") {
            return;
          }
          ReadableByteStreamControllerClearPendingPullIntos(controller);
          ResetQueue(controller);
          ReadableByteStreamControllerClearAlgorithms(controller);
          ReadableStreamError(stream, e);
        }
        function ReadableByteStreamControllerGetBYOBRequest(controller) {
          if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {
            const firstDescriptor = controller._pendingPullIntos.peek();
            const view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);
            const byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);
            SetUpReadableStreamBYOBRequest(byobRequest, controller, view);
            controller._byobRequest = byobRequest;
          }
          return controller._byobRequest;
        }
        function ReadableByteStreamControllerGetDesiredSize(controller) {
          const state = controller._controlledReadableByteStream._state;
          if (state === "errored") {
            return null;
          }
          if (state === "closed") {
            return 0;
          }
          return controller._strategyHWM - controller._queueTotalSize;
        }
        function ReadableByteStreamControllerRespond(controller, bytesWritten) {
          const firstDescriptor = controller._pendingPullIntos.peek();
          const state = controller._controlledReadableByteStream._state;
          if (state === "closed") {
            if (bytesWritten !== 0) {
              throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");
            }
          } else {
            if (bytesWritten === 0) {
              throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");
            }
            if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {
              throw new RangeError("bytesWritten out of range");
            }
          }
          firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);
          ReadableByteStreamControllerRespondInternal(controller, bytesWritten);
        }
        function ReadableByteStreamControllerRespondWithNewView(controller, view) {
          const firstDescriptor = controller._pendingPullIntos.peek();
          const state = controller._controlledReadableByteStream._state;
          if (state === "closed") {
            if (view.byteLength !== 0) {
              throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream");
            }
          } else {
            if (view.byteLength === 0) {
              throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream");
            }
          }
          if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {
            throw new RangeError("The region specified by view does not match byobRequest");
          }
          if (firstDescriptor.bufferByteLength !== view.buffer.byteLength) {
            throw new RangeError("The buffer of view has different capacity than byobRequest");
          }
          if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength) {
            throw new RangeError("The region specified by view is larger than byobRequest");
          }
          firstDescriptor.buffer = TransferArrayBuffer(view.buffer);
          ReadableByteStreamControllerRespondInternal(controller, view.byteLength);
        }
        function SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {
          controller._controlledReadableByteStream = stream;
          controller._pullAgain = false;
          controller._pulling = false;
          controller._byobRequest = null;
          controller._queue = controller._queueTotalSize = void 0;
          ResetQueue(controller);
          controller._closeRequested = false;
          controller._started = false;
          controller._strategyHWM = highWaterMark;
          controller._pullAlgorithm = pullAlgorithm;
          controller._cancelAlgorithm = cancelAlgorithm;
          controller._autoAllocateChunkSize = autoAllocateChunkSize;
          controller._pendingPullIntos = new SimpleQueue();
          stream._readableStreamController = controller;
          const startResult = startAlgorithm();
          uponPromise(promiseResolvedWith(startResult), () => {
            controller._started = true;
            ReadableByteStreamControllerCallPullIfNeeded(controller);
          }, (r) => {
            ReadableByteStreamControllerError(controller, r);
          });
        }
        function SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {
          const controller = Object.create(ReadableByteStreamController.prototype);
          let startAlgorithm = () => void 0;
          let pullAlgorithm = () => promiseResolvedWith(void 0);
          let cancelAlgorithm = () => promiseResolvedWith(void 0);
          if (underlyingByteSource.start !== void 0) {
            startAlgorithm = () => underlyingByteSource.start(controller);
          }
          if (underlyingByteSource.pull !== void 0) {
            pullAlgorithm = () => underlyingByteSource.pull(controller);
          }
          if (underlyingByteSource.cancel !== void 0) {
            cancelAlgorithm = (reason) => underlyingByteSource.cancel(reason);
          }
          const autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;
          if (autoAllocateChunkSize === 0) {
            throw new TypeError("autoAllocateChunkSize must be greater than 0");
          }
          SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);
        }
        function SetUpReadableStreamBYOBRequest(request, controller, view) {
          request._associatedReadableByteStreamController = controller;
          request._view = view;
        }
        function byobRequestBrandCheckException(name) {
          return new TypeError(`ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);
        }
        function byteStreamControllerBrandCheckException(name) {
          return new TypeError(`ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);
        }
        function AcquireReadableStreamBYOBReader(stream) {
          return new ReadableStreamBYOBReader(stream);
        }
        function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {
          stream._reader._readIntoRequests.push(readIntoRequest);
        }
        function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {
          const reader = stream._reader;
          const readIntoRequest = reader._readIntoRequests.shift();
          if (done) {
            readIntoRequest._closeSteps(chunk);
          } else {
            readIntoRequest._chunkSteps(chunk);
          }
        }
        function ReadableStreamGetNumReadIntoRequests(stream) {
          return stream._reader._readIntoRequests.length;
        }
        function ReadableStreamHasBYOBReader(stream) {
          const reader = stream._reader;
          if (reader === void 0) {
            return false;
          }
          if (!IsReadableStreamBYOBReader(reader)) {
            return false;
          }
          return true;
        }
        class ReadableStreamBYOBReader {
          constructor(stream) {
            assertRequiredArgument(stream, 1, "ReadableStreamBYOBReader");
            assertReadableStream(stream, "First parameter");
            if (IsReadableStreamLocked(stream)) {
              throw new TypeError("This stream has already been locked for exclusive reading by another reader");
            }
            if (!IsReadableByteStreamController(stream._readableStreamController)) {
              throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");
            }
            ReadableStreamReaderGenericInitialize(this, stream);
            this._readIntoRequests = new SimpleQueue();
          }
          get closed() {
            if (!IsReadableStreamBYOBReader(this)) {
              return promiseRejectedWith(byobReaderBrandCheckException("closed"));
            }
            return this._closedPromise;
          }
          cancel(reason = void 0) {
            if (!IsReadableStreamBYOBReader(this)) {
              return promiseRejectedWith(byobReaderBrandCheckException("cancel"));
            }
            if (this._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("cancel"));
            }
            return ReadableStreamReaderGenericCancel(this, reason);
          }
          read(view) {
            if (!IsReadableStreamBYOBReader(this)) {
              return promiseRejectedWith(byobReaderBrandCheckException("read"));
            }
            if (!ArrayBuffer.isView(view)) {
              return promiseRejectedWith(new TypeError("view must be an array buffer view"));
            }
            if (view.byteLength === 0) {
              return promiseRejectedWith(new TypeError("view must have non-zero byteLength"));
            }
            if (view.buffer.byteLength === 0) {
              return promiseRejectedWith(new TypeError(`view's buffer must have non-zero byteLength`));
            }
            if (IsDetachedBuffer(view.buffer))
              ;
            if (this._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("read from"));
            }
            let resolvePromise;
            let rejectPromise;
            const promise = newPromise((resolve2, reject) => {
              resolvePromise = resolve2;
              rejectPromise = reject;
            });
            const readIntoRequest = {
              _chunkSteps: (chunk) => resolvePromise({ value: chunk, done: false }),
              _closeSteps: (chunk) => resolvePromise({ value: chunk, done: true }),
              _errorSteps: (e) => rejectPromise(e)
            };
            ReadableStreamBYOBReaderRead(this, view, readIntoRequest);
            return promise;
          }
          releaseLock() {
            if (!IsReadableStreamBYOBReader(this)) {
              throw byobReaderBrandCheckException("releaseLock");
            }
            if (this._ownerReadableStream === void 0) {
              return;
            }
            if (this._readIntoRequests.length > 0) {
              throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
            }
            ReadableStreamReaderGenericRelease(this);
          }
        }
        Object.defineProperties(ReadableStreamBYOBReader.prototype, {
          cancel: { enumerable: true },
          read: { enumerable: true },
          releaseLock: { enumerable: true },
          closed: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStreamBYOBReader.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStreamBYOBReader",
            configurable: true
          });
        }
        function IsReadableStreamBYOBReader(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_readIntoRequests")) {
            return false;
          }
          return x instanceof ReadableStreamBYOBReader;
        }
        function ReadableStreamBYOBReaderRead(reader, view, readIntoRequest) {
          const stream = reader._ownerReadableStream;
          stream._disturbed = true;
          if (stream._state === "errored") {
            readIntoRequest._errorSteps(stream._storedError);
          } else {
            ReadableByteStreamControllerPullInto(stream._readableStreamController, view, readIntoRequest);
          }
        }
        function byobReaderBrandCheckException(name) {
          return new TypeError(`ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);
        }
        function ExtractHighWaterMark(strategy, defaultHWM) {
          const { highWaterMark } = strategy;
          if (highWaterMark === void 0) {
            return defaultHWM;
          }
          if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {
            throw new RangeError("Invalid highWaterMark");
          }
          return highWaterMark;
        }
        function ExtractSizeAlgorithm(strategy) {
          const { size } = strategy;
          if (!size) {
            return () => 1;
          }
          return size;
        }
        function convertQueuingStrategy(init2, context) {
          assertDictionary(init2, context);
          const highWaterMark = init2 === null || init2 === void 0 ? void 0 : init2.highWaterMark;
          const size = init2 === null || init2 === void 0 ? void 0 : init2.size;
          return {
            highWaterMark: highWaterMark === void 0 ? void 0 : convertUnrestrictedDouble(highWaterMark),
            size: size === void 0 ? void 0 : convertQueuingStrategySize(size, `${context} has member 'size' that`)
          };
        }
        function convertQueuingStrategySize(fn, context) {
          assertFunction(fn, context);
          return (chunk) => convertUnrestrictedDouble(fn(chunk));
        }
        function convertUnderlyingSink(original, context) {
          assertDictionary(original, context);
          const abort = original === null || original === void 0 ? void 0 : original.abort;
          const close = original === null || original === void 0 ? void 0 : original.close;
          const start = original === null || original === void 0 ? void 0 : original.start;
          const type = original === null || original === void 0 ? void 0 : original.type;
          const write = original === null || original === void 0 ? void 0 : original.write;
          return {
            abort: abort === void 0 ? void 0 : convertUnderlyingSinkAbortCallback(abort, original, `${context} has member 'abort' that`),
            close: close === void 0 ? void 0 : convertUnderlyingSinkCloseCallback(close, original, `${context} has member 'close' that`),
            start: start === void 0 ? void 0 : convertUnderlyingSinkStartCallback(start, original, `${context} has member 'start' that`),
            write: write === void 0 ? void 0 : convertUnderlyingSinkWriteCallback(write, original, `${context} has member 'write' that`),
            type
          };
        }
        function convertUnderlyingSinkAbortCallback(fn, original, context) {
          assertFunction(fn, context);
          return (reason) => promiseCall(fn, original, [reason]);
        }
        function convertUnderlyingSinkCloseCallback(fn, original, context) {
          assertFunction(fn, context);
          return () => promiseCall(fn, original, []);
        }
        function convertUnderlyingSinkStartCallback(fn, original, context) {
          assertFunction(fn, context);
          return (controller) => reflectCall(fn, original, [controller]);
        }
        function convertUnderlyingSinkWriteCallback(fn, original, context) {
          assertFunction(fn, context);
          return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);
        }
        function assertWritableStream(x, context) {
          if (!IsWritableStream(x)) {
            throw new TypeError(`${context} is not a WritableStream.`);
          }
        }
        function isAbortSignal2(value) {
          if (typeof value !== "object" || value === null) {
            return false;
          }
          try {
            return typeof value.aborted === "boolean";
          } catch (_a) {
            return false;
          }
        }
        const supportsAbortController = typeof AbortController === "function";
        function createAbortController() {
          if (supportsAbortController) {
            return new AbortController();
          }
          return void 0;
        }
        class WritableStream {
          constructor(rawUnderlyingSink = {}, rawStrategy = {}) {
            if (rawUnderlyingSink === void 0) {
              rawUnderlyingSink = null;
            } else {
              assertObject(rawUnderlyingSink, "First parameter");
            }
            const strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
            const underlyingSink = convertUnderlyingSink(rawUnderlyingSink, "First parameter");
            InitializeWritableStream(this);
            const type = underlyingSink.type;
            if (type !== void 0) {
              throw new RangeError("Invalid type is specified");
            }
            const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
            const highWaterMark = ExtractHighWaterMark(strategy, 1);
            SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);
          }
          get locked() {
            if (!IsWritableStream(this)) {
              throw streamBrandCheckException$2("locked");
            }
            return IsWritableStreamLocked(this);
          }
          abort(reason = void 0) {
            if (!IsWritableStream(this)) {
              return promiseRejectedWith(streamBrandCheckException$2("abort"));
            }
            if (IsWritableStreamLocked(this)) {
              return promiseRejectedWith(new TypeError("Cannot abort a stream that already has a writer"));
            }
            return WritableStreamAbort(this, reason);
          }
          close() {
            if (!IsWritableStream(this)) {
              return promiseRejectedWith(streamBrandCheckException$2("close"));
            }
            if (IsWritableStreamLocked(this)) {
              return promiseRejectedWith(new TypeError("Cannot close a stream that already has a writer"));
            }
            if (WritableStreamCloseQueuedOrInFlight(this)) {
              return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
            }
            return WritableStreamClose(this);
          }
          getWriter() {
            if (!IsWritableStream(this)) {
              throw streamBrandCheckException$2("getWriter");
            }
            return AcquireWritableStreamDefaultWriter(this);
          }
        }
        Object.defineProperties(WritableStream.prototype, {
          abort: { enumerable: true },
          close: { enumerable: true },
          getWriter: { enumerable: true },
          locked: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(WritableStream.prototype, SymbolPolyfill.toStringTag, {
            value: "WritableStream",
            configurable: true
          });
        }
        function AcquireWritableStreamDefaultWriter(stream) {
          return new WritableStreamDefaultWriter(stream);
        }
        function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
          const stream = Object.create(WritableStream.prototype);
          InitializeWritableStream(stream);
          const controller = Object.create(WritableStreamDefaultController.prototype);
          SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
          return stream;
        }
        function InitializeWritableStream(stream) {
          stream._state = "writable";
          stream._storedError = void 0;
          stream._writer = void 0;
          stream._writableStreamController = void 0;
          stream._writeRequests = new SimpleQueue();
          stream._inFlightWriteRequest = void 0;
          stream._closeRequest = void 0;
          stream._inFlightCloseRequest = void 0;
          stream._pendingAbortRequest = void 0;
          stream._backpressure = false;
        }
        function IsWritableStream(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_writableStreamController")) {
            return false;
          }
          return x instanceof WritableStream;
        }
        function IsWritableStreamLocked(stream) {
          if (stream._writer === void 0) {
            return false;
          }
          return true;
        }
        function WritableStreamAbort(stream, reason) {
          var _a;
          if (stream._state === "closed" || stream._state === "errored") {
            return promiseResolvedWith(void 0);
          }
          stream._writableStreamController._abortReason = reason;
          (_a = stream._writableStreamController._abortController) === null || _a === void 0 ? void 0 : _a.abort();
          const state = stream._state;
          if (state === "closed" || state === "errored") {
            return promiseResolvedWith(void 0);
          }
          if (stream._pendingAbortRequest !== void 0) {
            return stream._pendingAbortRequest._promise;
          }
          let wasAlreadyErroring = false;
          if (state === "erroring") {
            wasAlreadyErroring = true;
            reason = void 0;
          }
          const promise = newPromise((resolve2, reject) => {
            stream._pendingAbortRequest = {
              _promise: void 0,
              _resolve: resolve2,
              _reject: reject,
              _reason: reason,
              _wasAlreadyErroring: wasAlreadyErroring
            };
          });
          stream._pendingAbortRequest._promise = promise;
          if (!wasAlreadyErroring) {
            WritableStreamStartErroring(stream, reason);
          }
          return promise;
        }
        function WritableStreamClose(stream) {
          const state = stream._state;
          if (state === "closed" || state === "errored") {
            return promiseRejectedWith(new TypeError(`The stream (in ${state} state) is not in the writable state and cannot be closed`));
          }
          const promise = newPromise((resolve2, reject) => {
            const closeRequest = {
              _resolve: resolve2,
              _reject: reject
            };
            stream._closeRequest = closeRequest;
          });
          const writer = stream._writer;
          if (writer !== void 0 && stream._backpressure && state === "writable") {
            defaultWriterReadyPromiseResolve(writer);
          }
          WritableStreamDefaultControllerClose(stream._writableStreamController);
          return promise;
        }
        function WritableStreamAddWriteRequest(stream) {
          const promise = newPromise((resolve2, reject) => {
            const writeRequest = {
              _resolve: resolve2,
              _reject: reject
            };
            stream._writeRequests.push(writeRequest);
          });
          return promise;
        }
        function WritableStreamDealWithRejection(stream, error2) {
          const state = stream._state;
          if (state === "writable") {
            WritableStreamStartErroring(stream, error2);
            return;
          }
          WritableStreamFinishErroring(stream);
        }
        function WritableStreamStartErroring(stream, reason) {
          const controller = stream._writableStreamController;
          stream._state = "erroring";
          stream._storedError = reason;
          const writer = stream._writer;
          if (writer !== void 0) {
            WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);
          }
          if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {
            WritableStreamFinishErroring(stream);
          }
        }
        function WritableStreamFinishErroring(stream) {
          stream._state = "errored";
          stream._writableStreamController[ErrorSteps]();
          const storedError = stream._storedError;
          stream._writeRequests.forEach((writeRequest) => {
            writeRequest._reject(storedError);
          });
          stream._writeRequests = new SimpleQueue();
          if (stream._pendingAbortRequest === void 0) {
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
            return;
          }
          const abortRequest = stream._pendingAbortRequest;
          stream._pendingAbortRequest = void 0;
          if (abortRequest._wasAlreadyErroring) {
            abortRequest._reject(storedError);
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
            return;
          }
          const promise = stream._writableStreamController[AbortSteps](abortRequest._reason);
          uponPromise(promise, () => {
            abortRequest._resolve();
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          }, (reason) => {
            abortRequest._reject(reason);
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          });
        }
        function WritableStreamFinishInFlightWrite(stream) {
          stream._inFlightWriteRequest._resolve(void 0);
          stream._inFlightWriteRequest = void 0;
        }
        function WritableStreamFinishInFlightWriteWithError(stream, error2) {
          stream._inFlightWriteRequest._reject(error2);
          stream._inFlightWriteRequest = void 0;
          WritableStreamDealWithRejection(stream, error2);
        }
        function WritableStreamFinishInFlightClose(stream) {
          stream._inFlightCloseRequest._resolve(void 0);
          stream._inFlightCloseRequest = void 0;
          const state = stream._state;
          if (state === "erroring") {
            stream._storedError = void 0;
            if (stream._pendingAbortRequest !== void 0) {
              stream._pendingAbortRequest._resolve();
              stream._pendingAbortRequest = void 0;
            }
          }
          stream._state = "closed";
          const writer = stream._writer;
          if (writer !== void 0) {
            defaultWriterClosedPromiseResolve(writer);
          }
        }
        function WritableStreamFinishInFlightCloseWithError(stream, error2) {
          stream._inFlightCloseRequest._reject(error2);
          stream._inFlightCloseRequest = void 0;
          if (stream._pendingAbortRequest !== void 0) {
            stream._pendingAbortRequest._reject(error2);
            stream._pendingAbortRequest = void 0;
          }
          WritableStreamDealWithRejection(stream, error2);
        }
        function WritableStreamCloseQueuedOrInFlight(stream) {
          if (stream._closeRequest === void 0 && stream._inFlightCloseRequest === void 0) {
            return false;
          }
          return true;
        }
        function WritableStreamHasOperationMarkedInFlight(stream) {
          if (stream._inFlightWriteRequest === void 0 && stream._inFlightCloseRequest === void 0) {
            return false;
          }
          return true;
        }
        function WritableStreamMarkCloseRequestInFlight(stream) {
          stream._inFlightCloseRequest = stream._closeRequest;
          stream._closeRequest = void 0;
        }
        function WritableStreamMarkFirstWriteRequestInFlight(stream) {
          stream._inFlightWriteRequest = stream._writeRequests.shift();
        }
        function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {
          if (stream._closeRequest !== void 0) {
            stream._closeRequest._reject(stream._storedError);
            stream._closeRequest = void 0;
          }
          const writer = stream._writer;
          if (writer !== void 0) {
            defaultWriterClosedPromiseReject(writer, stream._storedError);
          }
        }
        function WritableStreamUpdateBackpressure(stream, backpressure) {
          const writer = stream._writer;
          if (writer !== void 0 && backpressure !== stream._backpressure) {
            if (backpressure) {
              defaultWriterReadyPromiseReset(writer);
            } else {
              defaultWriterReadyPromiseResolve(writer);
            }
          }
          stream._backpressure = backpressure;
        }
        class WritableStreamDefaultWriter {
          constructor(stream) {
            assertRequiredArgument(stream, 1, "WritableStreamDefaultWriter");
            assertWritableStream(stream, "First parameter");
            if (IsWritableStreamLocked(stream)) {
              throw new TypeError("This stream has already been locked for exclusive writing by another writer");
            }
            this._ownerWritableStream = stream;
            stream._writer = this;
            const state = stream._state;
            if (state === "writable") {
              if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {
                defaultWriterReadyPromiseInitialize(this);
              } else {
                defaultWriterReadyPromiseInitializeAsResolved(this);
              }
              defaultWriterClosedPromiseInitialize(this);
            } else if (state === "erroring") {
              defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);
              defaultWriterClosedPromiseInitialize(this);
            } else if (state === "closed") {
              defaultWriterReadyPromiseInitializeAsResolved(this);
              defaultWriterClosedPromiseInitializeAsResolved(this);
            } else {
              const storedError = stream._storedError;
              defaultWriterReadyPromiseInitializeAsRejected(this, storedError);
              defaultWriterClosedPromiseInitializeAsRejected(this, storedError);
            }
          }
          get closed() {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("closed"));
            }
            return this._closedPromise;
          }
          get desiredSize() {
            if (!IsWritableStreamDefaultWriter(this)) {
              throw defaultWriterBrandCheckException("desiredSize");
            }
            if (this._ownerWritableStream === void 0) {
              throw defaultWriterLockException("desiredSize");
            }
            return WritableStreamDefaultWriterGetDesiredSize(this);
          }
          get ready() {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("ready"));
            }
            return this._readyPromise;
          }
          abort(reason = void 0) {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("abort"));
            }
            if (this._ownerWritableStream === void 0) {
              return promiseRejectedWith(defaultWriterLockException("abort"));
            }
            return WritableStreamDefaultWriterAbort(this, reason);
          }
          close() {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("close"));
            }
            const stream = this._ownerWritableStream;
            if (stream === void 0) {
              return promiseRejectedWith(defaultWriterLockException("close"));
            }
            if (WritableStreamCloseQueuedOrInFlight(stream)) {
              return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
            }
            return WritableStreamDefaultWriterClose(this);
          }
          releaseLock() {
            if (!IsWritableStreamDefaultWriter(this)) {
              throw defaultWriterBrandCheckException("releaseLock");
            }
            const stream = this._ownerWritableStream;
            if (stream === void 0) {
              return;
            }
            WritableStreamDefaultWriterRelease(this);
          }
          write(chunk = void 0) {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("write"));
            }
            if (this._ownerWritableStream === void 0) {
              return promiseRejectedWith(defaultWriterLockException("write to"));
            }
            return WritableStreamDefaultWriterWrite(this, chunk);
          }
        }
        Object.defineProperties(WritableStreamDefaultWriter.prototype, {
          abort: { enumerable: true },
          close: { enumerable: true },
          releaseLock: { enumerable: true },
          write: { enumerable: true },
          closed: { enumerable: true },
          desiredSize: { enumerable: true },
          ready: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(WritableStreamDefaultWriter.prototype, SymbolPolyfill.toStringTag, {
            value: "WritableStreamDefaultWriter",
            configurable: true
          });
        }
        function IsWritableStreamDefaultWriter(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_ownerWritableStream")) {
            return false;
          }
          return x instanceof WritableStreamDefaultWriter;
        }
        function WritableStreamDefaultWriterAbort(writer, reason) {
          const stream = writer._ownerWritableStream;
          return WritableStreamAbort(stream, reason);
        }
        function WritableStreamDefaultWriterClose(writer) {
          const stream = writer._ownerWritableStream;
          return WritableStreamClose(stream);
        }
        function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {
          const stream = writer._ownerWritableStream;
          const state = stream._state;
          if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
            return promiseResolvedWith(void 0);
          }
          if (state === "errored") {
            return promiseRejectedWith(stream._storedError);
          }
          return WritableStreamDefaultWriterClose(writer);
        }
        function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error2) {
          if (writer._closedPromiseState === "pending") {
            defaultWriterClosedPromiseReject(writer, error2);
          } else {
            defaultWriterClosedPromiseResetToRejected(writer, error2);
          }
        }
        function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error2) {
          if (writer._readyPromiseState === "pending") {
            defaultWriterReadyPromiseReject(writer, error2);
          } else {
            defaultWriterReadyPromiseResetToRejected(writer, error2);
          }
        }
        function WritableStreamDefaultWriterGetDesiredSize(writer) {
          const stream = writer._ownerWritableStream;
          const state = stream._state;
          if (state === "errored" || state === "erroring") {
            return null;
          }
          if (state === "closed") {
            return 0;
          }
          return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);
        }
        function WritableStreamDefaultWriterRelease(writer) {
          const stream = writer._ownerWritableStream;
          const releasedError = new TypeError(`Writer was released and can no longer be used to monitor the stream's closedness`);
          WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);
          WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);
          stream._writer = void 0;
          writer._ownerWritableStream = void 0;
        }
        function WritableStreamDefaultWriterWrite(writer, chunk) {
          const stream = writer._ownerWritableStream;
          const controller = stream._writableStreamController;
          const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);
          if (stream !== writer._ownerWritableStream) {
            return promiseRejectedWith(defaultWriterLockException("write to"));
          }
          const state = stream._state;
          if (state === "errored") {
            return promiseRejectedWith(stream._storedError);
          }
          if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
            return promiseRejectedWith(new TypeError("The stream is closing or closed and cannot be written to"));
          }
          if (state === "erroring") {
            return promiseRejectedWith(stream._storedError);
          }
          const promise = WritableStreamAddWriteRequest(stream);
          WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);
          return promise;
        }
        const closeSentinel = {};
        class WritableStreamDefaultController {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get abortReason() {
            if (!IsWritableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$2("abortReason");
            }
            return this._abortReason;
          }
          get signal() {
            if (!IsWritableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$2("signal");
            }
            if (this._abortController === void 0) {
              throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported");
            }
            return this._abortController.signal;
          }
          error(e = void 0) {
            if (!IsWritableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$2("error");
            }
            const state = this._controlledWritableStream._state;
            if (state !== "writable") {
              return;
            }
            WritableStreamDefaultControllerError(this, e);
          }
          [AbortSteps](reason) {
            const result = this._abortAlgorithm(reason);
            WritableStreamDefaultControllerClearAlgorithms(this);
            return result;
          }
          [ErrorSteps]() {
            ResetQueue(this);
          }
        }
        Object.defineProperties(WritableStreamDefaultController.prototype, {
          error: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(WritableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
            value: "WritableStreamDefaultController",
            configurable: true
          });
        }
        function IsWritableStreamDefaultController(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_controlledWritableStream")) {
            return false;
          }
          return x instanceof WritableStreamDefaultController;
        }
        function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
          controller._controlledWritableStream = stream;
          stream._writableStreamController = controller;
          controller._queue = void 0;
          controller._queueTotalSize = void 0;
          ResetQueue(controller);
          controller._abortReason = void 0;
          controller._abortController = createAbortController();
          controller._started = false;
          controller._strategySizeAlgorithm = sizeAlgorithm;
          controller._strategyHWM = highWaterMark;
          controller._writeAlgorithm = writeAlgorithm;
          controller._closeAlgorithm = closeAlgorithm;
          controller._abortAlgorithm = abortAlgorithm;
          const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
          WritableStreamUpdateBackpressure(stream, backpressure);
          const startResult = startAlgorithm();
          const startPromise = promiseResolvedWith(startResult);
          uponPromise(startPromise, () => {
            controller._started = true;
            WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
          }, (r) => {
            controller._started = true;
            WritableStreamDealWithRejection(stream, r);
          });
        }
        function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {
          const controller = Object.create(WritableStreamDefaultController.prototype);
          let startAlgorithm = () => void 0;
          let writeAlgorithm = () => promiseResolvedWith(void 0);
          let closeAlgorithm = () => promiseResolvedWith(void 0);
          let abortAlgorithm = () => promiseResolvedWith(void 0);
          if (underlyingSink.start !== void 0) {
            startAlgorithm = () => underlyingSink.start(controller);
          }
          if (underlyingSink.write !== void 0) {
            writeAlgorithm = (chunk) => underlyingSink.write(chunk, controller);
          }
          if (underlyingSink.close !== void 0) {
            closeAlgorithm = () => underlyingSink.close();
          }
          if (underlyingSink.abort !== void 0) {
            abortAlgorithm = (reason) => underlyingSink.abort(reason);
          }
          SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
        }
        function WritableStreamDefaultControllerClearAlgorithms(controller) {
          controller._writeAlgorithm = void 0;
          controller._closeAlgorithm = void 0;
          controller._abortAlgorithm = void 0;
          controller._strategySizeAlgorithm = void 0;
        }
        function WritableStreamDefaultControllerClose(controller) {
          EnqueueValueWithSize(controller, closeSentinel, 0);
          WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
        }
        function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {
          try {
            return controller._strategySizeAlgorithm(chunk);
          } catch (chunkSizeE) {
            WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);
            return 1;
          }
        }
        function WritableStreamDefaultControllerGetDesiredSize(controller) {
          return controller._strategyHWM - controller._queueTotalSize;
        }
        function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {
          try {
            EnqueueValueWithSize(controller, chunk, chunkSize);
          } catch (enqueueE) {
            WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);
            return;
          }
          const stream = controller._controlledWritableStream;
          if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === "writable") {
            const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
            WritableStreamUpdateBackpressure(stream, backpressure);
          }
          WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
        }
        function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {
          const stream = controller._controlledWritableStream;
          if (!controller._started) {
            return;
          }
          if (stream._inFlightWriteRequest !== void 0) {
            return;
          }
          const state = stream._state;
          if (state === "erroring") {
            WritableStreamFinishErroring(stream);
            return;
          }
          if (controller._queue.length === 0) {
            return;
          }
          const value = PeekQueueValue(controller);
          if (value === closeSentinel) {
            WritableStreamDefaultControllerProcessClose(controller);
          } else {
            WritableStreamDefaultControllerProcessWrite(controller, value);
          }
        }
        function WritableStreamDefaultControllerErrorIfNeeded(controller, error2) {
          if (controller._controlledWritableStream._state === "writable") {
            WritableStreamDefaultControllerError(controller, error2);
          }
        }
        function WritableStreamDefaultControllerProcessClose(controller) {
          const stream = controller._controlledWritableStream;
          WritableStreamMarkCloseRequestInFlight(stream);
          DequeueValue(controller);
          const sinkClosePromise = controller._closeAlgorithm();
          WritableStreamDefaultControllerClearAlgorithms(controller);
          uponPromise(sinkClosePromise, () => {
            WritableStreamFinishInFlightClose(stream);
          }, (reason) => {
            WritableStreamFinishInFlightCloseWithError(stream, reason);
          });
        }
        function WritableStreamDefaultControllerProcessWrite(controller, chunk) {
          const stream = controller._controlledWritableStream;
          WritableStreamMarkFirstWriteRequestInFlight(stream);
          const sinkWritePromise = controller._writeAlgorithm(chunk);
          uponPromise(sinkWritePromise, () => {
            WritableStreamFinishInFlightWrite(stream);
            const state = stream._state;
            DequeueValue(controller);
            if (!WritableStreamCloseQueuedOrInFlight(stream) && state === "writable") {
              const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
              WritableStreamUpdateBackpressure(stream, backpressure);
            }
            WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
          }, (reason) => {
            if (stream._state === "writable") {
              WritableStreamDefaultControllerClearAlgorithms(controller);
            }
            WritableStreamFinishInFlightWriteWithError(stream, reason);
          });
        }
        function WritableStreamDefaultControllerGetBackpressure(controller) {
          const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);
          return desiredSize <= 0;
        }
        function WritableStreamDefaultControllerError(controller, error2) {
          const stream = controller._controlledWritableStream;
          WritableStreamDefaultControllerClearAlgorithms(controller);
          WritableStreamStartErroring(stream, error2);
        }
        function streamBrandCheckException$2(name) {
          return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);
        }
        function defaultControllerBrandCheckException$2(name) {
          return new TypeError(`WritableStreamDefaultController.prototype.${name} can only be used on a WritableStreamDefaultController`);
        }
        function defaultWriterBrandCheckException(name) {
          return new TypeError(`WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);
        }
        function defaultWriterLockException(name) {
          return new TypeError("Cannot " + name + " a stream using a released writer");
        }
        function defaultWriterClosedPromiseInitialize(writer) {
          writer._closedPromise = newPromise((resolve2, reject) => {
            writer._closedPromise_resolve = resolve2;
            writer._closedPromise_reject = reject;
            writer._closedPromiseState = "pending";
          });
        }
        function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {
          defaultWriterClosedPromiseInitialize(writer);
          defaultWriterClosedPromiseReject(writer, reason);
        }
        function defaultWriterClosedPromiseInitializeAsResolved(writer) {
          defaultWriterClosedPromiseInitialize(writer);
          defaultWriterClosedPromiseResolve(writer);
        }
        function defaultWriterClosedPromiseReject(writer, reason) {
          if (writer._closedPromise_reject === void 0) {
            return;
          }
          setPromiseIsHandledToTrue(writer._closedPromise);
          writer._closedPromise_reject(reason);
          writer._closedPromise_resolve = void 0;
          writer._closedPromise_reject = void 0;
          writer._closedPromiseState = "rejected";
        }
        function defaultWriterClosedPromiseResetToRejected(writer, reason) {
          defaultWriterClosedPromiseInitializeAsRejected(writer, reason);
        }
        function defaultWriterClosedPromiseResolve(writer) {
          if (writer._closedPromise_resolve === void 0) {
            return;
          }
          writer._closedPromise_resolve(void 0);
          writer._closedPromise_resolve = void 0;
          writer._closedPromise_reject = void 0;
          writer._closedPromiseState = "resolved";
        }
        function defaultWriterReadyPromiseInitialize(writer) {
          writer._readyPromise = newPromise((resolve2, reject) => {
            writer._readyPromise_resolve = resolve2;
            writer._readyPromise_reject = reject;
          });
          writer._readyPromiseState = "pending";
        }
        function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {
          defaultWriterReadyPromiseInitialize(writer);
          defaultWriterReadyPromiseReject(writer, reason);
        }
        function defaultWriterReadyPromiseInitializeAsResolved(writer) {
          defaultWriterReadyPromiseInitialize(writer);
          defaultWriterReadyPromiseResolve(writer);
        }
        function defaultWriterReadyPromiseReject(writer, reason) {
          if (writer._readyPromise_reject === void 0) {
            return;
          }
          setPromiseIsHandledToTrue(writer._readyPromise);
          writer._readyPromise_reject(reason);
          writer._readyPromise_resolve = void 0;
          writer._readyPromise_reject = void 0;
          writer._readyPromiseState = "rejected";
        }
        function defaultWriterReadyPromiseReset(writer) {
          defaultWriterReadyPromiseInitialize(writer);
        }
        function defaultWriterReadyPromiseResetToRejected(writer, reason) {
          defaultWriterReadyPromiseInitializeAsRejected(writer, reason);
        }
        function defaultWriterReadyPromiseResolve(writer) {
          if (writer._readyPromise_resolve === void 0) {
            return;
          }
          writer._readyPromise_resolve(void 0);
          writer._readyPromise_resolve = void 0;
          writer._readyPromise_reject = void 0;
          writer._readyPromiseState = "fulfilled";
        }
        const NativeDOMException = typeof DOMException !== "undefined" ? DOMException : void 0;
        function isDOMExceptionConstructor(ctor) {
          if (!(typeof ctor === "function" || typeof ctor === "object")) {
            return false;
          }
          try {
            new ctor();
            return true;
          } catch (_a) {
            return false;
          }
        }
        function createDOMExceptionPolyfill() {
          const ctor = function DOMException2(message, name) {
            this.message = message || "";
            this.name = name || "Error";
            if (Error.captureStackTrace) {
              Error.captureStackTrace(this, this.constructor);
            }
          };
          ctor.prototype = Object.create(Error.prototype);
          Object.defineProperty(ctor.prototype, "constructor", { value: ctor, writable: true, configurable: true });
          return ctor;
        }
        const DOMException$1 = isDOMExceptionConstructor(NativeDOMException) ? NativeDOMException : createDOMExceptionPolyfill();
        function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {
          const reader = AcquireReadableStreamDefaultReader(source);
          const writer = AcquireWritableStreamDefaultWriter(dest);
          source._disturbed = true;
          let shuttingDown = false;
          let currentWrite = promiseResolvedWith(void 0);
          return newPromise((resolve2, reject) => {
            let abortAlgorithm;
            if (signal !== void 0) {
              abortAlgorithm = () => {
                const error2 = new DOMException$1("Aborted", "AbortError");
                const actions = [];
                if (!preventAbort) {
                  actions.push(() => {
                    if (dest._state === "writable") {
                      return WritableStreamAbort(dest, error2);
                    }
                    return promiseResolvedWith(void 0);
                  });
                }
                if (!preventCancel) {
                  actions.push(() => {
                    if (source._state === "readable") {
                      return ReadableStreamCancel(source, error2);
                    }
                    return promiseResolvedWith(void 0);
                  });
                }
                shutdownWithAction(() => Promise.all(actions.map((action) => action())), true, error2);
              };
              if (signal.aborted) {
                abortAlgorithm();
                return;
              }
              signal.addEventListener("abort", abortAlgorithm);
            }
            function pipeLoop() {
              return newPromise((resolveLoop, rejectLoop) => {
                function next(done) {
                  if (done) {
                    resolveLoop();
                  } else {
                    PerformPromiseThen(pipeStep(), next, rejectLoop);
                  }
                }
                next(false);
              });
            }
            function pipeStep() {
              if (shuttingDown) {
                return promiseResolvedWith(true);
              }
              return PerformPromiseThen(writer._readyPromise, () => {
                return newPromise((resolveRead, rejectRead) => {
                  ReadableStreamDefaultReaderRead(reader, {
                    _chunkSteps: (chunk) => {
                      currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), void 0, noop2);
                      resolveRead(false);
                    },
                    _closeSteps: () => resolveRead(true),
                    _errorSteps: rejectRead
                  });
                });
              });
            }
            isOrBecomesErrored(source, reader._closedPromise, (storedError) => {
              if (!preventAbort) {
                shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);
              } else {
                shutdown(true, storedError);
              }
            });
            isOrBecomesErrored(dest, writer._closedPromise, (storedError) => {
              if (!preventCancel) {
                shutdownWithAction(() => ReadableStreamCancel(source, storedError), true, storedError);
              } else {
                shutdown(true, storedError);
              }
            });
            isOrBecomesClosed(source, reader._closedPromise, () => {
              if (!preventClose) {
                shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));
              } else {
                shutdown();
              }
            });
            if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === "closed") {
              const destClosed = new TypeError("the destination writable stream closed before all data could be piped to it");
              if (!preventCancel) {
                shutdownWithAction(() => ReadableStreamCancel(source, destClosed), true, destClosed);
              } else {
                shutdown(true, destClosed);
              }
            }
            setPromiseIsHandledToTrue(pipeLoop());
            function waitForWritesToFinish() {
              const oldCurrentWrite = currentWrite;
              return PerformPromiseThen(currentWrite, () => oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : void 0);
            }
            function isOrBecomesErrored(stream, promise, action) {
              if (stream._state === "errored") {
                action(stream._storedError);
              } else {
                uponRejection(promise, action);
              }
            }
            function isOrBecomesClosed(stream, promise, action) {
              if (stream._state === "closed") {
                action();
              } else {
                uponFulfillment(promise, action);
              }
            }
            function shutdownWithAction(action, originalIsError, originalError) {
              if (shuttingDown) {
                return;
              }
              shuttingDown = true;
              if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
                uponFulfillment(waitForWritesToFinish(), doTheRest);
              } else {
                doTheRest();
              }
              function doTheRest() {
                uponPromise(action(), () => finalize(originalIsError, originalError), (newError) => finalize(true, newError));
              }
            }
            function shutdown(isError, error2) {
              if (shuttingDown) {
                return;
              }
              shuttingDown = true;
              if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
                uponFulfillment(waitForWritesToFinish(), () => finalize(isError, error2));
              } else {
                finalize(isError, error2);
              }
            }
            function finalize(isError, error2) {
              WritableStreamDefaultWriterRelease(writer);
              ReadableStreamReaderGenericRelease(reader);
              if (signal !== void 0) {
                signal.removeEventListener("abort", abortAlgorithm);
              }
              if (isError) {
                reject(error2);
              } else {
                resolve2(void 0);
              }
            }
          });
        }
        class ReadableStreamDefaultController {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get desiredSize() {
            if (!IsReadableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$1("desiredSize");
            }
            return ReadableStreamDefaultControllerGetDesiredSize(this);
          }
          close() {
            if (!IsReadableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$1("close");
            }
            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
              throw new TypeError("The stream is not in a state that permits close");
            }
            ReadableStreamDefaultControllerClose(this);
          }
          enqueue(chunk = void 0) {
            if (!IsReadableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$1("enqueue");
            }
            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
              throw new TypeError("The stream is not in a state that permits enqueue");
            }
            return ReadableStreamDefaultControllerEnqueue(this, chunk);
          }
          error(e = void 0) {
            if (!IsReadableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$1("error");
            }
            ReadableStreamDefaultControllerError(this, e);
          }
          [CancelSteps](reason) {
            ResetQueue(this);
            const result = this._cancelAlgorithm(reason);
            ReadableStreamDefaultControllerClearAlgorithms(this);
            return result;
          }
          [PullSteps](readRequest) {
            const stream = this._controlledReadableStream;
            if (this._queue.length > 0) {
              const chunk = DequeueValue(this);
              if (this._closeRequested && this._queue.length === 0) {
                ReadableStreamDefaultControllerClearAlgorithms(this);
                ReadableStreamClose(stream);
              } else {
                ReadableStreamDefaultControllerCallPullIfNeeded(this);
              }
              readRequest._chunkSteps(chunk);
            } else {
              ReadableStreamAddReadRequest(stream, readRequest);
              ReadableStreamDefaultControllerCallPullIfNeeded(this);
            }
          }
        }
        Object.defineProperties(ReadableStreamDefaultController.prototype, {
          close: { enumerable: true },
          enqueue: { enumerable: true },
          error: { enumerable: true },
          desiredSize: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStreamDefaultController",
            configurable: true
          });
        }
        function IsReadableStreamDefaultController(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_controlledReadableStream")) {
            return false;
          }
          return x instanceof ReadableStreamDefaultController;
        }
        function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {
          const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);
          if (!shouldPull) {
            return;
          }
          if (controller._pulling) {
            controller._pullAgain = true;
            return;
          }
          controller._pulling = true;
          const pullPromise = controller._pullAlgorithm();
          uponPromise(pullPromise, () => {
            controller._pulling = false;
            if (controller._pullAgain) {
              controller._pullAgain = false;
              ReadableStreamDefaultControllerCallPullIfNeeded(controller);
            }
          }, (e) => {
            ReadableStreamDefaultControllerError(controller, e);
          });
        }
        function ReadableStreamDefaultControllerShouldCallPull(controller) {
          const stream = controller._controlledReadableStream;
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
            return false;
          }
          if (!controller._started) {
            return false;
          }
          if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
            return true;
          }
          const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);
          if (desiredSize > 0) {
            return true;
          }
          return false;
        }
        function ReadableStreamDefaultControllerClearAlgorithms(controller) {
          controller._pullAlgorithm = void 0;
          controller._cancelAlgorithm = void 0;
          controller._strategySizeAlgorithm = void 0;
        }
        function ReadableStreamDefaultControllerClose(controller) {
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
            return;
          }
          const stream = controller._controlledReadableStream;
          controller._closeRequested = true;
          if (controller._queue.length === 0) {
            ReadableStreamDefaultControllerClearAlgorithms(controller);
            ReadableStreamClose(stream);
          }
        }
        function ReadableStreamDefaultControllerEnqueue(controller, chunk) {
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
            return;
          }
          const stream = controller._controlledReadableStream;
          if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
            ReadableStreamFulfillReadRequest(stream, chunk, false);
          } else {
            let chunkSize;
            try {
              chunkSize = controller._strategySizeAlgorithm(chunk);
            } catch (chunkSizeE) {
              ReadableStreamDefaultControllerError(controller, chunkSizeE);
              throw chunkSizeE;
            }
            try {
              EnqueueValueWithSize(controller, chunk, chunkSize);
            } catch (enqueueE) {
              ReadableStreamDefaultControllerError(controller, enqueueE);
              throw enqueueE;
            }
          }
          ReadableStreamDefaultControllerCallPullIfNeeded(controller);
        }
        function ReadableStreamDefaultControllerError(controller, e) {
          const stream = controller._controlledReadableStream;
          if (stream._state !== "readable") {
            return;
          }
          ResetQueue(controller);
          ReadableStreamDefaultControllerClearAlgorithms(controller);
          ReadableStreamError(stream, e);
        }
        function ReadableStreamDefaultControllerGetDesiredSize(controller) {
          const state = controller._controlledReadableStream._state;
          if (state === "errored") {
            return null;
          }
          if (state === "closed") {
            return 0;
          }
          return controller._strategyHWM - controller._queueTotalSize;
        }
        function ReadableStreamDefaultControllerHasBackpressure(controller) {
          if (ReadableStreamDefaultControllerShouldCallPull(controller)) {
            return false;
          }
          return true;
        }
        function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {
          const state = controller._controlledReadableStream._state;
          if (!controller._closeRequested && state === "readable") {
            return true;
          }
          return false;
        }
        function SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
          controller._controlledReadableStream = stream;
          controller._queue = void 0;
          controller._queueTotalSize = void 0;
          ResetQueue(controller);
          controller._started = false;
          controller._closeRequested = false;
          controller._pullAgain = false;
          controller._pulling = false;
          controller._strategySizeAlgorithm = sizeAlgorithm;
          controller._strategyHWM = highWaterMark;
          controller._pullAlgorithm = pullAlgorithm;
          controller._cancelAlgorithm = cancelAlgorithm;
          stream._readableStreamController = controller;
          const startResult = startAlgorithm();
          uponPromise(promiseResolvedWith(startResult), () => {
            controller._started = true;
            ReadableStreamDefaultControllerCallPullIfNeeded(controller);
          }, (r) => {
            ReadableStreamDefaultControllerError(controller, r);
          });
        }
        function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {
          const controller = Object.create(ReadableStreamDefaultController.prototype);
          let startAlgorithm = () => void 0;
          let pullAlgorithm = () => promiseResolvedWith(void 0);
          let cancelAlgorithm = () => promiseResolvedWith(void 0);
          if (underlyingSource.start !== void 0) {
            startAlgorithm = () => underlyingSource.start(controller);
          }
          if (underlyingSource.pull !== void 0) {
            pullAlgorithm = () => underlyingSource.pull(controller);
          }
          if (underlyingSource.cancel !== void 0) {
            cancelAlgorithm = (reason) => underlyingSource.cancel(reason);
          }
          SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
        }
        function defaultControllerBrandCheckException$1(name) {
          return new TypeError(`ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);
        }
        function ReadableStreamTee(stream, cloneForBranch2) {
          if (IsReadableByteStreamController(stream._readableStreamController)) {
            return ReadableByteStreamTee(stream);
          }
          return ReadableStreamDefaultTee(stream);
        }
        function ReadableStreamDefaultTee(stream, cloneForBranch2) {
          const reader = AcquireReadableStreamDefaultReader(stream);
          let reading = false;
          let canceled1 = false;
          let canceled2 = false;
          let reason1;
          let reason2;
          let branch1;
          let branch2;
          let resolveCancelPromise;
          const cancelPromise = newPromise((resolve2) => {
            resolveCancelPromise = resolve2;
          });
          function pullAlgorithm() {
            if (reading) {
              return promiseResolvedWith(void 0);
            }
            reading = true;
            const readRequest = {
              _chunkSteps: (chunk) => {
                queueMicrotask(() => {
                  reading = false;
                  const chunk1 = chunk;
                  const chunk2 = chunk;
                  if (!canceled1) {
                    ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1);
                  }
                  if (!canceled2) {
                    ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2);
                  }
                });
              },
              _closeSteps: () => {
                reading = false;
                if (!canceled1) {
                  ReadableStreamDefaultControllerClose(branch1._readableStreamController);
                }
                if (!canceled2) {
                  ReadableStreamDefaultControllerClose(branch2._readableStreamController);
                }
                if (!canceled1 || !canceled2) {
                  resolveCancelPromise(void 0);
                }
              },
              _errorSteps: () => {
                reading = false;
              }
            };
            ReadableStreamDefaultReaderRead(reader, readRequest);
            return promiseResolvedWith(void 0);
          }
          function cancel1Algorithm(reason) {
            canceled1 = true;
            reason1 = reason;
            if (canceled2) {
              const compositeReason = CreateArrayFromList([reason1, reason2]);
              const cancelResult = ReadableStreamCancel(stream, compositeReason);
              resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
          }
          function cancel2Algorithm(reason) {
            canceled2 = true;
            reason2 = reason;
            if (canceled1) {
              const compositeReason = CreateArrayFromList([reason1, reason2]);
              const cancelResult = ReadableStreamCancel(stream, compositeReason);
              resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
          }
          function startAlgorithm() {
          }
          branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);
          branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);
          uponRejection(reader._closedPromise, (r) => {
            ReadableStreamDefaultControllerError(branch1._readableStreamController, r);
            ReadableStreamDefaultControllerError(branch2._readableStreamController, r);
            if (!canceled1 || !canceled2) {
              resolveCancelPromise(void 0);
            }
          });
          return [branch1, branch2];
        }
        function ReadableByteStreamTee(stream) {
          let reader = AcquireReadableStreamDefaultReader(stream);
          let reading = false;
          let canceled1 = false;
          let canceled2 = false;
          let reason1;
          let reason2;
          let branch1;
          let branch2;
          let resolveCancelPromise;
          const cancelPromise = newPromise((resolve2) => {
            resolveCancelPromise = resolve2;
          });
          function forwardReaderError(thisReader) {
            uponRejection(thisReader._closedPromise, (r) => {
              if (thisReader !== reader) {
                return;
              }
              ReadableByteStreamControllerError(branch1._readableStreamController, r);
              ReadableByteStreamControllerError(branch2._readableStreamController, r);
              if (!canceled1 || !canceled2) {
                resolveCancelPromise(void 0);
              }
            });
          }
          function pullWithDefaultReader() {
            if (IsReadableStreamBYOBReader(reader)) {
              ReadableStreamReaderGenericRelease(reader);
              reader = AcquireReadableStreamDefaultReader(stream);
              forwardReaderError(reader);
            }
            const readRequest = {
              _chunkSteps: (chunk) => {
                queueMicrotask(() => {
                  reading = false;
                  const chunk1 = chunk;
                  let chunk2 = chunk;
                  if (!canceled1 && !canceled2) {
                    try {
                      chunk2 = CloneAsUint8Array(chunk);
                    } catch (cloneE) {
                      ReadableByteStreamControllerError(branch1._readableStreamController, cloneE);
                      ReadableByteStreamControllerError(branch2._readableStreamController, cloneE);
                      resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                      return;
                    }
                  }
                  if (!canceled1) {
                    ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1);
                  }
                  if (!canceled2) {
                    ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);
                  }
                });
              },
              _closeSteps: () => {
                reading = false;
                if (!canceled1) {
                  ReadableByteStreamControllerClose(branch1._readableStreamController);
                }
                if (!canceled2) {
                  ReadableByteStreamControllerClose(branch2._readableStreamController);
                }
                if (branch1._readableStreamController._pendingPullIntos.length > 0) {
                  ReadableByteStreamControllerRespond(branch1._readableStreamController, 0);
                }
                if (branch2._readableStreamController._pendingPullIntos.length > 0) {
                  ReadableByteStreamControllerRespond(branch2._readableStreamController, 0);
                }
                if (!canceled1 || !canceled2) {
                  resolveCancelPromise(void 0);
                }
              },
              _errorSteps: () => {
                reading = false;
              }
            };
            ReadableStreamDefaultReaderRead(reader, readRequest);
          }
          function pullWithBYOBReader(view, forBranch2) {
            if (IsReadableStreamDefaultReader(reader)) {
              ReadableStreamReaderGenericRelease(reader);
              reader = AcquireReadableStreamBYOBReader(stream);
              forwardReaderError(reader);
            }
            const byobBranch = forBranch2 ? branch2 : branch1;
            const otherBranch = forBranch2 ? branch1 : branch2;
            const readIntoRequest = {
              _chunkSteps: (chunk) => {
                queueMicrotask(() => {
                  reading = false;
                  const byobCanceled = forBranch2 ? canceled2 : canceled1;
                  const otherCanceled = forBranch2 ? canceled1 : canceled2;
                  if (!otherCanceled) {
                    let clonedChunk;
                    try {
                      clonedChunk = CloneAsUint8Array(chunk);
                    } catch (cloneE) {
                      ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE);
                      ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE);
                      resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                      return;
                    }
                    if (!byobCanceled) {
                      ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                    }
                    ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);
                  } else if (!byobCanceled) {
                    ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                  }
                });
              },
              _closeSteps: (chunk) => {
                reading = false;
                const byobCanceled = forBranch2 ? canceled2 : canceled1;
                const otherCanceled = forBranch2 ? canceled1 : canceled2;
                if (!byobCanceled) {
                  ReadableByteStreamControllerClose(byobBranch._readableStreamController);
                }
                if (!otherCanceled) {
                  ReadableByteStreamControllerClose(otherBranch._readableStreamController);
                }
                if (chunk !== void 0) {
                  if (!byobCanceled) {
                    ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                  }
                  if (!otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0) {
                    ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0);
                  }
                }
                if (!byobCanceled || !otherCanceled) {
                  resolveCancelPromise(void 0);
                }
              },
              _errorSteps: () => {
                reading = false;
              }
            };
            ReadableStreamBYOBReaderRead(reader, view, readIntoRequest);
          }
          function pull1Algorithm() {
            if (reading) {
              return promiseResolvedWith(void 0);
            }
            reading = true;
            const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);
            if (byobRequest === null) {
              pullWithDefaultReader();
            } else {
              pullWithBYOBReader(byobRequest._view, false);
            }
            return promiseResolvedWith(void 0);
          }
          function pull2Algorithm() {
            if (reading) {
              return promiseResolvedWith(void 0);
            }
            reading = true;
            const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);
            if (byobRequest === null) {
              pullWithDefaultReader();
            } else {
              pullWithBYOBReader(byobRequest._view, true);
            }
            return promiseResolvedWith(void 0);
          }
          function cancel1Algorithm(reason) {
            canceled1 = true;
            reason1 = reason;
            if (canceled2) {
              const compositeReason = CreateArrayFromList([reason1, reason2]);
              const cancelResult = ReadableStreamCancel(stream, compositeReason);
              resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
          }
          function cancel2Algorithm(reason) {
            canceled2 = true;
            reason2 = reason;
            if (canceled1) {
              const compositeReason = CreateArrayFromList([reason1, reason2]);
              const cancelResult = ReadableStreamCancel(stream, compositeReason);
              resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
          }
          function startAlgorithm() {
            return;
          }
          branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);
          branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);
          forwardReaderError(reader);
          return [branch1, branch2];
        }
        function convertUnderlyingDefaultOrByteSource(source, context) {
          assertDictionary(source, context);
          const original = source;
          const autoAllocateChunkSize = original === null || original === void 0 ? void 0 : original.autoAllocateChunkSize;
          const cancel = original === null || original === void 0 ? void 0 : original.cancel;
          const pull = original === null || original === void 0 ? void 0 : original.pull;
          const start = original === null || original === void 0 ? void 0 : original.start;
          const type = original === null || original === void 0 ? void 0 : original.type;
          return {
            autoAllocateChunkSize: autoAllocateChunkSize === void 0 ? void 0 : convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, `${context} has member 'autoAllocateChunkSize' that`),
            cancel: cancel === void 0 ? void 0 : convertUnderlyingSourceCancelCallback(cancel, original, `${context} has member 'cancel' that`),
            pull: pull === void 0 ? void 0 : convertUnderlyingSourcePullCallback(pull, original, `${context} has member 'pull' that`),
            start: start === void 0 ? void 0 : convertUnderlyingSourceStartCallback(start, original, `${context} has member 'start' that`),
            type: type === void 0 ? void 0 : convertReadableStreamType(type, `${context} has member 'type' that`)
          };
        }
        function convertUnderlyingSourceCancelCallback(fn, original, context) {
          assertFunction(fn, context);
          return (reason) => promiseCall(fn, original, [reason]);
        }
        function convertUnderlyingSourcePullCallback(fn, original, context) {
          assertFunction(fn, context);
          return (controller) => promiseCall(fn, original, [controller]);
        }
        function convertUnderlyingSourceStartCallback(fn, original, context) {
          assertFunction(fn, context);
          return (controller) => reflectCall(fn, original, [controller]);
        }
        function convertReadableStreamType(type, context) {
          type = `${type}`;
          if (type !== "bytes") {
            throw new TypeError(`${context} '${type}' is not a valid enumeration value for ReadableStreamType`);
          }
          return type;
        }
        function convertReaderOptions(options2, context) {
          assertDictionary(options2, context);
          const mode = options2 === null || options2 === void 0 ? void 0 : options2.mode;
          return {
            mode: mode === void 0 ? void 0 : convertReadableStreamReaderMode(mode, `${context} has member 'mode' that`)
          };
        }
        function convertReadableStreamReaderMode(mode, context) {
          mode = `${mode}`;
          if (mode !== "byob") {
            throw new TypeError(`${context} '${mode}' is not a valid enumeration value for ReadableStreamReaderMode`);
          }
          return mode;
        }
        function convertIteratorOptions(options2, context) {
          assertDictionary(options2, context);
          const preventCancel = options2 === null || options2 === void 0 ? void 0 : options2.preventCancel;
          return { preventCancel: Boolean(preventCancel) };
        }
        function convertPipeOptions(options2, context) {
          assertDictionary(options2, context);
          const preventAbort = options2 === null || options2 === void 0 ? void 0 : options2.preventAbort;
          const preventCancel = options2 === null || options2 === void 0 ? void 0 : options2.preventCancel;
          const preventClose = options2 === null || options2 === void 0 ? void 0 : options2.preventClose;
          const signal = options2 === null || options2 === void 0 ? void 0 : options2.signal;
          if (signal !== void 0) {
            assertAbortSignal(signal, `${context} has member 'signal' that`);
          }
          return {
            preventAbort: Boolean(preventAbort),
            preventCancel: Boolean(preventCancel),
            preventClose: Boolean(preventClose),
            signal
          };
        }
        function assertAbortSignal(signal, context) {
          if (!isAbortSignal2(signal)) {
            throw new TypeError(`${context} is not an AbortSignal.`);
          }
        }
        function convertReadableWritablePair(pair, context) {
          assertDictionary(pair, context);
          const readable = pair === null || pair === void 0 ? void 0 : pair.readable;
          assertRequiredField(readable, "readable", "ReadableWritablePair");
          assertReadableStream(readable, `${context} has member 'readable' that`);
          const writable2 = pair === null || pair === void 0 ? void 0 : pair.writable;
          assertRequiredField(writable2, "writable", "ReadableWritablePair");
          assertWritableStream(writable2, `${context} has member 'writable' that`);
          return { readable, writable: writable2 };
        }
        class ReadableStream2 {
          constructor(rawUnderlyingSource = {}, rawStrategy = {}) {
            if (rawUnderlyingSource === void 0) {
              rawUnderlyingSource = null;
            } else {
              assertObject(rawUnderlyingSource, "First parameter");
            }
            const strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
            const underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, "First parameter");
            InitializeReadableStream(this);
            if (underlyingSource.type === "bytes") {
              if (strategy.size !== void 0) {
                throw new RangeError("The strategy for a byte stream cannot have a size function");
              }
              const highWaterMark = ExtractHighWaterMark(strategy, 0);
              SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);
            } else {
              const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
              const highWaterMark = ExtractHighWaterMark(strategy, 1);
              SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);
            }
          }
          get locked() {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("locked");
            }
            return IsReadableStreamLocked(this);
          }
          cancel(reason = void 0) {
            if (!IsReadableStream(this)) {
              return promiseRejectedWith(streamBrandCheckException$1("cancel"));
            }
            if (IsReadableStreamLocked(this)) {
              return promiseRejectedWith(new TypeError("Cannot cancel a stream that already has a reader"));
            }
            return ReadableStreamCancel(this, reason);
          }
          getReader(rawOptions = void 0) {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("getReader");
            }
            const options2 = convertReaderOptions(rawOptions, "First parameter");
            if (options2.mode === void 0) {
              return AcquireReadableStreamDefaultReader(this);
            }
            return AcquireReadableStreamBYOBReader(this);
          }
          pipeThrough(rawTransform, rawOptions = {}) {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("pipeThrough");
            }
            assertRequiredArgument(rawTransform, 1, "pipeThrough");
            const transform = convertReadableWritablePair(rawTransform, "First parameter");
            const options2 = convertPipeOptions(rawOptions, "Second parameter");
            if (IsReadableStreamLocked(this)) {
              throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");
            }
            if (IsWritableStreamLocked(transform.writable)) {
              throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");
            }
            const promise = ReadableStreamPipeTo(this, transform.writable, options2.preventClose, options2.preventAbort, options2.preventCancel, options2.signal);
            setPromiseIsHandledToTrue(promise);
            return transform.readable;
          }
          pipeTo(destination, rawOptions = {}) {
            if (!IsReadableStream(this)) {
              return promiseRejectedWith(streamBrandCheckException$1("pipeTo"));
            }
            if (destination === void 0) {
              return promiseRejectedWith(`Parameter 1 is required in 'pipeTo'.`);
            }
            if (!IsWritableStream(destination)) {
              return promiseRejectedWith(new TypeError(`ReadableStream.prototype.pipeTo's first argument must be a WritableStream`));
            }
            let options2;
            try {
              options2 = convertPipeOptions(rawOptions, "Second parameter");
            } catch (e) {
              return promiseRejectedWith(e);
            }
            if (IsReadableStreamLocked(this)) {
              return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream"));
            }
            if (IsWritableStreamLocked(destination)) {
              return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream"));
            }
            return ReadableStreamPipeTo(this, destination, options2.preventClose, options2.preventAbort, options2.preventCancel, options2.signal);
          }
          tee() {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("tee");
            }
            const branches = ReadableStreamTee(this);
            return CreateArrayFromList(branches);
          }
          values(rawOptions = void 0) {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("values");
            }
            const options2 = convertIteratorOptions(rawOptions, "First parameter");
            return AcquireReadableStreamAsyncIterator(this, options2.preventCancel);
          }
        }
        Object.defineProperties(ReadableStream2.prototype, {
          cancel: { enumerable: true },
          getReader: { enumerable: true },
          pipeThrough: { enumerable: true },
          pipeTo: { enumerable: true },
          tee: { enumerable: true },
          values: { enumerable: true },
          locked: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStream2.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStream",
            configurable: true
          });
        }
        if (typeof SymbolPolyfill.asyncIterator === "symbol") {
          Object.defineProperty(ReadableStream2.prototype, SymbolPolyfill.asyncIterator, {
            value: ReadableStream2.prototype.values,
            writable: true,
            configurable: true
          });
        }
        function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
          const stream = Object.create(ReadableStream2.prototype);
          InitializeReadableStream(stream);
          const controller = Object.create(ReadableStreamDefaultController.prototype);
          SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
          return stream;
        }
        function CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm) {
          const stream = Object.create(ReadableStream2.prototype);
          InitializeReadableStream(stream);
          const controller = Object.create(ReadableByteStreamController.prototype);
          SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, void 0);
          return stream;
        }
        function InitializeReadableStream(stream) {
          stream._state = "readable";
          stream._reader = void 0;
          stream._storedError = void 0;
          stream._disturbed = false;
        }
        function IsReadableStream(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_readableStreamController")) {
            return false;
          }
          return x instanceof ReadableStream2;
        }
        function IsReadableStreamLocked(stream) {
          if (stream._reader === void 0) {
            return false;
          }
          return true;
        }
        function ReadableStreamCancel(stream, reason) {
          stream._disturbed = true;
          if (stream._state === "closed") {
            return promiseResolvedWith(void 0);
          }
          if (stream._state === "errored") {
            return promiseRejectedWith(stream._storedError);
          }
          ReadableStreamClose(stream);
          const reader = stream._reader;
          if (reader !== void 0 && IsReadableStreamBYOBReader(reader)) {
            reader._readIntoRequests.forEach((readIntoRequest) => {
              readIntoRequest._closeSteps(void 0);
            });
            reader._readIntoRequests = new SimpleQueue();
          }
          const sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);
          return transformPromiseWith(sourceCancelPromise, noop2);
        }
        function ReadableStreamClose(stream) {
          stream._state = "closed";
          const reader = stream._reader;
          if (reader === void 0) {
            return;
          }
          defaultReaderClosedPromiseResolve(reader);
          if (IsReadableStreamDefaultReader(reader)) {
            reader._readRequests.forEach((readRequest) => {
              readRequest._closeSteps();
            });
            reader._readRequests = new SimpleQueue();
          }
        }
        function ReadableStreamError(stream, e) {
          stream._state = "errored";
          stream._storedError = e;
          const reader = stream._reader;
          if (reader === void 0) {
            return;
          }
          defaultReaderClosedPromiseReject(reader, e);
          if (IsReadableStreamDefaultReader(reader)) {
            reader._readRequests.forEach((readRequest) => {
              readRequest._errorSteps(e);
            });
            reader._readRequests = new SimpleQueue();
          } else {
            reader._readIntoRequests.forEach((readIntoRequest) => {
              readIntoRequest._errorSteps(e);
            });
            reader._readIntoRequests = new SimpleQueue();
          }
        }
        function streamBrandCheckException$1(name) {
          return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);
        }
        function convertQueuingStrategyInit(init2, context) {
          assertDictionary(init2, context);
          const highWaterMark = init2 === null || init2 === void 0 ? void 0 : init2.highWaterMark;
          assertRequiredField(highWaterMark, "highWaterMark", "QueuingStrategyInit");
          return {
            highWaterMark: convertUnrestrictedDouble(highWaterMark)
          };
        }
        const byteLengthSizeFunction = (chunk) => {
          return chunk.byteLength;
        };
        Object.defineProperty(byteLengthSizeFunction, "name", {
          value: "size",
          configurable: true
        });
        class ByteLengthQueuingStrategy {
          constructor(options2) {
            assertRequiredArgument(options2, 1, "ByteLengthQueuingStrategy");
            options2 = convertQueuingStrategyInit(options2, "First parameter");
            this._byteLengthQueuingStrategyHighWaterMark = options2.highWaterMark;
          }
          get highWaterMark() {
            if (!IsByteLengthQueuingStrategy(this)) {
              throw byteLengthBrandCheckException("highWaterMark");
            }
            return this._byteLengthQueuingStrategyHighWaterMark;
          }
          get size() {
            if (!IsByteLengthQueuingStrategy(this)) {
              throw byteLengthBrandCheckException("size");
            }
            return byteLengthSizeFunction;
          }
        }
        Object.defineProperties(ByteLengthQueuingStrategy.prototype, {
          highWaterMark: { enumerable: true },
          size: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ByteLengthQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
            value: "ByteLengthQueuingStrategy",
            configurable: true
          });
        }
        function byteLengthBrandCheckException(name) {
          return new TypeError(`ByteLengthQueuingStrategy.prototype.${name} can only be used on a ByteLengthQueuingStrategy`);
        }
        function IsByteLengthQueuingStrategy(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_byteLengthQueuingStrategyHighWaterMark")) {
            return false;
          }
          return x instanceof ByteLengthQueuingStrategy;
        }
        const countSizeFunction = () => {
          return 1;
        };
        Object.defineProperty(countSizeFunction, "name", {
          value: "size",
          configurable: true
        });
        class CountQueuingStrategy {
          constructor(options2) {
            assertRequiredArgument(options2, 1, "CountQueuingStrategy");
            options2 = convertQueuingStrategyInit(options2, "First parameter");
            this._countQueuingStrategyHighWaterMark = options2.highWaterMark;
          }
          get highWaterMark() {
            if (!IsCountQueuingStrategy(this)) {
              throw countBrandCheckException("highWaterMark");
            }
            return this._countQueuingStrategyHighWaterMark;
          }
          get size() {
            if (!IsCountQueuingStrategy(this)) {
              throw countBrandCheckException("size");
            }
            return countSizeFunction;
          }
        }
        Object.defineProperties(CountQueuingStrategy.prototype, {
          highWaterMark: { enumerable: true },
          size: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(CountQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
            value: "CountQueuingStrategy",
            configurable: true
          });
        }
        function countBrandCheckException(name) {
          return new TypeError(`CountQueuingStrategy.prototype.${name} can only be used on a CountQueuingStrategy`);
        }
        function IsCountQueuingStrategy(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_countQueuingStrategyHighWaterMark")) {
            return false;
          }
          return x instanceof CountQueuingStrategy;
        }
        function convertTransformer(original, context) {
          assertDictionary(original, context);
          const flush = original === null || original === void 0 ? void 0 : original.flush;
          const readableType = original === null || original === void 0 ? void 0 : original.readableType;
          const start = original === null || original === void 0 ? void 0 : original.start;
          const transform = original === null || original === void 0 ? void 0 : original.transform;
          const writableType = original === null || original === void 0 ? void 0 : original.writableType;
          return {
            flush: flush === void 0 ? void 0 : convertTransformerFlushCallback(flush, original, `${context} has member 'flush' that`),
            readableType,
            start: start === void 0 ? void 0 : convertTransformerStartCallback(start, original, `${context} has member 'start' that`),
            transform: transform === void 0 ? void 0 : convertTransformerTransformCallback(transform, original, `${context} has member 'transform' that`),
            writableType
          };
        }
        function convertTransformerFlushCallback(fn, original, context) {
          assertFunction(fn, context);
          return (controller) => promiseCall(fn, original, [controller]);
        }
        function convertTransformerStartCallback(fn, original, context) {
          assertFunction(fn, context);
          return (controller) => reflectCall(fn, original, [controller]);
        }
        function convertTransformerTransformCallback(fn, original, context) {
          assertFunction(fn, context);
          return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);
        }
        class TransformStream {
          constructor(rawTransformer = {}, rawWritableStrategy = {}, rawReadableStrategy = {}) {
            if (rawTransformer === void 0) {
              rawTransformer = null;
            }
            const writableStrategy = convertQueuingStrategy(rawWritableStrategy, "Second parameter");
            const readableStrategy = convertQueuingStrategy(rawReadableStrategy, "Third parameter");
            const transformer2 = convertTransformer(rawTransformer, "First parameter");
            if (transformer2.readableType !== void 0) {
              throw new RangeError("Invalid readableType specified");
            }
            if (transformer2.writableType !== void 0) {
              throw new RangeError("Invalid writableType specified");
            }
            const readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);
            const readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);
            const writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);
            const writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);
            let startPromise_resolve;
            const startPromise = newPromise((resolve2) => {
              startPromise_resolve = resolve2;
            });
            InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
            SetUpTransformStreamDefaultControllerFromTransformer(this, transformer2);
            if (transformer2.start !== void 0) {
              startPromise_resolve(transformer2.start(this._transformStreamController));
            } else {
              startPromise_resolve(void 0);
            }
          }
          get readable() {
            if (!IsTransformStream(this)) {
              throw streamBrandCheckException("readable");
            }
            return this._readable;
          }
          get writable() {
            if (!IsTransformStream(this)) {
              throw streamBrandCheckException("writable");
            }
            return this._writable;
          }
        }
        Object.defineProperties(TransformStream.prototype, {
          readable: { enumerable: true },
          writable: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(TransformStream.prototype, SymbolPolyfill.toStringTag, {
            value: "TransformStream",
            configurable: true
          });
        }
        function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {
          function startAlgorithm() {
            return startPromise;
          }
          function writeAlgorithm(chunk) {
            return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);
          }
          function abortAlgorithm(reason) {
            return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);
          }
          function closeAlgorithm() {
            return TransformStreamDefaultSinkCloseAlgorithm(stream);
          }
          stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);
          function pullAlgorithm() {
            return TransformStreamDefaultSourcePullAlgorithm(stream);
          }
          function cancelAlgorithm(reason) {
            TransformStreamErrorWritableAndUnblockWrite(stream, reason);
            return promiseResolvedWith(void 0);
          }
          stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
          stream._backpressure = void 0;
          stream._backpressureChangePromise = void 0;
          stream._backpressureChangePromise_resolve = void 0;
          TransformStreamSetBackpressure(stream, true);
          stream._transformStreamController = void 0;
        }
        function IsTransformStream(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_transformStreamController")) {
            return false;
          }
          return x instanceof TransformStream;
        }
        function TransformStreamError(stream, e) {
          ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e);
          TransformStreamErrorWritableAndUnblockWrite(stream, e);
        }
        function TransformStreamErrorWritableAndUnblockWrite(stream, e) {
          TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);
          WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e);
          if (stream._backpressure) {
            TransformStreamSetBackpressure(stream, false);
          }
        }
        function TransformStreamSetBackpressure(stream, backpressure) {
          if (stream._backpressureChangePromise !== void 0) {
            stream._backpressureChangePromise_resolve();
          }
          stream._backpressureChangePromise = newPromise((resolve2) => {
            stream._backpressureChangePromise_resolve = resolve2;
          });
          stream._backpressure = backpressure;
        }
        class TransformStreamDefaultController {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get desiredSize() {
            if (!IsTransformStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException("desiredSize");
            }
            const readableController = this._controlledTransformStream._readable._readableStreamController;
            return ReadableStreamDefaultControllerGetDesiredSize(readableController);
          }
          enqueue(chunk = void 0) {
            if (!IsTransformStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException("enqueue");
            }
            TransformStreamDefaultControllerEnqueue(this, chunk);
          }
          error(reason = void 0) {
            if (!IsTransformStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException("error");
            }
            TransformStreamDefaultControllerError(this, reason);
          }
          terminate() {
            if (!IsTransformStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException("terminate");
            }
            TransformStreamDefaultControllerTerminate(this);
          }
        }
        Object.defineProperties(TransformStreamDefaultController.prototype, {
          enqueue: { enumerable: true },
          error: { enumerable: true },
          terminate: { enumerable: true },
          desiredSize: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(TransformStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
            value: "TransformStreamDefaultController",
            configurable: true
          });
        }
        function IsTransformStreamDefaultController(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_controlledTransformStream")) {
            return false;
          }
          return x instanceof TransformStreamDefaultController;
        }
        function SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {
          controller._controlledTransformStream = stream;
          stream._transformStreamController = controller;
          controller._transformAlgorithm = transformAlgorithm;
          controller._flushAlgorithm = flushAlgorithm;
        }
        function SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer2) {
          const controller = Object.create(TransformStreamDefaultController.prototype);
          let transformAlgorithm = (chunk) => {
            try {
              TransformStreamDefaultControllerEnqueue(controller, chunk);
              return promiseResolvedWith(void 0);
            } catch (transformResultE) {
              return promiseRejectedWith(transformResultE);
            }
          };
          let flushAlgorithm = () => promiseResolvedWith(void 0);
          if (transformer2.transform !== void 0) {
            transformAlgorithm = (chunk) => transformer2.transform(chunk, controller);
          }
          if (transformer2.flush !== void 0) {
            flushAlgorithm = () => transformer2.flush(controller);
          }
          SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);
        }
        function TransformStreamDefaultControllerClearAlgorithms(controller) {
          controller._transformAlgorithm = void 0;
          controller._flushAlgorithm = void 0;
        }
        function TransformStreamDefaultControllerEnqueue(controller, chunk) {
          const stream = controller._controlledTransformStream;
          const readableController = stream._readable._readableStreamController;
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {
            throw new TypeError("Readable side is not in a state that permits enqueue");
          }
          try {
            ReadableStreamDefaultControllerEnqueue(readableController, chunk);
          } catch (e) {
            TransformStreamErrorWritableAndUnblockWrite(stream, e);
            throw stream._readable._storedError;
          }
          const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);
          if (backpressure !== stream._backpressure) {
            TransformStreamSetBackpressure(stream, true);
          }
        }
        function TransformStreamDefaultControllerError(controller, e) {
          TransformStreamError(controller._controlledTransformStream, e);
        }
        function TransformStreamDefaultControllerPerformTransform(controller, chunk) {
          const transformPromise = controller._transformAlgorithm(chunk);
          return transformPromiseWith(transformPromise, void 0, (r) => {
            TransformStreamError(controller._controlledTransformStream, r);
            throw r;
          });
        }
        function TransformStreamDefaultControllerTerminate(controller) {
          const stream = controller._controlledTransformStream;
          const readableController = stream._readable._readableStreamController;
          ReadableStreamDefaultControllerClose(readableController);
          const error2 = new TypeError("TransformStream terminated");
          TransformStreamErrorWritableAndUnblockWrite(stream, error2);
        }
        function TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {
          const controller = stream._transformStreamController;
          if (stream._backpressure) {
            const backpressureChangePromise = stream._backpressureChangePromise;
            return transformPromiseWith(backpressureChangePromise, () => {
              const writable2 = stream._writable;
              const state = writable2._state;
              if (state === "erroring") {
                throw writable2._storedError;
              }
              return TransformStreamDefaultControllerPerformTransform(controller, chunk);
            });
          }
          return TransformStreamDefaultControllerPerformTransform(controller, chunk);
        }
        function TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {
          TransformStreamError(stream, reason);
          return promiseResolvedWith(void 0);
        }
        function TransformStreamDefaultSinkCloseAlgorithm(stream) {
          const readable = stream._readable;
          const controller = stream._transformStreamController;
          const flushPromise = controller._flushAlgorithm();
          TransformStreamDefaultControllerClearAlgorithms(controller);
          return transformPromiseWith(flushPromise, () => {
            if (readable._state === "errored") {
              throw readable._storedError;
            }
            ReadableStreamDefaultControllerClose(readable._readableStreamController);
          }, (r) => {
            TransformStreamError(stream, r);
            throw readable._storedError;
          });
        }
        function TransformStreamDefaultSourcePullAlgorithm(stream) {
          TransformStreamSetBackpressure(stream, false);
          return stream._backpressureChangePromise;
        }
        function defaultControllerBrandCheckException(name) {
          return new TypeError(`TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);
        }
        function streamBrandCheckException(name) {
          return new TypeError(`TransformStream.prototype.${name} can only be used on a TransformStream`);
        }
        exports2.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy;
        exports2.CountQueuingStrategy = CountQueuingStrategy;
        exports2.ReadableByteStreamController = ReadableByteStreamController;
        exports2.ReadableStream = ReadableStream2;
        exports2.ReadableStreamBYOBReader = ReadableStreamBYOBReader;
        exports2.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest;
        exports2.ReadableStreamDefaultController = ReadableStreamDefaultController;
        exports2.ReadableStreamDefaultReader = ReadableStreamDefaultReader;
        exports2.TransformStream = TransformStream;
        exports2.TransformStreamDefaultController = TransformStreamDefaultController;
        exports2.WritableStream = WritableStream;
        exports2.WritableStreamDefaultController = WritableStreamDefaultController;
        exports2.WritableStreamDefaultWriter = WritableStreamDefaultWriter;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    })(ponyfill_es2018, ponyfill_es2018.exports);
    POOL_SIZE$1 = 65536;
    if (!globalThis.ReadableStream) {
      try {
        Object.assign(globalThis, require("stream/web"));
      } catch (error2) {
        Object.assign(globalThis, ponyfill_es2018.exports);
      }
    }
    try {
      const { Blob: Blob3 } = require("buffer");
      if (Blob3 && !Blob3.prototype.stream) {
        Blob3.prototype.stream = function name(params) {
          let position = 0;
          const blob = this;
          return new ReadableStream({
            type: "bytes",
            async pull(ctrl) {
              const chunk = blob.slice(position, Math.min(blob.size, position + POOL_SIZE$1));
              const buffer = await chunk.arrayBuffer();
              position += buffer.byteLength;
              ctrl.enqueue(new Uint8Array(buffer));
              if (position === blob.size) {
                ctrl.close();
              }
            }
          });
        };
      }
    } catch (error2) {
    }
    POOL_SIZE = 65536;
    _Blob = class Blob {
      #parts = [];
      #type = "";
      #size = 0;
      constructor(blobParts = [], options2 = {}) {
        let size = 0;
        const parts = blobParts.map((element) => {
          let part;
          if (ArrayBuffer.isView(element)) {
            part = new Uint8Array(element.buffer.slice(element.byteOffset, element.byteOffset + element.byteLength));
          } else if (element instanceof ArrayBuffer) {
            part = new Uint8Array(element.slice(0));
          } else if (element instanceof Blob) {
            part = element;
          } else {
            part = new TextEncoder().encode(element);
          }
          size += ArrayBuffer.isView(part) ? part.byteLength : part.size;
          return part;
        });
        const type = options2.type === void 0 ? "" : String(options2.type);
        this.#type = /[^\u0020-\u007E]/.test(type) ? "" : type;
        this.#size = size;
        this.#parts = parts;
      }
      get size() {
        return this.#size;
      }
      get type() {
        return this.#type;
      }
      async text() {
        const decoder = new TextDecoder();
        let str = "";
        for await (let part of toIterator(this.#parts, false)) {
          str += decoder.decode(part, { stream: true });
        }
        str += decoder.decode();
        return str;
      }
      async arrayBuffer() {
        const data = new Uint8Array(this.size);
        let offset = 0;
        for await (const chunk of toIterator(this.#parts, false)) {
          data.set(chunk, offset);
          offset += chunk.length;
        }
        return data.buffer;
      }
      stream() {
        const it = toIterator(this.#parts, true);
        return new ReadableStream({
          type: "bytes",
          async pull(ctrl) {
            const chunk = await it.next();
            chunk.done ? ctrl.close() : ctrl.enqueue(chunk.value);
          }
        });
      }
      slice(start = 0, end = this.size, type = "") {
        const { size } = this;
        let relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size);
        let relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size);
        const span = Math.max(relativeEnd - relativeStart, 0);
        const parts = this.#parts;
        const blobParts = [];
        let added = 0;
        for (const part of parts) {
          if (added >= span) {
            break;
          }
          const size2 = ArrayBuffer.isView(part) ? part.byteLength : part.size;
          if (relativeStart && size2 <= relativeStart) {
            relativeStart -= size2;
            relativeEnd -= size2;
          } else {
            let chunk;
            if (ArrayBuffer.isView(part)) {
              chunk = part.subarray(relativeStart, Math.min(size2, relativeEnd));
              added += chunk.byteLength;
            } else {
              chunk = part.slice(relativeStart, Math.min(size2, relativeEnd));
              added += chunk.size;
            }
            blobParts.push(chunk);
            relativeStart = 0;
          }
        }
        const blob = new Blob([], { type: String(type).toLowerCase() });
        blob.#size = span;
        blob.#parts = blobParts;
        return blob;
      }
      get [Symbol.toStringTag]() {
        return "Blob";
      }
      static [Symbol.hasInstance](object2) {
        return object2 && typeof object2 === "object" && typeof object2.constructor === "function" && (typeof object2.stream === "function" || typeof object2.arrayBuffer === "function") && /^(Blob|File)$/.test(object2[Symbol.toStringTag]);
      }
    };
    Object.defineProperties(_Blob.prototype, {
      size: { enumerable: true },
      type: { enumerable: true },
      slice: { enumerable: true }
    });
    Blob2 = _Blob;
    Blob$1 = Blob2;
    FetchBaseError = class extends Error {
      constructor(message, type) {
        super(message);
        Error.captureStackTrace(this, this.constructor);
        this.type = type;
      }
      get name() {
        return this.constructor.name;
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
    };
    FetchError = class extends FetchBaseError {
      constructor(message, type, systemError) {
        super(message, type);
        if (systemError) {
          this.code = this.errno = systemError.code;
          this.erroredSysCall = systemError.syscall;
        }
      }
    };
    NAME = Symbol.toStringTag;
    isURLSearchParameters = (object2) => {
      return typeof object2 === "object" && typeof object2.append === "function" && typeof object2.delete === "function" && typeof object2.get === "function" && typeof object2.getAll === "function" && typeof object2.has === "function" && typeof object2.set === "function" && typeof object2.sort === "function" && object2[NAME] === "URLSearchParams";
    };
    isBlob = (object2) => {
      return typeof object2 === "object" && typeof object2.arrayBuffer === "function" && typeof object2.type === "string" && typeof object2.stream === "function" && typeof object2.constructor === "function" && /^(Blob|File)$/.test(object2[NAME]);
    };
    isAbortSignal = (object2) => {
      return typeof object2 === "object" && (object2[NAME] === "AbortSignal" || object2[NAME] === "EventTarget");
    };
    carriage = "\r\n";
    dashes = "-".repeat(2);
    carriageLength = Buffer.byteLength(carriage);
    getFooter = (boundary) => `${dashes}${boundary}${dashes}${carriage.repeat(2)}`;
    getBoundary = () => (0, import_crypto.randomBytes)(8).toString("hex");
    INTERNALS$2 = Symbol("Body internals");
    Body = class {
      constructor(body, {
        size = 0
      } = {}) {
        let boundary = null;
        if (body === null) {
          body = null;
        } else if (isURLSearchParameters(body)) {
          body = Buffer.from(body.toString());
        } else if (isBlob(body))
          ;
        else if (Buffer.isBuffer(body))
          ;
        else if (import_util.types.isAnyArrayBuffer(body)) {
          body = Buffer.from(body);
        } else if (ArrayBuffer.isView(body)) {
          body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
        } else if (body instanceof import_stream.default)
          ;
        else if (isFormData(body)) {
          boundary = `NodeFetchFormDataBoundary${getBoundary()}`;
          body = import_stream.default.Readable.from(formDataIterator(body, boundary));
        } else {
          body = Buffer.from(String(body));
        }
        this[INTERNALS$2] = {
          body,
          boundary,
          disturbed: false,
          error: null
        };
        this.size = size;
        if (body instanceof import_stream.default) {
          body.on("error", (error_) => {
            const error2 = error_ instanceof FetchBaseError ? error_ : new FetchError(`Invalid response body while trying to fetch ${this.url}: ${error_.message}`, "system", error_);
            this[INTERNALS$2].error = error2;
          });
        }
      }
      get body() {
        return this[INTERNALS$2].body;
      }
      get bodyUsed() {
        return this[INTERNALS$2].disturbed;
      }
      async arrayBuffer() {
        const { buffer, byteOffset, byteLength } = await consumeBody(this);
        return buffer.slice(byteOffset, byteOffset + byteLength);
      }
      async blob() {
        const ct = this.headers && this.headers.get("content-type") || this[INTERNALS$2].body && this[INTERNALS$2].body.type || "";
        const buf = await this.buffer();
        return new Blob$1([buf], {
          type: ct
        });
      }
      async json() {
        const buffer = await consumeBody(this);
        return JSON.parse(buffer.toString());
      }
      async text() {
        const buffer = await consumeBody(this);
        return buffer.toString();
      }
      buffer() {
        return consumeBody(this);
      }
    };
    Object.defineProperties(Body.prototype, {
      body: { enumerable: true },
      bodyUsed: { enumerable: true },
      arrayBuffer: { enumerable: true },
      blob: { enumerable: true },
      json: { enumerable: true },
      text: { enumerable: true }
    });
    clone = (instance, highWaterMark) => {
      let p1;
      let p2;
      let { body } = instance;
      if (instance.bodyUsed) {
        throw new Error("cannot clone body after it is used");
      }
      if (body instanceof import_stream.default && typeof body.getBoundary !== "function") {
        p1 = new import_stream.PassThrough({ highWaterMark });
        p2 = new import_stream.PassThrough({ highWaterMark });
        body.pipe(p1);
        body.pipe(p2);
        instance[INTERNALS$2].body = p1;
        body = p2;
      }
      return body;
    };
    extractContentType = (body, request) => {
      if (body === null) {
        return null;
      }
      if (typeof body === "string") {
        return "text/plain;charset=UTF-8";
      }
      if (isURLSearchParameters(body)) {
        return "application/x-www-form-urlencoded;charset=UTF-8";
      }
      if (isBlob(body)) {
        return body.type || null;
      }
      if (Buffer.isBuffer(body) || import_util.types.isAnyArrayBuffer(body) || ArrayBuffer.isView(body)) {
        return null;
      }
      if (body && typeof body.getBoundary === "function") {
        return `multipart/form-data;boundary=${body.getBoundary()}`;
      }
      if (isFormData(body)) {
        return `multipart/form-data; boundary=${request[INTERNALS$2].boundary}`;
      }
      if (body instanceof import_stream.default) {
        return null;
      }
      return "text/plain;charset=UTF-8";
    };
    getTotalBytes = (request) => {
      const { body } = request;
      if (body === null) {
        return 0;
      }
      if (isBlob(body)) {
        return body.size;
      }
      if (Buffer.isBuffer(body)) {
        return body.length;
      }
      if (body && typeof body.getLengthSync === "function") {
        return body.hasKnownLength && body.hasKnownLength() ? body.getLengthSync() : null;
      }
      if (isFormData(body)) {
        return getFormDataLength(request[INTERNALS$2].boundary);
      }
      return null;
    };
    writeToStream = (dest, { body }) => {
      if (body === null) {
        dest.end();
      } else if (isBlob(body)) {
        import_stream.default.Readable.from(body.stream()).pipe(dest);
      } else if (Buffer.isBuffer(body)) {
        dest.write(body);
        dest.end();
      } else {
        body.pipe(dest);
      }
    };
    validateHeaderName = typeof import_http.default.validateHeaderName === "function" ? import_http.default.validateHeaderName : (name) => {
      if (!/^[\^`\-\w!#$%&'*+.|~]+$/.test(name)) {
        const error2 = new TypeError(`Header name must be a valid HTTP token [${name}]`);
        Object.defineProperty(error2, "code", { value: "ERR_INVALID_HTTP_TOKEN" });
        throw error2;
      }
    };
    validateHeaderValue = typeof import_http.default.validateHeaderValue === "function" ? import_http.default.validateHeaderValue : (name, value) => {
      if (/[^\t\u0020-\u007E\u0080-\u00FF]/.test(value)) {
        const error2 = new TypeError(`Invalid character in header content ["${name}"]`);
        Object.defineProperty(error2, "code", { value: "ERR_INVALID_CHAR" });
        throw error2;
      }
    };
    Headers = class extends URLSearchParams {
      constructor(init2) {
        let result = [];
        if (init2 instanceof Headers) {
          const raw = init2.raw();
          for (const [name, values] of Object.entries(raw)) {
            result.push(...values.map((value) => [name, value]));
          }
        } else if (init2 == null)
          ;
        else if (typeof init2 === "object" && !import_util.types.isBoxedPrimitive(init2)) {
          const method = init2[Symbol.iterator];
          if (method == null) {
            result.push(...Object.entries(init2));
          } else {
            if (typeof method !== "function") {
              throw new TypeError("Header pairs must be iterable");
            }
            result = [...init2].map((pair) => {
              if (typeof pair !== "object" || import_util.types.isBoxedPrimitive(pair)) {
                throw new TypeError("Each header pair must be an iterable object");
              }
              return [...pair];
            }).map((pair) => {
              if (pair.length !== 2) {
                throw new TypeError("Each header pair must be a name/value tuple");
              }
              return [...pair];
            });
          }
        } else {
          throw new TypeError("Failed to construct 'Headers': The provided value is not of type '(sequence<sequence<ByteString>> or record<ByteString, ByteString>)");
        }
        result = result.length > 0 ? result.map(([name, value]) => {
          validateHeaderName(name);
          validateHeaderValue(name, String(value));
          return [String(name).toLowerCase(), String(value)];
        }) : void 0;
        super(result);
        return new Proxy(this, {
          get(target, p, receiver) {
            switch (p) {
              case "append":
              case "set":
                return (name, value) => {
                  validateHeaderName(name);
                  validateHeaderValue(name, String(value));
                  return URLSearchParams.prototype[p].call(target, String(name).toLowerCase(), String(value));
                };
              case "delete":
              case "has":
              case "getAll":
                return (name) => {
                  validateHeaderName(name);
                  return URLSearchParams.prototype[p].call(target, String(name).toLowerCase());
                };
              case "keys":
                return () => {
                  target.sort();
                  return new Set(URLSearchParams.prototype.keys.call(target)).keys();
                };
              default:
                return Reflect.get(target, p, receiver);
            }
          }
        });
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
      toString() {
        return Object.prototype.toString.call(this);
      }
      get(name) {
        const values = this.getAll(name);
        if (values.length === 0) {
          return null;
        }
        let value = values.join(", ");
        if (/^content-encoding$/i.test(name)) {
          value = value.toLowerCase();
        }
        return value;
      }
      forEach(callback, thisArg = void 0) {
        for (const name of this.keys()) {
          Reflect.apply(callback, thisArg, [this.get(name), name, this]);
        }
      }
      *values() {
        for (const name of this.keys()) {
          yield this.get(name);
        }
      }
      *entries() {
        for (const name of this.keys()) {
          yield [name, this.get(name)];
        }
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      raw() {
        return [...this.keys()].reduce((result, key) => {
          result[key] = this.getAll(key);
          return result;
        }, {});
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return [...this.keys()].reduce((result, key) => {
          const values = this.getAll(key);
          if (key === "host") {
            result[key] = values[0];
          } else {
            result[key] = values.length > 1 ? values : values[0];
          }
          return result;
        }, {});
      }
    };
    Object.defineProperties(Headers.prototype, ["get", "entries", "forEach", "values"].reduce((result, property) => {
      result[property] = { enumerable: true };
      return result;
    }, {}));
    redirectStatus = new Set([301, 302, 303, 307, 308]);
    isRedirect = (code) => {
      return redirectStatus.has(code);
    };
    INTERNALS$1 = Symbol("Response internals");
    Response = class extends Body {
      constructor(body = null, options2 = {}) {
        super(body, options2);
        const status = options2.status != null ? options2.status : 200;
        const headers = new Headers(options2.headers);
        if (body !== null && !headers.has("Content-Type")) {
          const contentType = extractContentType(body);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        this[INTERNALS$1] = {
          type: "default",
          url: options2.url,
          status,
          statusText: options2.statusText || "",
          headers,
          counter: options2.counter,
          highWaterMark: options2.highWaterMark
        };
      }
      get type() {
        return this[INTERNALS$1].type;
      }
      get url() {
        return this[INTERNALS$1].url || "";
      }
      get status() {
        return this[INTERNALS$1].status;
      }
      get ok() {
        return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
      }
      get redirected() {
        return this[INTERNALS$1].counter > 0;
      }
      get statusText() {
        return this[INTERNALS$1].statusText;
      }
      get headers() {
        return this[INTERNALS$1].headers;
      }
      get highWaterMark() {
        return this[INTERNALS$1].highWaterMark;
      }
      clone() {
        return new Response(clone(this, this.highWaterMark), {
          type: this.type,
          url: this.url,
          status: this.status,
          statusText: this.statusText,
          headers: this.headers,
          ok: this.ok,
          redirected: this.redirected,
          size: this.size
        });
      }
      static redirect(url, status = 302) {
        if (!isRedirect(status)) {
          throw new RangeError('Failed to execute "redirect" on "response": Invalid status code');
        }
        return new Response(null, {
          headers: {
            location: new URL(url).toString()
          },
          status
        });
      }
      static error() {
        const response = new Response(null, { status: 0, statusText: "" });
        response[INTERNALS$1].type = "error";
        return response;
      }
      get [Symbol.toStringTag]() {
        return "Response";
      }
    };
    Object.defineProperties(Response.prototype, {
      type: { enumerable: true },
      url: { enumerable: true },
      status: { enumerable: true },
      ok: { enumerable: true },
      redirected: { enumerable: true },
      statusText: { enumerable: true },
      headers: { enumerable: true },
      clone: { enumerable: true }
    });
    getSearch = (parsedURL) => {
      if (parsedURL.search) {
        return parsedURL.search;
      }
      const lastOffset = parsedURL.href.length - 1;
      const hash2 = parsedURL.hash || (parsedURL.href[lastOffset] === "#" ? "#" : "");
      return parsedURL.href[lastOffset - hash2.length] === "?" ? "?" : "";
    };
    INTERNALS = Symbol("Request internals");
    isRequest = (object2) => {
      return typeof object2 === "object" && typeof object2[INTERNALS] === "object";
    };
    Request = class extends Body {
      constructor(input, init2 = {}) {
        let parsedURL;
        if (isRequest(input)) {
          parsedURL = new URL(input.url);
        } else {
          parsedURL = new URL(input);
          input = {};
        }
        let method = init2.method || input.method || "GET";
        method = method.toUpperCase();
        if ((init2.body != null || isRequest(input)) && input.body !== null && (method === "GET" || method === "HEAD")) {
          throw new TypeError("Request with GET/HEAD method cannot have body");
        }
        const inputBody = init2.body ? init2.body : isRequest(input) && input.body !== null ? clone(input) : null;
        super(inputBody, {
          size: init2.size || input.size || 0
        });
        const headers = new Headers(init2.headers || input.headers || {});
        if (inputBody !== null && !headers.has("Content-Type")) {
          const contentType = extractContentType(inputBody, this);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        let signal = isRequest(input) ? input.signal : null;
        if ("signal" in init2) {
          signal = init2.signal;
        }
        if (signal != null && !isAbortSignal(signal)) {
          throw new TypeError("Expected signal to be an instanceof AbortSignal or EventTarget");
        }
        this[INTERNALS] = {
          method,
          redirect: init2.redirect || input.redirect || "follow",
          headers,
          parsedURL,
          signal
        };
        this.follow = init2.follow === void 0 ? input.follow === void 0 ? 20 : input.follow : init2.follow;
        this.compress = init2.compress === void 0 ? input.compress === void 0 ? true : input.compress : init2.compress;
        this.counter = init2.counter || input.counter || 0;
        this.agent = init2.agent || input.agent;
        this.highWaterMark = init2.highWaterMark || input.highWaterMark || 16384;
        this.insecureHTTPParser = init2.insecureHTTPParser || input.insecureHTTPParser || false;
      }
      get method() {
        return this[INTERNALS].method;
      }
      get url() {
        return (0, import_url.format)(this[INTERNALS].parsedURL);
      }
      get headers() {
        return this[INTERNALS].headers;
      }
      get redirect() {
        return this[INTERNALS].redirect;
      }
      get signal() {
        return this[INTERNALS].signal;
      }
      clone() {
        return new Request(this);
      }
      get [Symbol.toStringTag]() {
        return "Request";
      }
    };
    Object.defineProperties(Request.prototype, {
      method: { enumerable: true },
      url: { enumerable: true },
      headers: { enumerable: true },
      redirect: { enumerable: true },
      clone: { enumerable: true },
      signal: { enumerable: true }
    });
    getNodeRequestOptions = (request) => {
      const { parsedURL } = request[INTERNALS];
      const headers = new Headers(request[INTERNALS].headers);
      if (!headers.has("Accept")) {
        headers.set("Accept", "*/*");
      }
      let contentLengthValue = null;
      if (request.body === null && /^(post|put)$/i.test(request.method)) {
        contentLengthValue = "0";
      }
      if (request.body !== null) {
        const totalBytes = getTotalBytes(request);
        if (typeof totalBytes === "number" && !Number.isNaN(totalBytes)) {
          contentLengthValue = String(totalBytes);
        }
      }
      if (contentLengthValue) {
        headers.set("Content-Length", contentLengthValue);
      }
      if (!headers.has("User-Agent")) {
        headers.set("User-Agent", "node-fetch");
      }
      if (request.compress && !headers.has("Accept-Encoding")) {
        headers.set("Accept-Encoding", "gzip,deflate,br");
      }
      let { agent } = request;
      if (typeof agent === "function") {
        agent = agent(parsedURL);
      }
      if (!headers.has("Connection") && !agent) {
        headers.set("Connection", "close");
      }
      const search = getSearch(parsedURL);
      const requestOptions = {
        path: parsedURL.pathname + search,
        pathname: parsedURL.pathname,
        hostname: parsedURL.hostname,
        protocol: parsedURL.protocol,
        port: parsedURL.port,
        hash: parsedURL.hash,
        search: parsedURL.search,
        query: parsedURL.query,
        href: parsedURL.href,
        method: request.method,
        headers: headers[Symbol.for("nodejs.util.inspect.custom")](),
        insecureHTTPParser: request.insecureHTTPParser,
        agent
      };
      return requestOptions;
    };
    AbortError = class extends FetchBaseError {
      constructor(message, type = "aborted") {
        super(message, type);
      }
    };
    supportedSchemas = new Set(["data:", "http:", "https:"]);
  }
});

// node_modules/@sveltejs/adapter-netlify/files/shims.js
var init_shims = __esm({
  "node_modules/@sveltejs/adapter-netlify/files/shims.js"() {
    init_install_fetch();
  }
});

// node_modules/gsap/dist/gsap.js
var require_gsap = __commonJS({
  "node_modules/gsap/dist/gsap.js"(exports, module2) {
    init_shims();
    (function(global2, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = global2 || self, factory(global2.window = global2.window || {}));
    })(exports, function(exports2) {
      "use strict";
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      function _assertThisInitialized(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      var _config = {
        autoSleep: 120,
        force3D: "auto",
        nullTargetWarn: 1,
        units: {
          lineHeight: ""
        }
      }, _defaults = {
        duration: 0.5,
        overwrite: false,
        delay: 0
      }, _suppressOverwrites, _bigNum = 1e8, _tinyNum = 1 / _bigNum, _2PI = Math.PI * 2, _HALF_PI = _2PI / 4, _gsID = 0, _sqrt = Math.sqrt, _cos = Math.cos, _sin = Math.sin, _isString = function _isString2(value) {
        return typeof value === "string";
      }, _isFunction = function _isFunction2(value) {
        return typeof value === "function";
      }, _isNumber = function _isNumber2(value) {
        return typeof value === "number";
      }, _isUndefined = function _isUndefined2(value) {
        return typeof value === "undefined";
      }, _isObject = function _isObject2(value) {
        return typeof value === "object";
      }, _isNotFalse = function _isNotFalse2(value) {
        return value !== false;
      }, _windowExists = function _windowExists2() {
        return typeof window !== "undefined";
      }, _isFuncOrString = function _isFuncOrString2(value) {
        return _isFunction(value) || _isString(value);
      }, _isTypedArray = typeof ArrayBuffer === "function" && ArrayBuffer.isView || function() {
      }, _isArray = Array.isArray, _strictNumExp = /(?:-?\.?\d|\.)+/gi, _numExp = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g, _numWithUnitExp = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g, _complexStringNumExp = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi, _relExp = /[+-]=-?[.\d]+/, _delimitedValueExp = /[^,'"\[\]\s]+/gi, _unitExp = /[\d.+\-=]+(?:e[-+]\d*)*/i, _globalTimeline, _win, _coreInitted, _doc, _globals = {}, _installScope = {}, _coreReady, _install = function _install2(scope) {
        return (_installScope = _merge(scope, _globals)) && gsap2;
      }, _missingPlugin = function _missingPlugin2(property, value) {
        return console.warn("Invalid property", property, "set to", value, "Missing plugin? gsap.registerPlugin()");
      }, _warn = function _warn2(message, suppress) {
        return !suppress && console.warn(message);
      }, _addGlobal = function _addGlobal2(name, obj) {
        return name && (_globals[name] = obj) && _installScope && (_installScope[name] = obj) || _globals;
      }, _emptyFunc = function _emptyFunc2() {
        return 0;
      }, _reservedProps = {}, _lazyTweens = [], _lazyLookup = {}, _lastRenderedFrame, _plugins = {}, _effects = {}, _nextGCFrame = 30, _harnessPlugins = [], _callbackNames = "", _harness = function _harness2(targets) {
        var target = targets[0], harnessPlugin, i;
        _isObject(target) || _isFunction(target) || (targets = [targets]);
        if (!(harnessPlugin = (target._gsap || {}).harness)) {
          i = _harnessPlugins.length;
          while (i-- && !_harnessPlugins[i].targetTest(target)) {
          }
          harnessPlugin = _harnessPlugins[i];
        }
        i = targets.length;
        while (i--) {
          targets[i] && (targets[i]._gsap || (targets[i]._gsap = new GSCache(targets[i], harnessPlugin))) || targets.splice(i, 1);
        }
        return targets;
      }, _getCache = function _getCache2(target) {
        return target._gsap || _harness(toArray(target))[0]._gsap;
      }, _getProperty = function _getProperty2(target, property, v) {
        return (v = target[property]) && _isFunction(v) ? target[property]() : _isUndefined(v) && target.getAttribute && target.getAttribute(property) || v;
      }, _forEachName = function _forEachName2(names, func) {
        return (names = names.split(",")).forEach(func) || names;
      }, _round = function _round2(value) {
        return Math.round(value * 1e5) / 1e5 || 0;
      }, _roundPrecise = function _roundPrecise2(value) {
        return Math.round(value * 1e7) / 1e7 || 0;
      }, _arrayContainsAny = function _arrayContainsAny2(toSearch, toFind) {
        var l = toFind.length, i = 0;
        for (; toSearch.indexOf(toFind[i]) < 0 && ++i < l; ) {
        }
        return i < l;
      }, _lazyRender = function _lazyRender2() {
        var l = _lazyTweens.length, a = _lazyTweens.slice(0), i, tween;
        _lazyLookup = {};
        _lazyTweens.length = 0;
        for (i = 0; i < l; i++) {
          tween = a[i];
          tween && tween._lazy && (tween.render(tween._lazy[0], tween._lazy[1], true)._lazy = 0);
        }
      }, _lazySafeRender = function _lazySafeRender2(animation, time, suppressEvents, force) {
        _lazyTweens.length && _lazyRender();
        animation.render(time, suppressEvents, force);
        _lazyTweens.length && _lazyRender();
      }, _numericIfPossible = function _numericIfPossible2(value) {
        var n = parseFloat(value);
        return (n || n === 0) && (value + "").match(_delimitedValueExp).length < 2 ? n : _isString(value) ? value.trim() : value;
      }, _passThrough = function _passThrough2(p) {
        return p;
      }, _setDefaults = function _setDefaults2(obj, defaults) {
        for (var p in defaults) {
          p in obj || (obj[p] = defaults[p]);
        }
        return obj;
      }, _setKeyframeDefaults = function _setKeyframeDefaults2(obj, defaults) {
        for (var p in defaults) {
          p in obj || p === "duration" || p === "ease" || (obj[p] = defaults[p]);
        }
      }, _merge = function _merge2(base2, toMerge) {
        for (var p in toMerge) {
          base2[p] = toMerge[p];
        }
        return base2;
      }, _mergeDeep = function _mergeDeep2(base2, toMerge) {
        for (var p in toMerge) {
          p !== "__proto__" && p !== "constructor" && p !== "prototype" && (base2[p] = _isObject(toMerge[p]) ? _mergeDeep2(base2[p] || (base2[p] = {}), toMerge[p]) : toMerge[p]);
        }
        return base2;
      }, _copyExcluding = function _copyExcluding2(obj, excluding) {
        var copy2 = {}, p;
        for (p in obj) {
          p in excluding || (copy2[p] = obj[p]);
        }
        return copy2;
      }, _inheritDefaults = function _inheritDefaults2(vars) {
        var parent = vars.parent || _globalTimeline, func = vars.keyframes ? _setKeyframeDefaults : _setDefaults;
        if (_isNotFalse(vars.inherit)) {
          while (parent) {
            func(vars, parent.vars.defaults);
            parent = parent.parent || parent._dp;
          }
        }
        return vars;
      }, _arraysMatch = function _arraysMatch2(a1, a2) {
        var i = a1.length, match = i === a2.length;
        while (match && i-- && a1[i] === a2[i]) {
        }
        return i < 0;
      }, _addLinkedListItem = function _addLinkedListItem2(parent, child, firstProp, lastProp, sortBy) {
        if (firstProp === void 0) {
          firstProp = "_first";
        }
        if (lastProp === void 0) {
          lastProp = "_last";
        }
        var prev = parent[lastProp], t;
        if (sortBy) {
          t = child[sortBy];
          while (prev && prev[sortBy] > t) {
            prev = prev._prev;
          }
        }
        if (prev) {
          child._next = prev._next;
          prev._next = child;
        } else {
          child._next = parent[firstProp];
          parent[firstProp] = child;
        }
        if (child._next) {
          child._next._prev = child;
        } else {
          parent[lastProp] = child;
        }
        child._prev = prev;
        child.parent = child._dp = parent;
        return child;
      }, _removeLinkedListItem = function _removeLinkedListItem2(parent, child, firstProp, lastProp) {
        if (firstProp === void 0) {
          firstProp = "_first";
        }
        if (lastProp === void 0) {
          lastProp = "_last";
        }
        var prev = child._prev, next = child._next;
        if (prev) {
          prev._next = next;
        } else if (parent[firstProp] === child) {
          parent[firstProp] = next;
        }
        if (next) {
          next._prev = prev;
        } else if (parent[lastProp] === child) {
          parent[lastProp] = prev;
        }
        child._next = child._prev = child.parent = null;
      }, _removeFromParent = function _removeFromParent2(child, onlyIfParentHasAutoRemove) {
        child.parent && (!onlyIfParentHasAutoRemove || child.parent.autoRemoveChildren) && child.parent.remove(child);
        child._act = 0;
      }, _uncache = function _uncache2(animation, child) {
        if (animation && (!child || child._end > animation._dur || child._start < 0)) {
          var a = animation;
          while (a) {
            a._dirty = 1;
            a = a.parent;
          }
        }
        return animation;
      }, _recacheAncestors = function _recacheAncestors2(animation) {
        var parent = animation.parent;
        while (parent && parent.parent) {
          parent._dirty = 1;
          parent.totalDuration();
          parent = parent.parent;
        }
        return animation;
      }, _hasNoPausedAncestors = function _hasNoPausedAncestors2(animation) {
        return !animation || animation._ts && _hasNoPausedAncestors2(animation.parent);
      }, _elapsedCycleDuration = function _elapsedCycleDuration2(animation) {
        return animation._repeat ? _animationCycle(animation._tTime, animation = animation.duration() + animation._rDelay) * animation : 0;
      }, _animationCycle = function _animationCycle2(tTime, cycleDuration) {
        var whole = Math.floor(tTime /= cycleDuration);
        return tTime && whole === tTime ? whole - 1 : whole;
      }, _parentToChildTotalTime = function _parentToChildTotalTime2(parentTime, child) {
        return (parentTime - child._start) * child._ts + (child._ts >= 0 ? 0 : child._dirty ? child.totalDuration() : child._tDur);
      }, _setEnd = function _setEnd2(animation) {
        return animation._end = _roundPrecise(animation._start + (animation._tDur / Math.abs(animation._ts || animation._rts || _tinyNum) || 0));
      }, _alignPlayhead = function _alignPlayhead2(animation, totalTime) {
        var parent = animation._dp;
        if (parent && parent.smoothChildTiming && animation._ts) {
          animation._start = _roundPrecise(parent._time - (animation._ts > 0 ? totalTime / animation._ts : ((animation._dirty ? animation.totalDuration() : animation._tDur) - totalTime) / -animation._ts));
          _setEnd(animation);
          parent._dirty || _uncache(parent, animation);
        }
        return animation;
      }, _postAddChecks = function _postAddChecks2(timeline, child) {
        var t;
        if (child._time || child._initted && !child._dur) {
          t = _parentToChildTotalTime(timeline.rawTime(), child);
          if (!child._dur || _clamp(0, child.totalDuration(), t) - child._tTime > _tinyNum) {
            child.render(t, true);
          }
        }
        if (_uncache(timeline, child)._dp && timeline._initted && timeline._time >= timeline._dur && timeline._ts) {
          if (timeline._dur < timeline.duration()) {
            t = timeline;
            while (t._dp) {
              t.rawTime() >= 0 && t.totalTime(t._tTime);
              t = t._dp;
            }
          }
          timeline._zTime = -_tinyNum;
        }
      }, _addToTimeline = function _addToTimeline2(timeline, child, position, skipChecks) {
        child.parent && _removeFromParent(child);
        child._start = _roundPrecise((_isNumber(position) ? position : position || timeline !== _globalTimeline ? _parsePosition(timeline, position, child) : timeline._time) + child._delay);
        child._end = _roundPrecise(child._start + (child.totalDuration() / Math.abs(child.timeScale()) || 0));
        _addLinkedListItem(timeline, child, "_first", "_last", timeline._sort ? "_start" : 0);
        _isFromOrFromStart(child) || (timeline._recent = child);
        skipChecks || _postAddChecks(timeline, child);
        return timeline;
      }, _scrollTrigger = function _scrollTrigger2(animation, trigger) {
        return (_globals.ScrollTrigger || _missingPlugin("scrollTrigger", trigger)) && _globals.ScrollTrigger.create(trigger, animation);
      }, _attemptInitTween = function _attemptInitTween2(tween, totalTime, force, suppressEvents) {
        _initTween(tween, totalTime);
        if (!tween._initted) {
          return 1;
        }
        if (!force && tween._pt && (tween._dur && tween.vars.lazy !== false || !tween._dur && tween.vars.lazy) && _lastRenderedFrame !== _ticker.frame) {
          _lazyTweens.push(tween);
          tween._lazy = [totalTime, suppressEvents];
          return 1;
        }
      }, _parentPlayheadIsBeforeStart = function _parentPlayheadIsBeforeStart2(_ref) {
        var parent = _ref.parent;
        return parent && parent._ts && parent._initted && !parent._lock && (parent.rawTime() < 0 || _parentPlayheadIsBeforeStart2(parent));
      }, _isFromOrFromStart = function _isFromOrFromStart2(_ref2) {
        var data = _ref2.data;
        return data === "isFromStart" || data === "isStart";
      }, _renderZeroDurationTween = function _renderZeroDurationTween2(tween, totalTime, suppressEvents, force) {
        var prevRatio = tween.ratio, ratio = totalTime < 0 || !totalTime && (!tween._start && _parentPlayheadIsBeforeStart(tween) && !(!tween._initted && _isFromOrFromStart(tween)) || (tween._ts < 0 || tween._dp._ts < 0) && !_isFromOrFromStart(tween)) ? 0 : 1, repeatDelay = tween._rDelay, tTime = 0, pt, iteration, prevIteration;
        if (repeatDelay && tween._repeat) {
          tTime = _clamp(0, tween._tDur, totalTime);
          iteration = _animationCycle(tTime, repeatDelay);
          prevIteration = _animationCycle(tween._tTime, repeatDelay);
          tween._yoyo && iteration & 1 && (ratio = 1 - ratio);
          if (iteration !== prevIteration) {
            prevRatio = 1 - ratio;
            tween.vars.repeatRefresh && tween._initted && tween.invalidate();
          }
        }
        if (ratio !== prevRatio || force || tween._zTime === _tinyNum || !totalTime && tween._zTime) {
          if (!tween._initted && _attemptInitTween(tween, totalTime, force, suppressEvents)) {
            return;
          }
          prevIteration = tween._zTime;
          tween._zTime = totalTime || (suppressEvents ? _tinyNum : 0);
          suppressEvents || (suppressEvents = totalTime && !prevIteration);
          tween.ratio = ratio;
          tween._from && (ratio = 1 - ratio);
          tween._time = 0;
          tween._tTime = tTime;
          pt = tween._pt;
          while (pt) {
            pt.r(ratio, pt.d);
            pt = pt._next;
          }
          tween._startAt && totalTime < 0 && tween._startAt.render(totalTime, true, true);
          tween._onUpdate && !suppressEvents && _callback(tween, "onUpdate");
          tTime && tween._repeat && !suppressEvents && tween.parent && _callback(tween, "onRepeat");
          if ((totalTime >= tween._tDur || totalTime < 0) && tween.ratio === ratio) {
            ratio && _removeFromParent(tween, 1);
            if (!suppressEvents) {
              _callback(tween, ratio ? "onComplete" : "onReverseComplete", true);
              tween._prom && tween._prom();
            }
          }
        } else if (!tween._zTime) {
          tween._zTime = totalTime;
        }
      }, _findNextPauseTween = function _findNextPauseTween2(animation, prevTime, time) {
        var child;
        if (time > prevTime) {
          child = animation._first;
          while (child && child._start <= time) {
            if (!child._dur && child.data === "isPause" && child._start > prevTime) {
              return child;
            }
            child = child._next;
          }
        } else {
          child = animation._last;
          while (child && child._start >= time) {
            if (!child._dur && child.data === "isPause" && child._start < prevTime) {
              return child;
            }
            child = child._prev;
          }
        }
      }, _setDuration = function _setDuration2(animation, duration, skipUncache, leavePlayhead) {
        var repeat = animation._repeat, dur = _roundPrecise(duration) || 0, totalProgress = animation._tTime / animation._tDur;
        totalProgress && !leavePlayhead && (animation._time *= dur / animation._dur);
        animation._dur = dur;
        animation._tDur = !repeat ? dur : repeat < 0 ? 1e10 : _roundPrecise(dur * (repeat + 1) + animation._rDelay * repeat);
        totalProgress && !leavePlayhead ? _alignPlayhead(animation, animation._tTime = animation._tDur * totalProgress) : animation.parent && _setEnd(animation);
        skipUncache || _uncache(animation.parent, animation);
        return animation;
      }, _onUpdateTotalDuration = function _onUpdateTotalDuration2(animation) {
        return animation instanceof Timeline ? _uncache(animation) : _setDuration(animation, animation._dur);
      }, _zeroPosition = {
        _start: 0,
        endTime: _emptyFunc,
        totalDuration: _emptyFunc
      }, _parsePosition = function _parsePosition2(animation, position, percentAnimation) {
        var labels = animation.labels, recent = animation._recent || _zeroPosition, clippedDuration = animation.duration() >= _bigNum ? recent.endTime(false) : animation._dur, i, offset, isPercent;
        if (_isString(position) && (isNaN(position) || position in labels)) {
          offset = position.charAt(0);
          isPercent = position.substr(-1) === "%";
          i = position.indexOf("=");
          if (offset === "<" || offset === ">") {
            i >= 0 && (position = position.replace(/=/, ""));
            return (offset === "<" ? recent._start : recent.endTime(recent._repeat >= 0)) + (parseFloat(position.substr(1)) || 0) * (isPercent ? (i < 0 ? recent : percentAnimation).totalDuration() / 100 : 1);
          }
          if (i < 0) {
            position in labels || (labels[position] = clippedDuration);
            return labels[position];
          }
          offset = parseFloat(position.charAt(i - 1) + position.substr(i + 1));
          if (isPercent && percentAnimation) {
            offset = offset / 100 * (_isArray(percentAnimation) ? percentAnimation[0] : percentAnimation).totalDuration();
          }
          return i > 1 ? _parsePosition2(animation, position.substr(0, i - 1), percentAnimation) + offset : clippedDuration + offset;
        }
        return position == null ? clippedDuration : +position;
      }, _createTweenType = function _createTweenType2(type, params, timeline) {
        var isLegacy = _isNumber(params[1]), varsIndex = (isLegacy ? 2 : 1) + (type < 2 ? 0 : 1), vars = params[varsIndex], irVars, parent;
        isLegacy && (vars.duration = params[1]);
        vars.parent = timeline;
        if (type) {
          irVars = vars;
          parent = timeline;
          while (parent && !("immediateRender" in irVars)) {
            irVars = parent.vars.defaults || {};
            parent = _isNotFalse(parent.vars.inherit) && parent.parent;
          }
          vars.immediateRender = _isNotFalse(irVars.immediateRender);
          type < 2 ? vars.runBackwards = 1 : vars.startAt = params[varsIndex - 1];
        }
        return new Tween(params[0], vars, params[varsIndex + 1]);
      }, _conditionalReturn = function _conditionalReturn2(value, func) {
        return value || value === 0 ? func(value) : func;
      }, _clamp = function _clamp2(min, max, value) {
        return value < min ? min : value > max ? max : value;
      }, getUnit = function getUnit2(value) {
        if (typeof value !== "string") {
          return "";
        }
        var v = _unitExp.exec(value);
        return v ? value.substr(v.index + v[0].length) : "";
      }, clamp = function clamp2(min, max, value) {
        return _conditionalReturn(value, function(v) {
          return _clamp(min, max, v);
        });
      }, _slice = [].slice, _isArrayLike = function _isArrayLike2(value, nonEmpty) {
        return value && _isObject(value) && "length" in value && (!nonEmpty && !value.length || value.length - 1 in value && _isObject(value[0])) && !value.nodeType && value !== _win;
      }, _flatten = function _flatten2(ar, leaveStrings, accumulator) {
        if (accumulator === void 0) {
          accumulator = [];
        }
        return ar.forEach(function(value) {
          var _accumulator;
          return _isString(value) && !leaveStrings || _isArrayLike(value, 1) ? (_accumulator = accumulator).push.apply(_accumulator, toArray(value)) : accumulator.push(value);
        }) || accumulator;
      }, toArray = function toArray2(value, scope, leaveStrings) {
        return _isString(value) && !leaveStrings && (_coreInitted || !_wake()) ? _slice.call((scope || _doc).querySelectorAll(value), 0) : _isArray(value) ? _flatten(value, leaveStrings) : _isArrayLike(value) ? _slice.call(value, 0) : value ? [value] : [];
      }, selector = function selector2(value) {
        value = toArray(value)[0] || _warn("Invalid scope") || {};
        return function(v) {
          var el = value.current || value.nativeElement || value;
          return toArray(v, el.querySelectorAll ? el : el === value ? _warn("Invalid scope") || _doc.createElement("div") : value);
        };
      }, shuffle = function shuffle2(a) {
        return a.sort(function() {
          return 0.5 - Math.random();
        });
      }, distribute = function distribute2(v) {
        if (_isFunction(v)) {
          return v;
        }
        var vars = _isObject(v) ? v : {
          each: v
        }, ease = _parseEase(vars.ease), from = vars.from || 0, base2 = parseFloat(vars.base) || 0, cache = {}, isDecimal = from > 0 && from < 1, ratios = isNaN(from) || isDecimal, axis = vars.axis, ratioX = from, ratioY = from;
        if (_isString(from)) {
          ratioX = ratioY = {
            center: 0.5,
            edges: 0.5,
            end: 1
          }[from] || 0;
        } else if (!isDecimal && ratios) {
          ratioX = from[0];
          ratioY = from[1];
        }
        return function(i, target, a) {
          var l = (a || vars).length, distances = cache[l], originX, originY, x, y, d, j, max, min, wrapAt;
          if (!distances) {
            wrapAt = vars.grid === "auto" ? 0 : (vars.grid || [1, _bigNum])[1];
            if (!wrapAt) {
              max = -_bigNum;
              while (max < (max = a[wrapAt++].getBoundingClientRect().left) && wrapAt < l) {
              }
              wrapAt--;
            }
            distances = cache[l] = [];
            originX = ratios ? Math.min(wrapAt, l) * ratioX - 0.5 : from % wrapAt;
            originY = ratios ? l * ratioY / wrapAt - 0.5 : from / wrapAt | 0;
            max = 0;
            min = _bigNum;
            for (j = 0; j < l; j++) {
              x = j % wrapAt - originX;
              y = originY - (j / wrapAt | 0);
              distances[j] = d = !axis ? _sqrt(x * x + y * y) : Math.abs(axis === "y" ? y : x);
              d > max && (max = d);
              d < min && (min = d);
            }
            from === "random" && shuffle(distances);
            distances.max = max - min;
            distances.min = min;
            distances.v = l = (parseFloat(vars.amount) || parseFloat(vars.each) * (wrapAt > l ? l - 1 : !axis ? Math.max(wrapAt, l / wrapAt) : axis === "y" ? l / wrapAt : wrapAt) || 0) * (from === "edges" ? -1 : 1);
            distances.b = l < 0 ? base2 - l : base2;
            distances.u = getUnit(vars.amount || vars.each) || 0;
            ease = ease && l < 0 ? _invertEase(ease) : ease;
          }
          l = (distances[i] - distances.min) / distances.max || 0;
          return _roundPrecise(distances.b + (ease ? ease(l) : l) * distances.v) + distances.u;
        };
      }, _roundModifier = function _roundModifier2(v) {
        var p = Math.pow(10, ((v + "").split(".")[1] || "").length);
        return function(raw) {
          var n = Math.round(parseFloat(raw) / v) * v * p;
          return (n - n % 1) / p + (_isNumber(raw) ? 0 : getUnit(raw));
        };
      }, snap = function snap2(snapTo, value) {
        var isArray = _isArray(snapTo), radius, is2D;
        if (!isArray && _isObject(snapTo)) {
          radius = isArray = snapTo.radius || _bigNum;
          if (snapTo.values) {
            snapTo = toArray(snapTo.values);
            if (is2D = !_isNumber(snapTo[0])) {
              radius *= radius;
            }
          } else {
            snapTo = _roundModifier(snapTo.increment);
          }
        }
        return _conditionalReturn(value, !isArray ? _roundModifier(snapTo) : _isFunction(snapTo) ? function(raw) {
          is2D = snapTo(raw);
          return Math.abs(is2D - raw) <= radius ? is2D : raw;
        } : function(raw) {
          var x = parseFloat(is2D ? raw.x : raw), y = parseFloat(is2D ? raw.y : 0), min = _bigNum, closest = 0, i = snapTo.length, dx, dy;
          while (i--) {
            if (is2D) {
              dx = snapTo[i].x - x;
              dy = snapTo[i].y - y;
              dx = dx * dx + dy * dy;
            } else {
              dx = Math.abs(snapTo[i] - x);
            }
            if (dx < min) {
              min = dx;
              closest = i;
            }
          }
          closest = !radius || min <= radius ? snapTo[closest] : raw;
          return is2D || closest === raw || _isNumber(raw) ? closest : closest + getUnit(raw);
        });
      }, random = function random2(min, max, roundingIncrement, returnFunction) {
        return _conditionalReturn(_isArray(min) ? !max : roundingIncrement === true ? !!(roundingIncrement = 0) : !returnFunction, function() {
          return _isArray(min) ? min[~~(Math.random() * min.length)] : (roundingIncrement = roundingIncrement || 1e-5) && (returnFunction = roundingIncrement < 1 ? Math.pow(10, (roundingIncrement + "").length - 2) : 1) && Math.floor(Math.round((min - roundingIncrement / 2 + Math.random() * (max - min + roundingIncrement * 0.99)) / roundingIncrement) * roundingIncrement * returnFunction) / returnFunction;
        });
      }, pipe = function pipe2() {
        for (var _len = arguments.length, functions = new Array(_len), _key = 0; _key < _len; _key++) {
          functions[_key] = arguments[_key];
        }
        return function(value) {
          return functions.reduce(function(v, f) {
            return f(v);
          }, value);
        };
      }, unitize = function unitize2(func, unit2) {
        return function(value) {
          return func(parseFloat(value)) + (unit2 || getUnit(value));
        };
      }, normalize2 = function normalize3(min, max, value) {
        return mapRange(min, max, 0, 1, value);
      }, _wrapArray = function _wrapArray2(a, wrapper, value) {
        return _conditionalReturn(value, function(index2) {
          return a[~~wrapper(index2)];
        });
      }, wrap = function wrap2(min, max, value) {
        var range = max - min;
        return _isArray(min) ? _wrapArray(min, wrap2(0, min.length), max) : _conditionalReturn(value, function(value2) {
          return (range + (value2 - min) % range) % range + min;
        });
      }, wrapYoyo = function wrapYoyo2(min, max, value) {
        var range = max - min, total = range * 2;
        return _isArray(min) ? _wrapArray(min, wrapYoyo2(0, min.length - 1), max) : _conditionalReturn(value, function(value2) {
          value2 = (total + (value2 - min) % total) % total || 0;
          return min + (value2 > range ? total - value2 : value2);
        });
      }, _replaceRandom = function _replaceRandom2(value) {
        var prev = 0, s2 = "", i, nums, end, isArray;
        while (~(i = value.indexOf("random(", prev))) {
          end = value.indexOf(")", i);
          isArray = value.charAt(i + 7) === "[";
          nums = value.substr(i + 7, end - i - 7).match(isArray ? _delimitedValueExp : _strictNumExp);
          s2 += value.substr(prev, i - prev) + random(isArray ? nums : +nums[0], isArray ? 0 : +nums[1], +nums[2] || 1e-5);
          prev = end + 1;
        }
        return s2 + value.substr(prev, value.length - prev);
      }, mapRange = function mapRange2(inMin, inMax, outMin, outMax, value) {
        var inRange = inMax - inMin, outRange = outMax - outMin;
        return _conditionalReturn(value, function(value2) {
          return outMin + ((value2 - inMin) / inRange * outRange || 0);
        });
      }, interpolate2 = function interpolate3(start, end, progress, mutate) {
        var func = isNaN(start + end) ? 0 : function(p2) {
          return (1 - p2) * start + p2 * end;
        };
        if (!func) {
          var isString = _isString(start), master = {}, p, i, interpolators, l, il;
          progress === true && (mutate = 1) && (progress = null);
          if (isString) {
            start = {
              p: start
            };
            end = {
              p: end
            };
          } else if (_isArray(start) && !_isArray(end)) {
            interpolators = [];
            l = start.length;
            il = l - 2;
            for (i = 1; i < l; i++) {
              interpolators.push(interpolate3(start[i - 1], start[i]));
            }
            l--;
            func = function func2(p2) {
              p2 *= l;
              var i2 = Math.min(il, ~~p2);
              return interpolators[i2](p2 - i2);
            };
            progress = end;
          } else if (!mutate) {
            start = _merge(_isArray(start) ? [] : {}, start);
          }
          if (!interpolators) {
            for (p in end) {
              _addPropTween.call(master, start, p, "get", end[p]);
            }
            func = function func2(p2) {
              return _renderPropTweens(p2, master) || (isString ? start.p : start);
            };
          }
        }
        return _conditionalReturn(progress, func);
      }, _getLabelInDirection = function _getLabelInDirection2(timeline, fromTime, backward) {
        var labels = timeline.labels, min = _bigNum, p, distance, label;
        for (p in labels) {
          distance = labels[p] - fromTime;
          if (distance < 0 === !!backward && distance && min > (distance = Math.abs(distance))) {
            label = p;
            min = distance;
          }
        }
        return label;
      }, _callback = function _callback2(animation, type, executeLazyFirst) {
        var v = animation.vars, callback = v[type], params, scope;
        if (!callback) {
          return;
        }
        params = v[type + "Params"];
        scope = v.callbackScope || animation;
        executeLazyFirst && _lazyTweens.length && _lazyRender();
        return params ? callback.apply(scope, params) : callback.call(scope);
      }, _interrupt = function _interrupt2(animation) {
        _removeFromParent(animation);
        animation.scrollTrigger && animation.scrollTrigger.kill(false);
        animation.progress() < 1 && _callback(animation, "onInterrupt");
        return animation;
      }, _quickTween, _createPlugin = function _createPlugin2(config) {
        config = !config.name && config["default"] || config;
        var name = config.name, isFunc = _isFunction(config), Plugin = name && !isFunc && config.init ? function() {
          this._props = [];
        } : config, instanceDefaults = {
          init: _emptyFunc,
          render: _renderPropTweens,
          add: _addPropTween,
          kill: _killPropTweensOf,
          modifier: _addPluginModifier,
          rawVars: 0
        }, statics = {
          targetTest: 0,
          get: 0,
          getSetter: _getSetter,
          aliases: {},
          register: 0
        };
        _wake();
        if (config !== Plugin) {
          if (_plugins[name]) {
            return;
          }
          _setDefaults(Plugin, _setDefaults(_copyExcluding(config, instanceDefaults), statics));
          _merge(Plugin.prototype, _merge(instanceDefaults, _copyExcluding(config, statics)));
          _plugins[Plugin.prop = name] = Plugin;
          if (config.targetTest) {
            _harnessPlugins.push(Plugin);
            _reservedProps[name] = 1;
          }
          name = (name === "css" ? "CSS" : name.charAt(0).toUpperCase() + name.substr(1)) + "Plugin";
        }
        _addGlobal(name, Plugin);
        config.register && config.register(gsap2, Plugin, PropTween);
      }, _255 = 255, _colorLookup = {
        aqua: [0, _255, _255],
        lime: [0, _255, 0],
        silver: [192, 192, 192],
        black: [0, 0, 0],
        maroon: [128, 0, 0],
        teal: [0, 128, 128],
        blue: [0, 0, _255],
        navy: [0, 0, 128],
        white: [_255, _255, _255],
        olive: [128, 128, 0],
        yellow: [_255, _255, 0],
        orange: [_255, 165, 0],
        gray: [128, 128, 128],
        purple: [128, 0, 128],
        green: [0, 128, 0],
        red: [_255, 0, 0],
        pink: [_255, 192, 203],
        cyan: [0, _255, _255],
        transparent: [_255, _255, _255, 0]
      }, _hue = function _hue2(h, m1, m2) {
        h = h < 0 ? h + 1 : h > 1 ? h - 1 : h;
        return (h * 6 < 1 ? m1 + (m2 - m1) * h * 6 : h < 0.5 ? m2 : h * 3 < 2 ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * _255 + 0.5 | 0;
      }, splitColor = function splitColor2(v, toHSL, forceAlpha) {
        var a = !v ? _colorLookup.black : _isNumber(v) ? [v >> 16, v >> 8 & _255, v & _255] : 0, r, g, b, h, s2, l, max, min, d, wasHSL;
        if (!a) {
          if (v.substr(-1) === ",") {
            v = v.substr(0, v.length - 1);
          }
          if (_colorLookup[v]) {
            a = _colorLookup[v];
          } else if (v.charAt(0) === "#") {
            if (v.length < 6) {
              r = v.charAt(1);
              g = v.charAt(2);
              b = v.charAt(3);
              v = "#" + r + r + g + g + b + b + (v.length === 5 ? v.charAt(4) + v.charAt(4) : "");
            }
            if (v.length === 9) {
              a = parseInt(v.substr(1, 6), 16);
              return [a >> 16, a >> 8 & _255, a & _255, parseInt(v.substr(7), 16) / 255];
            }
            v = parseInt(v.substr(1), 16);
            a = [v >> 16, v >> 8 & _255, v & _255];
          } else if (v.substr(0, 3) === "hsl") {
            a = wasHSL = v.match(_strictNumExp);
            if (!toHSL) {
              h = +a[0] % 360 / 360;
              s2 = +a[1] / 100;
              l = +a[2] / 100;
              g = l <= 0.5 ? l * (s2 + 1) : l + s2 - l * s2;
              r = l * 2 - g;
              a.length > 3 && (a[3] *= 1);
              a[0] = _hue(h + 1 / 3, r, g);
              a[1] = _hue(h, r, g);
              a[2] = _hue(h - 1 / 3, r, g);
            } else if (~v.indexOf("=")) {
              a = v.match(_numExp);
              forceAlpha && a.length < 4 && (a[3] = 1);
              return a;
            }
          } else {
            a = v.match(_strictNumExp) || _colorLookup.transparent;
          }
          a = a.map(Number);
        }
        if (toHSL && !wasHSL) {
          r = a[0] / _255;
          g = a[1] / _255;
          b = a[2] / _255;
          max = Math.max(r, g, b);
          min = Math.min(r, g, b);
          l = (max + min) / 2;
          if (max === min) {
            h = s2 = 0;
          } else {
            d = max - min;
            s2 = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            h = max === r ? (g - b) / d + (g < b ? 6 : 0) : max === g ? (b - r) / d + 2 : (r - g) / d + 4;
            h *= 60;
          }
          a[0] = ~~(h + 0.5);
          a[1] = ~~(s2 * 100 + 0.5);
          a[2] = ~~(l * 100 + 0.5);
        }
        forceAlpha && a.length < 4 && (a[3] = 1);
        return a;
      }, _colorOrderData = function _colorOrderData2(v) {
        var values = [], c = [], i = -1;
        v.split(_colorExp).forEach(function(v2) {
          var a = v2.match(_numWithUnitExp) || [];
          values.push.apply(values, a);
          c.push(i += a.length + 1);
        });
        values.c = c;
        return values;
      }, _formatColors = function _formatColors2(s2, toHSL, orderMatchData) {
        var result = "", colors = (s2 + result).match(_colorExp), type = toHSL ? "hsla(" : "rgba(", i = 0, c, shell, d, l;
        if (!colors) {
          return s2;
        }
        colors = colors.map(function(color2) {
          return (color2 = splitColor(color2, toHSL, 1)) && type + (toHSL ? color2[0] + "," + color2[1] + "%," + color2[2] + "%," + color2[3] : color2.join(",")) + ")";
        });
        if (orderMatchData) {
          d = _colorOrderData(s2);
          c = orderMatchData.c;
          if (c.join(result) !== d.c.join(result)) {
            shell = s2.replace(_colorExp, "1").split(_numWithUnitExp);
            l = shell.length - 1;
            for (; i < l; i++) {
              result += shell[i] + (~c.indexOf(i) ? colors.shift() || type + "0,0,0,0)" : (d.length ? d : colors.length ? colors : orderMatchData).shift());
            }
          }
        }
        if (!shell) {
          shell = s2.split(_colorExp);
          l = shell.length - 1;
          for (; i < l; i++) {
            result += shell[i] + colors[i];
          }
        }
        return result + shell[l];
      }, _colorExp = function() {
        var s2 = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b", p;
        for (p in _colorLookup) {
          s2 += "|" + p + "\\b";
        }
        return new RegExp(s2 + ")", "gi");
      }(), _hslExp = /hsl[a]?\(/, _colorStringFilter = function _colorStringFilter2(a) {
        var combined = a.join(" "), toHSL;
        _colorExp.lastIndex = 0;
        if (_colorExp.test(combined)) {
          toHSL = _hslExp.test(combined);
          a[1] = _formatColors(a[1], toHSL);
          a[0] = _formatColors(a[0], toHSL, _colorOrderData(a[1]));
          return true;
        }
      }, _tickerActive, _ticker = function() {
        var _getTime = Date.now, _lagThreshold = 500, _adjustedLag = 33, _startTime = _getTime(), _lastUpdate = _startTime, _gap = 1e3 / 240, _nextTime = _gap, _listeners = [], _id, _req, _raf, _self, _delta, _i, _tick = function _tick2(v) {
          var elapsed = _getTime() - _lastUpdate, manual = v === true, overlap, dispatch, time, frame;
          elapsed > _lagThreshold && (_startTime += elapsed - _adjustedLag);
          _lastUpdate += elapsed;
          time = _lastUpdate - _startTime;
          overlap = time - _nextTime;
          if (overlap > 0 || manual) {
            frame = ++_self.frame;
            _delta = time - _self.time * 1e3;
            _self.time = time = time / 1e3;
            _nextTime += overlap + (overlap >= _gap ? 4 : _gap - overlap);
            dispatch = 1;
          }
          manual || (_id = _req(_tick2));
          if (dispatch) {
            for (_i = 0; _i < _listeners.length; _i++) {
              _listeners[_i](time, _delta, frame, v);
            }
          }
        };
        _self = {
          time: 0,
          frame: 0,
          tick: function tick() {
            _tick(true);
          },
          deltaRatio: function deltaRatio(fps) {
            return _delta / (1e3 / (fps || 60));
          },
          wake: function wake() {
            if (_coreReady) {
              if (!_coreInitted && _windowExists()) {
                _win = _coreInitted = window;
                _doc = _win.document || {};
                _globals.gsap = gsap2;
                (_win.gsapVersions || (_win.gsapVersions = [])).push(gsap2.version);
                _install(_installScope || _win.GreenSockGlobals || !_win.gsap && _win || {});
                _raf = _win.requestAnimationFrame;
              }
              _id && _self.sleep();
              _req = _raf || function(f) {
                return setTimeout(f, _nextTime - _self.time * 1e3 + 1 | 0);
              };
              _tickerActive = 1;
              _tick(2);
            }
          },
          sleep: function sleep() {
            (_raf ? _win.cancelAnimationFrame : clearTimeout)(_id);
            _tickerActive = 0;
            _req = _emptyFunc;
          },
          lagSmoothing: function lagSmoothing(threshold, adjustedLag) {
            _lagThreshold = threshold || 1 / _tinyNum;
            _adjustedLag = Math.min(adjustedLag, _lagThreshold, 0);
          },
          fps: function fps(_fps) {
            _gap = 1e3 / (_fps || 240);
            _nextTime = _self.time * 1e3 + _gap;
          },
          add: function add(callback) {
            _listeners.indexOf(callback) < 0 && _listeners.push(callback);
            _wake();
          },
          remove: function remove(callback) {
            var i;
            ~(i = _listeners.indexOf(callback)) && _listeners.splice(i, 1) && _i >= i && _i--;
          },
          _listeners
        };
        return _self;
      }(), _wake = function _wake2() {
        return !_tickerActive && _ticker.wake();
      }, _easeMap = {}, _customEaseExp = /^[\d.\-M][\d.\-,\s]/, _quotesExp = /["']/g, _parseObjectInString = function _parseObjectInString2(value) {
        var obj = {}, split = value.substr(1, value.length - 3).split(":"), key = split[0], i = 1, l = split.length, index2, val, parsedVal;
        for (; i < l; i++) {
          val = split[i];
          index2 = i !== l - 1 ? val.lastIndexOf(",") : val.length;
          parsedVal = val.substr(0, index2);
          obj[key] = isNaN(parsedVal) ? parsedVal.replace(_quotesExp, "").trim() : +parsedVal;
          key = val.substr(index2 + 1).trim();
        }
        return obj;
      }, _valueInParentheses = function _valueInParentheses2(value) {
        var open = value.indexOf("(") + 1, close = value.indexOf(")"), nested = value.indexOf("(", open);
        return value.substring(open, ~nested && nested < close ? value.indexOf(")", close + 1) : close);
      }, _configEaseFromString = function _configEaseFromString2(name) {
        var split = (name + "").split("("), ease = _easeMap[split[0]];
        return ease && split.length > 1 && ease.config ? ease.config.apply(null, ~name.indexOf("{") ? [_parseObjectInString(split[1])] : _valueInParentheses(name).split(",").map(_numericIfPossible)) : _easeMap._CE && _customEaseExp.test(name) ? _easeMap._CE("", name) : ease;
      }, _invertEase = function _invertEase2(ease) {
        return function(p) {
          return 1 - ease(1 - p);
        };
      }, _propagateYoyoEase = function _propagateYoyoEase2(timeline, isYoyo) {
        var child = timeline._first, ease;
        while (child) {
          if (child instanceof Timeline) {
            _propagateYoyoEase2(child, isYoyo);
          } else if (child.vars.yoyoEase && (!child._yoyo || !child._repeat) && child._yoyo !== isYoyo) {
            if (child.timeline) {
              _propagateYoyoEase2(child.timeline, isYoyo);
            } else {
              ease = child._ease;
              child._ease = child._yEase;
              child._yEase = ease;
              child._yoyo = isYoyo;
            }
          }
          child = child._next;
        }
      }, _parseEase = function _parseEase2(ease, defaultEase) {
        return !ease ? defaultEase : (_isFunction(ease) ? ease : _easeMap[ease] || _configEaseFromString(ease)) || defaultEase;
      }, _insertEase = function _insertEase2(names, easeIn, easeOut, easeInOut) {
        if (easeOut === void 0) {
          easeOut = function easeOut2(p) {
            return 1 - easeIn(1 - p);
          };
        }
        if (easeInOut === void 0) {
          easeInOut = function easeInOut2(p) {
            return p < 0.5 ? easeIn(p * 2) / 2 : 1 - easeIn((1 - p) * 2) / 2;
          };
        }
        var ease = {
          easeIn,
          easeOut,
          easeInOut
        }, lowercaseName;
        _forEachName(names, function(name) {
          _easeMap[name] = _globals[name] = ease;
          _easeMap[lowercaseName = name.toLowerCase()] = easeOut;
          for (var p in ease) {
            _easeMap[lowercaseName + (p === "easeIn" ? ".in" : p === "easeOut" ? ".out" : ".inOut")] = _easeMap[name + "." + p] = ease[p];
          }
        });
        return ease;
      }, _easeInOutFromOut = function _easeInOutFromOut2(easeOut) {
        return function(p) {
          return p < 0.5 ? (1 - easeOut(1 - p * 2)) / 2 : 0.5 + easeOut((p - 0.5) * 2) / 2;
        };
      }, _configElastic = function _configElastic2(type, amplitude, period) {
        var p1 = amplitude >= 1 ? amplitude : 1, p2 = (period || (type ? 0.3 : 0.45)) / (amplitude < 1 ? amplitude : 1), p3 = p2 / _2PI * (Math.asin(1 / p1) || 0), easeOut = function easeOut2(p) {
          return p === 1 ? 1 : p1 * Math.pow(2, -10 * p) * _sin((p - p3) * p2) + 1;
        }, ease = type === "out" ? easeOut : type === "in" ? function(p) {
          return 1 - easeOut(1 - p);
        } : _easeInOutFromOut(easeOut);
        p2 = _2PI / p2;
        ease.config = function(amplitude2, period2) {
          return _configElastic2(type, amplitude2, period2);
        };
        return ease;
      }, _configBack = function _configBack2(type, overshoot) {
        if (overshoot === void 0) {
          overshoot = 1.70158;
        }
        var easeOut = function easeOut2(p) {
          return p ? --p * p * ((overshoot + 1) * p + overshoot) + 1 : 0;
        }, ease = type === "out" ? easeOut : type === "in" ? function(p) {
          return 1 - easeOut(1 - p);
        } : _easeInOutFromOut(easeOut);
        ease.config = function(overshoot2) {
          return _configBack2(type, overshoot2);
        };
        return ease;
      };
      _forEachName("Linear,Quad,Cubic,Quart,Quint,Strong", function(name, i) {
        var power = i < 5 ? i + 1 : i;
        _insertEase(name + ",Power" + (power - 1), i ? function(p) {
          return Math.pow(p, power);
        } : function(p) {
          return p;
        }, function(p) {
          return 1 - Math.pow(1 - p, power);
        }, function(p) {
          return p < 0.5 ? Math.pow(p * 2, power) / 2 : 1 - Math.pow((1 - p) * 2, power) / 2;
        });
      });
      _easeMap.Linear.easeNone = _easeMap.none = _easeMap.Linear.easeIn;
      _insertEase("Elastic", _configElastic("in"), _configElastic("out"), _configElastic());
      (function(n, c) {
        var n1 = 1 / c, n2 = 2 * n1, n3 = 2.5 * n1, easeOut = function easeOut2(p) {
          return p < n1 ? n * p * p : p < n2 ? n * Math.pow(p - 1.5 / c, 2) + 0.75 : p < n3 ? n * (p -= 2.25 / c) * p + 0.9375 : n * Math.pow(p - 2.625 / c, 2) + 0.984375;
        };
        _insertEase("Bounce", function(p) {
          return 1 - easeOut(1 - p);
        }, easeOut);
      })(7.5625, 2.75);
      _insertEase("Expo", function(p) {
        return p ? Math.pow(2, 10 * (p - 1)) : 0;
      });
      _insertEase("Circ", function(p) {
        return -(_sqrt(1 - p * p) - 1);
      });
      _insertEase("Sine", function(p) {
        return p === 1 ? 1 : -_cos(p * _HALF_PI) + 1;
      });
      _insertEase("Back", _configBack("in"), _configBack("out"), _configBack());
      _easeMap.SteppedEase = _easeMap.steps = _globals.SteppedEase = {
        config: function config(steps, immediateStart) {
          if (steps === void 0) {
            steps = 1;
          }
          var p1 = 1 / steps, p2 = steps + (immediateStart ? 0 : 1), p3 = immediateStart ? 1 : 0, max = 1 - _tinyNum;
          return function(p) {
            return ((p2 * _clamp(0, max, p) | 0) + p3) * p1;
          };
        }
      };
      _defaults.ease = _easeMap["quad.out"];
      _forEachName("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function(name) {
        return _callbackNames += name + "," + name + "Params,";
      });
      var GSCache = function GSCache2(target, harness) {
        this.id = _gsID++;
        target._gsap = this;
        this.target = target;
        this.harness = harness;
        this.get = harness ? harness.get : _getProperty;
        this.set = harness ? harness.getSetter : _getSetter;
      };
      var Animation = function() {
        function Animation2(vars) {
          this.vars = vars;
          this._delay = +vars.delay || 0;
          if (this._repeat = vars.repeat === Infinity ? -2 : vars.repeat || 0) {
            this._rDelay = vars.repeatDelay || 0;
            this._yoyo = !!vars.yoyo || !!vars.yoyoEase;
          }
          this._ts = 1;
          _setDuration(this, +vars.duration, 1, 1);
          this.data = vars.data;
          _tickerActive || _ticker.wake();
        }
        var _proto = Animation2.prototype;
        _proto.delay = function delay(value) {
          if (value || value === 0) {
            this.parent && this.parent.smoothChildTiming && this.startTime(this._start + value - this._delay);
            this._delay = value;
            return this;
          }
          return this._delay;
        };
        _proto.duration = function duration(value) {
          return arguments.length ? this.totalDuration(this._repeat > 0 ? value + (value + this._rDelay) * this._repeat : value) : this.totalDuration() && this._dur;
        };
        _proto.totalDuration = function totalDuration(value) {
          if (!arguments.length) {
            return this._tDur;
          }
          this._dirty = 0;
          return _setDuration(this, this._repeat < 0 ? value : (value - this._repeat * this._rDelay) / (this._repeat + 1));
        };
        _proto.totalTime = function totalTime(_totalTime, suppressEvents) {
          _wake();
          if (!arguments.length) {
            return this._tTime;
          }
          var parent = this._dp;
          if (parent && parent.smoothChildTiming && this._ts) {
            _alignPlayhead(this, _totalTime);
            !parent._dp || parent.parent || _postAddChecks(parent, this);
            while (parent && parent.parent) {
              if (parent.parent._time !== parent._start + (parent._ts >= 0 ? parent._tTime / parent._ts : (parent.totalDuration() - parent._tTime) / -parent._ts)) {
                parent.totalTime(parent._tTime, true);
              }
              parent = parent.parent;
            }
            if (!this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && _totalTime < this._tDur || this._ts < 0 && _totalTime > 0 || !this._tDur && !_totalTime)) {
              _addToTimeline(this._dp, this, this._start - this._delay);
            }
          }
          if (this._tTime !== _totalTime || !this._dur && !suppressEvents || this._initted && Math.abs(this._zTime) === _tinyNum || !_totalTime && !this._initted && (this.add || this._ptLookup)) {
            this._ts || (this._pTime = _totalTime);
            _lazySafeRender(this, _totalTime, suppressEvents);
          }
          return this;
        };
        _proto.time = function time(value, suppressEvents) {
          return arguments.length ? this.totalTime(Math.min(this.totalDuration(), value + _elapsedCycleDuration(this)) % (this._dur + this._rDelay) || (value ? this._dur : 0), suppressEvents) : this._time;
        };
        _proto.totalProgress = function totalProgress(value, suppressEvents) {
          return arguments.length ? this.totalTime(this.totalDuration() * value, suppressEvents) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio;
        };
        _proto.progress = function progress(value, suppressEvents) {
          return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - value : value) + _elapsedCycleDuration(this), suppressEvents) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio;
        };
        _proto.iteration = function iteration(value, suppressEvents) {
          var cycleDuration = this.duration() + this._rDelay;
          return arguments.length ? this.totalTime(this._time + (value - 1) * cycleDuration, suppressEvents) : this._repeat ? _animationCycle(this._tTime, cycleDuration) + 1 : 1;
        };
        _proto.timeScale = function timeScale(value) {
          if (!arguments.length) {
            return this._rts === -_tinyNum ? 0 : this._rts;
          }
          if (this._rts === value) {
            return this;
          }
          var tTime = this.parent && this._ts ? _parentToChildTotalTime(this.parent._time, this) : this._tTime;
          this._rts = +value || 0;
          this._ts = this._ps || value === -_tinyNum ? 0 : this._rts;
          _recacheAncestors(this.totalTime(_clamp(-this._delay, this._tDur, tTime), true));
          _setEnd(this);
          return this;
        };
        _proto.paused = function paused(value) {
          if (!arguments.length) {
            return this._ps;
          }
          if (this._ps !== value) {
            this._ps = value;
            if (value) {
              this._pTime = this._tTime || Math.max(-this._delay, this.rawTime());
              this._ts = this._act = 0;
            } else {
              _wake();
              this._ts = this._rts;
              this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== _tinyNum && (this._tTime -= _tinyNum));
            }
          }
          return this;
        };
        _proto.startTime = function startTime(value) {
          if (arguments.length) {
            this._start = value;
            var parent = this.parent || this._dp;
            parent && (parent._sort || !this.parent) && _addToTimeline(parent, this, value - this._delay);
            return this;
          }
          return this._start;
        };
        _proto.endTime = function endTime(includeRepeats) {
          return this._start + (_isNotFalse(includeRepeats) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1);
        };
        _proto.rawTime = function rawTime(wrapRepeats) {
          var parent = this.parent || this._dp;
          return !parent ? this._tTime : wrapRepeats && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : !this._ts ? this._tTime : _parentToChildTotalTime(parent.rawTime(wrapRepeats), this);
        };
        _proto.globalTime = function globalTime(rawTime) {
          var animation = this, time = arguments.length ? rawTime : animation.rawTime();
          while (animation) {
            time = animation._start + time / (animation._ts || 1);
            animation = animation._dp;
          }
          return time;
        };
        _proto.repeat = function repeat(value) {
          if (arguments.length) {
            this._repeat = value === Infinity ? -2 : value;
            return _onUpdateTotalDuration(this);
          }
          return this._repeat === -2 ? Infinity : this._repeat;
        };
        _proto.repeatDelay = function repeatDelay(value) {
          if (arguments.length) {
            var time = this._time;
            this._rDelay = value;
            _onUpdateTotalDuration(this);
            return time ? this.time(time) : this;
          }
          return this._rDelay;
        };
        _proto.yoyo = function yoyo(value) {
          if (arguments.length) {
            this._yoyo = value;
            return this;
          }
          return this._yoyo;
        };
        _proto.seek = function seek(position, suppressEvents) {
          return this.totalTime(_parsePosition(this, position), _isNotFalse(suppressEvents));
        };
        _proto.restart = function restart(includeDelay, suppressEvents) {
          return this.play().totalTime(includeDelay ? -this._delay : 0, _isNotFalse(suppressEvents));
        };
        _proto.play = function play(from, suppressEvents) {
          from != null && this.seek(from, suppressEvents);
          return this.reversed(false).paused(false);
        };
        _proto.reverse = function reverse(from, suppressEvents) {
          from != null && this.seek(from || this.totalDuration(), suppressEvents);
          return this.reversed(true).paused(false);
        };
        _proto.pause = function pause(atTime, suppressEvents) {
          atTime != null && this.seek(atTime, suppressEvents);
          return this.paused(true);
        };
        _proto.resume = function resume() {
          return this.paused(false);
        };
        _proto.reversed = function reversed(value) {
          if (arguments.length) {
            !!value !== this.reversed() && this.timeScale(-this._rts || (value ? -_tinyNum : 0));
            return this;
          }
          return this._rts < 0;
        };
        _proto.invalidate = function invalidate() {
          this._initted = this._act = 0;
          this._zTime = -_tinyNum;
          return this;
        };
        _proto.isActive = function isActive() {
          var parent = this.parent || this._dp, start = this._start, rawTime;
          return !!(!parent || this._ts && this._initted && parent.isActive() && (rawTime = parent.rawTime(true)) >= start && rawTime < this.endTime(true) - _tinyNum);
        };
        _proto.eventCallback = function eventCallback(type, callback, params) {
          var vars = this.vars;
          if (arguments.length > 1) {
            if (!callback) {
              delete vars[type];
            } else {
              vars[type] = callback;
              params && (vars[type + "Params"] = params);
              type === "onUpdate" && (this._onUpdate = callback);
            }
            return this;
          }
          return vars[type];
        };
        _proto.then = function then(onFulfilled) {
          var self2 = this;
          return new Promise(function(resolve2) {
            var f = _isFunction(onFulfilled) ? onFulfilled : _passThrough, _resolve = function _resolve2() {
              var _then = self2.then;
              self2.then = null;
              _isFunction(f) && (f = f(self2)) && (f.then || f === self2) && (self2.then = _then);
              resolve2(f);
              self2.then = _then;
            };
            if (self2._initted && self2.totalProgress() === 1 && self2._ts >= 0 || !self2._tTime && self2._ts < 0) {
              _resolve();
            } else {
              self2._prom = _resolve;
            }
          });
        };
        _proto.kill = function kill() {
          _interrupt(this);
        };
        return Animation2;
      }();
      _setDefaults(Animation.prototype, {
        _time: 0,
        _start: 0,
        _end: 0,
        _tTime: 0,
        _tDur: 0,
        _dirty: 0,
        _repeat: 0,
        _yoyo: false,
        parent: null,
        _initted: false,
        _rDelay: 0,
        _ts: 1,
        _dp: 0,
        ratio: 0,
        _zTime: -_tinyNum,
        _prom: 0,
        _ps: false,
        _rts: 1
      });
      var Timeline = function(_Animation) {
        _inheritsLoose(Timeline2, _Animation);
        function Timeline2(vars, position) {
          var _this;
          if (vars === void 0) {
            vars = {};
          }
          _this = _Animation.call(this, vars) || this;
          _this.labels = {};
          _this.smoothChildTiming = !!vars.smoothChildTiming;
          _this.autoRemoveChildren = !!vars.autoRemoveChildren;
          _this._sort = _isNotFalse(vars.sortChildren);
          _globalTimeline && _addToTimeline(vars.parent || _globalTimeline, _assertThisInitialized(_this), position);
          vars.reversed && _this.reverse();
          vars.paused && _this.paused(true);
          vars.scrollTrigger && _scrollTrigger(_assertThisInitialized(_this), vars.scrollTrigger);
          return _this;
        }
        var _proto2 = Timeline2.prototype;
        _proto2.to = function to(targets, vars, position) {
          _createTweenType(0, arguments, this);
          return this;
        };
        _proto2.from = function from(targets, vars, position) {
          _createTweenType(1, arguments, this);
          return this;
        };
        _proto2.fromTo = function fromTo(targets, fromVars, toVars, position) {
          _createTweenType(2, arguments, this);
          return this;
        };
        _proto2.set = function set(targets, vars, position) {
          vars.duration = 0;
          vars.parent = this;
          _inheritDefaults(vars).repeatDelay || (vars.repeat = 0);
          vars.immediateRender = !!vars.immediateRender;
          new Tween(targets, vars, _parsePosition(this, position), 1);
          return this;
        };
        _proto2.call = function call(callback, params, position) {
          return _addToTimeline(this, Tween.delayedCall(0, callback, params), position);
        };
        _proto2.staggerTo = function staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
          vars.duration = duration;
          vars.stagger = vars.stagger || stagger;
          vars.onComplete = onCompleteAll;
          vars.onCompleteParams = onCompleteAllParams;
          vars.parent = this;
          new Tween(targets, vars, _parsePosition(this, position));
          return this;
        };
        _proto2.staggerFrom = function staggerFrom(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
          vars.runBackwards = 1;
          _inheritDefaults(vars).immediateRender = _isNotFalse(vars.immediateRender);
          return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams);
        };
        _proto2.staggerFromTo = function staggerFromTo(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams) {
          toVars.startAt = fromVars;
          _inheritDefaults(toVars).immediateRender = _isNotFalse(toVars.immediateRender);
          return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams);
        };
        _proto2.render = function render2(totalTime, suppressEvents, force) {
          var prevTime = this._time, tDur = this._dirty ? this.totalDuration() : this._tDur, dur = this._dur, tTime = totalTime <= 0 ? 0 : _roundPrecise(totalTime), crossingStart = this._zTime < 0 !== totalTime < 0 && (this._initted || !dur), time, child, next, iteration, cycleDuration, prevPaused, pauseTween, timeScale, prevStart, prevIteration, yoyo, isYoyo;
          this !== _globalTimeline && tTime > tDur && totalTime >= 0 && (tTime = tDur);
          if (tTime !== this._tTime || force || crossingStart) {
            if (prevTime !== this._time && dur) {
              tTime += this._time - prevTime;
              totalTime += this._time - prevTime;
            }
            time = tTime;
            prevStart = this._start;
            timeScale = this._ts;
            prevPaused = !timeScale;
            if (crossingStart) {
              dur || (prevTime = this._zTime);
              (totalTime || !suppressEvents) && (this._zTime = totalTime);
            }
            if (this._repeat) {
              yoyo = this._yoyo;
              cycleDuration = dur + this._rDelay;
              if (this._repeat < -1 && totalTime < 0) {
                return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
              }
              time = _roundPrecise(tTime % cycleDuration);
              if (tTime === tDur) {
                iteration = this._repeat;
                time = dur;
              } else {
                iteration = ~~(tTime / cycleDuration);
                if (iteration && iteration === tTime / cycleDuration) {
                  time = dur;
                  iteration--;
                }
                time > dur && (time = dur);
              }
              prevIteration = _animationCycle(this._tTime, cycleDuration);
              !prevTime && this._tTime && prevIteration !== iteration && (prevIteration = iteration);
              if (yoyo && iteration & 1) {
                time = dur - time;
                isYoyo = 1;
              }
              if (iteration !== prevIteration && !this._lock) {
                var rewinding = yoyo && prevIteration & 1, doesWrap = rewinding === (yoyo && iteration & 1);
                iteration < prevIteration && (rewinding = !rewinding);
                prevTime = rewinding ? 0 : dur;
                this._lock = 1;
                this.render(prevTime || (isYoyo ? 0 : _roundPrecise(iteration * cycleDuration)), suppressEvents, !dur)._lock = 0;
                this._tTime = tTime;
                !suppressEvents && this.parent && _callback(this, "onRepeat");
                this.vars.repeatRefresh && !isYoyo && (this.invalidate()._lock = 1);
                if (prevTime && prevTime !== this._time || prevPaused !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) {
                  return this;
                }
                dur = this._dur;
                tDur = this._tDur;
                if (doesWrap) {
                  this._lock = 2;
                  prevTime = rewinding ? dur : -1e-4;
                  this.render(prevTime, true);
                  this.vars.repeatRefresh && !isYoyo && this.invalidate();
                }
                this._lock = 0;
                if (!this._ts && !prevPaused) {
                  return this;
                }
                _propagateYoyoEase(this, isYoyo);
              }
            }
            if (this._hasPause && !this._forcing && this._lock < 2) {
              pauseTween = _findNextPauseTween(this, _roundPrecise(prevTime), _roundPrecise(time));
              if (pauseTween) {
                tTime -= time - (time = pauseTween._start);
              }
            }
            this._tTime = tTime;
            this._time = time;
            this._act = !timeScale;
            if (!this._initted) {
              this._onUpdate = this.vars.onUpdate;
              this._initted = 1;
              this._zTime = totalTime;
              prevTime = 0;
            }
            if (!prevTime && time && !suppressEvents) {
              _callback(this, "onStart");
              if (this._tTime !== tTime) {
                return this;
              }
            }
            if (time >= prevTime && totalTime >= 0) {
              child = this._first;
              while (child) {
                next = child._next;
                if ((child._act || time >= child._start) && child._ts && pauseTween !== child) {
                  if (child.parent !== this) {
                    return this.render(totalTime, suppressEvents, force);
                  }
                  child.render(child._ts > 0 ? (time - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (time - child._start) * child._ts, suppressEvents, force);
                  if (time !== this._time || !this._ts && !prevPaused) {
                    pauseTween = 0;
                    next && (tTime += this._zTime = -_tinyNum);
                    break;
                  }
                }
                child = next;
              }
            } else {
              child = this._last;
              var adjustedTime = totalTime < 0 ? totalTime : time;
              while (child) {
                next = child._prev;
                if ((child._act || adjustedTime <= child._end) && child._ts && pauseTween !== child) {
                  if (child.parent !== this) {
                    return this.render(totalTime, suppressEvents, force);
                  }
                  child.render(child._ts > 0 ? (adjustedTime - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (adjustedTime - child._start) * child._ts, suppressEvents, force);
                  if (time !== this._time || !this._ts && !prevPaused) {
                    pauseTween = 0;
                    next && (tTime += this._zTime = adjustedTime ? -_tinyNum : _tinyNum);
                    break;
                  }
                }
                child = next;
              }
            }
            if (pauseTween && !suppressEvents) {
              this.pause();
              pauseTween.render(time >= prevTime ? 0 : -_tinyNum)._zTime = time >= prevTime ? 1 : -1;
              if (this._ts) {
                this._start = prevStart;
                _setEnd(this);
                return this.render(totalTime, suppressEvents, force);
              }
            }
            this._onUpdate && !suppressEvents && _callback(this, "onUpdate", true);
            if (tTime === tDur && tDur >= this.totalDuration() || !tTime && prevTime) {
              if (prevStart === this._start || Math.abs(timeScale) !== Math.abs(this._ts)) {
                if (!this._lock) {
                  (totalTime || !dur) && (tTime === tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1);
                  if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime || !tDur)) {
                    _callback(this, tTime === tDur && totalTime >= 0 ? "onComplete" : "onReverseComplete", true);
                    this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
                  }
                }
              }
            }
          }
          return this;
        };
        _proto2.add = function add(child, position) {
          var _this2 = this;
          _isNumber(position) || (position = _parsePosition(this, position, child));
          if (!(child instanceof Animation)) {
            if (_isArray(child)) {
              child.forEach(function(obj) {
                return _this2.add(obj, position);
              });
              return this;
            }
            if (_isString(child)) {
              return this.addLabel(child, position);
            }
            if (_isFunction(child)) {
              child = Tween.delayedCall(0, child);
            } else {
              return this;
            }
          }
          return this !== child ? _addToTimeline(this, child, position) : this;
        };
        _proto2.getChildren = function getChildren(nested, tweens, timelines, ignoreBeforeTime) {
          if (nested === void 0) {
            nested = true;
          }
          if (tweens === void 0) {
            tweens = true;
          }
          if (timelines === void 0) {
            timelines = true;
          }
          if (ignoreBeforeTime === void 0) {
            ignoreBeforeTime = -_bigNum;
          }
          var a = [], child = this._first;
          while (child) {
            if (child._start >= ignoreBeforeTime) {
              if (child instanceof Tween) {
                tweens && a.push(child);
              } else {
                timelines && a.push(child);
                nested && a.push.apply(a, child.getChildren(true, tweens, timelines));
              }
            }
            child = child._next;
          }
          return a;
        };
        _proto2.getById = function getById(id) {
          var animations = this.getChildren(1, 1, 1), i = animations.length;
          while (i--) {
            if (animations[i].vars.id === id) {
              return animations[i];
            }
          }
        };
        _proto2.remove = function remove(child) {
          if (_isString(child)) {
            return this.removeLabel(child);
          }
          if (_isFunction(child)) {
            return this.killTweensOf(child);
          }
          _removeLinkedListItem(this, child);
          if (child === this._recent) {
            this._recent = this._last;
          }
          return _uncache(this);
        };
        _proto2.totalTime = function totalTime(_totalTime2, suppressEvents) {
          if (!arguments.length) {
            return this._tTime;
          }
          this._forcing = 1;
          if (!this._dp && this._ts) {
            this._start = _roundPrecise(_ticker.time - (this._ts > 0 ? _totalTime2 / this._ts : (this.totalDuration() - _totalTime2) / -this._ts));
          }
          _Animation.prototype.totalTime.call(this, _totalTime2, suppressEvents);
          this._forcing = 0;
          return this;
        };
        _proto2.addLabel = function addLabel(label, position) {
          this.labels[label] = _parsePosition(this, position);
          return this;
        };
        _proto2.removeLabel = function removeLabel(label) {
          delete this.labels[label];
          return this;
        };
        _proto2.addPause = function addPause(position, callback, params) {
          var t = Tween.delayedCall(0, callback || _emptyFunc, params);
          t.data = "isPause";
          this._hasPause = 1;
          return _addToTimeline(this, t, _parsePosition(this, position));
        };
        _proto2.removePause = function removePause(position) {
          var child = this._first;
          position = _parsePosition(this, position);
          while (child) {
            if (child._start === position && child.data === "isPause") {
              _removeFromParent(child);
            }
            child = child._next;
          }
        };
        _proto2.killTweensOf = function killTweensOf(targets, props, onlyActive) {
          var tweens = this.getTweensOf(targets, onlyActive), i = tweens.length;
          while (i--) {
            _overwritingTween !== tweens[i] && tweens[i].kill(targets, props);
          }
          return this;
        };
        _proto2.getTweensOf = function getTweensOf(targets, onlyActive) {
          var a = [], parsedTargets = toArray(targets), child = this._first, isGlobalTime = _isNumber(onlyActive), children;
          while (child) {
            if (child instanceof Tween) {
              if (_arrayContainsAny(child._targets, parsedTargets) && (isGlobalTime ? (!_overwritingTween || child._initted && child._ts) && child.globalTime(0) <= onlyActive && child.globalTime(child.totalDuration()) > onlyActive : !onlyActive || child.isActive())) {
                a.push(child);
              }
            } else if ((children = child.getTweensOf(parsedTargets, onlyActive)).length) {
              a.push.apply(a, children);
            }
            child = child._next;
          }
          return a;
        };
        _proto2.tweenTo = function tweenTo(position, vars) {
          vars = vars || {};
          var tl = this, endTime = _parsePosition(tl, position), _vars = vars, startAt = _vars.startAt, _onStart = _vars.onStart, onStartParams = _vars.onStartParams, immediateRender = _vars.immediateRender, initted, tween = Tween.to(tl, _setDefaults({
            ease: vars.ease || "none",
            lazy: false,
            immediateRender: false,
            time: endTime,
            overwrite: "auto",
            duration: vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale()) || _tinyNum,
            onStart: function onStart() {
              tl.pause();
              if (!initted) {
                var duration = vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale());
                tween._dur !== duration && _setDuration(tween, duration, 0, 1).render(tween._time, true, true);
                initted = 1;
              }
              _onStart && _onStart.apply(tween, onStartParams || []);
            }
          }, vars));
          return immediateRender ? tween.render(0) : tween;
        };
        _proto2.tweenFromTo = function tweenFromTo(fromPosition, toPosition, vars) {
          return this.tweenTo(toPosition, _setDefaults({
            startAt: {
              time: _parsePosition(this, fromPosition)
            }
          }, vars));
        };
        _proto2.recent = function recent() {
          return this._recent;
        };
        _proto2.nextLabel = function nextLabel(afterTime) {
          if (afterTime === void 0) {
            afterTime = this._time;
          }
          return _getLabelInDirection(this, _parsePosition(this, afterTime));
        };
        _proto2.previousLabel = function previousLabel(beforeTime) {
          if (beforeTime === void 0) {
            beforeTime = this._time;
          }
          return _getLabelInDirection(this, _parsePosition(this, beforeTime), 1);
        };
        _proto2.currentLabel = function currentLabel(value) {
          return arguments.length ? this.seek(value, true) : this.previousLabel(this._time + _tinyNum);
        };
        _proto2.shiftChildren = function shiftChildren(amount, adjustLabels, ignoreBeforeTime) {
          if (ignoreBeforeTime === void 0) {
            ignoreBeforeTime = 0;
          }
          var child = this._first, labels = this.labels, p;
          while (child) {
            if (child._start >= ignoreBeforeTime) {
              child._start += amount;
              child._end += amount;
            }
            child = child._next;
          }
          if (adjustLabels) {
            for (p in labels) {
              if (labels[p] >= ignoreBeforeTime) {
                labels[p] += amount;
              }
            }
          }
          return _uncache(this);
        };
        _proto2.invalidate = function invalidate() {
          var child = this._first;
          this._lock = 0;
          while (child) {
            child.invalidate();
            child = child._next;
          }
          return _Animation.prototype.invalidate.call(this);
        };
        _proto2.clear = function clear(includeLabels) {
          if (includeLabels === void 0) {
            includeLabels = true;
          }
          var child = this._first, next;
          while (child) {
            next = child._next;
            this.remove(child);
            child = next;
          }
          this._dp && (this._time = this._tTime = this._pTime = 0);
          includeLabels && (this.labels = {});
          return _uncache(this);
        };
        _proto2.totalDuration = function totalDuration(value) {
          var max = 0, self2 = this, child = self2._last, prevStart = _bigNum, prev, start, parent;
          if (arguments.length) {
            return self2.timeScale((self2._repeat < 0 ? self2.duration() : self2.totalDuration()) / (self2.reversed() ? -value : value));
          }
          if (self2._dirty) {
            parent = self2.parent;
            while (child) {
              prev = child._prev;
              child._dirty && child.totalDuration();
              start = child._start;
              if (start > prevStart && self2._sort && child._ts && !self2._lock) {
                self2._lock = 1;
                _addToTimeline(self2, child, start - child._delay, 1)._lock = 0;
              } else {
                prevStart = start;
              }
              if (start < 0 && child._ts) {
                max -= start;
                if (!parent && !self2._dp || parent && parent.smoothChildTiming) {
                  self2._start += start / self2._ts;
                  self2._time -= start;
                  self2._tTime -= start;
                }
                self2.shiftChildren(-start, false, -Infinity);
                prevStart = 0;
              }
              child._end > max && child._ts && (max = child._end);
              child = prev;
            }
            _setDuration(self2, self2 === _globalTimeline && self2._time > max ? self2._time : max, 1, 1);
            self2._dirty = 0;
          }
          return self2._tDur;
        };
        Timeline2.updateRoot = function updateRoot(time) {
          if (_globalTimeline._ts) {
            _lazySafeRender(_globalTimeline, _parentToChildTotalTime(time, _globalTimeline));
            _lastRenderedFrame = _ticker.frame;
          }
          if (_ticker.frame >= _nextGCFrame) {
            _nextGCFrame += _config.autoSleep || 120;
            var child = _globalTimeline._first;
            if (!child || !child._ts) {
              if (_config.autoSleep && _ticker._listeners.length < 2) {
                while (child && !child._ts) {
                  child = child._next;
                }
                child || _ticker.sleep();
              }
            }
          }
        };
        return Timeline2;
      }(Animation);
      _setDefaults(Timeline.prototype, {
        _lock: 0,
        _hasPause: 0,
        _forcing: 0
      });
      var _addComplexStringPropTween = function _addComplexStringPropTween2(target, prop, start, end, setter, stringFilter, funcParam) {
        var pt = new PropTween(this._pt, target, prop, 0, 1, _renderComplexString, null, setter), index2 = 0, matchIndex = 0, result, startNums, color2, endNum, chunk, startNum, hasRandom, a;
        pt.b = start;
        pt.e = end;
        start += "";
        end += "";
        if (hasRandom = ~end.indexOf("random(")) {
          end = _replaceRandom(end);
        }
        if (stringFilter) {
          a = [start, end];
          stringFilter(a, target, prop);
          start = a[0];
          end = a[1];
        }
        startNums = start.match(_complexStringNumExp) || [];
        while (result = _complexStringNumExp.exec(end)) {
          endNum = result[0];
          chunk = end.substring(index2, result.index);
          if (color2) {
            color2 = (color2 + 1) % 5;
          } else if (chunk.substr(-5) === "rgba(") {
            color2 = 1;
          }
          if (endNum !== startNums[matchIndex++]) {
            startNum = parseFloat(startNums[matchIndex - 1]) || 0;
            pt._pt = {
              _next: pt._pt,
              p: chunk || matchIndex === 1 ? chunk : ",",
              s: startNum,
              c: endNum.charAt(1) === "=" ? parseFloat(endNum.substr(2)) * (endNum.charAt(0) === "-" ? -1 : 1) : parseFloat(endNum) - startNum,
              m: color2 && color2 < 4 ? Math.round : 0
            };
            index2 = _complexStringNumExp.lastIndex;
          }
        }
        pt.c = index2 < end.length ? end.substring(index2, end.length) : "";
        pt.fp = funcParam;
        if (_relExp.test(end) || hasRandom) {
          pt.e = 0;
        }
        this._pt = pt;
        return pt;
      }, _addPropTween = function _addPropTween2(target, prop, start, end, index2, targets, modifier, stringFilter, funcParam) {
        _isFunction(end) && (end = end(index2 || 0, target, targets));
        var currentValue = target[prop], parsedStart = start !== "get" ? start : !_isFunction(currentValue) ? currentValue : funcParam ? target[prop.indexOf("set") || !_isFunction(target["get" + prop.substr(3)]) ? prop : "get" + prop.substr(3)](funcParam) : target[prop](), setter = !_isFunction(currentValue) ? _setterPlain : funcParam ? _setterFuncWithParam : _setterFunc, pt;
        if (_isString(end)) {
          if (~end.indexOf("random(")) {
            end = _replaceRandom(end);
          }
          if (end.charAt(1) === "=") {
            pt = parseFloat(parsedStart) + parseFloat(end.substr(2)) * (end.charAt(0) === "-" ? -1 : 1) + (getUnit(parsedStart) || 0);
            if (pt || pt === 0) {
              end = pt;
            }
          }
        }
        if (parsedStart !== end) {
          if (!isNaN(parsedStart * end) && end !== "") {
            pt = new PropTween(this._pt, target, prop, +parsedStart || 0, end - (parsedStart || 0), typeof currentValue === "boolean" ? _renderBoolean : _renderPlain, 0, setter);
            funcParam && (pt.fp = funcParam);
            modifier && pt.modifier(modifier, this, target);
            return this._pt = pt;
          }
          !currentValue && !(prop in target) && _missingPlugin(prop, end);
          return _addComplexStringPropTween.call(this, target, prop, parsedStart, end, setter, stringFilter || _config.stringFilter, funcParam);
        }
      }, _processVars = function _processVars2(vars, index2, target, targets, tween) {
        _isFunction(vars) && (vars = _parseFuncOrString(vars, tween, index2, target, targets));
        if (!_isObject(vars) || vars.style && vars.nodeType || _isArray(vars) || _isTypedArray(vars)) {
          return _isString(vars) ? _parseFuncOrString(vars, tween, index2, target, targets) : vars;
        }
        var copy2 = {}, p;
        for (p in vars) {
          copy2[p] = _parseFuncOrString(vars[p], tween, index2, target, targets);
        }
        return copy2;
      }, _checkPlugin = function _checkPlugin2(property, vars, tween, index2, target, targets) {
        var plugin, pt, ptLookup, i;
        if (_plugins[property] && (plugin = new _plugins[property]()).init(target, plugin.rawVars ? vars[property] : _processVars(vars[property], index2, target, targets, tween), tween, index2, targets) !== false) {
          tween._pt = pt = new PropTween(tween._pt, target, property, 0, 1, plugin.render, plugin, 0, plugin.priority);
          if (tween !== _quickTween) {
            ptLookup = tween._ptLookup[tween._targets.indexOf(target)];
            i = plugin._props.length;
            while (i--) {
              ptLookup[plugin._props[i]] = pt;
            }
          }
        }
        return plugin;
      }, _overwritingTween, _initTween = function _initTween2(tween, time) {
        var vars = tween.vars, ease = vars.ease, startAt = vars.startAt, immediateRender = vars.immediateRender, lazy = vars.lazy, onUpdate = vars.onUpdate, onUpdateParams = vars.onUpdateParams, callbackScope = vars.callbackScope, runBackwards = vars.runBackwards, yoyoEase = vars.yoyoEase, keyframes = vars.keyframes, autoRevert = vars.autoRevert, dur = tween._dur, prevStartAt = tween._startAt, targets = tween._targets, parent = tween.parent, fullTargets = parent && parent.data === "nested" ? parent.parent._targets : targets, autoOverwrite = tween._overwrite === "auto" && !_suppressOverwrites, tl = tween.timeline, cleanVars, i, p, pt, target, hasPriority, gsData, harness, plugin, ptLookup, index2, harnessVars, overwritten;
        tl && (!keyframes || !ease) && (ease = "none");
        tween._ease = _parseEase(ease, _defaults.ease);
        tween._yEase = yoyoEase ? _invertEase(_parseEase(yoyoEase === true ? ease : yoyoEase, _defaults.ease)) : 0;
        if (yoyoEase && tween._yoyo && !tween._repeat) {
          yoyoEase = tween._yEase;
          tween._yEase = tween._ease;
          tween._ease = yoyoEase;
        }
        tween._from = !tl && !!vars.runBackwards;
        if (!tl) {
          harness = targets[0] ? _getCache(targets[0]).harness : 0;
          harnessVars = harness && vars[harness.prop];
          cleanVars = _copyExcluding(vars, _reservedProps);
          prevStartAt && prevStartAt.render(-1, true).kill();
          if (startAt) {
            _removeFromParent(tween._startAt = Tween.set(targets, _setDefaults({
              data: "isStart",
              overwrite: false,
              parent,
              immediateRender: true,
              lazy: _isNotFalse(lazy),
              startAt: null,
              delay: 0,
              onUpdate,
              onUpdateParams,
              callbackScope,
              stagger: 0
            }, startAt)));
            time < 0 && !immediateRender && !autoRevert && tween._startAt.render(-1, true);
            if (immediateRender) {
              time > 0 && !autoRevert && (tween._startAt = 0);
              if (dur && time <= 0) {
                time && (tween._zTime = time);
                return;
              }
            } else if (autoRevert === false) {
              tween._startAt = 0;
            }
          } else if (runBackwards && dur) {
            if (prevStartAt) {
              !autoRevert && (tween._startAt = 0);
            } else {
              time && (immediateRender = false);
              p = _setDefaults({
                overwrite: false,
                data: "isFromStart",
                lazy: immediateRender && _isNotFalse(lazy),
                immediateRender,
                stagger: 0,
                parent
              }, cleanVars);
              harnessVars && (p[harness.prop] = harnessVars);
              _removeFromParent(tween._startAt = Tween.set(targets, p));
              time < 0 && tween._startAt.render(-1, true);
              if (!immediateRender) {
                _initTween2(tween._startAt, _tinyNum);
              } else if (!time) {
                return;
              }
            }
          }
          tween._pt = 0;
          lazy = dur && _isNotFalse(lazy) || lazy && !dur;
          for (i = 0; i < targets.length; i++) {
            target = targets[i];
            gsData = target._gsap || _harness(targets)[i]._gsap;
            tween._ptLookup[i] = ptLookup = {};
            _lazyLookup[gsData.id] && _lazyTweens.length && _lazyRender();
            index2 = fullTargets === targets ? i : fullTargets.indexOf(target);
            if (harness && (plugin = new harness()).init(target, harnessVars || cleanVars, tween, index2, fullTargets) !== false) {
              tween._pt = pt = new PropTween(tween._pt, target, plugin.name, 0, 1, plugin.render, plugin, 0, plugin.priority);
              plugin._props.forEach(function(name) {
                ptLookup[name] = pt;
              });
              plugin.priority && (hasPriority = 1);
            }
            if (!harness || harnessVars) {
              for (p in cleanVars) {
                if (_plugins[p] && (plugin = _checkPlugin(p, cleanVars, tween, index2, target, fullTargets))) {
                  plugin.priority && (hasPriority = 1);
                } else {
                  ptLookup[p] = pt = _addPropTween.call(tween, target, p, "get", cleanVars[p], index2, fullTargets, 0, vars.stringFilter);
                }
              }
            }
            tween._op && tween._op[i] && tween.kill(target, tween._op[i]);
            if (autoOverwrite && tween._pt) {
              _overwritingTween = tween;
              _globalTimeline.killTweensOf(target, ptLookup, tween.globalTime(time));
              overwritten = !tween.parent;
              _overwritingTween = 0;
            }
            tween._pt && lazy && (_lazyLookup[gsData.id] = 1);
          }
          hasPriority && _sortPropTweensByPriority(tween);
          tween._onInit && tween._onInit(tween);
        }
        tween._onUpdate = onUpdate;
        tween._initted = (!tween._op || tween._pt) && !overwritten;
      }, _addAliasesToVars = function _addAliasesToVars2(targets, vars) {
        var harness = targets[0] ? _getCache(targets[0]).harness : 0, propertyAliases = harness && harness.aliases, copy2, p, i, aliases;
        if (!propertyAliases) {
          return vars;
        }
        copy2 = _merge({}, vars);
        for (p in propertyAliases) {
          if (p in copy2) {
            aliases = propertyAliases[p].split(",");
            i = aliases.length;
            while (i--) {
              copy2[aliases[i]] = copy2[p];
            }
          }
        }
        return copy2;
      }, _parseFuncOrString = function _parseFuncOrString2(value, tween, i, target, targets) {
        return _isFunction(value) ? value.call(tween, i, target, targets) : _isString(value) && ~value.indexOf("random(") ? _replaceRandom(value) : value;
      }, _staggerTweenProps = _callbackNames + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase", _staggerPropsToSkip = (_staggerTweenProps + ",id,stagger,delay,duration,paused,scrollTrigger").split(",");
      var Tween = function(_Animation2) {
        _inheritsLoose(Tween2, _Animation2);
        function Tween2(targets, vars, position, skipInherit) {
          var _this3;
          if (typeof vars === "number") {
            position.duration = vars;
            vars = position;
            position = null;
          }
          _this3 = _Animation2.call(this, skipInherit ? vars : _inheritDefaults(vars)) || this;
          var _this3$vars = _this3.vars, duration = _this3$vars.duration, delay = _this3$vars.delay, immediateRender = _this3$vars.immediateRender, stagger = _this3$vars.stagger, overwrite = _this3$vars.overwrite, keyframes = _this3$vars.keyframes, defaults = _this3$vars.defaults, scrollTrigger = _this3$vars.scrollTrigger, yoyoEase = _this3$vars.yoyoEase, parent = vars.parent || _globalTimeline, parsedTargets = (_isArray(targets) || _isTypedArray(targets) ? _isNumber(targets[0]) : "length" in vars) ? [targets] : toArray(targets), tl, i, copy2, l, p, curTarget, staggerFunc, staggerVarsToMerge;
          _this3._targets = parsedTargets.length ? _harness(parsedTargets) : _warn("GSAP target " + targets + " not found. https://greensock.com", !_config.nullTargetWarn) || [];
          _this3._ptLookup = [];
          _this3._overwrite = overwrite;
          if (keyframes || stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {
            vars = _this3.vars;
            tl = _this3.timeline = new Timeline({
              data: "nested",
              defaults: defaults || {}
            });
            tl.kill();
            tl.parent = tl._dp = _assertThisInitialized(_this3);
            tl._start = 0;
            if (keyframes) {
              _inheritDefaults(_setDefaults(tl.vars.defaults, {
                ease: "none"
              }));
              stagger ? parsedTargets.forEach(function(t, i2) {
                return keyframes.forEach(function(frame, j) {
                  return tl.to(t, frame, j ? ">" : i2 * stagger);
                });
              }) : keyframes.forEach(function(frame) {
                return tl.to(parsedTargets, frame, ">");
              });
            } else {
              l = parsedTargets.length;
              staggerFunc = stagger ? distribute(stagger) : _emptyFunc;
              if (_isObject(stagger)) {
                for (p in stagger) {
                  if (~_staggerTweenProps.indexOf(p)) {
                    staggerVarsToMerge || (staggerVarsToMerge = {});
                    staggerVarsToMerge[p] = stagger[p];
                  }
                }
              }
              for (i = 0; i < l; i++) {
                copy2 = {};
                for (p in vars) {
                  if (_staggerPropsToSkip.indexOf(p) < 0) {
                    copy2[p] = vars[p];
                  }
                }
                copy2.stagger = 0;
                yoyoEase && (copy2.yoyoEase = yoyoEase);
                staggerVarsToMerge && _merge(copy2, staggerVarsToMerge);
                curTarget = parsedTargets[i];
                copy2.duration = +_parseFuncOrString(duration, _assertThisInitialized(_this3), i, curTarget, parsedTargets);
                copy2.delay = (+_parseFuncOrString(delay, _assertThisInitialized(_this3), i, curTarget, parsedTargets) || 0) - _this3._delay;
                if (!stagger && l === 1 && copy2.delay) {
                  _this3._delay = delay = copy2.delay;
                  _this3._start += delay;
                  copy2.delay = 0;
                }
                tl.to(curTarget, copy2, staggerFunc(i, curTarget, parsedTargets));
              }
              tl.duration() ? duration = delay = 0 : _this3.timeline = 0;
            }
            duration || _this3.duration(duration = tl.duration());
          } else {
            _this3.timeline = 0;
          }
          if (overwrite === true && !_suppressOverwrites) {
            _overwritingTween = _assertThisInitialized(_this3);
            _globalTimeline.killTweensOf(parsedTargets);
            _overwritingTween = 0;
          }
          _addToTimeline(parent, _assertThisInitialized(_this3), position);
          vars.reversed && _this3.reverse();
          vars.paused && _this3.paused(true);
          if (immediateRender || !duration && !keyframes && _this3._start === _roundPrecise(parent._time) && _isNotFalse(immediateRender) && _hasNoPausedAncestors(_assertThisInitialized(_this3)) && parent.data !== "nested") {
            _this3._tTime = -_tinyNum;
            _this3.render(Math.max(0, -delay));
          }
          scrollTrigger && _scrollTrigger(_assertThisInitialized(_this3), scrollTrigger);
          return _this3;
        }
        var _proto3 = Tween2.prototype;
        _proto3.render = function render2(totalTime, suppressEvents, force) {
          var prevTime = this._time, tDur = this._tDur, dur = this._dur, tTime = totalTime > tDur - _tinyNum && totalTime >= 0 ? tDur : totalTime < _tinyNum ? 0 : totalTime, time, pt, iteration, cycleDuration, prevIteration, isYoyo, ratio, timeline, yoyoEase;
          if (!dur) {
            _renderZeroDurationTween(this, totalTime, suppressEvents, force);
          } else if (tTime !== this._tTime || !totalTime || force || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== totalTime < 0) {
            time = tTime;
            timeline = this.timeline;
            if (this._repeat) {
              cycleDuration = dur + this._rDelay;
              if (this._repeat < -1 && totalTime < 0) {
                return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
              }
              time = _roundPrecise(tTime % cycleDuration);
              if (tTime === tDur) {
                iteration = this._repeat;
                time = dur;
              } else {
                iteration = ~~(tTime / cycleDuration);
                if (iteration && iteration === tTime / cycleDuration) {
                  time = dur;
                  iteration--;
                }
                time > dur && (time = dur);
              }
              isYoyo = this._yoyo && iteration & 1;
              if (isYoyo) {
                yoyoEase = this._yEase;
                time = dur - time;
              }
              prevIteration = _animationCycle(this._tTime, cycleDuration);
              if (time === prevTime && !force && this._initted) {
                return this;
              }
              if (iteration !== prevIteration) {
                timeline && this._yEase && _propagateYoyoEase(timeline, isYoyo);
                if (this.vars.repeatRefresh && !isYoyo && !this._lock) {
                  this._lock = force = 1;
                  this.render(_roundPrecise(cycleDuration * iteration), true).invalidate()._lock = 0;
                }
              }
            }
            if (!this._initted) {
              if (_attemptInitTween(this, totalTime < 0 ? totalTime : time, force, suppressEvents)) {
                this._tTime = 0;
                return this;
              }
              if (dur !== this._dur) {
                return this.render(totalTime, suppressEvents, force);
              }
            }
            this._tTime = tTime;
            this._time = time;
            if (!this._act && this._ts) {
              this._act = 1;
              this._lazy = 0;
            }
            this.ratio = ratio = (yoyoEase || this._ease)(time / dur);
            if (this._from) {
              this.ratio = ratio = 1 - ratio;
            }
            if (time && !prevTime && !suppressEvents) {
              _callback(this, "onStart");
              if (this._tTime !== tTime) {
                return this;
              }
            }
            pt = this._pt;
            while (pt) {
              pt.r(ratio, pt.d);
              pt = pt._next;
            }
            timeline && timeline.render(totalTime < 0 ? totalTime : !time && isYoyo ? -_tinyNum : timeline._dur * ratio, suppressEvents, force) || this._startAt && (this._zTime = totalTime);
            if (this._onUpdate && !suppressEvents) {
              totalTime < 0 && this._startAt && this._startAt.render(totalTime, true, force);
              _callback(this, "onUpdate");
            }
            this._repeat && iteration !== prevIteration && this.vars.onRepeat && !suppressEvents && this.parent && _callback(this, "onRepeat");
            if ((tTime === this._tDur || !tTime) && this._tTime === tTime) {
              totalTime < 0 && this._startAt && !this._onUpdate && this._startAt.render(totalTime, true, true);
              (totalTime || !dur) && (tTime === this._tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1);
              if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime)) {
                _callback(this, tTime === tDur ? "onComplete" : "onReverseComplete", true);
                this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
              }
            }
          }
          return this;
        };
        _proto3.targets = function targets() {
          return this._targets;
        };
        _proto3.invalidate = function invalidate() {
          this._pt = this._op = this._startAt = this._onUpdate = this._lazy = this.ratio = 0;
          this._ptLookup = [];
          this.timeline && this.timeline.invalidate();
          return _Animation2.prototype.invalidate.call(this);
        };
        _proto3.kill = function kill(targets, vars) {
          if (vars === void 0) {
            vars = "all";
          }
          if (!targets && (!vars || vars === "all")) {
            this._lazy = this._pt = 0;
            return this.parent ? _interrupt(this) : this;
          }
          if (this.timeline) {
            var tDur = this.timeline.totalDuration();
            this.timeline.killTweensOf(targets, vars, _overwritingTween && _overwritingTween.vars.overwrite !== true)._first || _interrupt(this);
            this.parent && tDur !== this.timeline.totalDuration() && _setDuration(this, this._dur * this.timeline._tDur / tDur, 0, 1);
            return this;
          }
          var parsedTargets = this._targets, killingTargets = targets ? toArray(targets) : parsedTargets, propTweenLookup = this._ptLookup, firstPT = this._pt, overwrittenProps, curLookup, curOverwriteProps, props, p, pt, i;
          if ((!vars || vars === "all") && _arraysMatch(parsedTargets, killingTargets)) {
            vars === "all" && (this._pt = 0);
            return _interrupt(this);
          }
          overwrittenProps = this._op = this._op || [];
          if (vars !== "all") {
            if (_isString(vars)) {
              p = {};
              _forEachName(vars, function(name) {
                return p[name] = 1;
              });
              vars = p;
            }
            vars = _addAliasesToVars(parsedTargets, vars);
          }
          i = parsedTargets.length;
          while (i--) {
            if (~killingTargets.indexOf(parsedTargets[i])) {
              curLookup = propTweenLookup[i];
              if (vars === "all") {
                overwrittenProps[i] = vars;
                props = curLookup;
                curOverwriteProps = {};
              } else {
                curOverwriteProps = overwrittenProps[i] = overwrittenProps[i] || {};
                props = vars;
              }
              for (p in props) {
                pt = curLookup && curLookup[p];
                if (pt) {
                  if (!("kill" in pt.d) || pt.d.kill(p) === true) {
                    _removeLinkedListItem(this, pt, "_pt");
                  }
                  delete curLookup[p];
                }
                if (curOverwriteProps !== "all") {
                  curOverwriteProps[p] = 1;
                }
              }
            }
          }
          this._initted && !this._pt && firstPT && _interrupt(this);
          return this;
        };
        Tween2.to = function to(targets, vars) {
          return new Tween2(targets, vars, arguments[2]);
        };
        Tween2.from = function from(targets, vars) {
          return _createTweenType(1, arguments);
        };
        Tween2.delayedCall = function delayedCall(delay, callback, params, scope) {
          return new Tween2(callback, 0, {
            immediateRender: false,
            lazy: false,
            overwrite: false,
            delay,
            onComplete: callback,
            onReverseComplete: callback,
            onCompleteParams: params,
            onReverseCompleteParams: params,
            callbackScope: scope
          });
        };
        Tween2.fromTo = function fromTo(targets, fromVars, toVars) {
          return _createTweenType(2, arguments);
        };
        Tween2.set = function set(targets, vars) {
          vars.duration = 0;
          vars.repeatDelay || (vars.repeat = 0);
          return new Tween2(targets, vars);
        };
        Tween2.killTweensOf = function killTweensOf(targets, props, onlyActive) {
          return _globalTimeline.killTweensOf(targets, props, onlyActive);
        };
        return Tween2;
      }(Animation);
      _setDefaults(Tween.prototype, {
        _targets: [],
        _lazy: 0,
        _startAt: 0,
        _op: 0,
        _onInit: 0
      });
      _forEachName("staggerTo,staggerFrom,staggerFromTo", function(name) {
        Tween[name] = function() {
          var tl = new Timeline(), params = _slice.call(arguments, 0);
          params.splice(name === "staggerFromTo" ? 5 : 4, 0, 0);
          return tl[name].apply(tl, params);
        };
      });
      var _setterPlain = function _setterPlain2(target, property, value) {
        return target[property] = value;
      }, _setterFunc = function _setterFunc2(target, property, value) {
        return target[property](value);
      }, _setterFuncWithParam = function _setterFuncWithParam2(target, property, value, data) {
        return target[property](data.fp, value);
      }, _setterAttribute = function _setterAttribute2(target, property, value) {
        return target.setAttribute(property, value);
      }, _getSetter = function _getSetter2(target, property) {
        return _isFunction(target[property]) ? _setterFunc : _isUndefined(target[property]) && target.setAttribute ? _setterAttribute : _setterPlain;
      }, _renderPlain = function _renderPlain2(ratio, data) {
        return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 1e6) / 1e6, data);
      }, _renderBoolean = function _renderBoolean2(ratio, data) {
        return data.set(data.t, data.p, !!(data.s + data.c * ratio), data);
      }, _renderComplexString = function _renderComplexString2(ratio, data) {
        var pt = data._pt, s2 = "";
        if (!ratio && data.b) {
          s2 = data.b;
        } else if (ratio === 1 && data.e) {
          s2 = data.e;
        } else {
          while (pt) {
            s2 = pt.p + (pt.m ? pt.m(pt.s + pt.c * ratio) : Math.round((pt.s + pt.c * ratio) * 1e4) / 1e4) + s2;
            pt = pt._next;
          }
          s2 += data.c;
        }
        data.set(data.t, data.p, s2, data);
      }, _renderPropTweens = function _renderPropTweens2(ratio, data) {
        var pt = data._pt;
        while (pt) {
          pt.r(ratio, pt.d);
          pt = pt._next;
        }
      }, _addPluginModifier = function _addPluginModifier2(modifier, tween, target, property) {
        var pt = this._pt, next;
        while (pt) {
          next = pt._next;
          pt.p === property && pt.modifier(modifier, tween, target);
          pt = next;
        }
      }, _killPropTweensOf = function _killPropTweensOf2(property) {
        var pt = this._pt, hasNonDependentRemaining, next;
        while (pt) {
          next = pt._next;
          if (pt.p === property && !pt.op || pt.op === property) {
            _removeLinkedListItem(this, pt, "_pt");
          } else if (!pt.dep) {
            hasNonDependentRemaining = 1;
          }
          pt = next;
        }
        return !hasNonDependentRemaining;
      }, _setterWithModifier = function _setterWithModifier2(target, property, value, data) {
        data.mSet(target, property, data.m.call(data.tween, value, data.mt), data);
      }, _sortPropTweensByPriority = function _sortPropTweensByPriority2(parent) {
        var pt = parent._pt, next, pt2, first, last;
        while (pt) {
          next = pt._next;
          pt2 = first;
          while (pt2 && pt2.pr > pt.pr) {
            pt2 = pt2._next;
          }
          if (pt._prev = pt2 ? pt2._prev : last) {
            pt._prev._next = pt;
          } else {
            first = pt;
          }
          if (pt._next = pt2) {
            pt2._prev = pt;
          } else {
            last = pt;
          }
          pt = next;
        }
        parent._pt = first;
      };
      var PropTween = function() {
        function PropTween2(next, target, prop, start, change, renderer, data, setter, priority) {
          this.t = target;
          this.s = start;
          this.c = change;
          this.p = prop;
          this.r = renderer || _renderPlain;
          this.d = data || this;
          this.set = setter || _setterPlain;
          this.pr = priority || 0;
          this._next = next;
          if (next) {
            next._prev = this;
          }
        }
        var _proto4 = PropTween2.prototype;
        _proto4.modifier = function modifier(func, tween, target) {
          this.mSet = this.mSet || this.set;
          this.set = _setterWithModifier;
          this.m = func;
          this.mt = target;
          this.tween = tween;
        };
        return PropTween2;
      }();
      _forEachName(_callbackNames + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function(name) {
        return _reservedProps[name] = 1;
      });
      _globals.TweenMax = _globals.TweenLite = Tween;
      _globals.TimelineLite = _globals.TimelineMax = Timeline;
      _globalTimeline = new Timeline({
        sortChildren: false,
        defaults: _defaults,
        autoRemoveChildren: true,
        id: "root",
        smoothChildTiming: true
      });
      _config.stringFilter = _colorStringFilter;
      var _gsap = {
        registerPlugin: function registerPlugin() {
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }
          args.forEach(function(config) {
            return _createPlugin(config);
          });
        },
        timeline: function timeline(vars) {
          return new Timeline(vars);
        },
        getTweensOf: function getTweensOf(targets, onlyActive) {
          return _globalTimeline.getTweensOf(targets, onlyActive);
        },
        getProperty: function getProperty(target, property, unit2, uncache) {
          _isString(target) && (target = toArray(target)[0]);
          var getter = _getCache(target || {}).get, format3 = unit2 ? _passThrough : _numericIfPossible;
          unit2 === "native" && (unit2 = "");
          return !target ? target : !property ? function(property2, unit3, uncache2) {
            return format3((_plugins[property2] && _plugins[property2].get || getter)(target, property2, unit3, uncache2));
          } : format3((_plugins[property] && _plugins[property].get || getter)(target, property, unit2, uncache));
        },
        quickSetter: function quickSetter(target, property, unit2) {
          target = toArray(target);
          if (target.length > 1) {
            var setters = target.map(function(t) {
              return gsap2.quickSetter(t, property, unit2);
            }), l = setters.length;
            return function(value) {
              var i = l;
              while (i--) {
                setters[i](value);
              }
            };
          }
          target = target[0] || {};
          var Plugin = _plugins[property], cache = _getCache(target), p = cache.harness && (cache.harness.aliases || {})[property] || property, setter = Plugin ? function(value) {
            var p2 = new Plugin();
            _quickTween._pt = 0;
            p2.init(target, unit2 ? value + unit2 : value, _quickTween, 0, [target]);
            p2.render(1, p2);
            _quickTween._pt && _renderPropTweens(1, _quickTween);
          } : cache.set(target, p);
          return Plugin ? setter : function(value) {
            return setter(target, p, unit2 ? value + unit2 : value, cache, 1);
          };
        },
        isTweening: function isTweening(targets) {
          return _globalTimeline.getTweensOf(targets, true).length > 0;
        },
        defaults: function defaults(value) {
          value && value.ease && (value.ease = _parseEase(value.ease, _defaults.ease));
          return _mergeDeep(_defaults, value || {});
        },
        config: function config(value) {
          return _mergeDeep(_config, value || {});
        },
        registerEffect: function registerEffect(_ref3) {
          var name = _ref3.name, effect = _ref3.effect, plugins = _ref3.plugins, defaults = _ref3.defaults, extendTimeline = _ref3.extendTimeline;
          (plugins || "").split(",").forEach(function(pluginName) {
            return pluginName && !_plugins[pluginName] && !_globals[pluginName] && _warn(name + " effect requires " + pluginName + " plugin.");
          });
          _effects[name] = function(targets, vars, tl) {
            return effect(toArray(targets), _setDefaults(vars || {}, defaults), tl);
          };
          if (extendTimeline) {
            Timeline.prototype[name] = function(targets, vars, position) {
              return this.add(_effects[name](targets, _isObject(vars) ? vars : (position = vars) && {}, this), position);
            };
          }
        },
        registerEase: function registerEase(name, ease) {
          _easeMap[name] = _parseEase(ease);
        },
        parseEase: function parseEase(ease, defaultEase) {
          return arguments.length ? _parseEase(ease, defaultEase) : _easeMap;
        },
        getById: function getById(id) {
          return _globalTimeline.getById(id);
        },
        exportRoot: function exportRoot(vars, includeDelayedCalls) {
          if (vars === void 0) {
            vars = {};
          }
          var tl = new Timeline(vars), child, next;
          tl.smoothChildTiming = _isNotFalse(vars.smoothChildTiming);
          _globalTimeline.remove(tl);
          tl._dp = 0;
          tl._time = tl._tTime = _globalTimeline._time;
          child = _globalTimeline._first;
          while (child) {
            next = child._next;
            if (includeDelayedCalls || !(!child._dur && child instanceof Tween && child.vars.onComplete === child._targets[0])) {
              _addToTimeline(tl, child, child._start - child._delay);
            }
            child = next;
          }
          _addToTimeline(_globalTimeline, tl, 0);
          return tl;
        },
        utils: {
          wrap,
          wrapYoyo,
          distribute,
          random,
          snap,
          normalize: normalize2,
          getUnit,
          clamp,
          splitColor,
          toArray,
          selector,
          mapRange,
          pipe,
          unitize,
          interpolate: interpolate2,
          shuffle
        },
        install: _install,
        effects: _effects,
        ticker: _ticker,
        updateRoot: Timeline.updateRoot,
        plugins: _plugins,
        globalTimeline: _globalTimeline,
        core: {
          PropTween,
          globals: _addGlobal,
          Tween,
          Timeline,
          Animation,
          getCache: _getCache,
          _removeLinkedListItem,
          suppressOverwrites: function suppressOverwrites(value) {
            return _suppressOverwrites = value;
          }
        }
      };
      _forEachName("to,from,fromTo,delayedCall,set,killTweensOf", function(name) {
        return _gsap[name] = Tween[name];
      });
      _ticker.add(Timeline.updateRoot);
      _quickTween = _gsap.to({}, {
        duration: 0
      });
      var _getPluginPropTween = function _getPluginPropTween2(plugin, prop) {
        var pt = plugin._pt;
        while (pt && pt.p !== prop && pt.op !== prop && pt.fp !== prop) {
          pt = pt._next;
        }
        return pt;
      }, _addModifiers = function _addModifiers2(tween, modifiers) {
        var targets = tween._targets, p, i, pt;
        for (p in modifiers) {
          i = targets.length;
          while (i--) {
            pt = tween._ptLookup[i][p];
            if (pt && (pt = pt.d)) {
              if (pt._pt) {
                pt = _getPluginPropTween(pt, p);
              }
              pt && pt.modifier && pt.modifier(modifiers[p], tween, targets[i], p);
            }
          }
        }
      }, _buildModifierPlugin = function _buildModifierPlugin2(name, modifier) {
        return {
          name,
          rawVars: 1,
          init: function init2(target, vars, tween) {
            tween._onInit = function(tween2) {
              var temp, p;
              if (_isString(vars)) {
                temp = {};
                _forEachName(vars, function(name2) {
                  return temp[name2] = 1;
                });
                vars = temp;
              }
              if (modifier) {
                temp = {};
                for (p in vars) {
                  temp[p] = modifier(vars[p]);
                }
                vars = temp;
              }
              _addModifiers(tween2, vars);
            };
          }
        };
      };
      var gsap2 = _gsap.registerPlugin({
        name: "attr",
        init: function init2(target, vars, tween, index2, targets) {
          var p, pt;
          for (p in vars) {
            pt = this.add(target, "setAttribute", (target.getAttribute(p) || 0) + "", vars[p], index2, targets, 0, 0, p);
            pt && (pt.op = p);
            this._props.push(p);
          }
        }
      }, {
        name: "endArray",
        init: function init2(target, value) {
          var i = value.length;
          while (i--) {
            this.add(target, i, target[i] || 0, value[i]);
          }
        }
      }, _buildModifierPlugin("roundProps", _roundModifier), _buildModifierPlugin("modifiers"), _buildModifierPlugin("snap", snap)) || _gsap;
      Tween.version = Timeline.version = gsap2.version = "3.8.0";
      _coreReady = 1;
      _windowExists() && _wake();
      var Power0 = _easeMap.Power0, Power1 = _easeMap.Power1, Power2 = _easeMap.Power2, Power3 = _easeMap.Power3, Power4 = _easeMap.Power4, Linear = _easeMap.Linear, Quad = _easeMap.Quad, Cubic = _easeMap.Cubic, Quart = _easeMap.Quart, Quint = _easeMap.Quint, Strong = _easeMap.Strong, Elastic = _easeMap.Elastic, Back = _easeMap.Back, SteppedEase = _easeMap.SteppedEase, Bounce = _easeMap.Bounce, Sine = _easeMap.Sine, Expo = _easeMap.Expo, Circ = _easeMap.Circ;
      var _win$1, _doc$1, _docElement, _pluginInitted, _tempDiv, _tempDivStyler, _recentSetterPlugin, _windowExists$1 = function _windowExists2() {
        return typeof window !== "undefined";
      }, _transformProps = {}, _RAD2DEG = 180 / Math.PI, _DEG2RAD = Math.PI / 180, _atan2 = Math.atan2, _bigNum$1 = 1e8, _capsExp = /([A-Z])/g, _horizontalExp = /(?:left|right|width|margin|padding|x)/i, _complexExp = /[\s,\(]\S/, _propertyAliases = {
        autoAlpha: "opacity,visibility",
        scale: "scaleX,scaleY",
        alpha: "opacity"
      }, _renderCSSProp = function _renderCSSProp2(ratio, data) {
        return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 1e4) / 1e4 + data.u, data);
      }, _renderPropWithEnd = function _renderPropWithEnd2(ratio, data) {
        return data.set(data.t, data.p, ratio === 1 ? data.e : Math.round((data.s + data.c * ratio) * 1e4) / 1e4 + data.u, data);
      }, _renderCSSPropWithBeginning = function _renderCSSPropWithBeginning2(ratio, data) {
        return data.set(data.t, data.p, ratio ? Math.round((data.s + data.c * ratio) * 1e4) / 1e4 + data.u : data.b, data);
      }, _renderRoundedCSSProp = function _renderRoundedCSSProp2(ratio, data) {
        var value = data.s + data.c * ratio;
        data.set(data.t, data.p, ~~(value + (value < 0 ? -0.5 : 0.5)) + data.u, data);
      }, _renderNonTweeningValue = function _renderNonTweeningValue2(ratio, data) {
        return data.set(data.t, data.p, ratio ? data.e : data.b, data);
      }, _renderNonTweeningValueOnlyAtEnd = function _renderNonTweeningValueOnlyAtEnd2(ratio, data) {
        return data.set(data.t, data.p, ratio !== 1 ? data.b : data.e, data);
      }, _setterCSSStyle = function _setterCSSStyle2(target, property, value) {
        return target.style[property] = value;
      }, _setterCSSProp = function _setterCSSProp2(target, property, value) {
        return target.style.setProperty(property, value);
      }, _setterTransform = function _setterTransform2(target, property, value) {
        return target._gsap[property] = value;
      }, _setterScale = function _setterScale2(target, property, value) {
        return target._gsap.scaleX = target._gsap.scaleY = value;
      }, _setterScaleWithRender = function _setterScaleWithRender2(target, property, value, data, ratio) {
        var cache = target._gsap;
        cache.scaleX = cache.scaleY = value;
        cache.renderTransform(ratio, cache);
      }, _setterTransformWithRender = function _setterTransformWithRender2(target, property, value, data, ratio) {
        var cache = target._gsap;
        cache[property] = value;
        cache.renderTransform(ratio, cache);
      }, _transformProp = "transform", _transformOriginProp = _transformProp + "Origin", _supports3D, _createElement = function _createElement2(type, ns) {
        var e = _doc$1.createElementNS ? _doc$1.createElementNS((ns || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), type) : _doc$1.createElement(type);
        return e.style ? e : _doc$1.createElement(type);
      }, _getComputedProperty = function _getComputedProperty2(target, property, skipPrefixFallback) {
        var cs = getComputedStyle(target);
        return cs[property] || cs.getPropertyValue(property.replace(_capsExp, "-$1").toLowerCase()) || cs.getPropertyValue(property) || !skipPrefixFallback && _getComputedProperty2(target, _checkPropPrefix(property) || property, 1) || "";
      }, _prefixes = "O,Moz,ms,Ms,Webkit".split(","), _checkPropPrefix = function _checkPropPrefix2(property, element, preferPrefix) {
        var e = element || _tempDiv, s2 = e.style, i = 5;
        if (property in s2 && !preferPrefix) {
          return property;
        }
        property = property.charAt(0).toUpperCase() + property.substr(1);
        while (i-- && !(_prefixes[i] + property in s2)) {
        }
        return i < 0 ? null : (i === 3 ? "ms" : i >= 0 ? _prefixes[i] : "") + property;
      }, _initCore = function _initCore2() {
        if (_windowExists$1() && window.document) {
          _win$1 = window;
          _doc$1 = _win$1.document;
          _docElement = _doc$1.documentElement;
          _tempDiv = _createElement("div") || {
            style: {}
          };
          _tempDivStyler = _createElement("div");
          _transformProp = _checkPropPrefix(_transformProp);
          _transformOriginProp = _transformProp + "Origin";
          _tempDiv.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0";
          _supports3D = !!_checkPropPrefix("perspective");
          _pluginInitted = 1;
        }
      }, _getBBoxHack = function _getBBoxHack2(swapIfPossible) {
        var svg = _createElement("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), oldParent = this.parentNode, oldSibling = this.nextSibling, oldCSS = this.style.cssText, bbox;
        _docElement.appendChild(svg);
        svg.appendChild(this);
        this.style.display = "block";
        if (swapIfPossible) {
          try {
            bbox = this.getBBox();
            this._gsapBBox = this.getBBox;
            this.getBBox = _getBBoxHack2;
          } catch (e) {
          }
        } else if (this._gsapBBox) {
          bbox = this._gsapBBox();
        }
        if (oldParent) {
          if (oldSibling) {
            oldParent.insertBefore(this, oldSibling);
          } else {
            oldParent.appendChild(this);
          }
        }
        _docElement.removeChild(svg);
        this.style.cssText = oldCSS;
        return bbox;
      }, _getAttributeFallbacks = function _getAttributeFallbacks2(target, attributesArray) {
        var i = attributesArray.length;
        while (i--) {
          if (target.hasAttribute(attributesArray[i])) {
            return target.getAttribute(attributesArray[i]);
          }
        }
      }, _getBBox = function _getBBox2(target) {
        var bounds;
        try {
          bounds = target.getBBox();
        } catch (error2) {
          bounds = _getBBoxHack.call(target, true);
        }
        bounds && (bounds.width || bounds.height) || target.getBBox === _getBBoxHack || (bounds = _getBBoxHack.call(target, true));
        return bounds && !bounds.width && !bounds.x && !bounds.y ? {
          x: +_getAttributeFallbacks(target, ["x", "cx", "x1"]) || 0,
          y: +_getAttributeFallbacks(target, ["y", "cy", "y1"]) || 0,
          width: 0,
          height: 0
        } : bounds;
      }, _isSVG = function _isSVG2(e) {
        return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && _getBBox(e));
      }, _removeProperty = function _removeProperty2(target, property) {
        if (property) {
          var style = target.style;
          if (property in _transformProps && property !== _transformOriginProp) {
            property = _transformProp;
          }
          if (style.removeProperty) {
            if (property.substr(0, 2) === "ms" || property.substr(0, 6) === "webkit") {
              property = "-" + property;
            }
            style.removeProperty(property.replace(_capsExp, "-$1").toLowerCase());
          } else {
            style.removeAttribute(property);
          }
        }
      }, _addNonTweeningPT = function _addNonTweeningPT2(plugin, target, property, beginning, end, onlySetAtEnd) {
        var pt = new PropTween(plugin._pt, target, property, 0, 1, onlySetAtEnd ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue);
        plugin._pt = pt;
        pt.b = beginning;
        pt.e = end;
        plugin._props.push(property);
        return pt;
      }, _nonConvertibleUnits = {
        deg: 1,
        rad: 1,
        turn: 1
      }, _convertToUnit = function _convertToUnit2(target, property, value, unit2) {
        var curValue = parseFloat(value) || 0, curUnit = (value + "").trim().substr((curValue + "").length) || "px", style = _tempDiv.style, horizontal = _horizontalExp.test(property), isRootSVG = target.tagName.toLowerCase() === "svg", measureProperty = (isRootSVG ? "client" : "offset") + (horizontal ? "Width" : "Height"), amount = 100, toPixels = unit2 === "px", toPercent = unit2 === "%", px, parent, cache, isSVG;
        if (unit2 === curUnit || !curValue || _nonConvertibleUnits[unit2] || _nonConvertibleUnits[curUnit]) {
          return curValue;
        }
        curUnit !== "px" && !toPixels && (curValue = _convertToUnit2(target, property, value, "px"));
        isSVG = target.getCTM && _isSVG(target);
        if ((toPercent || curUnit === "%") && (_transformProps[property] || ~property.indexOf("adius"))) {
          px = isSVG ? target.getBBox()[horizontal ? "width" : "height"] : target[measureProperty];
          return _round(toPercent ? curValue / px * amount : curValue / 100 * px);
        }
        style[horizontal ? "width" : "height"] = amount + (toPixels ? curUnit : unit2);
        parent = ~property.indexOf("adius") || unit2 === "em" && target.appendChild && !isRootSVG ? target : target.parentNode;
        if (isSVG) {
          parent = (target.ownerSVGElement || {}).parentNode;
        }
        if (!parent || parent === _doc$1 || !parent.appendChild) {
          parent = _doc$1.body;
        }
        cache = parent._gsap;
        if (cache && toPercent && cache.width && horizontal && cache.time === _ticker.time) {
          return _round(curValue / cache.width * amount);
        } else {
          (toPercent || curUnit === "%") && (style.position = _getComputedProperty(target, "position"));
          parent === target && (style.position = "static");
          parent.appendChild(_tempDiv);
          px = _tempDiv[measureProperty];
          parent.removeChild(_tempDiv);
          style.position = "absolute";
          if (horizontal && toPercent) {
            cache = _getCache(parent);
            cache.time = _ticker.time;
            cache.width = parent[measureProperty];
          }
        }
        return _round(toPixels ? px * curValue / amount : px && curValue ? amount / px * curValue : 0);
      }, _get = function _get2(target, property, unit2, uncache) {
        var value;
        _pluginInitted || _initCore();
        if (property in _propertyAliases && property !== "transform") {
          property = _propertyAliases[property];
          if (~property.indexOf(",")) {
            property = property.split(",")[0];
          }
        }
        if (_transformProps[property] && property !== "transform") {
          value = _parseTransform(target, uncache);
          value = property !== "transformOrigin" ? value[property] : value.svg ? value.origin : _firstTwoOnly(_getComputedProperty(target, _transformOriginProp)) + " " + value.zOrigin + "px";
        } else {
          value = target.style[property];
          if (!value || value === "auto" || uncache || ~(value + "").indexOf("calc(")) {
            value = _specialProps[property] && _specialProps[property](target, property, unit2) || _getComputedProperty(target, property) || _getProperty(target, property) || (property === "opacity" ? 1 : 0);
          }
        }
        return unit2 && !~(value + "").trim().indexOf(" ") ? _convertToUnit(target, property, value, unit2) + unit2 : value;
      }, _tweenComplexCSSString = function _tweenComplexCSSString2(target, prop, start, end) {
        if (!start || start === "none") {
          var p = _checkPropPrefix(prop, target, 1), s2 = p && _getComputedProperty(target, p, 1);
          if (s2 && s2 !== start) {
            prop = p;
            start = s2;
          } else if (prop === "borderColor") {
            start = _getComputedProperty(target, "borderTopColor");
          }
        }
        var pt = new PropTween(this._pt, target.style, prop, 0, 1, _renderComplexString), index2 = 0, matchIndex = 0, a, result, startValues, startNum, color2, startValue, endValue, endNum, chunk, endUnit, startUnit, relative, endValues;
        pt.b = start;
        pt.e = end;
        start += "";
        end += "";
        if (end === "auto") {
          target.style[prop] = end;
          end = _getComputedProperty(target, prop) || end;
          target.style[prop] = start;
        }
        a = [start, end];
        _colorStringFilter(a);
        start = a[0];
        end = a[1];
        startValues = start.match(_numWithUnitExp) || [];
        endValues = end.match(_numWithUnitExp) || [];
        if (endValues.length) {
          while (result = _numWithUnitExp.exec(end)) {
            endValue = result[0];
            chunk = end.substring(index2, result.index);
            if (color2) {
              color2 = (color2 + 1) % 5;
            } else if (chunk.substr(-5) === "rgba(" || chunk.substr(-5) === "hsla(") {
              color2 = 1;
            }
            if (endValue !== (startValue = startValues[matchIndex++] || "")) {
              startNum = parseFloat(startValue) || 0;
              startUnit = startValue.substr((startNum + "").length);
              relative = endValue.charAt(1) === "=" ? +(endValue.charAt(0) + "1") : 0;
              if (relative) {
                endValue = endValue.substr(2);
              }
              endNum = parseFloat(endValue);
              endUnit = endValue.substr((endNum + "").length);
              index2 = _numWithUnitExp.lastIndex - endUnit.length;
              if (!endUnit) {
                endUnit = endUnit || _config.units[prop] || startUnit;
                if (index2 === end.length) {
                  end += endUnit;
                  pt.e += endUnit;
                }
              }
              if (startUnit !== endUnit) {
                startNum = _convertToUnit(target, prop, startValue, endUnit) || 0;
              }
              pt._pt = {
                _next: pt._pt,
                p: chunk || matchIndex === 1 ? chunk : ",",
                s: startNum,
                c: relative ? relative * endNum : endNum - startNum,
                m: color2 && color2 < 4 || prop === "zIndex" ? Math.round : 0
              };
            }
          }
          pt.c = index2 < end.length ? end.substring(index2, end.length) : "";
        } else {
          pt.r = prop === "display" && end === "none" ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue;
        }
        _relExp.test(end) && (pt.e = 0);
        this._pt = pt;
        return pt;
      }, _keywordToPercent = {
        top: "0%",
        bottom: "100%",
        left: "0%",
        right: "100%",
        center: "50%"
      }, _convertKeywordsToPercentages = function _convertKeywordsToPercentages2(value) {
        var split = value.split(" "), x = split[0], y = split[1] || "50%";
        if (x === "top" || x === "bottom" || y === "left" || y === "right") {
          value = x;
          x = y;
          y = value;
        }
        split[0] = _keywordToPercent[x] || x;
        split[1] = _keywordToPercent[y] || y;
        return split.join(" ");
      }, _renderClearProps = function _renderClearProps2(ratio, data) {
        if (data.tween && data.tween._time === data.tween._dur) {
          var target = data.t, style = target.style, props = data.u, cache = target._gsap, prop, clearTransforms, i;
          if (props === "all" || props === true) {
            style.cssText = "";
            clearTransforms = 1;
          } else {
            props = props.split(",");
            i = props.length;
            while (--i > -1) {
              prop = props[i];
              if (_transformProps[prop]) {
                clearTransforms = 1;
                prop = prop === "transformOrigin" ? _transformOriginProp : _transformProp;
              }
              _removeProperty(target, prop);
            }
          }
          if (clearTransforms) {
            _removeProperty(target, _transformProp);
            if (cache) {
              cache.svg && target.removeAttribute("transform");
              _parseTransform(target, 1);
              cache.uncache = 1;
            }
          }
        }
      }, _specialProps = {
        clearProps: function clearProps(plugin, target, property, endValue, tween) {
          if (tween.data !== "isFromStart") {
            var pt = plugin._pt = new PropTween(plugin._pt, target, property, 0, 0, _renderClearProps);
            pt.u = endValue;
            pt.pr = -10;
            pt.tween = tween;
            plugin._props.push(property);
            return 1;
          }
        }
      }, _identity2DMatrix = [1, 0, 0, 1, 0, 0], _rotationalProperties = {}, _isNullTransform = function _isNullTransform2(value) {
        return value === "matrix(1, 0, 0, 1, 0, 0)" || value === "none" || !value;
      }, _getComputedTransformMatrixAsArray = function _getComputedTransformMatrixAsArray2(target) {
        var matrixString = _getComputedProperty(target, _transformProp);
        return _isNullTransform(matrixString) ? _identity2DMatrix : matrixString.substr(7).match(_numExp).map(_round);
      }, _getMatrix = function _getMatrix2(target, force2D) {
        var cache = target._gsap || _getCache(target), style = target.style, matrix = _getComputedTransformMatrixAsArray(target), parent, nextSibling, temp, addedToDOM;
        if (cache.svg && target.getAttribute("transform")) {
          temp = target.transform.baseVal.consolidate().matrix;
          matrix = [temp.a, temp.b, temp.c, temp.d, temp.e, temp.f];
          return matrix.join(",") === "1,0,0,1,0,0" ? _identity2DMatrix : matrix;
        } else if (matrix === _identity2DMatrix && !target.offsetParent && target !== _docElement && !cache.svg) {
          temp = style.display;
          style.display = "block";
          parent = target.parentNode;
          if (!parent || !target.offsetParent) {
            addedToDOM = 1;
            nextSibling = target.nextSibling;
            _docElement.appendChild(target);
          }
          matrix = _getComputedTransformMatrixAsArray(target);
          temp ? style.display = temp : _removeProperty(target, "display");
          if (addedToDOM) {
            nextSibling ? parent.insertBefore(target, nextSibling) : parent ? parent.appendChild(target) : _docElement.removeChild(target);
          }
        }
        return force2D && matrix.length > 6 ? [matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13]] : matrix;
      }, _applySVGOrigin = function _applySVGOrigin2(target, origin, originIsAbsolute, smooth, matrixArray, pluginToAddPropTweensTo) {
        var cache = target._gsap, matrix = matrixArray || _getMatrix(target, true), xOriginOld = cache.xOrigin || 0, yOriginOld = cache.yOrigin || 0, xOffsetOld = cache.xOffset || 0, yOffsetOld = cache.yOffset || 0, a = matrix[0], b = matrix[1], c = matrix[2], d = matrix[3], tx = matrix[4], ty = matrix[5], originSplit = origin.split(" "), xOrigin = parseFloat(originSplit[0]) || 0, yOrigin = parseFloat(originSplit[1]) || 0, bounds, determinant, x, y;
        if (!originIsAbsolute) {
          bounds = _getBBox(target);
          xOrigin = bounds.x + (~originSplit[0].indexOf("%") ? xOrigin / 100 * bounds.width : xOrigin);
          yOrigin = bounds.y + (~(originSplit[1] || originSplit[0]).indexOf("%") ? yOrigin / 100 * bounds.height : yOrigin);
        } else if (matrix !== _identity2DMatrix && (determinant = a * d - b * c)) {
          x = xOrigin * (d / determinant) + yOrigin * (-c / determinant) + (c * ty - d * tx) / determinant;
          y = xOrigin * (-b / determinant) + yOrigin * (a / determinant) - (a * ty - b * tx) / determinant;
          xOrigin = x;
          yOrigin = y;
        }
        if (smooth || smooth !== false && cache.smooth) {
          tx = xOrigin - xOriginOld;
          ty = yOrigin - yOriginOld;
          cache.xOffset = xOffsetOld + (tx * a + ty * c) - tx;
          cache.yOffset = yOffsetOld + (tx * b + ty * d) - ty;
        } else {
          cache.xOffset = cache.yOffset = 0;
        }
        cache.xOrigin = xOrigin;
        cache.yOrigin = yOrigin;
        cache.smooth = !!smooth;
        cache.origin = origin;
        cache.originIsAbsolute = !!originIsAbsolute;
        target.style[_transformOriginProp] = "0px 0px";
        if (pluginToAddPropTweensTo) {
          _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOrigin", xOriginOld, xOrigin);
          _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOrigin", yOriginOld, yOrigin);
          _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOffset", xOffsetOld, cache.xOffset);
          _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOffset", yOffsetOld, cache.yOffset);
        }
        target.setAttribute("data-svg-origin", xOrigin + " " + yOrigin);
      }, _parseTransform = function _parseTransform2(target, uncache) {
        var cache = target._gsap || new GSCache(target);
        if ("x" in cache && !uncache && !cache.uncache) {
          return cache;
        }
        var style = target.style, invertedScaleX = cache.scaleX < 0, px = "px", deg = "deg", origin = _getComputedProperty(target, _transformOriginProp) || "0", x, y, z, scaleX, scaleY, rotation, rotationX, rotationY, skewX, skewY, perspective, xOrigin, yOrigin, matrix, angle, cos, sin, a, b, c, d, a12, a22, t1, t2, t3, a13, a23, a33, a42, a43, a32;
        x = y = z = rotation = rotationX = rotationY = skewX = skewY = perspective = 0;
        scaleX = scaleY = 1;
        cache.svg = !!(target.getCTM && _isSVG(target));
        matrix = _getMatrix(target, cache.svg);
        if (cache.svg) {
          t1 = (!cache.uncache || origin === "0px 0px") && !uncache && target.getAttribute("data-svg-origin");
          _applySVGOrigin(target, t1 || origin, !!t1 || cache.originIsAbsolute, cache.smooth !== false, matrix);
        }
        xOrigin = cache.xOrigin || 0;
        yOrigin = cache.yOrigin || 0;
        if (matrix !== _identity2DMatrix) {
          a = matrix[0];
          b = matrix[1];
          c = matrix[2];
          d = matrix[3];
          x = a12 = matrix[4];
          y = a22 = matrix[5];
          if (matrix.length === 6) {
            scaleX = Math.sqrt(a * a + b * b);
            scaleY = Math.sqrt(d * d + c * c);
            rotation = a || b ? _atan2(b, a) * _RAD2DEG : 0;
            skewX = c || d ? _atan2(c, d) * _RAD2DEG + rotation : 0;
            skewX && (scaleY *= Math.abs(Math.cos(skewX * _DEG2RAD)));
            if (cache.svg) {
              x -= xOrigin - (xOrigin * a + yOrigin * c);
              y -= yOrigin - (xOrigin * b + yOrigin * d);
            }
          } else {
            a32 = matrix[6];
            a42 = matrix[7];
            a13 = matrix[8];
            a23 = matrix[9];
            a33 = matrix[10];
            a43 = matrix[11];
            x = matrix[12];
            y = matrix[13];
            z = matrix[14];
            angle = _atan2(a32, a33);
            rotationX = angle * _RAD2DEG;
            if (angle) {
              cos = Math.cos(-angle);
              sin = Math.sin(-angle);
              t1 = a12 * cos + a13 * sin;
              t2 = a22 * cos + a23 * sin;
              t3 = a32 * cos + a33 * sin;
              a13 = a12 * -sin + a13 * cos;
              a23 = a22 * -sin + a23 * cos;
              a33 = a32 * -sin + a33 * cos;
              a43 = a42 * -sin + a43 * cos;
              a12 = t1;
              a22 = t2;
              a32 = t3;
            }
            angle = _atan2(-c, a33);
            rotationY = angle * _RAD2DEG;
            if (angle) {
              cos = Math.cos(-angle);
              sin = Math.sin(-angle);
              t1 = a * cos - a13 * sin;
              t2 = b * cos - a23 * sin;
              t3 = c * cos - a33 * sin;
              a43 = d * sin + a43 * cos;
              a = t1;
              b = t2;
              c = t3;
            }
            angle = _atan2(b, a);
            rotation = angle * _RAD2DEG;
            if (angle) {
              cos = Math.cos(angle);
              sin = Math.sin(angle);
              t1 = a * cos + b * sin;
              t2 = a12 * cos + a22 * sin;
              b = b * cos - a * sin;
              a22 = a22 * cos - a12 * sin;
              a = t1;
              a12 = t2;
            }
            if (rotationX && Math.abs(rotationX) + Math.abs(rotation) > 359.9) {
              rotationX = rotation = 0;
              rotationY = 180 - rotationY;
            }
            scaleX = _round(Math.sqrt(a * a + b * b + c * c));
            scaleY = _round(Math.sqrt(a22 * a22 + a32 * a32));
            angle = _atan2(a12, a22);
            skewX = Math.abs(angle) > 2e-4 ? angle * _RAD2DEG : 0;
            perspective = a43 ? 1 / (a43 < 0 ? -a43 : a43) : 0;
          }
          if (cache.svg) {
            t1 = target.getAttribute("transform");
            cache.forceCSS = target.setAttribute("transform", "") || !_isNullTransform(_getComputedProperty(target, _transformProp));
            t1 && target.setAttribute("transform", t1);
          }
        }
        if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {
          if (invertedScaleX) {
            scaleX *= -1;
            skewX += rotation <= 0 ? 180 : -180;
            rotation += rotation <= 0 ? 180 : -180;
          } else {
            scaleY *= -1;
            skewX += skewX <= 0 ? 180 : -180;
          }
        }
        cache.x = x - ((cache.xPercent = x && (cache.xPercent || (Math.round(target.offsetWidth / 2) === Math.round(-x) ? -50 : 0))) ? target.offsetWidth * cache.xPercent / 100 : 0) + px;
        cache.y = y - ((cache.yPercent = y && (cache.yPercent || (Math.round(target.offsetHeight / 2) === Math.round(-y) ? -50 : 0))) ? target.offsetHeight * cache.yPercent / 100 : 0) + px;
        cache.z = z + px;
        cache.scaleX = _round(scaleX);
        cache.scaleY = _round(scaleY);
        cache.rotation = _round(rotation) + deg;
        cache.rotationX = _round(rotationX) + deg;
        cache.rotationY = _round(rotationY) + deg;
        cache.skewX = skewX + deg;
        cache.skewY = skewY + deg;
        cache.transformPerspective = perspective + px;
        if (cache.zOrigin = parseFloat(origin.split(" ")[2]) || 0) {
          style[_transformOriginProp] = _firstTwoOnly(origin);
        }
        cache.xOffset = cache.yOffset = 0;
        cache.force3D = _config.force3D;
        cache.renderTransform = cache.svg ? _renderSVGTransforms : _supports3D ? _renderCSSTransforms : _renderNon3DTransforms;
        cache.uncache = 0;
        return cache;
      }, _firstTwoOnly = function _firstTwoOnly2(value) {
        return (value = value.split(" "))[0] + " " + value[1];
      }, _addPxTranslate = function _addPxTranslate2(target, start, value) {
        var unit2 = getUnit(start);
        return _round(parseFloat(start) + parseFloat(_convertToUnit(target, "x", value + "px", unit2))) + unit2;
      }, _renderNon3DTransforms = function _renderNon3DTransforms2(ratio, cache) {
        cache.z = "0px";
        cache.rotationY = cache.rotationX = "0deg";
        cache.force3D = 0;
        _renderCSSTransforms(ratio, cache);
      }, _zeroDeg = "0deg", _zeroPx = "0px", _endParenthesis = ") ", _renderCSSTransforms = function _renderCSSTransforms2(ratio, cache) {
        var _ref = cache || this, xPercent = _ref.xPercent, yPercent = _ref.yPercent, x = _ref.x, y = _ref.y, z = _ref.z, rotation = _ref.rotation, rotationY = _ref.rotationY, rotationX = _ref.rotationX, skewX = _ref.skewX, skewY = _ref.skewY, scaleX = _ref.scaleX, scaleY = _ref.scaleY, transformPerspective = _ref.transformPerspective, force3D = _ref.force3D, target = _ref.target, zOrigin = _ref.zOrigin, transforms = "", use3D = force3D === "auto" && ratio && ratio !== 1 || force3D === true;
        if (zOrigin && (rotationX !== _zeroDeg || rotationY !== _zeroDeg)) {
          var angle = parseFloat(rotationY) * _DEG2RAD, a13 = Math.sin(angle), a33 = Math.cos(angle), cos;
          angle = parseFloat(rotationX) * _DEG2RAD;
          cos = Math.cos(angle);
          x = _addPxTranslate(target, x, a13 * cos * -zOrigin);
          y = _addPxTranslate(target, y, -Math.sin(angle) * -zOrigin);
          z = _addPxTranslate(target, z, a33 * cos * -zOrigin + zOrigin);
        }
        if (transformPerspective !== _zeroPx) {
          transforms += "perspective(" + transformPerspective + _endParenthesis;
        }
        if (xPercent || yPercent) {
          transforms += "translate(" + xPercent + "%, " + yPercent + "%) ";
        }
        if (use3D || x !== _zeroPx || y !== _zeroPx || z !== _zeroPx) {
          transforms += z !== _zeroPx || use3D ? "translate3d(" + x + ", " + y + ", " + z + ") " : "translate(" + x + ", " + y + _endParenthesis;
        }
        if (rotation !== _zeroDeg) {
          transforms += "rotate(" + rotation + _endParenthesis;
        }
        if (rotationY !== _zeroDeg) {
          transforms += "rotateY(" + rotationY + _endParenthesis;
        }
        if (rotationX !== _zeroDeg) {
          transforms += "rotateX(" + rotationX + _endParenthesis;
        }
        if (skewX !== _zeroDeg || skewY !== _zeroDeg) {
          transforms += "skew(" + skewX + ", " + skewY + _endParenthesis;
        }
        if (scaleX !== 1 || scaleY !== 1) {
          transforms += "scale(" + scaleX + ", " + scaleY + _endParenthesis;
        }
        target.style[_transformProp] = transforms || "translate(0, 0)";
      }, _renderSVGTransforms = function _renderSVGTransforms2(ratio, cache) {
        var _ref2 = cache || this, xPercent = _ref2.xPercent, yPercent = _ref2.yPercent, x = _ref2.x, y = _ref2.y, rotation = _ref2.rotation, skewX = _ref2.skewX, skewY = _ref2.skewY, scaleX = _ref2.scaleX, scaleY = _ref2.scaleY, target = _ref2.target, xOrigin = _ref2.xOrigin, yOrigin = _ref2.yOrigin, xOffset = _ref2.xOffset, yOffset = _ref2.yOffset, forceCSS = _ref2.forceCSS, tx = parseFloat(x), ty = parseFloat(y), a11, a21, a12, a22, temp;
        rotation = parseFloat(rotation);
        skewX = parseFloat(skewX);
        skewY = parseFloat(skewY);
        if (skewY) {
          skewY = parseFloat(skewY);
          skewX += skewY;
          rotation += skewY;
        }
        if (rotation || skewX) {
          rotation *= _DEG2RAD;
          skewX *= _DEG2RAD;
          a11 = Math.cos(rotation) * scaleX;
          a21 = Math.sin(rotation) * scaleX;
          a12 = Math.sin(rotation - skewX) * -scaleY;
          a22 = Math.cos(rotation - skewX) * scaleY;
          if (skewX) {
            skewY *= _DEG2RAD;
            temp = Math.tan(skewX - skewY);
            temp = Math.sqrt(1 + temp * temp);
            a12 *= temp;
            a22 *= temp;
            if (skewY) {
              temp = Math.tan(skewY);
              temp = Math.sqrt(1 + temp * temp);
              a11 *= temp;
              a21 *= temp;
            }
          }
          a11 = _round(a11);
          a21 = _round(a21);
          a12 = _round(a12);
          a22 = _round(a22);
        } else {
          a11 = scaleX;
          a22 = scaleY;
          a21 = a12 = 0;
        }
        if (tx && !~(x + "").indexOf("px") || ty && !~(y + "").indexOf("px")) {
          tx = _convertToUnit(target, "x", x, "px");
          ty = _convertToUnit(target, "y", y, "px");
        }
        if (xOrigin || yOrigin || xOffset || yOffset) {
          tx = _round(tx + xOrigin - (xOrigin * a11 + yOrigin * a12) + xOffset);
          ty = _round(ty + yOrigin - (xOrigin * a21 + yOrigin * a22) + yOffset);
        }
        if (xPercent || yPercent) {
          temp = target.getBBox();
          tx = _round(tx + xPercent / 100 * temp.width);
          ty = _round(ty + yPercent / 100 * temp.height);
        }
        temp = "matrix(" + a11 + "," + a21 + "," + a12 + "," + a22 + "," + tx + "," + ty + ")";
        target.setAttribute("transform", temp);
        forceCSS && (target.style[_transformProp] = temp);
      }, _addRotationalPropTween = function _addRotationalPropTween2(plugin, target, property, startNum, endValue, relative) {
        var cap = 360, isString = _isString(endValue), endNum = parseFloat(endValue) * (isString && ~endValue.indexOf("rad") ? _RAD2DEG : 1), change = relative ? endNum * relative : endNum - startNum, finalValue = startNum + change + "deg", direction, pt;
        if (isString) {
          direction = endValue.split("_")[1];
          if (direction === "short") {
            change %= cap;
            if (change !== change % (cap / 2)) {
              change += change < 0 ? cap : -cap;
            }
          }
          if (direction === "cw" && change < 0) {
            change = (change + cap * _bigNum$1) % cap - ~~(change / cap) * cap;
          } else if (direction === "ccw" && change > 0) {
            change = (change - cap * _bigNum$1) % cap - ~~(change / cap) * cap;
          }
        }
        plugin._pt = pt = new PropTween(plugin._pt, target, property, startNum, change, _renderPropWithEnd);
        pt.e = finalValue;
        pt.u = "deg";
        plugin._props.push(property);
        return pt;
      }, _assign = function _assign2(target, source) {
        for (var p in source) {
          target[p] = source[p];
        }
        return target;
      }, _addRawTransformPTs = function _addRawTransformPTs2(plugin, transforms, target) {
        var startCache = _assign({}, target._gsap), exclude = "perspective,force3D,transformOrigin,svgOrigin", style = target.style, endCache, p, startValue, endValue, startNum, endNum, startUnit, endUnit;
        if (startCache.svg) {
          startValue = target.getAttribute("transform");
          target.setAttribute("transform", "");
          style[_transformProp] = transforms;
          endCache = _parseTransform(target, 1);
          _removeProperty(target, _transformProp);
          target.setAttribute("transform", startValue);
        } else {
          startValue = getComputedStyle(target)[_transformProp];
          style[_transformProp] = transforms;
          endCache = _parseTransform(target, 1);
          style[_transformProp] = startValue;
        }
        for (p in _transformProps) {
          startValue = startCache[p];
          endValue = endCache[p];
          if (startValue !== endValue && exclude.indexOf(p) < 0) {
            startUnit = getUnit(startValue);
            endUnit = getUnit(endValue);
            startNum = startUnit !== endUnit ? _convertToUnit(target, p, startValue, endUnit) : parseFloat(startValue);
            endNum = parseFloat(endValue);
            plugin._pt = new PropTween(plugin._pt, endCache, p, startNum, endNum - startNum, _renderCSSProp);
            plugin._pt.u = endUnit || 0;
            plugin._props.push(p);
          }
        }
        _assign(endCache, startCache);
      };
      _forEachName("padding,margin,Width,Radius", function(name, index2) {
        var t = "Top", r = "Right", b = "Bottom", l = "Left", props = (index2 < 3 ? [t, r, b, l] : [t + l, t + r, b + r, b + l]).map(function(side) {
          return index2 < 2 ? name + side : "border" + side + name;
        });
        _specialProps[index2 > 1 ? "border" + name : name] = function(plugin, target, property, endValue, tween) {
          var a, vars;
          if (arguments.length < 4) {
            a = props.map(function(prop) {
              return _get(plugin, prop, property);
            });
            vars = a.join(" ");
            return vars.split(a[0]).length === 5 ? a[0] : vars;
          }
          a = (endValue + "").split(" ");
          vars = {};
          props.forEach(function(prop, i) {
            return vars[prop] = a[i] = a[i] || a[(i - 1) / 2 | 0];
          });
          plugin.init(target, vars, tween);
        };
      });
      var CSSPlugin = {
        name: "css",
        register: _initCore,
        targetTest: function targetTest(target) {
          return target.style && target.nodeType;
        },
        init: function init2(target, vars, tween, index2, targets) {
          var props = this._props, style = target.style, startAt = tween.vars.startAt, startValue, endValue, endNum, startNum, type, specialProp, p, startUnit, endUnit, relative, isTransformRelated, transformPropTween, cache, smooth, hasPriority;
          _pluginInitted || _initCore();
          for (p in vars) {
            if (p === "autoRound") {
              continue;
            }
            endValue = vars[p];
            if (_plugins[p] && _checkPlugin(p, vars, tween, index2, target, targets)) {
              continue;
            }
            type = typeof endValue;
            specialProp = _specialProps[p];
            if (type === "function") {
              endValue = endValue.call(tween, index2, target, targets);
              type = typeof endValue;
            }
            if (type === "string" && ~endValue.indexOf("random(")) {
              endValue = _replaceRandom(endValue);
            }
            if (specialProp) {
              specialProp(this, target, p, endValue, tween) && (hasPriority = 1);
            } else if (p.substr(0, 2) === "--") {
              startValue = (getComputedStyle(target).getPropertyValue(p) + "").trim();
              endValue += "";
              _colorExp.lastIndex = 0;
              if (!_colorExp.test(startValue)) {
                startUnit = getUnit(startValue);
                endUnit = getUnit(endValue);
              }
              endUnit ? startUnit !== endUnit && (startValue = _convertToUnit(target, p, startValue, endUnit) + endUnit) : startUnit && (endValue += startUnit);
              this.add(style, "setProperty", startValue, endValue, index2, targets, 0, 0, p);
              props.push(p);
            } else if (type !== "undefined") {
              if (startAt && p in startAt) {
                startValue = typeof startAt[p] === "function" ? startAt[p].call(tween, index2, target, targets) : startAt[p];
                p in _config.units && !getUnit(startValue) && (startValue += _config.units[p]);
                _isString(startValue) && ~startValue.indexOf("random(") && (startValue = _replaceRandom(startValue));
                (startValue + "").charAt(1) === "=" && (startValue = _get(target, p));
              } else {
                startValue = _get(target, p);
              }
              startNum = parseFloat(startValue);
              relative = type === "string" && endValue.charAt(1) === "=" ? +(endValue.charAt(0) + "1") : 0;
              relative && (endValue = endValue.substr(2));
              endNum = parseFloat(endValue);
              if (p in _propertyAliases) {
                if (p === "autoAlpha") {
                  if (startNum === 1 && _get(target, "visibility") === "hidden" && endNum) {
                    startNum = 0;
                  }
                  _addNonTweeningPT(this, style, "visibility", startNum ? "inherit" : "hidden", endNum ? "inherit" : "hidden", !endNum);
                }
                if (p !== "scale" && p !== "transform") {
                  p = _propertyAliases[p];
                  ~p.indexOf(",") && (p = p.split(",")[0]);
                }
              }
              isTransformRelated = p in _transformProps;
              if (isTransformRelated) {
                if (!transformPropTween) {
                  cache = target._gsap;
                  cache.renderTransform && !vars.parseTransform || _parseTransform(target, vars.parseTransform);
                  smooth = vars.smoothOrigin !== false && cache.smooth;
                  transformPropTween = this._pt = new PropTween(this._pt, style, _transformProp, 0, 1, cache.renderTransform, cache, 0, -1);
                  transformPropTween.dep = 1;
                }
                if (p === "scale") {
                  this._pt = new PropTween(this._pt, cache, "scaleY", cache.scaleY, (relative ? relative * endNum : endNum - cache.scaleY) || 0);
                  props.push("scaleY", p);
                  p += "X";
                } else if (p === "transformOrigin") {
                  endValue = _convertKeywordsToPercentages(endValue);
                  if (cache.svg) {
                    _applySVGOrigin(target, endValue, 0, smooth, 0, this);
                  } else {
                    endUnit = parseFloat(endValue.split(" ")[2]) || 0;
                    endUnit !== cache.zOrigin && _addNonTweeningPT(this, cache, "zOrigin", cache.zOrigin, endUnit);
                    _addNonTweeningPT(this, style, p, _firstTwoOnly(startValue), _firstTwoOnly(endValue));
                  }
                  continue;
                } else if (p === "svgOrigin") {
                  _applySVGOrigin(target, endValue, 1, smooth, 0, this);
                  continue;
                } else if (p in _rotationalProperties) {
                  _addRotationalPropTween(this, cache, p, startNum, endValue, relative);
                  continue;
                } else if (p === "smoothOrigin") {
                  _addNonTweeningPT(this, cache, "smooth", cache.smooth, endValue);
                  continue;
                } else if (p === "force3D") {
                  cache[p] = endValue;
                  continue;
                } else if (p === "transform") {
                  _addRawTransformPTs(this, endValue, target);
                  continue;
                }
              } else if (!(p in style)) {
                p = _checkPropPrefix(p) || p;
              }
              if (isTransformRelated || (endNum || endNum === 0) && (startNum || startNum === 0) && !_complexExp.test(endValue) && p in style) {
                startUnit = (startValue + "").substr((startNum + "").length);
                endNum || (endNum = 0);
                endUnit = getUnit(endValue) || (p in _config.units ? _config.units[p] : startUnit);
                startUnit !== endUnit && (startNum = _convertToUnit(target, p, startValue, endUnit));
                this._pt = new PropTween(this._pt, isTransformRelated ? cache : style, p, startNum, relative ? relative * endNum : endNum - startNum, !isTransformRelated && (endUnit === "px" || p === "zIndex") && vars.autoRound !== false ? _renderRoundedCSSProp : _renderCSSProp);
                this._pt.u = endUnit || 0;
                if (startUnit !== endUnit && endUnit !== "%") {
                  this._pt.b = startValue;
                  this._pt.r = _renderCSSPropWithBeginning;
                }
              } else if (!(p in style)) {
                if (p in target) {
                  this.add(target, p, startValue || target[p], endValue, index2, targets);
                } else {
                  _missingPlugin(p, endValue);
                  continue;
                }
              } else {
                _tweenComplexCSSString.call(this, target, p, startValue, endValue);
              }
              props.push(p);
            }
          }
          hasPriority && _sortPropTweensByPriority(this);
        },
        get: _get,
        aliases: _propertyAliases,
        getSetter: function getSetter(target, property, plugin) {
          var p = _propertyAliases[property];
          p && p.indexOf(",") < 0 && (property = p);
          return property in _transformProps && property !== _transformOriginProp && (target._gsap.x || _get(target, "x")) ? plugin && _recentSetterPlugin === plugin ? property === "scale" ? _setterScale : _setterTransform : (_recentSetterPlugin = plugin || {}) && (property === "scale" ? _setterScaleWithRender : _setterTransformWithRender) : target.style && !_isUndefined(target.style[property]) ? _setterCSSStyle : ~property.indexOf("-") ? _setterCSSProp : _getSetter(target, property);
        },
        core: {
          _removeProperty,
          _getMatrix
        }
      };
      gsap2.utils.checkPrefix = _checkPropPrefix;
      (function(positionAndScale, rotation, others, aliases) {
        var all = _forEachName(positionAndScale + "," + rotation + "," + others, function(name) {
          _transformProps[name] = 1;
        });
        _forEachName(rotation, function(name) {
          _config.units[name] = "deg";
          _rotationalProperties[name] = 1;
        });
        _propertyAliases[all[13]] = positionAndScale + "," + rotation;
        _forEachName(aliases, function(name) {
          var split = name.split(":");
          _propertyAliases[split[1]] = all[split[0]];
        });
      })("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");
      _forEachName("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function(name) {
        _config.units[name] = "px";
      });
      gsap2.registerPlugin(CSSPlugin);
      var gsapWithCSS = gsap2.registerPlugin(CSSPlugin) || gsap2, TweenMaxWithCSS = gsapWithCSS.core.Tween;
      exports2.Back = Back;
      exports2.Bounce = Bounce;
      exports2.CSSPlugin = CSSPlugin;
      exports2.Circ = Circ;
      exports2.Cubic = Cubic;
      exports2.Elastic = Elastic;
      exports2.Expo = Expo;
      exports2.Linear = Linear;
      exports2.Power0 = Power0;
      exports2.Power1 = Power1;
      exports2.Power2 = Power2;
      exports2.Power3 = Power3;
      exports2.Power4 = Power4;
      exports2.Quad = Quad;
      exports2.Quart = Quart;
      exports2.Quint = Quint;
      exports2.Sine = Sine;
      exports2.SteppedEase = SteppedEase;
      exports2.Strong = Strong;
      exports2.TimelineLite = Timeline;
      exports2.TimelineMax = Timeline;
      exports2.TweenLite = Tween;
      exports2.TweenMax = TweenMaxWithCSS;
      exports2.default = gsapWithCSS;
      exports2.gsap = gsapWithCSS;
      if (typeof window === "undefined" || window !== exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
      } else {
        delete window.default;
      }
    });
  }
});

// node_modules/gsap/dist/MorphSVGPlugin.js
var require_MorphSVGPlugin = __commonJS({
  "node_modules/gsap/dist/MorphSVGPlugin.js"(exports, module2) {
    init_shims();
    (function(global2, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = global2 || self, factory(global2.window = global2.window || {}));
    })(exports, function(exports2) {
      "use strict";
      var _svgPathExp = /[achlmqstvz]|(-?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/ig, _numbersExp = /(?:(-)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/ig, _scientific = /[\+\-]?\d*\.?\d+e[\+\-]?\d+/ig, _selectorExp = /(^[#\.][a-z]|[a-y][a-z])/i, _DEG2RAD = Math.PI / 180, _sin = Math.sin, _cos = Math.cos, _abs = Math.abs, _sqrt = Math.sqrt, _isString = function _isString2(value) {
        return typeof value === "string";
      }, _isNumber = function _isNumber2(value) {
        return typeof value === "number";
      }, _roundingNum = 1e5, _round = function _round2(value) {
        return Math.round(value * _roundingNum) / _roundingNum || 0;
      };
      function getRawPath(value) {
        value = _isString(value) && _selectorExp.test(value) ? document.querySelector(value) || value : value;
        var e = value.getAttribute ? value : 0, rawPath;
        if (e && (value = value.getAttribute("d"))) {
          if (!e._gsPath) {
            e._gsPath = {};
          }
          rawPath = e._gsPath[value];
          return rawPath && !rawPath._dirty ? rawPath : e._gsPath[value] = stringToRawPath(value);
        }
        return !value ? console.warn("Expecting a <path> element or an SVG path data string") : _isString(value) ? stringToRawPath(value) : _isNumber(value[0]) ? [value] : value;
      }
      function reverseSegment(segment) {
        var i = 0, y;
        segment.reverse();
        for (; i < segment.length; i += 2) {
          y = segment[i];
          segment[i] = segment[i + 1];
          segment[i + 1] = y;
        }
        segment.reversed = !segment.reversed;
      }
      var _createPath = function _createPath2(e, ignore) {
        var path = document.createElementNS("http://www.w3.org/2000/svg", "path"), attr = [].slice.call(e.attributes), i = attr.length, name;
        ignore = "," + ignore + ",";
        while (--i > -1) {
          name = attr[i].nodeName.toLowerCase();
          if (ignore.indexOf("," + name + ",") < 0) {
            path.setAttributeNS(null, name, attr[i].nodeValue);
          }
        }
        return path;
      }, _typeAttrs = {
        rect: "rx,ry,x,y,width,height",
        circle: "r,cx,cy",
        ellipse: "rx,ry,cx,cy",
        line: "x1,x2,y1,y2"
      }, _attrToObj = function _attrToObj2(e, attrs) {
        var props = attrs ? attrs.split(",") : [], obj = {}, i = props.length;
        while (--i > -1) {
          obj[props[i]] = +e.getAttribute(props[i]) || 0;
        }
        return obj;
      };
      function convertToPath(element, swap) {
        var type = element.tagName.toLowerCase(), circ = 0.552284749831, data, x, y, r, ry, path, rcirc, rycirc, points, w, h, x2, x3, x4, x5, x6, y2, y3, y4, y5, y6, attr;
        if (type === "path" || !element.getBBox) {
          return element;
        }
        path = _createPath(element, "x,y,width,height,cx,cy,rx,ry,r,x1,x2,y1,y2,points");
        attr = _attrToObj(element, _typeAttrs[type]);
        if (type === "rect") {
          r = attr.rx;
          ry = attr.ry || r;
          x = attr.x;
          y = attr.y;
          w = attr.width - r * 2;
          h = attr.height - ry * 2;
          if (r || ry) {
            x2 = x + r * (1 - circ);
            x3 = x + r;
            x4 = x3 + w;
            x5 = x4 + r * circ;
            x6 = x4 + r;
            y2 = y + ry * (1 - circ);
            y3 = y + ry;
            y4 = y3 + h;
            y5 = y4 + ry * circ;
            y6 = y4 + ry;
            data = "M" + x6 + "," + y3 + " V" + y4 + " C" + [x6, y5, x5, y6, x4, y6, x4 - (x4 - x3) / 3, y6, x3 + (x4 - x3) / 3, y6, x3, y6, x2, y6, x, y5, x, y4, x, y4 - (y4 - y3) / 3, x, y3 + (y4 - y3) / 3, x, y3, x, y2, x2, y, x3, y, x3 + (x4 - x3) / 3, y, x4 - (x4 - x3) / 3, y, x4, y, x5, y, x6, y2, x6, y3].join(",") + "z";
          } else {
            data = "M" + (x + w) + "," + y + " v" + h + " h" + -w + " v" + -h + " h" + w + "z";
          }
        } else if (type === "circle" || type === "ellipse") {
          if (type === "circle") {
            r = ry = attr.r;
            rycirc = r * circ;
          } else {
            r = attr.rx;
            ry = attr.ry;
            rycirc = ry * circ;
          }
          x = attr.cx;
          y = attr.cy;
          rcirc = r * circ;
          data = "M" + (x + r) + "," + y + " C" + [x + r, y + rycirc, x + rcirc, y + ry, x, y + ry, x - rcirc, y + ry, x - r, y + rycirc, x - r, y, x - r, y - rycirc, x - rcirc, y - ry, x, y - ry, x + rcirc, y - ry, x + r, y - rycirc, x + r, y].join(",") + "z";
        } else if (type === "line") {
          data = "M" + attr.x1 + "," + attr.y1 + " L" + attr.x2 + "," + attr.y2;
        } else if (type === "polyline" || type === "polygon") {
          points = (element.getAttribute("points") + "").match(_numbersExp) || [];
          x = points.shift();
          y = points.shift();
          data = "M" + x + "," + y + " L" + points.join(",");
          if (type === "polygon") {
            data += "," + x + "," + y + "z";
          }
        }
        path.setAttribute("d", rawPathToString(path._gsRawPath = stringToRawPath(data)));
        if (swap && element.parentNode) {
          element.parentNode.insertBefore(path, element);
          element.parentNode.removeChild(element);
        }
        return path;
      }
      function arcToSegment(lastX, lastY, rx, ry, angle, largeArcFlag, sweepFlag, x, y) {
        if (lastX === x && lastY === y) {
          return;
        }
        rx = _abs(rx);
        ry = _abs(ry);
        var angleRad = angle % 360 * _DEG2RAD, cosAngle = _cos(angleRad), sinAngle = _sin(angleRad), PI = Math.PI, TWOPI = PI * 2, dx2 = (lastX - x) / 2, dy2 = (lastY - y) / 2, x1 = cosAngle * dx2 + sinAngle * dy2, y1 = -sinAngle * dx2 + cosAngle * dy2, x1_sq = x1 * x1, y1_sq = y1 * y1, radiiCheck = x1_sq / (rx * rx) + y1_sq / (ry * ry);
        if (radiiCheck > 1) {
          rx = _sqrt(radiiCheck) * rx;
          ry = _sqrt(radiiCheck) * ry;
        }
        var rx_sq = rx * rx, ry_sq = ry * ry, sq = (rx_sq * ry_sq - rx_sq * y1_sq - ry_sq * x1_sq) / (rx_sq * y1_sq + ry_sq * x1_sq);
        if (sq < 0) {
          sq = 0;
        }
        var coef = (largeArcFlag === sweepFlag ? -1 : 1) * _sqrt(sq), cx1 = coef * (rx * y1 / ry), cy1 = coef * -(ry * x1 / rx), sx2 = (lastX + x) / 2, sy2 = (lastY + y) / 2, cx = sx2 + (cosAngle * cx1 - sinAngle * cy1), cy = sy2 + (sinAngle * cx1 + cosAngle * cy1), ux = (x1 - cx1) / rx, uy = (y1 - cy1) / ry, vx = (-x1 - cx1) / rx, vy = (-y1 - cy1) / ry, temp = ux * ux + uy * uy, angleStart = (uy < 0 ? -1 : 1) * Math.acos(ux / _sqrt(temp)), angleExtent = (ux * vy - uy * vx < 0 ? -1 : 1) * Math.acos((ux * vx + uy * vy) / _sqrt(temp * (vx * vx + vy * vy)));
        isNaN(angleExtent) && (angleExtent = PI);
        if (!sweepFlag && angleExtent > 0) {
          angleExtent -= TWOPI;
        } else if (sweepFlag && angleExtent < 0) {
          angleExtent += TWOPI;
        }
        angleStart %= TWOPI;
        angleExtent %= TWOPI;
        var segments = Math.ceil(_abs(angleExtent) / (TWOPI / 4)), rawPath = [], angleIncrement = angleExtent / segments, controlLength = 4 / 3 * _sin(angleIncrement / 2) / (1 + _cos(angleIncrement / 2)), ma = cosAngle * rx, mb = sinAngle * rx, mc = sinAngle * -ry, md = cosAngle * ry, i;
        for (i = 0; i < segments; i++) {
          angle = angleStart + i * angleIncrement;
          x1 = _cos(angle);
          y1 = _sin(angle);
          ux = _cos(angle += angleIncrement);
          uy = _sin(angle);
          rawPath.push(x1 - controlLength * y1, y1 + controlLength * x1, ux + controlLength * uy, uy - controlLength * ux, ux, uy);
        }
        for (i = 0; i < rawPath.length; i += 2) {
          x1 = rawPath[i];
          y1 = rawPath[i + 1];
          rawPath[i] = x1 * ma + y1 * mc + cx;
          rawPath[i + 1] = x1 * mb + y1 * md + cy;
        }
        rawPath[i - 2] = x;
        rawPath[i - 1] = y;
        return rawPath;
      }
      function stringToRawPath(d) {
        var a = (d + "").replace(_scientific, function(m) {
          var n = +m;
          return n < 1e-4 && n > -1e-4 ? 0 : n;
        }).match(_svgPathExp) || [], path = [], relativeX = 0, relativeY = 0, twoThirds = 2 / 3, elements = a.length, points = 0, errorMessage = "ERROR: malformed path: " + d, i, j, x, y, command, isRelative, segment, startX, startY, difX, difY, beziers, prevCommand, flag1, flag2, line = function line2(sx, sy, ex, ey) {
          difX = (ex - sx) / 3;
          difY = (ey - sy) / 3;
          segment.push(sx + difX, sy + difY, ex - difX, ey - difY, ex, ey);
        };
        if (!d || !isNaN(a[0]) || isNaN(a[1])) {
          console.log(errorMessage);
          return path;
        }
        for (i = 0; i < elements; i++) {
          prevCommand = command;
          if (isNaN(a[i])) {
            command = a[i].toUpperCase();
            isRelative = command !== a[i];
          } else {
            i--;
          }
          x = +a[i + 1];
          y = +a[i + 2];
          if (isRelative) {
            x += relativeX;
            y += relativeY;
          }
          if (!i) {
            startX = x;
            startY = y;
          }
          if (command === "M") {
            if (segment) {
              if (segment.length < 8) {
                path.length -= 1;
              } else {
                points += segment.length;
              }
            }
            relativeX = startX = x;
            relativeY = startY = y;
            segment = [x, y];
            path.push(segment);
            i += 2;
            command = "L";
          } else if (command === "C") {
            if (!segment) {
              segment = [0, 0];
            }
            if (!isRelative) {
              relativeX = relativeY = 0;
            }
            segment.push(x, y, relativeX + a[i + 3] * 1, relativeY + a[i + 4] * 1, relativeX += a[i + 5] * 1, relativeY += a[i + 6] * 1);
            i += 6;
          } else if (command === "S") {
            difX = relativeX;
            difY = relativeY;
            if (prevCommand === "C" || prevCommand === "S") {
              difX += relativeX - segment[segment.length - 4];
              difY += relativeY - segment[segment.length - 3];
            }
            if (!isRelative) {
              relativeX = relativeY = 0;
            }
            segment.push(difX, difY, x, y, relativeX += a[i + 3] * 1, relativeY += a[i + 4] * 1);
            i += 4;
          } else if (command === "Q") {
            difX = relativeX + (x - relativeX) * twoThirds;
            difY = relativeY + (y - relativeY) * twoThirds;
            if (!isRelative) {
              relativeX = relativeY = 0;
            }
            relativeX += a[i + 3] * 1;
            relativeY += a[i + 4] * 1;
            segment.push(difX, difY, relativeX + (x - relativeX) * twoThirds, relativeY + (y - relativeY) * twoThirds, relativeX, relativeY);
            i += 4;
          } else if (command === "T") {
            difX = relativeX - segment[segment.length - 4];
            difY = relativeY - segment[segment.length - 3];
            segment.push(relativeX + difX, relativeY + difY, x + (relativeX + difX * 1.5 - x) * twoThirds, y + (relativeY + difY * 1.5 - y) * twoThirds, relativeX = x, relativeY = y);
            i += 2;
          } else if (command === "H") {
            line(relativeX, relativeY, relativeX = x, relativeY);
            i += 1;
          } else if (command === "V") {
            line(relativeX, relativeY, relativeX, relativeY = x + (isRelative ? relativeY - relativeX : 0));
            i += 1;
          } else if (command === "L" || command === "Z") {
            if (command === "Z") {
              x = startX;
              y = startY;
              segment.closed = true;
            }
            if (command === "L" || _abs(relativeX - x) > 0.5 || _abs(relativeY - y) > 0.5) {
              line(relativeX, relativeY, x, y);
              if (command === "L") {
                i += 2;
              }
            }
            relativeX = x;
            relativeY = y;
          } else if (command === "A") {
            flag1 = a[i + 4];
            flag2 = a[i + 5];
            difX = a[i + 6];
            difY = a[i + 7];
            j = 7;
            if (flag1.length > 1) {
              if (flag1.length < 3) {
                difY = difX;
                difX = flag2;
                j--;
              } else {
                difY = flag2;
                difX = flag1.substr(2);
                j -= 2;
              }
              flag2 = flag1.charAt(1);
              flag1 = flag1.charAt(0);
            }
            beziers = arcToSegment(relativeX, relativeY, +a[i + 1], +a[i + 2], +a[i + 3], +flag1, +flag2, (isRelative ? relativeX : 0) + difX * 1, (isRelative ? relativeY : 0) + difY * 1);
            i += j;
            if (beziers) {
              for (j = 0; j < beziers.length; j++) {
                segment.push(beziers[j]);
              }
            }
            relativeX = segment[segment.length - 2];
            relativeY = segment[segment.length - 1];
          } else {
            console.log(errorMessage);
          }
        }
        i = segment.length;
        if (i < 6) {
          path.pop();
          i = 0;
        } else if (segment[0] === segment[i - 2] && segment[1] === segment[i - 1]) {
          segment.closed = true;
        }
        path.totalPoints = points + i;
        return path;
      }
      function rawPathToString(rawPath) {
        if (_isNumber(rawPath[0])) {
          rawPath = [rawPath];
        }
        var result = "", l = rawPath.length, sl, s2, i, segment;
        for (s2 = 0; s2 < l; s2++) {
          segment = rawPath[s2];
          result += "M" + _round(segment[0]) + "," + _round(segment[1]) + " C";
          sl = segment.length;
          for (i = 2; i < sl; i++) {
            result += _round(segment[i++]) + "," + _round(segment[i++]) + " " + _round(segment[i++]) + "," + _round(segment[i++]) + " " + _round(segment[i++]) + "," + _round(segment[i]) + " ";
          }
          if (segment.closed) {
            result += "z";
          }
        }
        return result;
      }
      var gsap2, _toArray, _lastLinkedAnchor, _coreInitted, PluginClass, _getGSAP = function _getGSAP2() {
        return gsap2 || typeof window !== "undefined" && (gsap2 = window.gsap) && gsap2.registerPlugin && gsap2;
      }, _isFunction = function _isFunction2(value) {
        return typeof value === "function";
      }, _atan2 = Math.atan2, _cos$1 = Math.cos, _sin$1 = Math.sin, _sqrt$1 = Math.sqrt, _PI = Math.PI, _2PI = _PI * 2, _angleMin = _PI * 0.3, _angleMax = _PI * 0.7, _bigNum = 1e20, _numExp = /[-+=\.]*\d+[\.e\-\+]*\d*[e\-\+]*\d*/gi, _selectorExp$1 = /(^[#\.][a-z]|[a-y][a-z])/i, _commands = /[achlmqstvz]/i, _log = function _log2(message) {
        return console && console.warn(message);
      }, _bonusValidated = 1, _getAverageXY = function _getAverageXY2(segment) {
        var l = segment.length, x = 0, y = 0, i;
        for (i = 0; i < l; i++) {
          x += segment[i++];
          y += segment[i];
        }
        return [x / (l / 2), y / (l / 2)];
      }, _getSize = function _getSize2(segment) {
        var l = segment.length, xMax = segment[0], xMin = xMax, yMax = segment[1], yMin = yMax, x, y, i;
        for (i = 6; i < l; i += 6) {
          x = segment[i];
          y = segment[i + 1];
          if (x > xMax) {
            xMax = x;
          } else if (x < xMin) {
            xMin = x;
          }
          if (y > yMax) {
            yMax = y;
          } else if (y < yMin) {
            yMin = y;
          }
        }
        segment.centerX = (xMax + xMin) / 2;
        segment.centerY = (yMax + yMin) / 2;
        return segment.size = (xMax - xMin) * (yMax - yMin);
      }, _getTotalSize = function _getTotalSize2(rawPath, samplesPerBezier) {
        if (samplesPerBezier === void 0) {
          samplesPerBezier = 3;
        }
        var j = rawPath.length, xMax = rawPath[0][0], xMin = xMax, yMax = rawPath[0][1], yMin = yMax, inc = 1 / samplesPerBezier, l, x, y, i, segment, k, t, inv, x1, y1, x2, x3, x4, y2, y3, y4;
        while (--j > -1) {
          segment = rawPath[j];
          l = segment.length;
          for (i = 6; i < l; i += 6) {
            x1 = segment[i];
            y1 = segment[i + 1];
            x2 = segment[i + 2] - x1;
            y2 = segment[i + 3] - y1;
            x3 = segment[i + 4] - x1;
            y3 = segment[i + 5] - y1;
            x4 = segment[i + 6] - x1;
            y4 = segment[i + 7] - y1;
            k = samplesPerBezier;
            while (--k > -1) {
              t = inc * k;
              inv = 1 - t;
              x = (t * t * x4 + 3 * inv * (t * x3 + inv * x2)) * t + x1;
              y = (t * t * y4 + 3 * inv * (t * y3 + inv * y2)) * t + y1;
              if (x > xMax) {
                xMax = x;
              } else if (x < xMin) {
                xMin = x;
              }
              if (y > yMax) {
                yMax = y;
              } else if (y < yMin) {
                yMin = y;
              }
            }
          }
        }
        rawPath.centerX = (xMax + xMin) / 2;
        rawPath.centerY = (yMax + yMin) / 2;
        rawPath.left = xMin;
        rawPath.width = xMax - xMin;
        rawPath.top = yMin;
        rawPath.height = yMax - yMin;
        return rawPath.size = (xMax - xMin) * (yMax - yMin);
      }, _sortByComplexity = function _sortByComplexity2(a, b) {
        return b.length - a.length;
      }, _sortBySize = function _sortBySize2(a, b) {
        var sizeA = a.size || _getSize(a), sizeB = b.size || _getSize(b);
        return Math.abs(sizeB - sizeA) < (sizeA + sizeB) / 20 ? b.centerX - a.centerX || b.centerY - a.centerY : sizeB - sizeA;
      }, _offsetSegment = function _offsetSegment2(segment, shapeIndex) {
        var a = segment.slice(0), l = segment.length, wrap = l - 2, i, index2;
        shapeIndex = shapeIndex | 0;
        for (i = 0; i < l; i++) {
          index2 = (i + shapeIndex) % wrap;
          segment[i++] = a[index2];
          segment[i] = a[index2 + 1];
        }
      }, _getTotalMovement = function _getTotalMovement2(sb, eb, shapeIndex, offsetX, offsetY) {
        var l = sb.length, d = 0, wrap = l - 2, index2, i, x, y;
        shapeIndex *= 6;
        for (i = 0; i < l; i += 6) {
          index2 = (i + shapeIndex) % wrap;
          y = sb[index2] - (eb[i] - offsetX);
          x = sb[index2 + 1] - (eb[i + 1] - offsetY);
          d += _sqrt$1(x * x + y * y);
        }
        return d;
      }, _getClosestShapeIndex = function _getClosestShapeIndex2(sb, eb, checkReverse) {
        var l = sb.length, sCenter = _getAverageXY(sb), eCenter = _getAverageXY(eb), offsetX = eCenter[0] - sCenter[0], offsetY = eCenter[1] - sCenter[1], min = _getTotalMovement(sb, eb, 0, offsetX, offsetY), minIndex = 0, copy2, d, i;
        for (i = 6; i < l; i += 6) {
          d = _getTotalMovement(sb, eb, i / 6, offsetX, offsetY);
          if (d < min) {
            min = d;
            minIndex = i;
          }
        }
        if (checkReverse) {
          copy2 = sb.slice(0);
          reverseSegment(copy2);
          for (i = 6; i < l; i += 6) {
            d = _getTotalMovement(copy2, eb, i / 6, offsetX, offsetY);
            if (d < min) {
              min = d;
              minIndex = -i;
            }
          }
        }
        return minIndex / 6;
      }, _getClosestAnchor = function _getClosestAnchor2(rawPath, x, y) {
        var j = rawPath.length, closestDistance = _bigNum, closestX = 0, closestY = 0, segment, dx, dy, d, i, l;
        while (--j > -1) {
          segment = rawPath[j];
          l = segment.length;
          for (i = 0; i < l; i += 6) {
            dx = segment[i] - x;
            dy = segment[i + 1] - y;
            d = _sqrt$1(dx * dx + dy * dy);
            if (d < closestDistance) {
              closestDistance = d;
              closestX = segment[i];
              closestY = segment[i + 1];
            }
          }
        }
        return [closestX, closestY];
      }, _getClosestSegment = function _getClosestSegment2(bezier, pool, startIndex, sortRatio, offsetX, offsetY) {
        var l = pool.length, index2 = 0, minSize = Math.min(bezier.size || _getSize(bezier), pool[startIndex].size || _getSize(pool[startIndex])) * sortRatio, min = _bigNum, cx = bezier.centerX + offsetX, cy = bezier.centerY + offsetY, size, i, dx, dy, d;
        for (i = startIndex; i < l; i++) {
          size = pool[i].size || _getSize(pool[i]);
          if (size < minSize) {
            break;
          }
          dx = pool[i].centerX - cx;
          dy = pool[i].centerY - cy;
          d = _sqrt$1(dx * dx + dy * dy);
          if (d < min) {
            index2 = i;
            min = d;
          }
        }
        d = pool[index2];
        pool.splice(index2, 1);
        return d;
      }, _subdivideSegmentQty = function _subdivideSegmentQty2(segment, quantity) {
        var tally = 0, max = 0.999999, l = segment.length, newPointsPerSegment = quantity / ((l - 2) / 6), ax, ay, cp1x, cp1y, cp2x, cp2y, bx, by, x1, y1, x2, y2, i, t;
        for (i = 2; i < l; i += 6) {
          tally += newPointsPerSegment;
          while (tally > max) {
            ax = segment[i - 2];
            ay = segment[i - 1];
            cp1x = segment[i];
            cp1y = segment[i + 1];
            cp2x = segment[i + 2];
            cp2y = segment[i + 3];
            bx = segment[i + 4];
            by = segment[i + 5];
            t = 1 / ((Math.floor(tally) || 1) + 1);
            x1 = ax + (cp1x - ax) * t;
            x2 = cp1x + (cp2x - cp1x) * t;
            x1 += (x2 - x1) * t;
            x2 += (cp2x + (bx - cp2x) * t - x2) * t;
            y1 = ay + (cp1y - ay) * t;
            y2 = cp1y + (cp2y - cp1y) * t;
            y1 += (y2 - y1) * t;
            y2 += (cp2y + (by - cp2y) * t - y2) * t;
            segment.splice(i, 4, ax + (cp1x - ax) * t, ay + (cp1y - ay) * t, x1, y1, x1 + (x2 - x1) * t, y1 + (y2 - y1) * t, x2, y2, cp2x + (bx - cp2x) * t, cp2y + (by - cp2y) * t);
            i += 6;
            l += 6;
            tally--;
          }
        }
        return segment;
      }, _equalizeSegmentQuantity = function _equalizeSegmentQuantity2(start, end, shapeIndex, map2, fillSafe) {
        var dif = end.length - start.length, longer = dif > 0 ? end : start, shorter = dif > 0 ? start : end, added = 0, sortMethod = map2 === "complexity" ? _sortByComplexity : _sortBySize, sortRatio = map2 === "position" ? 0 : typeof map2 === "number" ? map2 : 0.8, i = shorter.length, shapeIndices = typeof shapeIndex === "object" && shapeIndex.push ? shapeIndex.slice(0) : [shapeIndex], reverse = shapeIndices[0] === "reverse" || shapeIndices[0] < 0, log = shapeIndex === "log", eb, sb, b, x, y, offsetX, offsetY;
        if (!shorter[0]) {
          return;
        }
        if (longer.length > 1) {
          start.sort(sortMethod);
          end.sort(sortMethod);
          offsetX = longer.size || _getTotalSize(longer);
          offsetX = shorter.size || _getTotalSize(shorter);
          offsetX = longer.centerX - shorter.centerX;
          offsetY = longer.centerY - shorter.centerY;
          if (sortMethod === _sortBySize) {
            for (i = 0; i < shorter.length; i++) {
              longer.splice(i, 0, _getClosestSegment(shorter[i], longer, i, sortRatio, offsetX, offsetY));
            }
          }
        }
        if (dif) {
          if (dif < 0) {
            dif = -dif;
          }
          if (longer[0].length > shorter[0].length) {
            _subdivideSegmentQty(shorter[0], (longer[0].length - shorter[0].length) / 6 | 0);
          }
          i = shorter.length;
          while (added < dif) {
            x = longer[i].size || _getSize(longer[i]);
            b = _getClosestAnchor(shorter, longer[i].centerX, longer[i].centerY);
            x = b[0];
            y = b[1];
            shorter[i++] = [x, y, x, y, x, y, x, y];
            shorter.totalPoints += 8;
            added++;
          }
        }
        for (i = 0; i < start.length; i++) {
          eb = end[i];
          sb = start[i];
          dif = eb.length - sb.length;
          if (dif < 0) {
            _subdivideSegmentQty(eb, -dif / 6 | 0);
          } else if (dif > 0) {
            _subdivideSegmentQty(sb, dif / 6 | 0);
          }
          if (reverse && fillSafe !== false && !sb.reversed) {
            reverseSegment(sb);
          }
          shapeIndex = shapeIndices[i] || shapeIndices[i] === 0 ? shapeIndices[i] : "auto";
          if (shapeIndex) {
            if (sb.closed || Math.abs(sb[0] - sb[sb.length - 2]) < 0.5 && Math.abs(sb[1] - sb[sb.length - 1]) < 0.5) {
              if (shapeIndex === "auto" || shapeIndex === "log") {
                shapeIndices[i] = shapeIndex = _getClosestShapeIndex(sb, eb, !i || fillSafe === false);
                if (shapeIndex < 0) {
                  reverse = true;
                  reverseSegment(sb);
                  shapeIndex = -shapeIndex;
                }
                _offsetSegment(sb, shapeIndex * 6);
              } else if (shapeIndex !== "reverse") {
                if (i && shapeIndex < 0) {
                  reverseSegment(sb);
                }
                _offsetSegment(sb, (shapeIndex < 0 ? -shapeIndex : shapeIndex) * 6);
              }
            } else if (!reverse && (shapeIndex === "auto" && Math.abs(eb[0] - sb[0]) + Math.abs(eb[1] - sb[1]) + Math.abs(eb[eb.length - 2] - sb[sb.length - 2]) + Math.abs(eb[eb.length - 1] - sb[sb.length - 1]) > Math.abs(eb[0] - sb[sb.length - 2]) + Math.abs(eb[1] - sb[sb.length - 1]) + Math.abs(eb[eb.length - 2] - sb[0]) + Math.abs(eb[eb.length - 1] - sb[1]) || shapeIndex % 2)) {
              reverseSegment(sb);
              shapeIndices[i] = -1;
              reverse = true;
            } else if (shapeIndex === "auto") {
              shapeIndices[i] = 0;
            } else if (shapeIndex === "reverse") {
              shapeIndices[i] = -1;
            }
            if (sb.closed !== eb.closed) {
              sb.closed = eb.closed = false;
            }
          }
        }
        log && _log("shapeIndex:[" + shapeIndices.join(",") + "]");
        start.shapeIndex = shapeIndices;
        return shapeIndices;
      }, _pathFilter = function _pathFilter2(a, shapeIndex, map2, precompile, fillSafe) {
        var start = stringToRawPath(a[0]), end = stringToRawPath(a[1]);
        if (!_equalizeSegmentQuantity(start, end, shapeIndex || shapeIndex === 0 ? shapeIndex : "auto", map2, fillSafe)) {
          return;
        }
        a[0] = rawPathToString(start);
        a[1] = rawPathToString(end);
        if (precompile === "log" || precompile === true) {
          _log('precompile:["' + a[0] + '","' + a[1] + '"]');
        }
      }, _offsetPoints = function _offsetPoints2(text, offset) {
        if (!offset) {
          return text;
        }
        var a = text.match(_numExp) || [], l = a.length, s2 = "", inc, i, j;
        if (offset === "reverse") {
          i = l - 1;
          inc = -2;
        } else {
          i = ((parseInt(offset, 10) || 0) * 2 + 1 + l * 100) % l;
          inc = 2;
        }
        for (j = 0; j < l; j += 2) {
          s2 += a[i - 1] + "," + a[i] + " ";
          i = (i + inc) % l;
        }
        return s2;
      }, _equalizePointQuantity = function _equalizePointQuantity2(a, quantity) {
        var tally = 0, x = parseFloat(a[0]), y = parseFloat(a[1]), s2 = x + "," + y + " ", max = 0.999999, newPointsPerSegment, i, l, j, factor, nextX, nextY;
        l = a.length;
        newPointsPerSegment = quantity * 0.5 / (l * 0.5 - 1);
        for (i = 0; i < l - 2; i += 2) {
          tally += newPointsPerSegment;
          nextX = parseFloat(a[i + 2]);
          nextY = parseFloat(a[i + 3]);
          if (tally > max) {
            factor = 1 / (Math.floor(tally) + 1);
            j = 1;
            while (tally > max) {
              s2 += (x + (nextX - x) * factor * j).toFixed(2) + "," + (y + (nextY - y) * factor * j).toFixed(2) + " ";
              tally--;
              j++;
            }
          }
          s2 += nextX + "," + nextY + " ";
          x = nextX;
          y = nextY;
        }
        return s2;
      }, _pointsFilter = function _pointsFilter2(a) {
        var startNums = a[0].match(_numExp) || [], endNums = a[1].match(_numExp) || [], dif = endNums.length - startNums.length;
        if (dif > 0) {
          a[0] = _equalizePointQuantity(startNums, dif);
        } else {
          a[1] = _equalizePointQuantity(endNums, -dif);
        }
      }, _buildPointsFilter = function _buildPointsFilter2(shapeIndex) {
        return !isNaN(shapeIndex) ? function(a) {
          _pointsFilter(a);
          a[1] = _offsetPoints(a[1], parseInt(shapeIndex, 10));
        } : _pointsFilter;
      }, _parseShape = function _parseShape2(shape, forcePath, target) {
        var isString = typeof shape === "string", e, type;
        if (!isString || _selectorExp$1.test(shape) || (shape.match(_numExp) || []).length < 3) {
          e = _toArray(shape)[0];
          if (e) {
            type = (e.nodeName + "").toUpperCase();
            if (forcePath && type !== "PATH") {
              e = convertToPath(e, false);
              type = "PATH";
            }
            shape = e.getAttribute(type === "PATH" ? "d" : "points") || "";
            if (e === target) {
              shape = e.getAttributeNS(null, "data-original") || shape;
            }
          } else {
            _log("WARNING: invalid morph to: " + shape);
            shape = false;
          }
        }
        return shape;
      }, _populateSmoothData = function _populateSmoothData2(rawPath, tolerance) {
        var j = rawPath.length, limit = 0.2 * (tolerance || 1), smooth, segment, x, y, x2, y2, i, l, a, a2, isSmooth, smoothData;
        while (--j > -1) {
          segment = rawPath[j];
          isSmooth = segment.isSmooth = segment.isSmooth || [0, 0, 0, 0];
          smoothData = segment.smoothData = segment.smoothData || [0, 0, 0, 0];
          isSmooth.length = 4;
          l = segment.length - 2;
          for (i = 6; i < l; i += 6) {
            x = segment[i] - segment[i - 2];
            y = segment[i + 1] - segment[i - 1];
            x2 = segment[i + 2] - segment[i];
            y2 = segment[i + 3] - segment[i + 1];
            a = _atan2(y, x);
            a2 = _atan2(y2, x2);
            smooth = Math.abs(a - a2) < limit;
            if (smooth) {
              smoothData[i - 2] = a;
              smoothData[i + 2] = a2;
              smoothData[i - 1] = _sqrt$1(x * x + y * y);
              smoothData[i + 3] = _sqrt$1(x2 * x2 + y2 * y2);
            }
            isSmooth.push(smooth, smooth, 0, 0, smooth, smooth);
          }
          if (segment[l] === segment[0] && segment[l + 1] === segment[1]) {
            x = segment[0] - segment[l - 2];
            y = segment[1] - segment[l - 1];
            x2 = segment[2] - segment[0];
            y2 = segment[3] - segment[1];
            a = _atan2(y, x);
            a2 = _atan2(y2, x2);
            if (Math.abs(a - a2) < limit) {
              smoothData[l - 2] = a;
              smoothData[2] = a2;
              smoothData[l - 1] = _sqrt$1(x * x + y * y);
              smoothData[3] = _sqrt$1(x2 * x2 + y2 * y2);
              isSmooth[l - 2] = isSmooth[l - 1] = true;
            }
          }
        }
        return rawPath;
      }, _parseOriginFactors = function _parseOriginFactors2(v) {
        var a = v.trim().split(" "), x = ~v.indexOf("left") ? 0 : ~v.indexOf("right") ? 100 : isNaN(parseFloat(a[0])) ? 50 : parseFloat(a[0]), y = ~v.indexOf("top") ? 0 : ~v.indexOf("bottom") ? 100 : isNaN(parseFloat(a[1])) ? 50 : parseFloat(a[1]);
        return {
          x: x / 100,
          y: y / 100
        };
      }, _shortAngle = function _shortAngle2(dif) {
        return dif !== dif % _PI ? dif + (dif < 0 ? _2PI : -_2PI) : dif;
      }, _morphMessage = "Use MorphSVGPlugin.convertToPath() to convert to a path before morphing.", _tweenRotation = function _tweenRotation2(start, end, i, linkedPT) {
        var so = this._origin, eo = this._eOrigin, dx = start[i] - so.x, dy = start[i + 1] - so.y, d = _sqrt$1(dx * dx + dy * dy), sa = _atan2(dy, dx), angleDif, _short;
        dx = end[i] - eo.x;
        dy = end[i + 1] - eo.y;
        angleDif = _atan2(dy, dx) - sa;
        _short = _shortAngle(angleDif);
        if (!linkedPT && _lastLinkedAnchor && Math.abs(_short + _lastLinkedAnchor.ca) < _angleMin) {
          linkedPT = _lastLinkedAnchor;
        }
        return this._anchorPT = _lastLinkedAnchor = {
          _next: this._anchorPT,
          t: start,
          sa,
          ca: linkedPT && _short * linkedPT.ca < 0 && Math.abs(_short) > _angleMax ? angleDif : _short,
          sl: d,
          cl: _sqrt$1(dx * dx + dy * dy) - d,
          i
        };
      }, _initCore = function _initCore2(required) {
        gsap2 = _getGSAP();
        PluginClass = PluginClass || gsap2 && gsap2.plugins.morphSVG;
        if (gsap2 && PluginClass) {
          _toArray = gsap2.utils.toArray;
          PluginClass.prototype._tweenRotation = _tweenRotation;
          _coreInitted = 1;
        } else if (required) {
          _log("Please gsap.registerPlugin(MorphSVGPlugin)");
        }
      };
      var MorphSVGPlugin2 = {
        version: "3.8.0",
        name: "morphSVG",
        rawVars: 1,
        register: function register(core, Plugin) {
          gsap2 = core;
          PluginClass = Plugin;
          _initCore();
        },
        init: function init2(target, value, tween, index2, targets) {
          _coreInitted || _initCore(1);
          if (!value) {
            _log("invalid shape");
            return false;
          }
          _isFunction(value) && (value = value.call(tween, index2, target, targets));
          var type, p, pt, shape, isPoly, shapeIndex, map2, startSmooth, endSmooth, start, end, i, j, l, startSeg, endSeg, precompiled, sData, eData, originFactors, useRotation, offset;
          if (typeof value === "string" || value.getBBox || value[0]) {
            value = {
              shape: value
            };
          } else if (typeof value === "object") {
            type = {};
            for (p in value) {
              type[p] = _isFunction(value[p]) && p !== "render" ? value[p].call(tween, index2, target, targets) : value[p];
            }
            value = type;
          }
          var cs = target.nodeType ? window.getComputedStyle(target) : {}, fill = cs.fill + "", fillSafe = !(fill === "none" || (fill.match(_numExp) || [])[3] === "0" || cs.fillRule === "evenodd"), origins = (value.origin || "50 50").split(",");
          type = (target.nodeName + "").toUpperCase();
          isPoly = type === "POLYLINE" || type === "POLYGON";
          if (type !== "PATH" && !isPoly && !value.prop) {
            _log("Cannot morph a <" + type + "> element. " + _morphMessage);
            return false;
          }
          p = type === "PATH" ? "d" : "points";
          if (!value.prop && !_isFunction(target.setAttribute)) {
            return false;
          }
          shape = _parseShape(value.shape || value.d || value.points || "", p === "d", target);
          if (isPoly && _commands.test(shape)) {
            _log("A <" + type + "> cannot accept path data. " + _morphMessage);
            return false;
          }
          shapeIndex = value.shapeIndex || value.shapeIndex === 0 ? value.shapeIndex : "auto";
          map2 = value.map || MorphSVGPlugin2.defaultMap;
          this._prop = value.prop;
          this._render = value.render || MorphSVGPlugin2.defaultRender;
          this._apply = "updateTarget" in value ? value.updateTarget : MorphSVGPlugin2.defaultUpdateTarget;
          this._rnd = Math.pow(10, isNaN(value.precision) ? 2 : +value.precision);
          this._tween = tween;
          if (shape) {
            this._target = target;
            precompiled = typeof value.precompile === "object";
            start = this._prop ? target[this._prop] : target.getAttribute(p);
            if (!this._prop && !target.getAttributeNS(null, "data-original")) {
              target.setAttributeNS(null, "data-original", start);
            }
            if (p === "d" || this._prop) {
              start = stringToRawPath(precompiled ? value.precompile[0] : start);
              end = stringToRawPath(precompiled ? value.precompile[1] : shape);
              if (!precompiled && !_equalizeSegmentQuantity(start, end, shapeIndex, map2, fillSafe)) {
                return false;
              }
              if (value.precompile === "log" || value.precompile === true) {
                _log('precompile:["' + rawPathToString(start) + '","' + rawPathToString(end) + '"]');
              }
              useRotation = (value.type || MorphSVGPlugin2.defaultType) !== "linear";
              if (useRotation) {
                start = _populateSmoothData(start, value.smoothTolerance);
                end = _populateSmoothData(end, value.smoothTolerance);
                if (!start.size) {
                  _getTotalSize(start);
                }
                if (!end.size) {
                  _getTotalSize(end);
                }
                originFactors = _parseOriginFactors(origins[0]);
                this._origin = start.origin = {
                  x: start.left + originFactors.x * start.width,
                  y: start.top + originFactors.y * start.height
                };
                if (origins[1]) {
                  originFactors = _parseOriginFactors(origins[1]);
                }
                this._eOrigin = {
                  x: end.left + originFactors.x * end.width,
                  y: end.top + originFactors.y * end.height
                };
              }
              this._rawPath = target._gsRawPath = start;
              j = start.length;
              while (--j > -1) {
                startSeg = start[j];
                endSeg = end[j];
                startSmooth = startSeg.isSmooth || [];
                endSmooth = endSeg.isSmooth || [];
                l = startSeg.length;
                _lastLinkedAnchor = 0;
                for (i = 0; i < l; i += 2) {
                  if (endSeg[i] !== startSeg[i] || endSeg[i + 1] !== startSeg[i + 1]) {
                    if (useRotation) {
                      if (startSmooth[i] && endSmooth[i]) {
                        sData = startSeg.smoothData;
                        eData = endSeg.smoothData;
                        offset = i + (i === l - 4 ? 7 - l : 5);
                        this._controlPT = {
                          _next: this._controlPT,
                          i,
                          j,
                          l1s: sData[i + 1],
                          l1c: eData[i + 1] - sData[i + 1],
                          l2s: sData[offset],
                          l2c: eData[offset] - sData[offset]
                        };
                        pt = this._tweenRotation(startSeg, endSeg, i + 2);
                        this._tweenRotation(startSeg, endSeg, i, pt);
                        this._tweenRotation(startSeg, endSeg, offset - 1, pt);
                        i += 4;
                      } else {
                        this._tweenRotation(startSeg, endSeg, i);
                      }
                    } else {
                      pt = this.add(startSeg, i, startSeg[i], endSeg[i]);
                      pt = this.add(startSeg, i + 1, startSeg[i + 1], endSeg[i + 1]) || pt;
                    }
                  }
                }
              }
            } else {
              pt = this.add(target, "setAttribute", target.getAttribute(p) + "", shape + "", index2, targets, 0, _buildPointsFilter(shapeIndex), p);
            }
            if (useRotation) {
              this.add(this._origin, "x", this._origin.x, this._eOrigin.x);
              pt = this.add(this._origin, "y", this._origin.y, this._eOrigin.y);
            }
            if (pt) {
              this._props.push("morphSVG");
              pt.end = shape;
              pt.endProp = p;
            }
          }
          return _bonusValidated;
        },
        render: function render2(ratio, data) {
          var rawPath = data._rawPath, controlPT = data._controlPT, anchorPT = data._anchorPT, rnd = data._rnd, target = data._target, pt = data._pt, s2, space, easeInOut, segment, l, angle, i, j, x, y, sin, cos, offset;
          while (pt) {
            pt.r(ratio, pt.d);
            pt = pt._next;
          }
          if (ratio === 1 && data._apply) {
            pt = data._pt;
            while (pt) {
              if (pt.end) {
                if (data._prop) {
                  target[data._prop] = pt.end;
                } else {
                  target.setAttribute(pt.endProp, pt.end);
                }
              }
              pt = pt._next;
            }
          } else if (rawPath) {
            while (anchorPT) {
              angle = anchorPT.sa + ratio * anchorPT.ca;
              l = anchorPT.sl + ratio * anchorPT.cl;
              anchorPT.t[anchorPT.i] = data._origin.x + _cos$1(angle) * l;
              anchorPT.t[anchorPT.i + 1] = data._origin.y + _sin$1(angle) * l;
              anchorPT = anchorPT._next;
            }
            easeInOut = ratio < 0.5 ? 2 * ratio * ratio : (4 - 2 * ratio) * ratio - 1;
            while (controlPT) {
              i = controlPT.i;
              segment = rawPath[controlPT.j];
              offset = i + (i === segment.length - 4 ? 7 - segment.length : 5);
              angle = _atan2(segment[offset] - segment[i + 1], segment[offset - 1] - segment[i]);
              sin = _sin$1(angle);
              cos = _cos$1(angle);
              x = segment[i + 2];
              y = segment[i + 3];
              l = controlPT.l1s + easeInOut * controlPT.l1c;
              segment[i] = x - cos * l;
              segment[i + 1] = y - sin * l;
              l = controlPT.l2s + easeInOut * controlPT.l2c;
              segment[offset - 1] = x + cos * l;
              segment[offset] = y + sin * l;
              controlPT = controlPT._next;
            }
            target._gsRawPath = rawPath;
            if (data._apply) {
              s2 = "";
              space = " ";
              for (j = 0; j < rawPath.length; j++) {
                segment = rawPath[j];
                l = segment.length;
                s2 += "M" + (segment[0] * rnd | 0) / rnd + space + (segment[1] * rnd | 0) / rnd + " C";
                for (i = 2; i < l; i++) {
                  s2 += (segment[i] * rnd | 0) / rnd + space;
                }
              }
              if (data._prop) {
                target[data._prop] = s2;
              } else {
                target.setAttribute("d", s2);
              }
            }
          }
          data._render && rawPath && data._render.call(data._tween, rawPath, target);
        },
        kill: function kill(property) {
          this._pt = this._rawPath = 0;
        },
        getRawPath,
        stringToRawPath,
        rawPathToString,
        normalizeStrings: function normalizeStrings(shape1, shape2, _ref) {
          var shapeIndex = _ref.shapeIndex, map2 = _ref.map;
          var result = [shape1, shape2];
          _pathFilter(result, shapeIndex, map2);
          return result;
        },
        pathFilter: _pathFilter,
        pointsFilter: _pointsFilter,
        getTotalSize: _getTotalSize,
        equalizeSegmentQuantity: _equalizeSegmentQuantity,
        convertToPath: function convertToPath$1(targets, swap) {
          return _toArray(targets).map(function(target) {
            return convertToPath(target, swap !== false);
          });
        },
        defaultType: "linear",
        defaultUpdateTarget: true,
        defaultMap: "size"
      };
      _getGSAP() && gsap2.registerPlugin(MorphSVGPlugin2);
      exports2.MorphSVGPlugin = MorphSVGPlugin2;
      exports2.default = MorphSVGPlugin2;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// node_modules/orderedmap/index.js
var require_orderedmap = __commonJS({
  "node_modules/orderedmap/index.js"(exports, module2) {
    init_shims();
    function OrderedMap(content) {
      this.content = content;
    }
    OrderedMap.prototype = {
      constructor: OrderedMap,
      find: function(key) {
        for (var i = 0; i < this.content.length; i += 2)
          if (this.content[i] === key)
            return i;
        return -1;
      },
      get: function(key) {
        var found = this.find(key);
        return found == -1 ? void 0 : this.content[found + 1];
      },
      update: function(key, value, newKey) {
        var self2 = newKey && newKey != key ? this.remove(newKey) : this;
        var found = self2.find(key), content = self2.content.slice();
        if (found == -1) {
          content.push(newKey || key, value);
        } else {
          content[found + 1] = value;
          if (newKey)
            content[found] = newKey;
        }
        return new OrderedMap(content);
      },
      remove: function(key) {
        var found = this.find(key);
        if (found == -1)
          return this;
        var content = this.content.slice();
        content.splice(found, 2);
        return new OrderedMap(content);
      },
      addToStart: function(key, value) {
        return new OrderedMap([key, value].concat(this.remove(key).content));
      },
      addToEnd: function(key, value) {
        var content = this.remove(key).content.slice();
        content.push(key, value);
        return new OrderedMap(content);
      },
      addBefore: function(place, key, value) {
        var without = this.remove(key), content = without.content.slice();
        var found = without.find(place);
        content.splice(found == -1 ? content.length : found, 0, key, value);
        return new OrderedMap(content);
      },
      forEach: function(f) {
        for (var i = 0; i < this.content.length; i += 2)
          f(this.content[i], this.content[i + 1]);
      },
      prepend: function(map2) {
        map2 = OrderedMap.from(map2);
        if (!map2.size)
          return this;
        return new OrderedMap(map2.content.concat(this.subtract(map2).content));
      },
      append: function(map2) {
        map2 = OrderedMap.from(map2);
        if (!map2.size)
          return this;
        return new OrderedMap(this.subtract(map2).content.concat(map2.content));
      },
      subtract: function(map2) {
        var result = this;
        map2 = OrderedMap.from(map2);
        for (var i = 0; i < map2.content.length; i += 2)
          result = result.remove(map2.content[i]);
        return result;
      },
      get size() {
        return this.content.length >> 1;
      }
    };
    OrderedMap.from = function(value) {
      if (value instanceof OrderedMap)
        return value;
      var content = [];
      if (value)
        for (var prop in value)
          content.push(prop, value[prop]);
      return new OrderedMap(content);
    };
    module2.exports = OrderedMap;
  }
});

// node_modules/prosemirror-model/dist/index.js
var require_dist = __commonJS({
  "node_modules/prosemirror-model/dist/index.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var OrderedMap = require_orderedmap();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var OrderedMap__default = /* @__PURE__ */ _interopDefaultLegacy(OrderedMap);
    function findDiffStart(a, b, pos) {
      for (var i = 0; ; i++) {
        if (i == a.childCount || i == b.childCount) {
          return a.childCount == b.childCount ? null : pos;
        }
        var childA = a.child(i), childB = b.child(i);
        if (childA == childB) {
          pos += childA.nodeSize;
          continue;
        }
        if (!childA.sameMarkup(childB)) {
          return pos;
        }
        if (childA.isText && childA.text != childB.text) {
          for (var j = 0; childA.text[j] == childB.text[j]; j++) {
            pos++;
          }
          return pos;
        }
        if (childA.content.size || childB.content.size) {
          var inner = findDiffStart(childA.content, childB.content, pos + 1);
          if (inner != null) {
            return inner;
          }
        }
        pos += childA.nodeSize;
      }
    }
    function findDiffEnd(a, b, posA, posB) {
      for (var iA = a.childCount, iB = b.childCount; ; ) {
        if (iA == 0 || iB == 0) {
          return iA == iB ? null : { a: posA, b: posB };
        }
        var childA = a.child(--iA), childB = b.child(--iB), size = childA.nodeSize;
        if (childA == childB) {
          posA -= size;
          posB -= size;
          continue;
        }
        if (!childA.sameMarkup(childB)) {
          return { a: posA, b: posB };
        }
        if (childA.isText && childA.text != childB.text) {
          var same = 0, minSize = Math.min(childA.text.length, childB.text.length);
          while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {
            same++;
            posA--;
            posB--;
          }
          return { a: posA, b: posB };
        }
        if (childA.content.size || childB.content.size) {
          var inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);
          if (inner) {
            return inner;
          }
        }
        posA -= size;
        posB -= size;
      }
    }
    var Fragment = function Fragment2(content, size) {
      this.content = content;
      this.size = size || 0;
      if (size == null) {
        for (var i = 0; i < content.length; i++) {
          this.size += content[i].nodeSize;
        }
      }
    };
    var prototypeAccessors = { firstChild: { configurable: true }, lastChild: { configurable: true }, childCount: { configurable: true } };
    Fragment.prototype.nodesBetween = function nodesBetween(from, to, f, nodeStart, parent) {
      if (nodeStart === void 0)
        nodeStart = 0;
      for (var i = 0, pos = 0; pos < to; i++) {
        var child = this.content[i], end = pos + child.nodeSize;
        if (end > from && f(child, nodeStart + pos, parent, i) !== false && child.content.size) {
          var start = pos + 1;
          child.nodesBetween(Math.max(0, from - start), Math.min(child.content.size, to - start), f, nodeStart + start);
        }
        pos = end;
      }
    };
    Fragment.prototype.descendants = function descendants(f) {
      this.nodesBetween(0, this.size, f);
    };
    Fragment.prototype.textBetween = function textBetween(from, to, blockSeparator, leafText) {
      var text = "", separated = true;
      this.nodesBetween(from, to, function(node, pos) {
        if (node.isText) {
          text += node.text.slice(Math.max(from, pos) - pos, to - pos);
          separated = !blockSeparator;
        } else if (node.isLeaf && leafText) {
          text += leafText;
          separated = !blockSeparator;
        } else if (!separated && node.isBlock) {
          text += blockSeparator;
          separated = true;
        }
      }, 0);
      return text;
    };
    Fragment.prototype.append = function append(other) {
      if (!other.size) {
        return this;
      }
      if (!this.size) {
        return other;
      }
      var last = this.lastChild, first = other.firstChild, content = this.content.slice(), i = 0;
      if (last.isText && last.sameMarkup(first)) {
        content[content.length - 1] = last.withText(last.text + first.text);
        i = 1;
      }
      for (; i < other.content.length; i++) {
        content.push(other.content[i]);
      }
      return new Fragment(content, this.size + other.size);
    };
    Fragment.prototype.cut = function cut(from, to) {
      if (to == null) {
        to = this.size;
      }
      if (from == 0 && to == this.size) {
        return this;
      }
      var result = [], size = 0;
      if (to > from) {
        for (var i = 0, pos = 0; pos < to; i++) {
          var child = this.content[i], end = pos + child.nodeSize;
          if (end > from) {
            if (pos < from || end > to) {
              if (child.isText) {
                child = child.cut(Math.max(0, from - pos), Math.min(child.text.length, to - pos));
              } else {
                child = child.cut(Math.max(0, from - pos - 1), Math.min(child.content.size, to - pos - 1));
              }
            }
            result.push(child);
            size += child.nodeSize;
          }
          pos = end;
        }
      }
      return new Fragment(result, size);
    };
    Fragment.prototype.cutByIndex = function cutByIndex(from, to) {
      if (from == to) {
        return Fragment.empty;
      }
      if (from == 0 && to == this.content.length) {
        return this;
      }
      return new Fragment(this.content.slice(from, to));
    };
    Fragment.prototype.replaceChild = function replaceChild(index2, node) {
      var current = this.content[index2];
      if (current == node) {
        return this;
      }
      var copy3 = this.content.slice();
      var size = this.size + node.nodeSize - current.nodeSize;
      copy3[index2] = node;
      return new Fragment(copy3, size);
    };
    Fragment.prototype.addToStart = function addToStart(node) {
      return new Fragment([node].concat(this.content), this.size + node.nodeSize);
    };
    Fragment.prototype.addToEnd = function addToEnd(node) {
      return new Fragment(this.content.concat(node), this.size + node.nodeSize);
    };
    Fragment.prototype.eq = function eq(other) {
      if (this.content.length != other.content.length) {
        return false;
      }
      for (var i = 0; i < this.content.length; i++) {
        if (!this.content[i].eq(other.content[i])) {
          return false;
        }
      }
      return true;
    };
    prototypeAccessors.firstChild.get = function() {
      return this.content.length ? this.content[0] : null;
    };
    prototypeAccessors.lastChild.get = function() {
      return this.content.length ? this.content[this.content.length - 1] : null;
    };
    prototypeAccessors.childCount.get = function() {
      return this.content.length;
    };
    Fragment.prototype.child = function child(index2) {
      var found2 = this.content[index2];
      if (!found2) {
        throw new RangeError("Index " + index2 + " out of range for " + this);
      }
      return found2;
    };
    Fragment.prototype.maybeChild = function maybeChild(index2) {
      return this.content[index2];
    };
    Fragment.prototype.forEach = function forEach(f) {
      for (var i = 0, p = 0; i < this.content.length; i++) {
        var child = this.content[i];
        f(child, p, i);
        p += child.nodeSize;
      }
    };
    Fragment.prototype.findDiffStart = function findDiffStart$1(other, pos) {
      if (pos === void 0)
        pos = 0;
      return findDiffStart(this, other, pos);
    };
    Fragment.prototype.findDiffEnd = function findDiffEnd$1(other, pos, otherPos) {
      if (pos === void 0)
        pos = this.size;
      if (otherPos === void 0)
        otherPos = other.size;
      return findDiffEnd(this, other, pos, otherPos);
    };
    Fragment.prototype.findIndex = function findIndex(pos, round) {
      if (round === void 0)
        round = -1;
      if (pos == 0) {
        return retIndex(0, pos);
      }
      if (pos == this.size) {
        return retIndex(this.content.length, pos);
      }
      if (pos > this.size || pos < 0) {
        throw new RangeError("Position " + pos + " outside of fragment (" + this + ")");
      }
      for (var i = 0, curPos = 0; ; i++) {
        var cur = this.child(i), end = curPos + cur.nodeSize;
        if (end >= pos) {
          if (end == pos || round > 0) {
            return retIndex(i + 1, end);
          }
          return retIndex(i, curPos);
        }
        curPos = end;
      }
    };
    Fragment.prototype.toString = function toString() {
      return "<" + this.toStringInner() + ">";
    };
    Fragment.prototype.toStringInner = function toStringInner() {
      return this.content.join(", ");
    };
    Fragment.prototype.toJSON = function toJSON() {
      return this.content.length ? this.content.map(function(n) {
        return n.toJSON();
      }) : null;
    };
    Fragment.fromJSON = function fromJSON(schema, value) {
      if (!value) {
        return Fragment.empty;
      }
      if (!Array.isArray(value)) {
        throw new RangeError("Invalid input for Fragment.fromJSON");
      }
      return new Fragment(value.map(schema.nodeFromJSON));
    };
    Fragment.fromArray = function fromArray(array) {
      if (!array.length) {
        return Fragment.empty;
      }
      var joined, size = 0;
      for (var i = 0; i < array.length; i++) {
        var node = array[i];
        size += node.nodeSize;
        if (i && node.isText && array[i - 1].sameMarkup(node)) {
          if (!joined) {
            joined = array.slice(0, i);
          }
          joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text);
        } else if (joined) {
          joined.push(node);
        }
      }
      return new Fragment(joined || array, size);
    };
    Fragment.from = function from(nodes) {
      if (!nodes) {
        return Fragment.empty;
      }
      if (nodes instanceof Fragment) {
        return nodes;
      }
      if (Array.isArray(nodes)) {
        return this.fromArray(nodes);
      }
      if (nodes.attrs) {
        return new Fragment([nodes], nodes.nodeSize);
      }
      throw new RangeError("Can not convert " + nodes + " to a Fragment" + (nodes.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
    };
    Object.defineProperties(Fragment.prototype, prototypeAccessors);
    var found = { index: 0, offset: 0 };
    function retIndex(index2, offset) {
      found.index = index2;
      found.offset = offset;
      return found;
    }
    Fragment.empty = new Fragment([], 0);
    function compareDeep(a, b) {
      if (a === b) {
        return true;
      }
      if (!(a && typeof a == "object") || !(b && typeof b == "object")) {
        return false;
      }
      var array = Array.isArray(a);
      if (Array.isArray(b) != array) {
        return false;
      }
      if (array) {
        if (a.length != b.length) {
          return false;
        }
        for (var i = 0; i < a.length; i++) {
          if (!compareDeep(a[i], b[i])) {
            return false;
          }
        }
      } else {
        for (var p in a) {
          if (!(p in b) || !compareDeep(a[p], b[p])) {
            return false;
          }
        }
        for (var p$1 in b) {
          if (!(p$1 in a)) {
            return false;
          }
        }
      }
      return true;
    }
    var Mark = function Mark2(type, attrs) {
      this.type = type;
      this.attrs = attrs;
    };
    Mark.prototype.addToSet = function addToSet(set) {
      var copy3, placed = false;
      for (var i = 0; i < set.length; i++) {
        var other = set[i];
        if (this.eq(other)) {
          return set;
        }
        if (this.type.excludes(other.type)) {
          if (!copy3) {
            copy3 = set.slice(0, i);
          }
        } else if (other.type.excludes(this.type)) {
          return set;
        } else {
          if (!placed && other.type.rank > this.type.rank) {
            if (!copy3) {
              copy3 = set.slice(0, i);
            }
            copy3.push(this);
            placed = true;
          }
          if (copy3) {
            copy3.push(other);
          }
        }
      }
      if (!copy3) {
        copy3 = set.slice();
      }
      if (!placed) {
        copy3.push(this);
      }
      return copy3;
    };
    Mark.prototype.removeFromSet = function removeFromSet(set) {
      for (var i = 0; i < set.length; i++) {
        if (this.eq(set[i])) {
          return set.slice(0, i).concat(set.slice(i + 1));
        }
      }
      return set;
    };
    Mark.prototype.isInSet = function isInSet(set) {
      for (var i = 0; i < set.length; i++) {
        if (this.eq(set[i])) {
          return true;
        }
      }
      return false;
    };
    Mark.prototype.eq = function eq(other) {
      return this == other || this.type == other.type && compareDeep(this.attrs, other.attrs);
    };
    Mark.prototype.toJSON = function toJSON() {
      var obj = { type: this.type.name };
      for (var _ in this.attrs) {
        obj.attrs = this.attrs;
        break;
      }
      return obj;
    };
    Mark.fromJSON = function fromJSON(schema, json) {
      if (!json) {
        throw new RangeError("Invalid input for Mark.fromJSON");
      }
      var type = schema.marks[json.type];
      if (!type) {
        throw new RangeError("There is no mark type " + json.type + " in this schema");
      }
      return type.create(json.attrs);
    };
    Mark.sameSet = function sameSet(a, b) {
      if (a == b) {
        return true;
      }
      if (a.length != b.length) {
        return false;
      }
      for (var i = 0; i < a.length; i++) {
        if (!a[i].eq(b[i])) {
          return false;
        }
      }
      return true;
    };
    Mark.setFrom = function setFrom(marks) {
      if (!marks || marks.length == 0) {
        return Mark.none;
      }
      if (marks instanceof Mark) {
        return [marks];
      }
      var copy3 = marks.slice();
      copy3.sort(function(a, b) {
        return a.type.rank - b.type.rank;
      });
      return copy3;
    };
    Mark.none = [];
    function ReplaceError(message) {
      var err = Error.call(this, message);
      err.__proto__ = ReplaceError.prototype;
      return err;
    }
    ReplaceError.prototype = Object.create(Error.prototype);
    ReplaceError.prototype.constructor = ReplaceError;
    ReplaceError.prototype.name = "ReplaceError";
    var Slice = function Slice2(content, openStart, openEnd) {
      this.content = content;
      this.openStart = openStart;
      this.openEnd = openEnd;
    };
    var prototypeAccessors$1 = { size: { configurable: true } };
    prototypeAccessors$1.size.get = function() {
      return this.content.size - this.openStart - this.openEnd;
    };
    Slice.prototype.insertAt = function insertAt(pos, fragment) {
      var content = insertInto(this.content, pos + this.openStart, fragment, null);
      return content && new Slice(content, this.openStart, this.openEnd);
    };
    Slice.prototype.removeBetween = function removeBetween(from, to) {
      return new Slice(removeRange(this.content, from + this.openStart, to + this.openStart), this.openStart, this.openEnd);
    };
    Slice.prototype.eq = function eq(other) {
      return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;
    };
    Slice.prototype.toString = function toString() {
      return this.content + "(" + this.openStart + "," + this.openEnd + ")";
    };
    Slice.prototype.toJSON = function toJSON() {
      if (!this.content.size) {
        return null;
      }
      var json = { content: this.content.toJSON() };
      if (this.openStart > 0) {
        json.openStart = this.openStart;
      }
      if (this.openEnd > 0) {
        json.openEnd = this.openEnd;
      }
      return json;
    };
    Slice.fromJSON = function fromJSON(schema, json) {
      if (!json) {
        return Slice.empty;
      }
      var openStart = json.openStart || 0, openEnd = json.openEnd || 0;
      if (typeof openStart != "number" || typeof openEnd != "number") {
        throw new RangeError("Invalid input for Slice.fromJSON");
      }
      return new Slice(Fragment.fromJSON(schema, json.content), openStart, openEnd);
    };
    Slice.maxOpen = function maxOpen(fragment, openIsolating) {
      if (openIsolating === void 0)
        openIsolating = true;
      var openStart = 0, openEnd = 0;
      for (var n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild) {
        openStart++;
      }
      for (var n$1 = fragment.lastChild; n$1 && !n$1.isLeaf && (openIsolating || !n$1.type.spec.isolating); n$1 = n$1.lastChild) {
        openEnd++;
      }
      return new Slice(fragment, openStart, openEnd);
    };
    Object.defineProperties(Slice.prototype, prototypeAccessors$1);
    function removeRange(content, from, to) {
      var ref = content.findIndex(from);
      var index2 = ref.index;
      var offset = ref.offset;
      var child = content.maybeChild(index2);
      var ref$1 = content.findIndex(to);
      var indexTo = ref$1.index;
      var offsetTo = ref$1.offset;
      if (offset == from || child.isText) {
        if (offsetTo != to && !content.child(indexTo).isText) {
          throw new RangeError("Removing non-flat range");
        }
        return content.cut(0, from).append(content.cut(to));
      }
      if (index2 != indexTo) {
        throw new RangeError("Removing non-flat range");
      }
      return content.replaceChild(index2, child.copy(removeRange(child.content, from - offset - 1, to - offset - 1)));
    }
    function insertInto(content, dist, insert, parent) {
      var ref = content.findIndex(dist);
      var index2 = ref.index;
      var offset = ref.offset;
      var child = content.maybeChild(index2);
      if (offset == dist || child.isText) {
        if (parent && !parent.canReplace(index2, index2, insert)) {
          return null;
        }
        return content.cut(0, dist).append(insert).append(content.cut(dist));
      }
      var inner = insertInto(child.content, dist - offset - 1, insert);
      return inner && content.replaceChild(index2, child.copy(inner));
    }
    Slice.empty = new Slice(Fragment.empty, 0, 0);
    function replace($from, $to, slice) {
      if (slice.openStart > $from.depth) {
        throw new ReplaceError("Inserted content deeper than insertion position");
      }
      if ($from.depth - slice.openStart != $to.depth - slice.openEnd) {
        throw new ReplaceError("Inconsistent open depths");
      }
      return replaceOuter($from, $to, slice, 0);
    }
    function replaceOuter($from, $to, slice, depth) {
      var index2 = $from.index(depth), node = $from.node(depth);
      if (index2 == $to.index(depth) && depth < $from.depth - slice.openStart) {
        var inner = replaceOuter($from, $to, slice, depth + 1);
        return node.copy(node.content.replaceChild(index2, inner));
      } else if (!slice.content.size) {
        return close(node, replaceTwoWay($from, $to, depth));
      } else if (!slice.openStart && !slice.openEnd && $from.depth == depth && $to.depth == depth) {
        var parent = $from.parent, content = parent.content;
        return close(parent, content.cut(0, $from.parentOffset).append(slice.content).append(content.cut($to.parentOffset)));
      } else {
        var ref = prepareSliceForReplace(slice, $from);
        var start = ref.start;
        var end = ref.end;
        return close(node, replaceThreeWay($from, start, end, $to, depth));
      }
    }
    function checkJoin(main, sub) {
      if (!sub.type.compatibleContent(main.type)) {
        throw new ReplaceError("Cannot join " + sub.type.name + " onto " + main.type.name);
      }
    }
    function joinable($before, $after, depth) {
      var node = $before.node(depth);
      checkJoin(node, $after.node(depth));
      return node;
    }
    function addNode(child, target) {
      var last = target.length - 1;
      if (last >= 0 && child.isText && child.sameMarkup(target[last])) {
        target[last] = child.withText(target[last].text + child.text);
      } else {
        target.push(child);
      }
    }
    function addRange($start, $end, depth, target) {
      var node = ($end || $start).node(depth);
      var startIndex = 0, endIndex = $end ? $end.index(depth) : node.childCount;
      if ($start) {
        startIndex = $start.index(depth);
        if ($start.depth > depth) {
          startIndex++;
        } else if ($start.textOffset) {
          addNode($start.nodeAfter, target);
          startIndex++;
        }
      }
      for (var i = startIndex; i < endIndex; i++) {
        addNode(node.child(i), target);
      }
      if ($end && $end.depth == depth && $end.textOffset) {
        addNode($end.nodeBefore, target);
      }
    }
    function close(node, content) {
      if (!node.type.validContent(content)) {
        throw new ReplaceError("Invalid content for node " + node.type.name);
      }
      return node.copy(content);
    }
    function replaceThreeWay($from, $start, $end, $to, depth) {
      var openStart = $from.depth > depth && joinable($from, $start, depth + 1);
      var openEnd = $to.depth > depth && joinable($end, $to, depth + 1);
      var content = [];
      addRange(null, $from, depth, content);
      if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {
        checkJoin(openStart, openEnd);
        addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content);
      } else {
        if (openStart) {
          addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content);
        }
        addRange($start, $end, depth, content);
        if (openEnd) {
          addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content);
        }
      }
      addRange($to, null, depth, content);
      return new Fragment(content);
    }
    function replaceTwoWay($from, $to, depth) {
      var content = [];
      addRange(null, $from, depth, content);
      if ($from.depth > depth) {
        var type = joinable($from, $to, depth + 1);
        addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content);
      }
      addRange($to, null, depth, content);
      return new Fragment(content);
    }
    function prepareSliceForReplace(slice, $along) {
      var extra = $along.depth - slice.openStart, parent = $along.node(extra);
      var node = parent.copy(slice.content);
      for (var i = extra - 1; i >= 0; i--) {
        node = $along.node(i).copy(Fragment.from(node));
      }
      return {
        start: node.resolveNoCache(slice.openStart + extra),
        end: node.resolveNoCache(node.content.size - slice.openEnd - extra)
      };
    }
    var ResolvedPos = function ResolvedPos2(pos, path, parentOffset) {
      this.pos = pos;
      this.path = path;
      this.depth = path.length / 3 - 1;
      this.parentOffset = parentOffset;
    };
    var prototypeAccessors$2 = { parent: { configurable: true }, doc: { configurable: true }, textOffset: { configurable: true }, nodeAfter: { configurable: true }, nodeBefore: { configurable: true } };
    ResolvedPos.prototype.resolveDepth = function resolveDepth(val) {
      if (val == null) {
        return this.depth;
      }
      if (val < 0) {
        return this.depth + val;
      }
      return val;
    };
    prototypeAccessors$2.parent.get = function() {
      return this.node(this.depth);
    };
    prototypeAccessors$2.doc.get = function() {
      return this.node(0);
    };
    ResolvedPos.prototype.node = function node(depth) {
      return this.path[this.resolveDepth(depth) * 3];
    };
    ResolvedPos.prototype.index = function index2(depth) {
      return this.path[this.resolveDepth(depth) * 3 + 1];
    };
    ResolvedPos.prototype.indexAfter = function indexAfter(depth) {
      depth = this.resolveDepth(depth);
      return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);
    };
    ResolvedPos.prototype.start = function start(depth) {
      depth = this.resolveDepth(depth);
      return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
    };
    ResolvedPos.prototype.end = function end(depth) {
      depth = this.resolveDepth(depth);
      return this.start(depth) + this.node(depth).content.size;
    };
    ResolvedPos.prototype.before = function before(depth) {
      depth = this.resolveDepth(depth);
      if (!depth) {
        throw new RangeError("There is no position before the top-level node");
      }
      return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];
    };
    ResolvedPos.prototype.after = function after(depth) {
      depth = this.resolveDepth(depth);
      if (!depth) {
        throw new RangeError("There is no position after the top-level node");
      }
      return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;
    };
    prototypeAccessors$2.textOffset.get = function() {
      return this.pos - this.path[this.path.length - 1];
    };
    prototypeAccessors$2.nodeAfter.get = function() {
      var parent = this.parent, index2 = this.index(this.depth);
      if (index2 == parent.childCount) {
        return null;
      }
      var dOff = this.pos - this.path[this.path.length - 1], child = parent.child(index2);
      return dOff ? parent.child(index2).cut(dOff) : child;
    };
    prototypeAccessors$2.nodeBefore.get = function() {
      var index2 = this.index(this.depth);
      var dOff = this.pos - this.path[this.path.length - 1];
      if (dOff) {
        return this.parent.child(index2).cut(0, dOff);
      }
      return index2 == 0 ? null : this.parent.child(index2 - 1);
    };
    ResolvedPos.prototype.posAtIndex = function posAtIndex(index2, depth) {
      depth = this.resolveDepth(depth);
      var node = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
      for (var i = 0; i < index2; i++) {
        pos += node.child(i).nodeSize;
      }
      return pos;
    };
    ResolvedPos.prototype.marks = function marks() {
      var parent = this.parent, index2 = this.index();
      if (parent.content.size == 0) {
        return Mark.none;
      }
      if (this.textOffset) {
        return parent.child(index2).marks;
      }
      var main = parent.maybeChild(index2 - 1), other = parent.maybeChild(index2);
      if (!main) {
        var tmp = main;
        main = other;
        other = tmp;
      }
      var marks2 = main.marks;
      for (var i = 0; i < marks2.length; i++) {
        if (marks2[i].type.spec.inclusive === false && (!other || !marks2[i].isInSet(other.marks))) {
          marks2 = marks2[i--].removeFromSet(marks2);
        }
      }
      return marks2;
    };
    ResolvedPos.prototype.marksAcross = function marksAcross($end) {
      var after = this.parent.maybeChild(this.index());
      if (!after || !after.isInline) {
        return null;
      }
      var marks = after.marks, next = $end.parent.maybeChild($end.index());
      for (var i = 0; i < marks.length; i++) {
        if (marks[i].type.spec.inclusive === false && (!next || !marks[i].isInSet(next.marks))) {
          marks = marks[i--].removeFromSet(marks);
        }
      }
      return marks;
    };
    ResolvedPos.prototype.sharedDepth = function sharedDepth(pos) {
      for (var depth = this.depth; depth > 0; depth--) {
        if (this.start(depth) <= pos && this.end(depth) >= pos) {
          return depth;
        }
      }
      return 0;
    };
    ResolvedPos.prototype.blockRange = function blockRange(other, pred) {
      if (other === void 0)
        other = this;
      if (other.pos < this.pos) {
        return other.blockRange(this);
      }
      for (var d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--) {
        if (other.pos <= this.end(d) && (!pred || pred(this.node(d)))) {
          return new NodeRange(this, other, d);
        }
      }
    };
    ResolvedPos.prototype.sameParent = function sameParent(other) {
      return this.pos - this.parentOffset == other.pos - other.parentOffset;
    };
    ResolvedPos.prototype.max = function max(other) {
      return other.pos > this.pos ? other : this;
    };
    ResolvedPos.prototype.min = function min(other) {
      return other.pos < this.pos ? other : this;
    };
    ResolvedPos.prototype.toString = function toString() {
      var str = "";
      for (var i = 1; i <= this.depth; i++) {
        str += (str ? "/" : "") + this.node(i).type.name + "_" + this.index(i - 1);
      }
      return str + ":" + this.parentOffset;
    };
    ResolvedPos.resolve = function resolve2(doc2, pos) {
      if (!(pos >= 0 && pos <= doc2.content.size)) {
        throw new RangeError("Position " + pos + " out of range");
      }
      var path = [];
      var start = 0, parentOffset = pos;
      for (var node = doc2; ; ) {
        var ref = node.content.findIndex(parentOffset);
        var index2 = ref.index;
        var offset = ref.offset;
        var rem = parentOffset - offset;
        path.push(node, index2, start + offset);
        if (!rem) {
          break;
        }
        node = node.child(index2);
        if (node.isText) {
          break;
        }
        parentOffset = rem - 1;
        start += offset + 1;
      }
      return new ResolvedPos(pos, path, parentOffset);
    };
    ResolvedPos.resolveCached = function resolveCached(doc2, pos) {
      for (var i = 0; i < resolveCache.length; i++) {
        var cached = resolveCache[i];
        if (cached.pos == pos && cached.doc == doc2) {
          return cached;
        }
      }
      var result = resolveCache[resolveCachePos] = ResolvedPos.resolve(doc2, pos);
      resolveCachePos = (resolveCachePos + 1) % resolveCacheSize;
      return result;
    };
    Object.defineProperties(ResolvedPos.prototype, prototypeAccessors$2);
    var resolveCache = [];
    var resolveCachePos = 0;
    var resolveCacheSize = 12;
    var NodeRange = function NodeRange2($from, $to, depth) {
      this.$from = $from;
      this.$to = $to;
      this.depth = depth;
    };
    var prototypeAccessors$1$1 = { start: { configurable: true }, end: { configurable: true }, parent: { configurable: true }, startIndex: { configurable: true }, endIndex: { configurable: true } };
    prototypeAccessors$1$1.start.get = function() {
      return this.$from.before(this.depth + 1);
    };
    prototypeAccessors$1$1.end.get = function() {
      return this.$to.after(this.depth + 1);
    };
    prototypeAccessors$1$1.parent.get = function() {
      return this.$from.node(this.depth);
    };
    prototypeAccessors$1$1.startIndex.get = function() {
      return this.$from.index(this.depth);
    };
    prototypeAccessors$1$1.endIndex.get = function() {
      return this.$to.indexAfter(this.depth);
    };
    Object.defineProperties(NodeRange.prototype, prototypeAccessors$1$1);
    var emptyAttrs = Object.create(null);
    var Node = function Node2(type, attrs, content, marks) {
      this.type = type;
      this.attrs = attrs;
      this.content = content || Fragment.empty;
      this.marks = marks || Mark.none;
    };
    var prototypeAccessors$3 = { nodeSize: { configurable: true }, childCount: { configurable: true }, textContent: { configurable: true }, firstChild: { configurable: true }, lastChild: { configurable: true }, isBlock: { configurable: true }, isTextblock: { configurable: true }, inlineContent: { configurable: true }, isInline: { configurable: true }, isText: { configurable: true }, isLeaf: { configurable: true }, isAtom: { configurable: true } };
    prototypeAccessors$3.nodeSize.get = function() {
      return this.isLeaf ? 1 : 2 + this.content.size;
    };
    prototypeAccessors$3.childCount.get = function() {
      return this.content.childCount;
    };
    Node.prototype.child = function child(index2) {
      return this.content.child(index2);
    };
    Node.prototype.maybeChild = function maybeChild(index2) {
      return this.content.maybeChild(index2);
    };
    Node.prototype.forEach = function forEach(f) {
      this.content.forEach(f);
    };
    Node.prototype.nodesBetween = function nodesBetween(from, to, f, startPos) {
      if (startPos === void 0)
        startPos = 0;
      this.content.nodesBetween(from, to, f, startPos, this);
    };
    Node.prototype.descendants = function descendants(f) {
      this.nodesBetween(0, this.content.size, f);
    };
    prototypeAccessors$3.textContent.get = function() {
      return this.textBetween(0, this.content.size, "");
    };
    Node.prototype.textBetween = function textBetween(from, to, blockSeparator, leafText) {
      return this.content.textBetween(from, to, blockSeparator, leafText);
    };
    prototypeAccessors$3.firstChild.get = function() {
      return this.content.firstChild;
    };
    prototypeAccessors$3.lastChild.get = function() {
      return this.content.lastChild;
    };
    Node.prototype.eq = function eq(other) {
      return this == other || this.sameMarkup(other) && this.content.eq(other.content);
    };
    Node.prototype.sameMarkup = function sameMarkup(other) {
      return this.hasMarkup(other.type, other.attrs, other.marks);
    };
    Node.prototype.hasMarkup = function hasMarkup(type, attrs, marks) {
      return this.type == type && compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) && Mark.sameSet(this.marks, marks || Mark.none);
    };
    Node.prototype.copy = function copy3(content) {
      if (content === void 0)
        content = null;
      if (content == this.content) {
        return this;
      }
      return new this.constructor(this.type, this.attrs, content, this.marks);
    };
    Node.prototype.mark = function mark(marks) {
      return marks == this.marks ? this : new this.constructor(this.type, this.attrs, this.content, marks);
    };
    Node.prototype.cut = function cut(from, to) {
      if (from == 0 && to == this.content.size) {
        return this;
      }
      return this.copy(this.content.cut(from, to));
    };
    Node.prototype.slice = function slice(from, to, includeParents) {
      if (to === void 0)
        to = this.content.size;
      if (includeParents === void 0)
        includeParents = false;
      if (from == to) {
        return Slice.empty;
      }
      var $from = this.resolve(from), $to = this.resolve(to);
      var depth = includeParents ? 0 : $from.sharedDepth(to);
      var start = $from.start(depth), node = $from.node(depth);
      var content = node.content.cut($from.pos - start, $to.pos - start);
      return new Slice(content, $from.depth - depth, $to.depth - depth);
    };
    Node.prototype.replace = function replace$1(from, to, slice) {
      return replace(this.resolve(from), this.resolve(to), slice);
    };
    Node.prototype.nodeAt = function nodeAt(pos) {
      for (var node = this; ; ) {
        var ref = node.content.findIndex(pos);
        var index2 = ref.index;
        var offset = ref.offset;
        node = node.maybeChild(index2);
        if (!node) {
          return null;
        }
        if (offset == pos || node.isText) {
          return node;
        }
        pos -= offset + 1;
      }
    };
    Node.prototype.childAfter = function childAfter(pos) {
      var ref = this.content.findIndex(pos);
      var index2 = ref.index;
      var offset = ref.offset;
      return { node: this.content.maybeChild(index2), index: index2, offset };
    };
    Node.prototype.childBefore = function childBefore(pos) {
      if (pos == 0) {
        return { node: null, index: 0, offset: 0 };
      }
      var ref = this.content.findIndex(pos);
      var index2 = ref.index;
      var offset = ref.offset;
      if (offset < pos) {
        return { node: this.content.child(index2), index: index2, offset };
      }
      var node = this.content.child(index2 - 1);
      return { node, index: index2 - 1, offset: offset - node.nodeSize };
    };
    Node.prototype.resolve = function resolve2(pos) {
      return ResolvedPos.resolveCached(this, pos);
    };
    Node.prototype.resolveNoCache = function resolveNoCache(pos) {
      return ResolvedPos.resolve(this, pos);
    };
    Node.prototype.rangeHasMark = function rangeHasMark(from, to, type) {
      var found2 = false;
      if (to > from) {
        this.nodesBetween(from, to, function(node) {
          if (type.isInSet(node.marks)) {
            found2 = true;
          }
          return !found2;
        });
      }
      return found2;
    };
    prototypeAccessors$3.isBlock.get = function() {
      return this.type.isBlock;
    };
    prototypeAccessors$3.isTextblock.get = function() {
      return this.type.isTextblock;
    };
    prototypeAccessors$3.inlineContent.get = function() {
      return this.type.inlineContent;
    };
    prototypeAccessors$3.isInline.get = function() {
      return this.type.isInline;
    };
    prototypeAccessors$3.isText.get = function() {
      return this.type.isText;
    };
    prototypeAccessors$3.isLeaf.get = function() {
      return this.type.isLeaf;
    };
    prototypeAccessors$3.isAtom.get = function() {
      return this.type.isAtom;
    };
    Node.prototype.toString = function toString() {
      if (this.type.spec.toDebugString) {
        return this.type.spec.toDebugString(this);
      }
      var name = this.type.name;
      if (this.content.size) {
        name += "(" + this.content.toStringInner() + ")";
      }
      return wrapMarks(this.marks, name);
    };
    Node.prototype.contentMatchAt = function contentMatchAt(index2) {
      var match = this.type.contentMatch.matchFragment(this.content, 0, index2);
      if (!match) {
        throw new Error("Called contentMatchAt on a node with invalid content");
      }
      return match;
    };
    Node.prototype.canReplace = function canReplace(from, to, replacement, start, end) {
      if (replacement === void 0)
        replacement = Fragment.empty;
      if (start === void 0)
        start = 0;
      if (end === void 0)
        end = replacement.childCount;
      var one2 = this.contentMatchAt(from).matchFragment(replacement, start, end);
      var two = one2 && one2.matchFragment(this.content, to);
      if (!two || !two.validEnd) {
        return false;
      }
      for (var i = start; i < end; i++) {
        if (!this.type.allowsMarks(replacement.child(i).marks)) {
          return false;
        }
      }
      return true;
    };
    Node.prototype.canReplaceWith = function canReplaceWith(from, to, type, marks) {
      if (marks && !this.type.allowsMarks(marks)) {
        return false;
      }
      var start = this.contentMatchAt(from).matchType(type);
      var end = start && start.matchFragment(this.content, to);
      return end ? end.validEnd : false;
    };
    Node.prototype.canAppend = function canAppend(other) {
      if (other.content.size) {
        return this.canReplace(this.childCount, this.childCount, other.content);
      } else {
        return this.type.compatibleContent(other.type);
      }
    };
    Node.prototype.check = function check() {
      if (!this.type.validContent(this.content)) {
        throw new RangeError("Invalid content for node " + this.type.name + ": " + this.content.toString().slice(0, 50));
      }
      var copy3 = Mark.none;
      for (var i = 0; i < this.marks.length; i++) {
        copy3 = this.marks[i].addToSet(copy3);
      }
      if (!Mark.sameSet(copy3, this.marks)) {
        throw new RangeError("Invalid collection of marks for node " + this.type.name + ": " + this.marks.map(function(m) {
          return m.type.name;
        }));
      }
      this.content.forEach(function(node) {
        return node.check();
      });
    };
    Node.prototype.toJSON = function toJSON() {
      var obj = { type: this.type.name };
      for (var _ in this.attrs) {
        obj.attrs = this.attrs;
        break;
      }
      if (this.content.size) {
        obj.content = this.content.toJSON();
      }
      if (this.marks.length) {
        obj.marks = this.marks.map(function(n) {
          return n.toJSON();
        });
      }
      return obj;
    };
    Node.fromJSON = function fromJSON(schema, json) {
      if (!json) {
        throw new RangeError("Invalid input for Node.fromJSON");
      }
      var marks = null;
      if (json.marks) {
        if (!Array.isArray(json.marks)) {
          throw new RangeError("Invalid mark data for Node.fromJSON");
        }
        marks = json.marks.map(schema.markFromJSON);
      }
      if (json.type == "text") {
        if (typeof json.text != "string") {
          throw new RangeError("Invalid text node in JSON");
        }
        return schema.text(json.text, marks);
      }
      var content = Fragment.fromJSON(schema, json.content);
      return schema.nodeType(json.type).create(json.attrs, content, marks);
    };
    Object.defineProperties(Node.prototype, prototypeAccessors$3);
    var TextNode = /* @__PURE__ */ function(Node2) {
      function TextNode2(type, attrs, content, marks) {
        Node2.call(this, type, attrs, null, marks);
        if (!content) {
          throw new RangeError("Empty text nodes are not allowed");
        }
        this.text = content;
      }
      if (Node2)
        TextNode2.__proto__ = Node2;
      TextNode2.prototype = Object.create(Node2 && Node2.prototype);
      TextNode2.prototype.constructor = TextNode2;
      var prototypeAccessors$12 = { textContent: { configurable: true }, nodeSize: { configurable: true } };
      TextNode2.prototype.toString = function toString() {
        if (this.type.spec.toDebugString) {
          return this.type.spec.toDebugString(this);
        }
        return wrapMarks(this.marks, JSON.stringify(this.text));
      };
      prototypeAccessors$12.textContent.get = function() {
        return this.text;
      };
      TextNode2.prototype.textBetween = function textBetween(from, to) {
        return this.text.slice(from, to);
      };
      prototypeAccessors$12.nodeSize.get = function() {
        return this.text.length;
      };
      TextNode2.prototype.mark = function mark(marks) {
        return marks == this.marks ? this : new TextNode2(this.type, this.attrs, this.text, marks);
      };
      TextNode2.prototype.withText = function withText(text) {
        if (text == this.text) {
          return this;
        }
        return new TextNode2(this.type, this.attrs, text, this.marks);
      };
      TextNode2.prototype.cut = function cut(from, to) {
        if (from === void 0)
          from = 0;
        if (to === void 0)
          to = this.text.length;
        if (from == 0 && to == this.text.length) {
          return this;
        }
        return this.withText(this.text.slice(from, to));
      };
      TextNode2.prototype.eq = function eq(other) {
        return this.sameMarkup(other) && this.text == other.text;
      };
      TextNode2.prototype.toJSON = function toJSON() {
        var base2 = Node2.prototype.toJSON.call(this);
        base2.text = this.text;
        return base2;
      };
      Object.defineProperties(TextNode2.prototype, prototypeAccessors$12);
      return TextNode2;
    }(Node);
    function wrapMarks(marks, str) {
      for (var i = marks.length - 1; i >= 0; i--) {
        str = marks[i].type.name + "(" + str + ")";
      }
      return str;
    }
    var ContentMatch = function ContentMatch2(validEnd) {
      this.validEnd = validEnd;
      this.next = [];
      this.wrapCache = [];
    };
    var prototypeAccessors$4 = { inlineContent: { configurable: true }, defaultType: { configurable: true }, edgeCount: { configurable: true } };
    ContentMatch.parse = function parse(string2, nodeTypes) {
      var stream = new TokenStream(string2, nodeTypes);
      if (stream.next == null) {
        return ContentMatch.empty;
      }
      var expr = parseExpr(stream);
      if (stream.next) {
        stream.err("Unexpected trailing text");
      }
      var match = dfa(nfa(expr));
      checkForDeadEnds(match, stream);
      return match;
    };
    ContentMatch.prototype.matchType = function matchType(type) {
      for (var i = 0; i < this.next.length; i += 2) {
        if (this.next[i] == type) {
          return this.next[i + 1];
        }
      }
      return null;
    };
    ContentMatch.prototype.matchFragment = function matchFragment(frag, start, end) {
      if (start === void 0)
        start = 0;
      if (end === void 0)
        end = frag.childCount;
      var cur = this;
      for (var i = start; cur && i < end; i++) {
        cur = cur.matchType(frag.child(i).type);
      }
      return cur;
    };
    prototypeAccessors$4.inlineContent.get = function() {
      var first = this.next[0];
      return first ? first.isInline : false;
    };
    prototypeAccessors$4.defaultType.get = function() {
      for (var i = 0; i < this.next.length; i += 2) {
        var type = this.next[i];
        if (!(type.isText || type.hasRequiredAttrs())) {
          return type;
        }
      }
    };
    ContentMatch.prototype.compatible = function compatible(other) {
      for (var i = 0; i < this.next.length; i += 2) {
        for (var j = 0; j < other.next.length; j += 2) {
          if (this.next[i] == other.next[j]) {
            return true;
          }
        }
      }
      return false;
    };
    ContentMatch.prototype.fillBefore = function fillBefore(after, toEnd, startIndex) {
      if (toEnd === void 0)
        toEnd = false;
      if (startIndex === void 0)
        startIndex = 0;
      var seen = [this];
      function search(match, types2) {
        var finished = match.matchFragment(after, startIndex);
        if (finished && (!toEnd || finished.validEnd)) {
          return Fragment.from(types2.map(function(tp) {
            return tp.createAndFill();
          }));
        }
        for (var i = 0; i < match.next.length; i += 2) {
          var type = match.next[i], next = match.next[i + 1];
          if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {
            seen.push(next);
            var found2 = search(next, types2.concat(type));
            if (found2) {
              return found2;
            }
          }
        }
      }
      return search(this, []);
    };
    ContentMatch.prototype.findWrapping = function findWrapping(target) {
      for (var i = 0; i < this.wrapCache.length; i += 2) {
        if (this.wrapCache[i] == target) {
          return this.wrapCache[i + 1];
        }
      }
      var computed = this.computeWrapping(target);
      this.wrapCache.push(target, computed);
      return computed;
    };
    ContentMatch.prototype.computeWrapping = function computeWrapping(target) {
      var seen = Object.create(null), active = [{ match: this, type: null, via: null }];
      while (active.length) {
        var current = active.shift(), match = current.match;
        if (match.matchType(target)) {
          var result = [];
          for (var obj = current; obj.type; obj = obj.via) {
            result.push(obj.type);
          }
          return result.reverse();
        }
        for (var i = 0; i < match.next.length; i += 2) {
          var type = match.next[i];
          if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || match.next[i + 1].validEnd)) {
            active.push({ match: type.contentMatch, type, via: current });
            seen[type.name] = true;
          }
        }
      }
    };
    prototypeAccessors$4.edgeCount.get = function() {
      return this.next.length >> 1;
    };
    ContentMatch.prototype.edge = function edge(n) {
      var i = n << 1;
      if (i >= this.next.length) {
        throw new RangeError("There's no " + n + "th edge in this content match");
      }
      return { type: this.next[i], next: this.next[i + 1] };
    };
    ContentMatch.prototype.toString = function toString() {
      var seen = [];
      function scan(m) {
        seen.push(m);
        for (var i = 1; i < m.next.length; i += 2) {
          if (seen.indexOf(m.next[i]) == -1) {
            scan(m.next[i]);
          }
        }
      }
      scan(this);
      return seen.map(function(m, i) {
        var out = i + (m.validEnd ? "*" : " ") + " ";
        for (var i$1 = 0; i$1 < m.next.length; i$1 += 2) {
          out += (i$1 ? ", " : "") + m.next[i$1].name + "->" + seen.indexOf(m.next[i$1 + 1]);
        }
        return out;
      }).join("\n");
    };
    Object.defineProperties(ContentMatch.prototype, prototypeAccessors$4);
    ContentMatch.empty = new ContentMatch(true);
    var TokenStream = function TokenStream2(string2, nodeTypes) {
      this.string = string2;
      this.nodeTypes = nodeTypes;
      this.inline = null;
      this.pos = 0;
      this.tokens = string2.split(/\s*(?=\b|\W|$)/);
      if (this.tokens[this.tokens.length - 1] == "") {
        this.tokens.pop();
      }
      if (this.tokens[0] == "") {
        this.tokens.shift();
      }
    };
    var prototypeAccessors$1$2 = { next: { configurable: true } };
    prototypeAccessors$1$2.next.get = function() {
      return this.tokens[this.pos];
    };
    TokenStream.prototype.eat = function eat(tok) {
      return this.next == tok && (this.pos++ || true);
    };
    TokenStream.prototype.err = function err(str) {
      throw new SyntaxError(str + " (in content expression '" + this.string + "')");
    };
    Object.defineProperties(TokenStream.prototype, prototypeAccessors$1$2);
    function parseExpr(stream) {
      var exprs = [];
      do {
        exprs.push(parseExprSeq(stream));
      } while (stream.eat("|"));
      return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
    }
    function parseExprSeq(stream) {
      var exprs = [];
      do {
        exprs.push(parseExprSubscript(stream));
      } while (stream.next && stream.next != ")" && stream.next != "|");
      return exprs.length == 1 ? exprs[0] : { type: "seq", exprs };
    }
    function parseExprSubscript(stream) {
      var expr = parseExprAtom(stream);
      for (; ; ) {
        if (stream.eat("+")) {
          expr = { type: "plus", expr };
        } else if (stream.eat("*")) {
          expr = { type: "star", expr };
        } else if (stream.eat("?")) {
          expr = { type: "opt", expr };
        } else if (stream.eat("{")) {
          expr = parseExprRange(stream, expr);
        } else {
          break;
        }
      }
      return expr;
    }
    function parseNum(stream) {
      if (/\D/.test(stream.next)) {
        stream.err("Expected number, got '" + stream.next + "'");
      }
      var result = Number(stream.next);
      stream.pos++;
      return result;
    }
    function parseExprRange(stream, expr) {
      var min = parseNum(stream), max = min;
      if (stream.eat(",")) {
        if (stream.next != "}") {
          max = parseNum(stream);
        } else {
          max = -1;
        }
      }
      if (!stream.eat("}")) {
        stream.err("Unclosed braced range");
      }
      return { type: "range", min, max, expr };
    }
    function resolveName(stream, name) {
      var types2 = stream.nodeTypes, type = types2[name];
      if (type) {
        return [type];
      }
      var result = [];
      for (var typeName in types2) {
        var type$1 = types2[typeName];
        if (type$1.groups.indexOf(name) > -1) {
          result.push(type$1);
        }
      }
      if (result.length == 0) {
        stream.err("No node type or group '" + name + "' found");
      }
      return result;
    }
    function parseExprAtom(stream) {
      if (stream.eat("(")) {
        var expr = parseExpr(stream);
        if (!stream.eat(")")) {
          stream.err("Missing closing paren");
        }
        return expr;
      } else if (!/\W/.test(stream.next)) {
        var exprs = resolveName(stream, stream.next).map(function(type) {
          if (stream.inline == null) {
            stream.inline = type.isInline;
          } else if (stream.inline != type.isInline) {
            stream.err("Mixing inline and block content");
          }
          return { type: "name", value: type };
        });
        stream.pos++;
        return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
      } else {
        stream.err("Unexpected token '" + stream.next + "'");
      }
    }
    function nfa(expr) {
      var nfa2 = [[]];
      connect(compile(expr, 0), node());
      return nfa2;
      function node() {
        return nfa2.push([]) - 1;
      }
      function edge(from, to, term) {
        var edge2 = { term, to };
        nfa2[from].push(edge2);
        return edge2;
      }
      function connect(edges, to) {
        edges.forEach(function(edge2) {
          return edge2.to = to;
        });
      }
      function compile(expr2, from) {
        if (expr2.type == "choice") {
          return expr2.exprs.reduce(function(out, expr3) {
            return out.concat(compile(expr3, from));
          }, []);
        } else if (expr2.type == "seq") {
          for (var i = 0; ; i++) {
            var next = compile(expr2.exprs[i], from);
            if (i == expr2.exprs.length - 1) {
              return next;
            }
            connect(next, from = node());
          }
        } else if (expr2.type == "star") {
          var loop = node();
          edge(from, loop);
          connect(compile(expr2.expr, loop), loop);
          return [edge(loop)];
        } else if (expr2.type == "plus") {
          var loop$1 = node();
          connect(compile(expr2.expr, from), loop$1);
          connect(compile(expr2.expr, loop$1), loop$1);
          return [edge(loop$1)];
        } else if (expr2.type == "opt") {
          return [edge(from)].concat(compile(expr2.expr, from));
        } else if (expr2.type == "range") {
          var cur = from;
          for (var i$1 = 0; i$1 < expr2.min; i$1++) {
            var next$1 = node();
            connect(compile(expr2.expr, cur), next$1);
            cur = next$1;
          }
          if (expr2.max == -1) {
            connect(compile(expr2.expr, cur), cur);
          } else {
            for (var i$2 = expr2.min; i$2 < expr2.max; i$2++) {
              var next$2 = node();
              edge(cur, next$2);
              connect(compile(expr2.expr, cur), next$2);
              cur = next$2;
            }
          }
          return [edge(cur)];
        } else if (expr2.type == "name") {
          return [edge(from, null, expr2.value)];
        }
      }
    }
    function cmp(a, b) {
      return b - a;
    }
    function nullFrom(nfa2, node) {
      var result = [];
      scan(node);
      return result.sort(cmp);
      function scan(node2) {
        var edges = nfa2[node2];
        if (edges.length == 1 && !edges[0].term) {
          return scan(edges[0].to);
        }
        result.push(node2);
        for (var i = 0; i < edges.length; i++) {
          var ref = edges[i];
          var term = ref.term;
          var to = ref.to;
          if (!term && result.indexOf(to) == -1) {
            scan(to);
          }
        }
      }
    }
    function dfa(nfa2) {
      var labeled = Object.create(null);
      return explore(nullFrom(nfa2, 0));
      function explore(states) {
        var out = [];
        states.forEach(function(node) {
          nfa2[node].forEach(function(ref) {
            var term = ref.term;
            var to = ref.to;
            if (!term) {
              return;
            }
            var known = out.indexOf(term), set = known > -1 && out[known + 1];
            nullFrom(nfa2, to).forEach(function(node2) {
              if (!set) {
                out.push(term, set = []);
              }
              if (set.indexOf(node2) == -1) {
                set.push(node2);
              }
            });
          });
        });
        var state = labeled[states.join(",")] = new ContentMatch(states.indexOf(nfa2.length - 1) > -1);
        for (var i = 0; i < out.length; i += 2) {
          var states$1 = out[i + 1].sort(cmp);
          state.next.push(out[i], labeled[states$1.join(",")] || explore(states$1));
        }
        return state;
      }
    }
    function checkForDeadEnds(match, stream) {
      for (var i = 0, work = [match]; i < work.length; i++) {
        var state = work[i], dead = !state.validEnd, nodes = [];
        for (var j = 0; j < state.next.length; j += 2) {
          var node = state.next[j], next = state.next[j + 1];
          nodes.push(node.name);
          if (dead && !(node.isText || node.hasRequiredAttrs())) {
            dead = false;
          }
          if (work.indexOf(next) == -1) {
            work.push(next);
          }
        }
        if (dead) {
          stream.err("Only non-generatable nodes (" + nodes.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
        }
      }
    }
    function defaultAttrs(attrs) {
      var defaults = Object.create(null);
      for (var attrName in attrs) {
        var attr = attrs[attrName];
        if (!attr.hasDefault) {
          return null;
        }
        defaults[attrName] = attr.default;
      }
      return defaults;
    }
    function computeAttrs(attrs, value) {
      var built = Object.create(null);
      for (var name in attrs) {
        var given = value && value[name];
        if (given === void 0) {
          var attr = attrs[name];
          if (attr.hasDefault) {
            given = attr.default;
          } else {
            throw new RangeError("No value supplied for attribute " + name);
          }
        }
        built[name] = given;
      }
      return built;
    }
    function initAttrs(attrs) {
      var result = Object.create(null);
      if (attrs) {
        for (var name in attrs) {
          result[name] = new Attribute(attrs[name]);
        }
      }
      return result;
    }
    var NodeType = function NodeType2(name, schema, spec) {
      this.name = name;
      this.schema = schema;
      this.spec = spec;
      this.groups = spec.group ? spec.group.split(" ") : [];
      this.attrs = initAttrs(spec.attrs);
      this.defaultAttrs = defaultAttrs(this.attrs);
      this.contentMatch = null;
      this.markSet = null;
      this.inlineContent = null;
      this.isBlock = !(spec.inline || name == "text");
      this.isText = name == "text";
    };
    var prototypeAccessors$5 = { isInline: { configurable: true }, isTextblock: { configurable: true }, isLeaf: { configurable: true }, isAtom: { configurable: true } };
    prototypeAccessors$5.isInline.get = function() {
      return !this.isBlock;
    };
    prototypeAccessors$5.isTextblock.get = function() {
      return this.isBlock && this.inlineContent;
    };
    prototypeAccessors$5.isLeaf.get = function() {
      return this.contentMatch == ContentMatch.empty;
    };
    prototypeAccessors$5.isAtom.get = function() {
      return this.isLeaf || this.spec.atom;
    };
    NodeType.prototype.hasRequiredAttrs = function hasRequiredAttrs() {
      for (var n in this.attrs) {
        if (this.attrs[n].isRequired) {
          return true;
        }
      }
      return false;
    };
    NodeType.prototype.compatibleContent = function compatibleContent(other) {
      return this == other || this.contentMatch.compatible(other.contentMatch);
    };
    NodeType.prototype.computeAttrs = function computeAttrs$1(attrs) {
      if (!attrs && this.defaultAttrs) {
        return this.defaultAttrs;
      } else {
        return computeAttrs(this.attrs, attrs);
      }
    };
    NodeType.prototype.create = function create(attrs, content, marks) {
      if (this.isText) {
        throw new Error("NodeType.create can't construct text nodes");
      }
      return new Node(this, this.computeAttrs(attrs), Fragment.from(content), Mark.setFrom(marks));
    };
    NodeType.prototype.createChecked = function createChecked(attrs, content, marks) {
      content = Fragment.from(content);
      if (!this.validContent(content)) {
        throw new RangeError("Invalid content for node " + this.name);
      }
      return new Node(this, this.computeAttrs(attrs), content, Mark.setFrom(marks));
    };
    NodeType.prototype.createAndFill = function createAndFill(attrs, content, marks) {
      attrs = this.computeAttrs(attrs);
      content = Fragment.from(content);
      if (content.size) {
        var before = this.contentMatch.fillBefore(content);
        if (!before) {
          return null;
        }
        content = before.append(content);
      }
      var after = this.contentMatch.matchFragment(content).fillBefore(Fragment.empty, true);
      if (!after) {
        return null;
      }
      return new Node(this, attrs, content.append(after), Mark.setFrom(marks));
    };
    NodeType.prototype.validContent = function validContent(content) {
      var result = this.contentMatch.matchFragment(content);
      if (!result || !result.validEnd) {
        return false;
      }
      for (var i = 0; i < content.childCount; i++) {
        if (!this.allowsMarks(content.child(i).marks)) {
          return false;
        }
      }
      return true;
    };
    NodeType.prototype.allowsMarkType = function allowsMarkType(markType) {
      return this.markSet == null || this.markSet.indexOf(markType) > -1;
    };
    NodeType.prototype.allowsMarks = function allowsMarks(marks) {
      if (this.markSet == null) {
        return true;
      }
      for (var i = 0; i < marks.length; i++) {
        if (!this.allowsMarkType(marks[i].type)) {
          return false;
        }
      }
      return true;
    };
    NodeType.prototype.allowedMarks = function allowedMarks(marks) {
      if (this.markSet == null) {
        return marks;
      }
      var copy3;
      for (var i = 0; i < marks.length; i++) {
        if (!this.allowsMarkType(marks[i].type)) {
          if (!copy3) {
            copy3 = marks.slice(0, i);
          }
        } else if (copy3) {
          copy3.push(marks[i]);
        }
      }
      return !copy3 ? marks : copy3.length ? copy3 : Mark.empty;
    };
    NodeType.compile = function compile(nodes, schema) {
      var result = Object.create(null);
      nodes.forEach(function(name, spec) {
        return result[name] = new NodeType(name, schema, spec);
      });
      var topType = schema.spec.topNode || "doc";
      if (!result[topType]) {
        throw new RangeError("Schema is missing its top node type ('" + topType + "')");
      }
      if (!result.text) {
        throw new RangeError("Every schema needs a 'text' type");
      }
      for (var _ in result.text.attrs) {
        throw new RangeError("The text node type should not have attributes");
      }
      return result;
    };
    Object.defineProperties(NodeType.prototype, prototypeAccessors$5);
    var Attribute = function Attribute2(options2) {
      this.hasDefault = Object.prototype.hasOwnProperty.call(options2, "default");
      this.default = options2.default;
    };
    var prototypeAccessors$1$3 = { isRequired: { configurable: true } };
    prototypeAccessors$1$3.isRequired.get = function() {
      return !this.hasDefault;
    };
    Object.defineProperties(Attribute.prototype, prototypeAccessors$1$3);
    var MarkType = function MarkType2(name, rank, schema, spec) {
      this.name = name;
      this.schema = schema;
      this.spec = spec;
      this.attrs = initAttrs(spec.attrs);
      this.rank = rank;
      this.excluded = null;
      var defaults = defaultAttrs(this.attrs);
      this.instance = defaults && new Mark(this, defaults);
    };
    MarkType.prototype.create = function create(attrs) {
      if (!attrs && this.instance) {
        return this.instance;
      }
      return new Mark(this, computeAttrs(this.attrs, attrs));
    };
    MarkType.compile = function compile(marks, schema) {
      var result = Object.create(null), rank = 0;
      marks.forEach(function(name, spec) {
        return result[name] = new MarkType(name, rank++, schema, spec);
      });
      return result;
    };
    MarkType.prototype.removeFromSet = function removeFromSet(set) {
      for (var i = 0; i < set.length; i++) {
        if (set[i].type == this) {
          set = set.slice(0, i).concat(set.slice(i + 1));
          i--;
        }
      }
      return set;
    };
    MarkType.prototype.isInSet = function isInSet(set) {
      for (var i = 0; i < set.length; i++) {
        if (set[i].type == this) {
          return set[i];
        }
      }
    };
    MarkType.prototype.excludes = function excludes(other) {
      return this.excluded.indexOf(other) > -1;
    };
    var Schema = function Schema2(spec) {
      this.spec = {};
      for (var prop in spec) {
        this.spec[prop] = spec[prop];
      }
      this.spec.nodes = OrderedMap__default["default"].from(spec.nodes);
      this.spec.marks = OrderedMap__default["default"].from(spec.marks);
      this.nodes = NodeType.compile(this.spec.nodes, this);
      this.marks = MarkType.compile(this.spec.marks, this);
      var contentExprCache = Object.create(null);
      for (var prop$1 in this.nodes) {
        if (prop$1 in this.marks) {
          throw new RangeError(prop$1 + " can not be both a node and a mark");
        }
        var type = this.nodes[prop$1], contentExpr = type.spec.content || "", markExpr = type.spec.marks;
        type.contentMatch = contentExprCache[contentExpr] || (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes));
        type.inlineContent = type.contentMatch.inlineContent;
        type.markSet = markExpr == "_" ? null : markExpr ? gatherMarks(this, markExpr.split(" ")) : markExpr == "" || !type.inlineContent ? [] : null;
      }
      for (var prop$2 in this.marks) {
        var type$1 = this.marks[prop$2], excl = type$1.spec.excludes;
        type$1.excluded = excl == null ? [type$1] : excl == "" ? [] : gatherMarks(this, excl.split(" "));
      }
      this.nodeFromJSON = this.nodeFromJSON.bind(this);
      this.markFromJSON = this.markFromJSON.bind(this);
      this.topNodeType = this.nodes[this.spec.topNode || "doc"];
      this.cached = Object.create(null);
      this.cached.wrappings = Object.create(null);
    };
    Schema.prototype.node = function node(type, attrs, content, marks) {
      if (typeof type == "string") {
        type = this.nodeType(type);
      } else if (!(type instanceof NodeType)) {
        throw new RangeError("Invalid node type: " + type);
      } else if (type.schema != this) {
        throw new RangeError("Node type from different schema used (" + type.name + ")");
      }
      return type.createChecked(attrs, content, marks);
    };
    Schema.prototype.text = function text(text$1, marks) {
      var type = this.nodes.text;
      return new TextNode(type, type.defaultAttrs, text$1, Mark.setFrom(marks));
    };
    Schema.prototype.mark = function mark(type, attrs) {
      if (typeof type == "string") {
        type = this.marks[type];
      }
      return type.create(attrs);
    };
    Schema.prototype.nodeFromJSON = function nodeFromJSON(json) {
      return Node.fromJSON(this, json);
    };
    Schema.prototype.markFromJSON = function markFromJSON(json) {
      return Mark.fromJSON(this, json);
    };
    Schema.prototype.nodeType = function nodeType(name) {
      var found2 = this.nodes[name];
      if (!found2) {
        throw new RangeError("Unknown node type: " + name);
      }
      return found2;
    };
    function gatherMarks(schema, marks) {
      var found2 = [];
      for (var i = 0; i < marks.length; i++) {
        var name = marks[i], mark = schema.marks[name], ok = mark;
        if (mark) {
          found2.push(mark);
        } else {
          for (var prop in schema.marks) {
            var mark$1 = schema.marks[prop];
            if (name == "_" || mark$1.spec.group && mark$1.spec.group.split(" ").indexOf(name) > -1) {
              found2.push(ok = mark$1);
            }
          }
        }
        if (!ok) {
          throw new SyntaxError("Unknown mark type: '" + marks[i] + "'");
        }
      }
      return found2;
    }
    var DOMParser = function DOMParser2(schema, rules) {
      var this$1 = this;
      this.schema = schema;
      this.rules = rules;
      this.tags = [];
      this.styles = [];
      rules.forEach(function(rule) {
        if (rule.tag) {
          this$1.tags.push(rule);
        } else if (rule.style) {
          this$1.styles.push(rule);
        }
      });
      this.normalizeLists = !this.tags.some(function(r) {
        if (!/^(ul|ol)\b/.test(r.tag) || !r.node) {
          return false;
        }
        var node = schema.nodes[r.node];
        return node.contentMatch.matchType(node);
      });
    };
    DOMParser.prototype.parse = function parse(dom, options2) {
      if (options2 === void 0)
        options2 = {};
      var context = new ParseContext(this, options2, false);
      context.addAll(dom, null, options2.from, options2.to);
      return context.finish();
    };
    DOMParser.prototype.parseSlice = function parseSlice(dom, options2) {
      if (options2 === void 0)
        options2 = {};
      var context = new ParseContext(this, options2, true);
      context.addAll(dom, null, options2.from, options2.to);
      return Slice.maxOpen(context.finish());
    };
    DOMParser.prototype.matchTag = function matchTag(dom, context, after) {
      for (var i = after ? this.tags.indexOf(after) + 1 : 0; i < this.tags.length; i++) {
        var rule = this.tags[i];
        if (matches(dom, rule.tag) && (rule.namespace === void 0 || dom.namespaceURI == rule.namespace) && (!rule.context || context.matchesContext(rule.context))) {
          if (rule.getAttrs) {
            var result = rule.getAttrs(dom);
            if (result === false) {
              continue;
            }
            rule.attrs = result;
          }
          return rule;
        }
      }
    };
    DOMParser.prototype.matchStyle = function matchStyle(prop, value, context, after) {
      for (var i = after ? this.styles.indexOf(after) + 1 : 0; i < this.styles.length; i++) {
        var rule = this.styles[i];
        if (rule.style.indexOf(prop) != 0 || rule.context && !context.matchesContext(rule.context) || rule.style.length > prop.length && (rule.style.charCodeAt(prop.length) != 61 || rule.style.slice(prop.length + 1) != value)) {
          continue;
        }
        if (rule.getAttrs) {
          var result = rule.getAttrs(value);
          if (result === false) {
            continue;
          }
          rule.attrs = result;
        }
        return rule;
      }
    };
    DOMParser.schemaRules = function schemaRules(schema) {
      var result = [];
      function insert(rule) {
        var priority = rule.priority == null ? 50 : rule.priority, i = 0;
        for (; i < result.length; i++) {
          var next = result[i], nextPriority = next.priority == null ? 50 : next.priority;
          if (nextPriority < priority) {
            break;
          }
        }
        result.splice(i, 0, rule);
      }
      var loop = function(name2) {
        var rules = schema.marks[name2].spec.parseDOM;
        if (rules) {
          rules.forEach(function(rule) {
            insert(rule = copy2(rule));
            rule.mark = name2;
          });
        }
      };
      for (var name in schema.marks)
        loop(name);
      var loop$1 = function(name2) {
        var rules$1 = schema.nodes[name$1].spec.parseDOM;
        if (rules$1) {
          rules$1.forEach(function(rule) {
            insert(rule = copy2(rule));
            rule.node = name$1;
          });
        }
      };
      for (var name$1 in schema.nodes)
        loop$1();
      return result;
    };
    DOMParser.fromSchema = function fromSchema(schema) {
      return schema.cached.domParser || (schema.cached.domParser = new DOMParser(schema, DOMParser.schemaRules(schema)));
    };
    var blockTags = {
      address: true,
      article: true,
      aside: true,
      blockquote: true,
      canvas: true,
      dd: true,
      div: true,
      dl: true,
      fieldset: true,
      figcaption: true,
      figure: true,
      footer: true,
      form: true,
      h1: true,
      h2: true,
      h3: true,
      h4: true,
      h5: true,
      h6: true,
      header: true,
      hgroup: true,
      hr: true,
      li: true,
      noscript: true,
      ol: true,
      output: true,
      p: true,
      pre: true,
      section: true,
      table: true,
      tfoot: true,
      ul: true
    };
    var ignoreTags = {
      head: true,
      noscript: true,
      object: true,
      script: true,
      style: true,
      title: true
    };
    var listTags = { ol: true, ul: true };
    var OPT_PRESERVE_WS = 1;
    var OPT_PRESERVE_WS_FULL = 2;
    var OPT_OPEN_LEFT = 4;
    function wsOptionsFor(preserveWhitespace) {
      return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === "full" ? OPT_PRESERVE_WS_FULL : 0);
    }
    var NodeContext = function NodeContext2(type, attrs, marks, pendingMarks, solid, match, options2) {
      this.type = type;
      this.attrs = attrs;
      this.solid = solid;
      this.match = match || (options2 & OPT_OPEN_LEFT ? null : type.contentMatch);
      this.options = options2;
      this.content = [];
      this.marks = marks;
      this.activeMarks = Mark.none;
      this.pendingMarks = pendingMarks;
      this.stashMarks = [];
    };
    NodeContext.prototype.findWrapping = function findWrapping(node) {
      if (!this.match) {
        if (!this.type) {
          return [];
        }
        var fill = this.type.contentMatch.fillBefore(Fragment.from(node));
        if (fill) {
          this.match = this.type.contentMatch.matchFragment(fill);
        } else {
          var start = this.type.contentMatch, wrap;
          if (wrap = start.findWrapping(node.type)) {
            this.match = start;
            return wrap;
          } else {
            return null;
          }
        }
      }
      return this.match.findWrapping(node.type);
    };
    NodeContext.prototype.finish = function finish(openEnd) {
      if (!(this.options & OPT_PRESERVE_WS)) {
        var last = this.content[this.content.length - 1], m;
        if (last && last.isText && (m = /[ \t\r\n\u000c]+$/.exec(last.text))) {
          if (last.text.length == m[0].length) {
            this.content.pop();
          } else {
            this.content[this.content.length - 1] = last.withText(last.text.slice(0, last.text.length - m[0].length));
          }
        }
      }
      var content = Fragment.from(this.content);
      if (!openEnd && this.match) {
        content = content.append(this.match.fillBefore(Fragment.empty, true));
      }
      return this.type ? this.type.create(this.attrs, content, this.marks) : content;
    };
    NodeContext.prototype.popFromStashMark = function popFromStashMark(mark) {
      for (var i = this.stashMarks.length - 1; i >= 0; i--) {
        if (mark.eq(this.stashMarks[i])) {
          return this.stashMarks.splice(i, 1)[0];
        }
      }
    };
    NodeContext.prototype.applyPending = function applyPending(nextType) {
      for (var i = 0, pending = this.pendingMarks; i < pending.length; i++) {
        var mark = pending[i];
        if ((this.type ? this.type.allowsMarkType(mark.type) : markMayApply(mark.type, nextType)) && !mark.isInSet(this.activeMarks)) {
          this.activeMarks = mark.addToSet(this.activeMarks);
          this.pendingMarks = mark.removeFromSet(this.pendingMarks);
        }
      }
    };
    NodeContext.prototype.inlineContext = function inlineContext(node) {
      if (this.type) {
        return this.type.inlineContent;
      }
      if (this.content.length) {
        return this.content[0].isInline;
      }
      return node.parentNode && !blockTags.hasOwnProperty(node.parentNode.nodeName.toLowerCase());
    };
    var ParseContext = function ParseContext2(parser, options2, open) {
      this.parser = parser;
      this.options = options2;
      this.isOpen = open;
      var topNode = options2.topNode, topContext;
      var topOptions = wsOptionsFor(options2.preserveWhitespace) | (open ? OPT_OPEN_LEFT : 0);
      if (topNode) {
        topContext = new NodeContext(topNode.type, topNode.attrs, Mark.none, Mark.none, true, options2.topMatch || topNode.type.contentMatch, topOptions);
      } else if (open) {
        topContext = new NodeContext(null, null, Mark.none, Mark.none, true, null, topOptions);
      } else {
        topContext = new NodeContext(parser.schema.topNodeType, null, Mark.none, Mark.none, true, null, topOptions);
      }
      this.nodes = [topContext];
      this.open = 0;
      this.find = options2.findPositions;
      this.needsBlock = false;
    };
    var prototypeAccessors$6 = { top: { configurable: true }, currentPos: { configurable: true } };
    prototypeAccessors$6.top.get = function() {
      return this.nodes[this.open];
    };
    ParseContext.prototype.addDOM = function addDOM(dom) {
      if (dom.nodeType == 3) {
        this.addTextNode(dom);
      } else if (dom.nodeType == 1) {
        var style = dom.getAttribute("style");
        var marks = style ? this.readStyles(parseStyles(style)) : null, top = this.top;
        if (marks != null) {
          for (var i = 0; i < marks.length; i++) {
            this.addPendingMark(marks[i]);
          }
        }
        this.addElement(dom);
        if (marks != null) {
          for (var i$1 = 0; i$1 < marks.length; i$1++) {
            this.removePendingMark(marks[i$1], top);
          }
        }
      }
    };
    ParseContext.prototype.addTextNode = function addTextNode(dom) {
      var value = dom.nodeValue;
      var top = this.top;
      if (top.options & OPT_PRESERVE_WS_FULL || top.inlineContext(dom) || /[^ \t\r\n\u000c]/.test(value)) {
        if (!(top.options & OPT_PRESERVE_WS)) {
          value = value.replace(/[ \t\r\n\u000c]+/g, " ");
          if (/^[ \t\r\n\u000c]/.test(value) && this.open == this.nodes.length - 1) {
            var nodeBefore = top.content[top.content.length - 1];
            var domNodeBefore = dom.previousSibling;
            if (!nodeBefore || domNodeBefore && domNodeBefore.nodeName == "BR" || nodeBefore.isText && /[ \t\r\n\u000c]$/.test(nodeBefore.text)) {
              value = value.slice(1);
            }
          }
        } else if (!(top.options & OPT_PRESERVE_WS_FULL)) {
          value = value.replace(/\r?\n|\r/g, " ");
        } else {
          value = value.replace(/\r\n?/g, "\n");
        }
        if (value) {
          this.insertNode(this.parser.schema.text(value));
        }
        this.findInText(dom);
      } else {
        this.findInside(dom);
      }
    };
    ParseContext.prototype.addElement = function addElement(dom, matchAfter) {
      var name = dom.nodeName.toLowerCase(), ruleID;
      if (listTags.hasOwnProperty(name) && this.parser.normalizeLists) {
        normalizeList(dom);
      }
      var rule = this.options.ruleFromNode && this.options.ruleFromNode(dom) || (ruleID = this.parser.matchTag(dom, this, matchAfter));
      if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {
        this.findInside(dom);
        this.ignoreFallback(dom);
      } else if (!rule || rule.skip || rule.closeParent) {
        if (rule && rule.closeParent) {
          this.open = Math.max(0, this.open - 1);
        } else if (rule && rule.skip.nodeType) {
          dom = rule.skip;
        }
        var sync, top = this.top, oldNeedsBlock = this.needsBlock;
        if (blockTags.hasOwnProperty(name)) {
          sync = true;
          if (!top.type) {
            this.needsBlock = true;
          }
        } else if (!dom.firstChild) {
          this.leafFallback(dom);
          return;
        }
        this.addAll(dom);
        if (sync) {
          this.sync(top);
        }
        this.needsBlock = oldNeedsBlock;
      } else {
        this.addElementByRule(dom, rule, rule.consuming === false ? ruleID : null);
      }
    };
    ParseContext.prototype.leafFallback = function leafFallback(dom) {
      if (dom.nodeName == "BR" && this.top.type && this.top.type.inlineContent) {
        this.addTextNode(dom.ownerDocument.createTextNode("\n"));
      }
    };
    ParseContext.prototype.ignoreFallback = function ignoreFallback(dom) {
      if (dom.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent)) {
        this.findPlace(this.parser.schema.text("-"));
      }
    };
    ParseContext.prototype.readStyles = function readStyles(styles) {
      var marks = Mark.none;
      style:
        for (var i = 0; i < styles.length; i += 2) {
          for (var after = null; ; ) {
            var rule = this.parser.matchStyle(styles[i], styles[i + 1], this, after);
            if (!rule) {
              continue style;
            }
            if (rule.ignore) {
              return null;
            }
            marks = this.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(marks);
            if (rule.consuming === false) {
              after = rule;
            } else {
              break;
            }
          }
        }
      return marks;
    };
    ParseContext.prototype.addElementByRule = function addElementByRule(dom, rule, continueAfter) {
      var this$1 = this;
      var sync, nodeType, markType, mark;
      if (rule.node) {
        nodeType = this.parser.schema.nodes[rule.node];
        if (!nodeType.isLeaf) {
          sync = this.enter(nodeType, rule.attrs, rule.preserveWhitespace);
        } else if (!this.insertNode(nodeType.create(rule.attrs))) {
          this.leafFallback(dom);
        }
      } else {
        markType = this.parser.schema.marks[rule.mark];
        mark = markType.create(rule.attrs);
        this.addPendingMark(mark);
      }
      var startIn = this.top;
      if (nodeType && nodeType.isLeaf) {
        this.findInside(dom);
      } else if (continueAfter) {
        this.addElement(dom, continueAfter);
      } else if (rule.getContent) {
        this.findInside(dom);
        rule.getContent(dom, this.parser.schema).forEach(function(node) {
          return this$1.insertNode(node);
        });
      } else {
        var contentDOM = rule.contentElement;
        if (typeof contentDOM == "string") {
          contentDOM = dom.querySelector(contentDOM);
        } else if (typeof contentDOM == "function") {
          contentDOM = contentDOM(dom);
        }
        if (!contentDOM) {
          contentDOM = dom;
        }
        this.findAround(dom, contentDOM, true);
        this.addAll(contentDOM, sync);
      }
      if (sync) {
        this.sync(startIn);
        this.open--;
      }
      if (mark) {
        this.removePendingMark(mark, startIn);
      }
    };
    ParseContext.prototype.addAll = function addAll(parent, sync, startIndex, endIndex) {
      var index2 = startIndex || 0;
      for (var dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild, end = endIndex == null ? null : parent.childNodes[endIndex]; dom != end; dom = dom.nextSibling, ++index2) {
        this.findAtPoint(parent, index2);
        this.addDOM(dom);
        if (sync && blockTags.hasOwnProperty(dom.nodeName.toLowerCase())) {
          this.sync(sync);
        }
      }
      this.findAtPoint(parent, index2);
    };
    ParseContext.prototype.findPlace = function findPlace(node) {
      var route, sync;
      for (var depth = this.open; depth >= 0; depth--) {
        var cx = this.nodes[depth];
        var found2 = cx.findWrapping(node);
        if (found2 && (!route || route.length > found2.length)) {
          route = found2;
          sync = cx;
          if (!found2.length) {
            break;
          }
        }
        if (cx.solid) {
          break;
        }
      }
      if (!route) {
        return false;
      }
      this.sync(sync);
      for (var i = 0; i < route.length; i++) {
        this.enterInner(route[i], null, false);
      }
      return true;
    };
    ParseContext.prototype.insertNode = function insertNode(node) {
      if (node.isInline && this.needsBlock && !this.top.type) {
        var block = this.textblockFromContext();
        if (block) {
          this.enterInner(block);
        }
      }
      if (this.findPlace(node)) {
        this.closeExtra();
        var top = this.top;
        top.applyPending(node.type);
        if (top.match) {
          top.match = top.match.matchType(node.type);
        }
        var marks = top.activeMarks;
        for (var i = 0; i < node.marks.length; i++) {
          if (!top.type || top.type.allowsMarkType(node.marks[i].type)) {
            marks = node.marks[i].addToSet(marks);
          }
        }
        top.content.push(node.mark(marks));
        return true;
      }
      return false;
    };
    ParseContext.prototype.enter = function enter(type, attrs, preserveWS) {
      var ok = this.findPlace(type.create(attrs));
      if (ok) {
        this.enterInner(type, attrs, true, preserveWS);
      }
      return ok;
    };
    ParseContext.prototype.enterInner = function enterInner(type, attrs, solid, preserveWS) {
      this.closeExtra();
      var top = this.top;
      top.applyPending(type);
      top.match = top.match && top.match.matchType(type, attrs);
      var options2 = preserveWS == null ? top.options & ~OPT_OPEN_LEFT : wsOptionsFor(preserveWS);
      if (top.options & OPT_OPEN_LEFT && top.content.length == 0) {
        options2 |= OPT_OPEN_LEFT;
      }
      this.nodes.push(new NodeContext(type, attrs, top.activeMarks, top.pendingMarks, solid, null, options2));
      this.open++;
    };
    ParseContext.prototype.closeExtra = function closeExtra(openEnd) {
      var i = this.nodes.length - 1;
      if (i > this.open) {
        for (; i > this.open; i--) {
          this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd));
        }
        this.nodes.length = this.open + 1;
      }
    };
    ParseContext.prototype.finish = function finish() {
      this.open = 0;
      this.closeExtra(this.isOpen);
      return this.nodes[0].finish(this.isOpen || this.options.topOpen);
    };
    ParseContext.prototype.sync = function sync(to) {
      for (var i = this.open; i >= 0; i--) {
        if (this.nodes[i] == to) {
          this.open = i;
          return;
        }
      }
    };
    prototypeAccessors$6.currentPos.get = function() {
      this.closeExtra();
      var pos = 0;
      for (var i = this.open; i >= 0; i--) {
        var content = this.nodes[i].content;
        for (var j = content.length - 1; j >= 0; j--) {
          pos += content[j].nodeSize;
        }
        if (i) {
          pos++;
        }
      }
      return pos;
    };
    ParseContext.prototype.findAtPoint = function findAtPoint(parent, offset) {
      if (this.find) {
        for (var i = 0; i < this.find.length; i++) {
          if (this.find[i].node == parent && this.find[i].offset == offset) {
            this.find[i].pos = this.currentPos;
          }
        }
      }
    };
    ParseContext.prototype.findInside = function findInside(parent) {
      if (this.find) {
        for (var i = 0; i < this.find.length; i++) {
          if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {
            this.find[i].pos = this.currentPos;
          }
        }
      }
    };
    ParseContext.prototype.findAround = function findAround(parent, content, before) {
      if (parent != content && this.find) {
        for (var i = 0; i < this.find.length; i++) {
          if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {
            var pos = content.compareDocumentPosition(this.find[i].node);
            if (pos & (before ? 2 : 4)) {
              this.find[i].pos = this.currentPos;
            }
          }
        }
      }
    };
    ParseContext.prototype.findInText = function findInText(textNode) {
      if (this.find) {
        for (var i = 0; i < this.find.length; i++) {
          if (this.find[i].node == textNode) {
            this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset);
          }
        }
      }
    };
    ParseContext.prototype.matchesContext = function matchesContext(context) {
      var this$1 = this;
      if (context.indexOf("|") > -1) {
        return context.split(/\s*\|\s*/).some(this.matchesContext, this);
      }
      var parts = context.split("/");
      var option = this.options.context;
      var useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);
      var minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);
      var match = function(i, depth) {
        for (; i >= 0; i--) {
          var part = parts[i];
          if (part == "") {
            if (i == parts.length - 1 || i == 0) {
              continue;
            }
            for (; depth >= minDepth; depth--) {
              if (match(i - 1, depth)) {
                return true;
              }
            }
            return false;
          } else {
            var next = depth > 0 || depth == 0 && useRoot ? this$1.nodes[depth].type : option && depth >= minDepth ? option.node(depth - minDepth).type : null;
            if (!next || next.name != part && next.groups.indexOf(part) == -1) {
              return false;
            }
            depth--;
          }
        }
        return true;
      };
      return match(parts.length - 1, this.open);
    };
    ParseContext.prototype.textblockFromContext = function textblockFromContext() {
      var $context = this.options.context;
      if ($context) {
        for (var d = $context.depth; d >= 0; d--) {
          var deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;
          if (deflt && deflt.isTextblock && deflt.defaultAttrs) {
            return deflt;
          }
        }
      }
      for (var name in this.parser.schema.nodes) {
        var type = this.parser.schema.nodes[name];
        if (type.isTextblock && type.defaultAttrs) {
          return type;
        }
      }
    };
    ParseContext.prototype.addPendingMark = function addPendingMark(mark) {
      var found2 = findSameMarkInSet(mark, this.top.pendingMarks);
      if (found2) {
        this.top.stashMarks.push(found2);
      }
      this.top.pendingMarks = mark.addToSet(this.top.pendingMarks);
    };
    ParseContext.prototype.removePendingMark = function removePendingMark(mark, upto) {
      for (var depth = this.open; depth >= 0; depth--) {
        var level = this.nodes[depth];
        var found2 = level.pendingMarks.lastIndexOf(mark);
        if (found2 > -1) {
          level.pendingMarks = mark.removeFromSet(level.pendingMarks);
        } else {
          level.activeMarks = mark.removeFromSet(level.activeMarks);
          var stashMark = level.popFromStashMark(mark);
          if (stashMark && level.type && level.type.allowsMarkType(stashMark.type)) {
            level.activeMarks = stashMark.addToSet(level.activeMarks);
          }
        }
        if (level == upto) {
          break;
        }
      }
    };
    Object.defineProperties(ParseContext.prototype, prototypeAccessors$6);
    function normalizeList(dom) {
      for (var child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {
        var name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null;
        if (name && listTags.hasOwnProperty(name) && prevItem) {
          prevItem.appendChild(child);
          child = prevItem;
        } else if (name == "li") {
          prevItem = child;
        } else if (name) {
          prevItem = null;
        }
      }
    }
    function matches(dom, selector) {
      return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector);
    }
    function parseStyles(style) {
      var re2 = /\s*([\w-]+)\s*:\s*([^;]+)/g, m, result = [];
      while (m = re2.exec(style)) {
        result.push(m[1], m[2].trim());
      }
      return result;
    }
    function copy2(obj) {
      var copy3 = {};
      for (var prop in obj) {
        copy3[prop] = obj[prop];
      }
      return copy3;
    }
    function markMayApply(markType, nodeType) {
      var nodes = nodeType.schema.nodes;
      var loop = function(name2) {
        var parent = nodes[name2];
        if (!parent.allowsMarkType(markType)) {
          return;
        }
        var seen = [], scan = function(match) {
          seen.push(match);
          for (var i = 0; i < match.edgeCount; i++) {
            var ref = match.edge(i);
            var type = ref.type;
            var next = ref.next;
            if (type == nodeType) {
              return true;
            }
            if (seen.indexOf(next) < 0 && scan(next)) {
              return true;
            }
          }
        };
        if (scan(parent.contentMatch)) {
          return { v: true };
        }
      };
      for (var name in nodes) {
        var returned = loop(name);
        if (returned)
          return returned.v;
      }
    }
    function findSameMarkInSet(mark, set) {
      for (var i = 0; i < set.length; i++) {
        if (mark.eq(set[i])) {
          return set[i];
        }
      }
    }
    var DOMSerializer = function DOMSerializer2(nodes, marks) {
      this.nodes = nodes || {};
      this.marks = marks || {};
    };
    DOMSerializer.prototype.serializeFragment = function serializeFragment(fragment, options2, target) {
      var this$1 = this;
      if (options2 === void 0)
        options2 = {};
      if (!target) {
        target = doc(options2).createDocumentFragment();
      }
      var top = target, active = null;
      fragment.forEach(function(node) {
        if (active || node.marks.length) {
          if (!active) {
            active = [];
          }
          var keep = 0, rendered = 0;
          while (keep < active.length && rendered < node.marks.length) {
            var next = node.marks[rendered];
            if (!this$1.marks[next.type.name]) {
              rendered++;
              continue;
            }
            if (!next.eq(active[keep]) || next.type.spec.spanning === false) {
              break;
            }
            keep += 2;
            rendered++;
          }
          while (keep < active.length) {
            top = active.pop();
            active.pop();
          }
          while (rendered < node.marks.length) {
            var add = node.marks[rendered++];
            var markDOM = this$1.serializeMark(add, node.isInline, options2);
            if (markDOM) {
              active.push(add, top);
              top.appendChild(markDOM.dom);
              top = markDOM.contentDOM || markDOM.dom;
            }
          }
        }
        top.appendChild(this$1.serializeNodeInner(node, options2));
      });
      return target;
    };
    DOMSerializer.prototype.serializeNodeInner = function serializeNodeInner(node, options2) {
      if (options2 === void 0)
        options2 = {};
      var ref = DOMSerializer.renderSpec(doc(options2), this.nodes[node.type.name](node));
      var dom = ref.dom;
      var contentDOM = ref.contentDOM;
      if (contentDOM) {
        if (node.isLeaf) {
          throw new RangeError("Content hole not allowed in a leaf node spec");
        }
        if (options2.onContent) {
          options2.onContent(node, contentDOM, options2);
        } else {
          this.serializeFragment(node.content, options2, contentDOM);
        }
      }
      return dom;
    };
    DOMSerializer.prototype.serializeNode = function serializeNode(node, options2) {
      if (options2 === void 0)
        options2 = {};
      var dom = this.serializeNodeInner(node, options2);
      for (var i = node.marks.length - 1; i >= 0; i--) {
        var wrap = this.serializeMark(node.marks[i], node.isInline, options2);
        if (wrap) {
          (wrap.contentDOM || wrap.dom).appendChild(dom);
          dom = wrap.dom;
        }
      }
      return dom;
    };
    DOMSerializer.prototype.serializeMark = function serializeMark(mark, inline, options2) {
      if (options2 === void 0)
        options2 = {};
      var toDOM = this.marks[mark.type.name];
      return toDOM && DOMSerializer.renderSpec(doc(options2), toDOM(mark, inline));
    };
    DOMSerializer.renderSpec = function renderSpec(doc2, structure, xmlNS) {
      if (xmlNS === void 0)
        xmlNS = null;
      if (typeof structure == "string") {
        return { dom: doc2.createTextNode(structure) };
      }
      if (structure.nodeType != null) {
        return { dom: structure };
      }
      if (structure.dom && structure.dom.nodeType != null) {
        return structure;
      }
      var tagName = structure[0], space = tagName.indexOf(" ");
      if (space > 0) {
        xmlNS = tagName.slice(0, space);
        tagName = tagName.slice(space + 1);
      }
      var contentDOM = null, dom = xmlNS ? doc2.createElementNS(xmlNS, tagName) : doc2.createElement(tagName);
      var attrs = structure[1], start = 1;
      if (attrs && typeof attrs == "object" && attrs.nodeType == null && !Array.isArray(attrs)) {
        start = 2;
        for (var name in attrs) {
          if (attrs[name] != null) {
            var space$1 = name.indexOf(" ");
            if (space$1 > 0) {
              dom.setAttributeNS(name.slice(0, space$1), name.slice(space$1 + 1), attrs[name]);
            } else {
              dom.setAttribute(name, attrs[name]);
            }
          }
        }
      }
      for (var i = start; i < structure.length; i++) {
        var child = structure[i];
        if (child === 0) {
          if (i < structure.length - 1 || i > start) {
            throw new RangeError("Content hole must be the only child of its parent node");
          }
          return { dom, contentDOM: dom };
        } else {
          var ref = DOMSerializer.renderSpec(doc2, child, xmlNS);
          var inner = ref.dom;
          var innerContent = ref.contentDOM;
          dom.appendChild(inner);
          if (innerContent) {
            if (contentDOM) {
              throw new RangeError("Multiple content holes");
            }
            contentDOM = innerContent;
          }
        }
      }
      return { dom, contentDOM };
    };
    DOMSerializer.fromSchema = function fromSchema(schema) {
      return schema.cached.domSerializer || (schema.cached.domSerializer = new DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)));
    };
    DOMSerializer.nodesFromSchema = function nodesFromSchema(schema) {
      var result = gatherToDOM(schema.nodes);
      if (!result.text) {
        result.text = function(node) {
          return node.text;
        };
      }
      return result;
    };
    DOMSerializer.marksFromSchema = function marksFromSchema(schema) {
      return gatherToDOM(schema.marks);
    };
    function gatherToDOM(obj) {
      var result = {};
      for (var name in obj) {
        var toDOM = obj[name].spec.toDOM;
        if (toDOM) {
          result[name] = toDOM;
        }
      }
      return result;
    }
    function doc(options2) {
      return options2.document || window.document;
    }
    exports.ContentMatch = ContentMatch;
    exports.DOMParser = DOMParser;
    exports.DOMSerializer = DOMSerializer;
    exports.Fragment = Fragment;
    exports.Mark = Mark;
    exports.MarkType = MarkType;
    exports.Node = Node;
    exports.NodeRange = NodeRange;
    exports.NodeType = NodeType;
    exports.ReplaceError = ReplaceError;
    exports.ResolvedPos = ResolvedPos;
    exports.Schema = Schema;
    exports.Slice = Slice;
  }
});

// node_modules/prosemirror-transform/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/prosemirror-transform/dist/index.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var prosemirrorModel = require_dist();
    var lower16 = 65535;
    var factor16 = Math.pow(2, 16);
    function makeRecover(index2, offset) {
      return index2 + offset * factor16;
    }
    function recoverIndex(value) {
      return value & lower16;
    }
    function recoverOffset(value) {
      return (value - (value & lower16)) / factor16;
    }
    var MapResult = function MapResult2(pos, deleted, recover) {
      if (deleted === void 0)
        deleted = false;
      if (recover === void 0)
        recover = null;
      this.pos = pos;
      this.deleted = deleted;
      this.recover = recover;
    };
    var StepMap = function StepMap2(ranges, inverted) {
      if (inverted === void 0)
        inverted = false;
      this.ranges = ranges;
      this.inverted = inverted;
    };
    StepMap.prototype.recover = function recover(value) {
      var diff = 0, index2 = recoverIndex(value);
      if (!this.inverted) {
        for (var i = 0; i < index2; i++) {
          diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];
        }
      }
      return this.ranges[index2 * 3] + diff + recoverOffset(value);
    };
    StepMap.prototype.mapResult = function mapResult(pos, assoc) {
      if (assoc === void 0)
        assoc = 1;
      return this._map(pos, assoc, false);
    };
    StepMap.prototype.map = function map2(pos, assoc) {
      if (assoc === void 0)
        assoc = 1;
      return this._map(pos, assoc, true);
    };
    StepMap.prototype._map = function _map2(pos, assoc, simple) {
      var diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
      for (var i = 0; i < this.ranges.length; i += 3) {
        var start = this.ranges[i] - (this.inverted ? diff : 0);
        if (start > pos) {
          break;
        }
        var oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex], end = start + oldSize;
        if (pos <= end) {
          var side = !oldSize ? assoc : pos == start ? -1 : pos == end ? 1 : assoc;
          var result = start + diff + (side < 0 ? 0 : newSize);
          if (simple) {
            return result;
          }
          var recover = pos == (assoc < 0 ? start : end) ? null : makeRecover(i / 3, pos - start);
          return new MapResult(result, assoc < 0 ? pos != start : pos != end, recover);
        }
        diff += newSize - oldSize;
      }
      return simple ? pos + diff : new MapResult(pos + diff);
    };
    StepMap.prototype.touches = function touches(pos, recover) {
      var diff = 0, index2 = recoverIndex(recover);
      var oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
      for (var i = 0; i < this.ranges.length; i += 3) {
        var start = this.ranges[i] - (this.inverted ? diff : 0);
        if (start > pos) {
          break;
        }
        var oldSize = this.ranges[i + oldIndex], end = start + oldSize;
        if (pos <= end && i == index2 * 3) {
          return true;
        }
        diff += this.ranges[i + newIndex] - oldSize;
      }
      return false;
    };
    StepMap.prototype.forEach = function forEach(f) {
      var oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
      for (var i = 0, diff = 0; i < this.ranges.length; i += 3) {
        var start = this.ranges[i], oldStart = start - (this.inverted ? diff : 0), newStart = start + (this.inverted ? 0 : diff);
        var oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex];
        f(oldStart, oldStart + oldSize, newStart, newStart + newSize);
        diff += newSize - oldSize;
      }
    };
    StepMap.prototype.invert = function invert() {
      return new StepMap(this.ranges, !this.inverted);
    };
    StepMap.prototype.toString = function toString() {
      return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
    };
    StepMap.offset = function offset(n) {
      return n == 0 ? StepMap.empty : new StepMap(n < 0 ? [0, -n, 0] : [0, 0, n]);
    };
    StepMap.empty = new StepMap([]);
    var Mapping = function Mapping2(maps, mirror, from, to) {
      this.maps = maps || [];
      this.from = from || 0;
      this.to = to == null ? this.maps.length : to;
      this.mirror = mirror;
    };
    Mapping.prototype.slice = function slice(from, to) {
      if (from === void 0)
        from = 0;
      if (to === void 0)
        to = this.maps.length;
      return new Mapping(this.maps, this.mirror, from, to);
    };
    Mapping.prototype.copy = function copy2() {
      return new Mapping(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to);
    };
    Mapping.prototype.appendMap = function appendMap(map2, mirrors) {
      this.to = this.maps.push(map2);
      if (mirrors != null) {
        this.setMirror(this.maps.length - 1, mirrors);
      }
    };
    Mapping.prototype.appendMapping = function appendMapping(mapping) {
      for (var i = 0, startSize = this.maps.length; i < mapping.maps.length; i++) {
        var mirr = mapping.getMirror(i);
        this.appendMap(mapping.maps[i], mirr != null && mirr < i ? startSize + mirr : null);
      }
    };
    Mapping.prototype.getMirror = function getMirror(n) {
      if (this.mirror) {
        for (var i = 0; i < this.mirror.length; i++) {
          if (this.mirror[i] == n) {
            return this.mirror[i + (i % 2 ? -1 : 1)];
          }
        }
      }
    };
    Mapping.prototype.setMirror = function setMirror(n, m) {
      if (!this.mirror) {
        this.mirror = [];
      }
      this.mirror.push(n, m);
    };
    Mapping.prototype.appendMappingInverted = function appendMappingInverted(mapping) {
      for (var i = mapping.maps.length - 1, totalSize = this.maps.length + mapping.maps.length; i >= 0; i--) {
        var mirr = mapping.getMirror(i);
        this.appendMap(mapping.maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : null);
      }
    };
    Mapping.prototype.invert = function invert() {
      var inverse = new Mapping();
      inverse.appendMappingInverted(this);
      return inverse;
    };
    Mapping.prototype.map = function map2(pos, assoc) {
      if (assoc === void 0)
        assoc = 1;
      if (this.mirror) {
        return this._map(pos, assoc, true);
      }
      for (var i = this.from; i < this.to; i++) {
        pos = this.maps[i].map(pos, assoc);
      }
      return pos;
    };
    Mapping.prototype.mapResult = function mapResult(pos, assoc) {
      if (assoc === void 0)
        assoc = 1;
      return this._map(pos, assoc, false);
    };
    Mapping.prototype._map = function _map2(pos, assoc, simple) {
      var deleted = false;
      for (var i = this.from; i < this.to; i++) {
        var map2 = this.maps[i], result = map2.mapResult(pos, assoc);
        if (result.recover != null) {
          var corr = this.getMirror(i);
          if (corr != null && corr > i && corr < this.to) {
            i = corr;
            pos = this.maps[corr].recover(result.recover);
            continue;
          }
        }
        if (result.deleted) {
          deleted = true;
        }
        pos = result.pos;
      }
      return simple ? pos : new MapResult(pos, deleted);
    };
    function TransformError(message) {
      var err = Error.call(this, message);
      err.__proto__ = TransformError.prototype;
      return err;
    }
    TransformError.prototype = Object.create(Error.prototype);
    TransformError.prototype.constructor = TransformError;
    TransformError.prototype.name = "TransformError";
    var Transform = function Transform2(doc) {
      this.doc = doc;
      this.steps = [];
      this.docs = [];
      this.mapping = new Mapping();
    };
    var prototypeAccessors = { before: { configurable: true }, docChanged: { configurable: true } };
    prototypeAccessors.before.get = function() {
      return this.docs.length ? this.docs[0] : this.doc;
    };
    Transform.prototype.step = function step(object2) {
      var result = this.maybeStep(object2);
      if (result.failed) {
        throw new TransformError(result.failed);
      }
      return this;
    };
    Transform.prototype.maybeStep = function maybeStep(step) {
      var result = step.apply(this.doc);
      if (!result.failed) {
        this.addStep(step, result.doc);
      }
      return result;
    };
    prototypeAccessors.docChanged.get = function() {
      return this.steps.length > 0;
    };
    Transform.prototype.addStep = function addStep(step, doc) {
      this.docs.push(this.doc);
      this.steps.push(step);
      this.mapping.appendMap(step.getMap());
      this.doc = doc;
    };
    Object.defineProperties(Transform.prototype, prototypeAccessors);
    function mustOverride() {
      throw new Error("Override me");
    }
    var stepsByID = Object.create(null);
    var Step = function Step2() {
    };
    Step.prototype.apply = function apply(_doc) {
      return mustOverride();
    };
    Step.prototype.getMap = function getMap() {
      return StepMap.empty;
    };
    Step.prototype.invert = function invert(_doc) {
      return mustOverride();
    };
    Step.prototype.map = function map2(_mapping) {
      return mustOverride();
    };
    Step.prototype.merge = function merge(_other) {
      return null;
    };
    Step.prototype.toJSON = function toJSON() {
      return mustOverride();
    };
    Step.fromJSON = function fromJSON(schema, json) {
      if (!json || !json.stepType) {
        throw new RangeError("Invalid input for Step.fromJSON");
      }
      var type = stepsByID[json.stepType];
      if (!type) {
        throw new RangeError("No step type " + json.stepType + " defined");
      }
      return type.fromJSON(schema, json);
    };
    Step.jsonID = function jsonID(id, stepClass) {
      if (id in stepsByID) {
        throw new RangeError("Duplicate use of step JSON ID " + id);
      }
      stepsByID[id] = stepClass;
      stepClass.prototype.jsonID = id;
      return stepClass;
    };
    var StepResult = function StepResult2(doc, failed) {
      this.doc = doc;
      this.failed = failed;
    };
    StepResult.ok = function ok(doc) {
      return new StepResult(doc, null);
    };
    StepResult.fail = function fail(message) {
      return new StepResult(null, message);
    };
    StepResult.fromReplace = function fromReplace(doc, from, to, slice) {
      try {
        return StepResult.ok(doc.replace(from, to, slice));
      } catch (e) {
        if (e instanceof prosemirrorModel.ReplaceError) {
          return StepResult.fail(e.message);
        }
        throw e;
      }
    };
    var ReplaceStep = /* @__PURE__ */ function(Step2) {
      function ReplaceStep2(from, to, slice, structure) {
        Step2.call(this);
        this.from = from;
        this.to = to;
        this.slice = slice;
        this.structure = !!structure;
      }
      if (Step2)
        ReplaceStep2.__proto__ = Step2;
      ReplaceStep2.prototype = Object.create(Step2 && Step2.prototype);
      ReplaceStep2.prototype.constructor = ReplaceStep2;
      ReplaceStep2.prototype.apply = function apply(doc) {
        if (this.structure && contentBetween(doc, this.from, this.to)) {
          return StepResult.fail("Structure replace would overwrite content");
        }
        return StepResult.fromReplace(doc, this.from, this.to, this.slice);
      };
      ReplaceStep2.prototype.getMap = function getMap() {
        return new StepMap([this.from, this.to - this.from, this.slice.size]);
      };
      ReplaceStep2.prototype.invert = function invert(doc) {
        return new ReplaceStep2(this.from, this.from + this.slice.size, doc.slice(this.from, this.to));
      };
      ReplaceStep2.prototype.map = function map2(mapping) {
        var from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
        if (from.deleted && to.deleted) {
          return null;
        }
        return new ReplaceStep2(from.pos, Math.max(from.pos, to.pos), this.slice);
      };
      ReplaceStep2.prototype.merge = function merge(other) {
        if (!(other instanceof ReplaceStep2) || other.structure || this.structure) {
          return null;
        }
        if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {
          var slice = this.slice.size + other.slice.size == 0 ? prosemirrorModel.Slice.empty : new prosemirrorModel.Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);
          return new ReplaceStep2(this.from, this.to + (other.to - other.from), slice, this.structure);
        } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {
          var slice$1 = this.slice.size + other.slice.size == 0 ? prosemirrorModel.Slice.empty : new prosemirrorModel.Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);
          return new ReplaceStep2(other.from, this.to, slice$1, this.structure);
        } else {
          return null;
        }
      };
      ReplaceStep2.prototype.toJSON = function toJSON() {
        var json = { stepType: "replace", from: this.from, to: this.to };
        if (this.slice.size) {
          json.slice = this.slice.toJSON();
        }
        if (this.structure) {
          json.structure = true;
        }
        return json;
      };
      ReplaceStep2.fromJSON = function fromJSON(schema, json) {
        if (typeof json.from != "number" || typeof json.to != "number") {
          throw new RangeError("Invalid input for ReplaceStep.fromJSON");
        }
        return new ReplaceStep2(json.from, json.to, prosemirrorModel.Slice.fromJSON(schema, json.slice), !!json.structure);
      };
      return ReplaceStep2;
    }(Step);
    Step.jsonID("replace", ReplaceStep);
    var ReplaceAroundStep = /* @__PURE__ */ function(Step2) {
      function ReplaceAroundStep2(from, to, gapFrom, gapTo, slice, insert, structure) {
        Step2.call(this);
        this.from = from;
        this.to = to;
        this.gapFrom = gapFrom;
        this.gapTo = gapTo;
        this.slice = slice;
        this.insert = insert;
        this.structure = !!structure;
      }
      if (Step2)
        ReplaceAroundStep2.__proto__ = Step2;
      ReplaceAroundStep2.prototype = Object.create(Step2 && Step2.prototype);
      ReplaceAroundStep2.prototype.constructor = ReplaceAroundStep2;
      ReplaceAroundStep2.prototype.apply = function apply(doc) {
        if (this.structure && (contentBetween(doc, this.from, this.gapFrom) || contentBetween(doc, this.gapTo, this.to))) {
          return StepResult.fail("Structure gap-replace would overwrite content");
        }
        var gap = doc.slice(this.gapFrom, this.gapTo);
        if (gap.openStart || gap.openEnd) {
          return StepResult.fail("Gap is not a flat range");
        }
        var inserted = this.slice.insertAt(this.insert, gap.content);
        if (!inserted) {
          return StepResult.fail("Content does not fit in gap");
        }
        return StepResult.fromReplace(doc, this.from, this.to, inserted);
      };
      ReplaceAroundStep2.prototype.getMap = function getMap() {
        return new StepMap([
          this.from,
          this.gapFrom - this.from,
          this.insert,
          this.gapTo,
          this.to - this.gapTo,
          this.slice.size - this.insert
        ]);
      };
      ReplaceAroundStep2.prototype.invert = function invert(doc) {
        var gap = this.gapTo - this.gapFrom;
        return new ReplaceAroundStep2(this.from, this.from + this.slice.size + gap, this.from + this.insert, this.from + this.insert + gap, doc.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
      };
      ReplaceAroundStep2.prototype.map = function map2(mapping) {
        var from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
        var gapFrom = mapping.map(this.gapFrom, -1), gapTo = mapping.map(this.gapTo, 1);
        if (from.deleted && to.deleted || gapFrom < from.pos || gapTo > to.pos) {
          return null;
        }
        return new ReplaceAroundStep2(from.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);
      };
      ReplaceAroundStep2.prototype.toJSON = function toJSON() {
        var json = {
          stepType: "replaceAround",
          from: this.from,
          to: this.to,
          gapFrom: this.gapFrom,
          gapTo: this.gapTo,
          insert: this.insert
        };
        if (this.slice.size) {
          json.slice = this.slice.toJSON();
        }
        if (this.structure) {
          json.structure = true;
        }
        return json;
      };
      ReplaceAroundStep2.fromJSON = function fromJSON(schema, json) {
        if (typeof json.from != "number" || typeof json.to != "number" || typeof json.gapFrom != "number" || typeof json.gapTo != "number" || typeof json.insert != "number") {
          throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
        }
        return new ReplaceAroundStep2(json.from, json.to, json.gapFrom, json.gapTo, prosemirrorModel.Slice.fromJSON(schema, json.slice), json.insert, !!json.structure);
      };
      return ReplaceAroundStep2;
    }(Step);
    Step.jsonID("replaceAround", ReplaceAroundStep);
    function contentBetween(doc, from, to) {
      var $from = doc.resolve(from), dist = to - from, depth = $from.depth;
      while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {
        depth--;
        dist--;
      }
      if (dist > 0) {
        var next = $from.node(depth).maybeChild($from.indexAfter(depth));
        while (dist > 0) {
          if (!next || next.isLeaf) {
            return true;
          }
          next = next.firstChild;
          dist--;
        }
      }
      return false;
    }
    function canCut(node, start, end) {
      return (start == 0 || node.canReplace(start, node.childCount)) && (end == node.childCount || node.canReplace(0, end));
    }
    function liftTarget(range) {
      var parent = range.parent;
      var content = parent.content.cutByIndex(range.startIndex, range.endIndex);
      for (var depth = range.depth; ; --depth) {
        var node = range.$from.node(depth);
        var index2 = range.$from.index(depth), endIndex = range.$to.indexAfter(depth);
        if (depth < range.depth && node.canReplace(index2, endIndex, content)) {
          return depth;
        }
        if (depth == 0 || node.type.spec.isolating || !canCut(node, index2, endIndex)) {
          break;
        }
      }
    }
    Transform.prototype.lift = function(range, target) {
      var $from = range.$from;
      var $to = range.$to;
      var depth = range.depth;
      var gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1);
      var start = gapStart, end = gapEnd;
      var before = prosemirrorModel.Fragment.empty, openStart = 0;
      for (var d = depth, splitting = false; d > target; d--) {
        if (splitting || $from.index(d) > 0) {
          splitting = true;
          before = prosemirrorModel.Fragment.from($from.node(d).copy(before));
          openStart++;
        } else {
          start--;
        }
      }
      var after = prosemirrorModel.Fragment.empty, openEnd = 0;
      for (var d$1 = depth, splitting$1 = false; d$1 > target; d$1--) {
        if (splitting$1 || $to.after(d$1 + 1) < $to.end(d$1)) {
          splitting$1 = true;
          after = prosemirrorModel.Fragment.from($to.node(d$1).copy(after));
          openEnd++;
        } else {
          end++;
        }
      }
      return this.step(new ReplaceAroundStep(start, end, gapStart, gapEnd, new prosemirrorModel.Slice(before.append(after), openStart, openEnd), before.size - openStart, true));
    };
    function findWrapping(range, nodeType, attrs, innerRange) {
      if (innerRange === void 0)
        innerRange = range;
      var around = findWrappingOutside(range, nodeType);
      var inner = around && findWrappingInside(innerRange, nodeType);
      if (!inner) {
        return null;
      }
      return around.map(withAttrs).concat({ type: nodeType, attrs }).concat(inner.map(withAttrs));
    }
    function withAttrs(type) {
      return { type, attrs: null };
    }
    function findWrappingOutside(range, type) {
      var parent = range.parent;
      var startIndex = range.startIndex;
      var endIndex = range.endIndex;
      var around = parent.contentMatchAt(startIndex).findWrapping(type);
      if (!around) {
        return null;
      }
      var outer = around.length ? around[0] : type;
      return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null;
    }
    function findWrappingInside(range, type) {
      var parent = range.parent;
      var startIndex = range.startIndex;
      var endIndex = range.endIndex;
      var inner = parent.child(startIndex);
      var inside = type.contentMatch.findWrapping(inner.type);
      if (!inside) {
        return null;
      }
      var lastType = inside.length ? inside[inside.length - 1] : type;
      var innerMatch = lastType.contentMatch;
      for (var i = startIndex; innerMatch && i < endIndex; i++) {
        innerMatch = innerMatch.matchType(parent.child(i).type);
      }
      if (!innerMatch || !innerMatch.validEnd) {
        return null;
      }
      return inside;
    }
    Transform.prototype.wrap = function(range, wrappers) {
      var content = prosemirrorModel.Fragment.empty;
      for (var i = wrappers.length - 1; i >= 0; i--) {
        content = prosemirrorModel.Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));
      }
      var start = range.start, end = range.end;
      return this.step(new ReplaceAroundStep(start, end, start, end, new prosemirrorModel.Slice(content, 0, 0), wrappers.length, true));
    };
    Transform.prototype.setBlockType = function(from, to, type, attrs) {
      var this$1 = this;
      if (to === void 0)
        to = from;
      if (!type.isTextblock) {
        throw new RangeError("Type given to setBlockType should be a textblock");
      }
      var mapFrom = this.steps.length;
      this.doc.nodesBetween(from, to, function(node, pos) {
        if (node.isTextblock && !node.hasMarkup(type, attrs) && canChangeType(this$1.doc, this$1.mapping.slice(mapFrom).map(pos), type)) {
          this$1.clearIncompatible(this$1.mapping.slice(mapFrom).map(pos, 1), type);
          var mapping = this$1.mapping.slice(mapFrom);
          var startM = mapping.map(pos, 1), endM = mapping.map(pos + node.nodeSize, 1);
          this$1.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1, new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(type.create(attrs, null, node.marks)), 0, 0), 1, true));
          return false;
        }
      });
      return this;
    };
    function canChangeType(doc, pos, type) {
      var $pos = doc.resolve(pos), index2 = $pos.index();
      return $pos.parent.canReplaceWith(index2, index2 + 1, type);
    }
    Transform.prototype.setNodeMarkup = function(pos, type, attrs, marks) {
      var node = this.doc.nodeAt(pos);
      if (!node) {
        throw new RangeError("No node at given position");
      }
      if (!type) {
        type = node.type;
      }
      var newNode = type.create(attrs, null, marks || node.marks);
      if (node.isLeaf) {
        return this.replaceWith(pos, pos + node.nodeSize, newNode);
      }
      if (!type.validContent(node.content)) {
        throw new RangeError("Invalid content for node type " + type.name);
      }
      return this.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1, new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(newNode), 0, 0), 1, true));
    };
    function canSplit(doc, pos, depth, typesAfter) {
      if (depth === void 0)
        depth = 1;
      var $pos = doc.resolve(pos), base2 = $pos.depth - depth;
      var innerType = typesAfter && typesAfter[typesAfter.length - 1] || $pos.parent;
      if (base2 < 0 || $pos.parent.type.spec.isolating || !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) || !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount))) {
        return false;
      }
      for (var d = $pos.depth - 1, i = depth - 2; d > base2; d--, i--) {
        var node = $pos.node(d), index$12 = $pos.index(d);
        if (node.type.spec.isolating) {
          return false;
        }
        var rest = node.content.cutByIndex(index$12, node.childCount);
        var after = typesAfter && typesAfter[i] || node;
        if (after != node) {
          rest = rest.replaceChild(0, after.type.create(after.attrs));
        }
        if (!node.canReplace(index$12 + 1, node.childCount) || !after.type.validContent(rest)) {
          return false;
        }
      }
      var index2 = $pos.indexAfter(base2);
      var baseType = typesAfter && typesAfter[0];
      return $pos.node(base2).canReplaceWith(index2, index2, baseType ? baseType.type : $pos.node(base2 + 1).type);
    }
    Transform.prototype.split = function(pos, depth, typesAfter) {
      if (depth === void 0)
        depth = 1;
      var $pos = this.doc.resolve(pos), before = prosemirrorModel.Fragment.empty, after = prosemirrorModel.Fragment.empty;
      for (var d = $pos.depth, e = $pos.depth - depth, i = depth - 1; d > e; d--, i--) {
        before = prosemirrorModel.Fragment.from($pos.node(d).copy(before));
        var typeAfter = typesAfter && typesAfter[i];
        after = prosemirrorModel.Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after));
      }
      return this.step(new ReplaceStep(pos, pos, new prosemirrorModel.Slice(before.append(after), depth, depth), true));
    };
    function canJoin(doc, pos) {
      var $pos = doc.resolve(pos), index2 = $pos.index();
      return joinable($pos.nodeBefore, $pos.nodeAfter) && $pos.parent.canReplace(index2, index2 + 1);
    }
    function joinable(a, b) {
      return a && b && !a.isLeaf && a.canAppend(b);
    }
    function joinPoint(doc, pos, dir) {
      if (dir === void 0)
        dir = -1;
      var $pos = doc.resolve(pos);
      for (var d = $pos.depth; ; d--) {
        var before = void 0, after = void 0, index2 = $pos.index(d);
        if (d == $pos.depth) {
          before = $pos.nodeBefore;
          after = $pos.nodeAfter;
        } else if (dir > 0) {
          before = $pos.node(d + 1);
          index2++;
          after = $pos.node(d).maybeChild(index2);
        } else {
          before = $pos.node(d).maybeChild(index2 - 1);
          after = $pos.node(d + 1);
        }
        if (before && !before.isTextblock && joinable(before, after) && $pos.node(d).canReplace(index2, index2 + 1)) {
          return pos;
        }
        if (d == 0) {
          break;
        }
        pos = dir < 0 ? $pos.before(d) : $pos.after(d);
      }
    }
    Transform.prototype.join = function(pos, depth) {
      if (depth === void 0)
        depth = 1;
      var step = new ReplaceStep(pos - depth, pos + depth, prosemirrorModel.Slice.empty, true);
      return this.step(step);
    };
    function insertPoint(doc, pos, nodeType) {
      var $pos = doc.resolve(pos);
      if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType)) {
        return pos;
      }
      if ($pos.parentOffset == 0) {
        for (var d = $pos.depth - 1; d >= 0; d--) {
          var index2 = $pos.index(d);
          if ($pos.node(d).canReplaceWith(index2, index2, nodeType)) {
            return $pos.before(d + 1);
          }
          if (index2 > 0) {
            return null;
          }
        }
      }
      if ($pos.parentOffset == $pos.parent.content.size) {
        for (var d$1 = $pos.depth - 1; d$1 >= 0; d$1--) {
          var index$12 = $pos.indexAfter(d$1);
          if ($pos.node(d$1).canReplaceWith(index$12, index$12, nodeType)) {
            return $pos.after(d$1 + 1);
          }
          if (index$12 < $pos.node(d$1).childCount) {
            return null;
          }
        }
      }
    }
    function dropPoint(doc, pos, slice) {
      var $pos = doc.resolve(pos);
      if (!slice.content.size) {
        return pos;
      }
      var content = slice.content;
      for (var i = 0; i < slice.openStart; i++) {
        content = content.firstChild.content;
      }
      for (var pass = 1; pass <= (slice.openStart == 0 && slice.size ? 2 : 1); pass++) {
        for (var d = $pos.depth; d >= 0; d--) {
          var bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1;
          var insertPos = $pos.index(d) + (bias > 0 ? 1 : 0);
          var parent = $pos.node(d), fits = false;
          if (pass == 1) {
            fits = parent.canReplace(insertPos, insertPos, content);
          } else {
            var wrapping = parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type);
            fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0]);
          }
          if (fits) {
            return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1);
          }
        }
      }
      return null;
    }
    function mapFragment(fragment, f, parent) {
      var mapped = [];
      for (var i = 0; i < fragment.childCount; i++) {
        var child = fragment.child(i);
        if (child.content.size) {
          child = child.copy(mapFragment(child.content, f, child));
        }
        if (child.isInline) {
          child = f(child, parent, i);
        }
        mapped.push(child);
      }
      return prosemirrorModel.Fragment.fromArray(mapped);
    }
    var AddMarkStep = /* @__PURE__ */ function(Step2) {
      function AddMarkStep2(from, to, mark) {
        Step2.call(this);
        this.from = from;
        this.to = to;
        this.mark = mark;
      }
      if (Step2)
        AddMarkStep2.__proto__ = Step2;
      AddMarkStep2.prototype = Object.create(Step2 && Step2.prototype);
      AddMarkStep2.prototype.constructor = AddMarkStep2;
      AddMarkStep2.prototype.apply = function apply(doc) {
        var this$1 = this;
        var oldSlice = doc.slice(this.from, this.to), $from = doc.resolve(this.from);
        var parent = $from.node($from.sharedDepth(this.to));
        var slice = new prosemirrorModel.Slice(mapFragment(oldSlice.content, function(node, parent2) {
          if (!node.isAtom || !parent2.type.allowsMarkType(this$1.mark.type)) {
            return node;
          }
          return node.mark(this$1.mark.addToSet(node.marks));
        }, parent), oldSlice.openStart, oldSlice.openEnd);
        return StepResult.fromReplace(doc, this.from, this.to, slice);
      };
      AddMarkStep2.prototype.invert = function invert() {
        return new RemoveMarkStep(this.from, this.to, this.mark);
      };
      AddMarkStep2.prototype.map = function map2(mapping) {
        var from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
        if (from.deleted && to.deleted || from.pos >= to.pos) {
          return null;
        }
        return new AddMarkStep2(from.pos, to.pos, this.mark);
      };
      AddMarkStep2.prototype.merge = function merge(other) {
        if (other instanceof AddMarkStep2 && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from) {
          return new AddMarkStep2(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
        }
      };
      AddMarkStep2.prototype.toJSON = function toJSON() {
        return {
          stepType: "addMark",
          mark: this.mark.toJSON(),
          from: this.from,
          to: this.to
        };
      };
      AddMarkStep2.fromJSON = function fromJSON(schema, json) {
        if (typeof json.from != "number" || typeof json.to != "number") {
          throw new RangeError("Invalid input for AddMarkStep.fromJSON");
        }
        return new AddMarkStep2(json.from, json.to, schema.markFromJSON(json.mark));
      };
      return AddMarkStep2;
    }(Step);
    Step.jsonID("addMark", AddMarkStep);
    var RemoveMarkStep = /* @__PURE__ */ function(Step2) {
      function RemoveMarkStep2(from, to, mark) {
        Step2.call(this);
        this.from = from;
        this.to = to;
        this.mark = mark;
      }
      if (Step2)
        RemoveMarkStep2.__proto__ = Step2;
      RemoveMarkStep2.prototype = Object.create(Step2 && Step2.prototype);
      RemoveMarkStep2.prototype.constructor = RemoveMarkStep2;
      RemoveMarkStep2.prototype.apply = function apply(doc) {
        var this$1 = this;
        var oldSlice = doc.slice(this.from, this.to);
        var slice = new prosemirrorModel.Slice(mapFragment(oldSlice.content, function(node) {
          return node.mark(this$1.mark.removeFromSet(node.marks));
        }), oldSlice.openStart, oldSlice.openEnd);
        return StepResult.fromReplace(doc, this.from, this.to, slice);
      };
      RemoveMarkStep2.prototype.invert = function invert() {
        return new AddMarkStep(this.from, this.to, this.mark);
      };
      RemoveMarkStep2.prototype.map = function map2(mapping) {
        var from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
        if (from.deleted && to.deleted || from.pos >= to.pos) {
          return null;
        }
        return new RemoveMarkStep2(from.pos, to.pos, this.mark);
      };
      RemoveMarkStep2.prototype.merge = function merge(other) {
        if (other instanceof RemoveMarkStep2 && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from) {
          return new RemoveMarkStep2(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
        }
      };
      RemoveMarkStep2.prototype.toJSON = function toJSON() {
        return {
          stepType: "removeMark",
          mark: this.mark.toJSON(),
          from: this.from,
          to: this.to
        };
      };
      RemoveMarkStep2.fromJSON = function fromJSON(schema, json) {
        if (typeof json.from != "number" || typeof json.to != "number") {
          throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
        }
        return new RemoveMarkStep2(json.from, json.to, schema.markFromJSON(json.mark));
      };
      return RemoveMarkStep2;
    }(Step);
    Step.jsonID("removeMark", RemoveMarkStep);
    Transform.prototype.addMark = function(from, to, mark) {
      var this$1 = this;
      var removed = [], added = [], removing = null, adding = null;
      this.doc.nodesBetween(from, to, function(node, pos, parent) {
        if (!node.isInline) {
          return;
        }
        var marks = node.marks;
        if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {
          var start = Math.max(pos, from), end = Math.min(pos + node.nodeSize, to);
          var newSet = mark.addToSet(marks);
          for (var i = 0; i < marks.length; i++) {
            if (!marks[i].isInSet(newSet)) {
              if (removing && removing.to == start && removing.mark.eq(marks[i])) {
                removing.to = end;
              } else {
                removed.push(removing = new RemoveMarkStep(start, end, marks[i]));
              }
            }
          }
          if (adding && adding.to == start) {
            adding.to = end;
          } else {
            added.push(adding = new AddMarkStep(start, end, mark));
          }
        }
      });
      removed.forEach(function(s2) {
        return this$1.step(s2);
      });
      added.forEach(function(s2) {
        return this$1.step(s2);
      });
      return this;
    };
    Transform.prototype.removeMark = function(from, to, mark) {
      var this$1 = this;
      if (mark === void 0)
        mark = null;
      var matched = [], step = 0;
      this.doc.nodesBetween(from, to, function(node, pos) {
        if (!node.isInline) {
          return;
        }
        step++;
        var toRemove = null;
        if (mark instanceof prosemirrorModel.MarkType) {
          var set = node.marks, found;
          while (found = mark.isInSet(set)) {
            (toRemove || (toRemove = [])).push(found);
            set = found.removeFromSet(set);
          }
        } else if (mark) {
          if (mark.isInSet(node.marks)) {
            toRemove = [mark];
          }
        } else {
          toRemove = node.marks;
        }
        if (toRemove && toRemove.length) {
          var end = Math.min(pos + node.nodeSize, to);
          for (var i = 0; i < toRemove.length; i++) {
            var style = toRemove[i], found$1 = void 0;
            for (var j = 0; j < matched.length; j++) {
              var m = matched[j];
              if (m.step == step - 1 && style.eq(matched[j].style)) {
                found$1 = m;
              }
            }
            if (found$1) {
              found$1.to = end;
              found$1.step = step;
            } else {
              matched.push({ style, from: Math.max(pos, from), to: end, step });
            }
          }
        }
      });
      matched.forEach(function(m) {
        return this$1.step(new RemoveMarkStep(m.from, m.to, m.style));
      });
      return this;
    };
    Transform.prototype.clearIncompatible = function(pos, parentType, match) {
      if (match === void 0)
        match = parentType.contentMatch;
      var node = this.doc.nodeAt(pos);
      var delSteps = [], cur = pos + 1;
      for (var i = 0; i < node.childCount; i++) {
        var child = node.child(i), end = cur + child.nodeSize;
        var allowed = match.matchType(child.type, child.attrs);
        if (!allowed) {
          delSteps.push(new ReplaceStep(cur, end, prosemirrorModel.Slice.empty));
        } else {
          match = allowed;
          for (var j = 0; j < child.marks.length; j++) {
            if (!parentType.allowsMarkType(child.marks[j].type)) {
              this.step(new RemoveMarkStep(cur, end, child.marks[j]));
            }
          }
        }
        cur = end;
      }
      if (!match.validEnd) {
        var fill = match.fillBefore(prosemirrorModel.Fragment.empty, true);
        this.replace(cur, cur, new prosemirrorModel.Slice(fill, 0, 0));
      }
      for (var i$1 = delSteps.length - 1; i$1 >= 0; i$1--) {
        this.step(delSteps[i$1]);
      }
      return this;
    };
    function replaceStep(doc, from, to, slice) {
      if (to === void 0)
        to = from;
      if (slice === void 0)
        slice = prosemirrorModel.Slice.empty;
      if (from == to && !slice.size) {
        return null;
      }
      var $from = doc.resolve(from), $to = doc.resolve(to);
      if (fitsTrivially($from, $to, slice)) {
        return new ReplaceStep(from, to, slice);
      }
      return new Fitter($from, $to, slice).fit();
    }
    Transform.prototype.replace = function(from, to, slice) {
      if (to === void 0)
        to = from;
      if (slice === void 0)
        slice = prosemirrorModel.Slice.empty;
      var step = replaceStep(this.doc, from, to, slice);
      if (step) {
        this.step(step);
      }
      return this;
    };
    Transform.prototype.replaceWith = function(from, to, content) {
      return this.replace(from, to, new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(content), 0, 0));
    };
    Transform.prototype.delete = function(from, to) {
      return this.replace(from, to, prosemirrorModel.Slice.empty);
    };
    Transform.prototype.insert = function(pos, content) {
      return this.replaceWith(pos, pos, content);
    };
    function fitsTrivially($from, $to, slice) {
      return !slice.openStart && !slice.openEnd && $from.start() == $to.start() && $from.parent.canReplace($from.index(), $to.index(), slice.content);
    }
    var Fitter = function Fitter2($from, $to, slice) {
      this.$to = $to;
      this.$from = $from;
      this.unplaced = slice;
      this.frontier = [];
      for (var i = 0; i <= $from.depth; i++) {
        var node = $from.node(i);
        this.frontier.push({
          type: node.type,
          match: node.contentMatchAt($from.indexAfter(i))
        });
      }
      this.placed = prosemirrorModel.Fragment.empty;
      for (var i$1 = $from.depth; i$1 > 0; i$1--) {
        this.placed = prosemirrorModel.Fragment.from($from.node(i$1).copy(this.placed));
      }
    };
    var prototypeAccessors$1 = { depth: { configurable: true } };
    prototypeAccessors$1.depth.get = function() {
      return this.frontier.length - 1;
    };
    Fitter.prototype.fit = function fit() {
      while (this.unplaced.size) {
        var fit2 = this.findFittable();
        if (fit2) {
          this.placeNodes(fit2);
        } else {
          this.openMore() || this.dropNode();
        }
      }
      var moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth;
      var $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));
      if (!$to) {
        return null;
      }
      var content = this.placed, openStart = $from.depth, openEnd = $to.depth;
      while (openStart && openEnd && content.childCount == 1) {
        content = content.firstChild.content;
        openStart--;
        openEnd--;
      }
      var slice = new prosemirrorModel.Slice(content, openStart, openEnd);
      if (moveInline > -1) {
        return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice, placedSize);
      }
      if (slice.size || $from.pos != this.$to.pos) {
        return new ReplaceStep($from.pos, $to.pos, slice);
      }
    };
    Fitter.prototype.findFittable = function findFittable() {
      for (var pass = 1; pass <= 2; pass++) {
        for (var sliceDepth = this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {
          var fragment = void 0, parent = void 0;
          if (sliceDepth) {
            parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild;
            fragment = parent.content;
          } else {
            fragment = this.unplaced.content;
          }
          var first = fragment.firstChild;
          for (var frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {
            var ref = this.frontier[frontierDepth];
            var type = ref.type;
            var match = ref.match;
            var wrap = void 0, inject = void 0;
            if (pass == 1 && (first ? match.matchType(first.type) || (inject = match.fillBefore(prosemirrorModel.Fragment.from(first), false)) : type.compatibleContent(parent.type))) {
              return { sliceDepth, frontierDepth, parent, inject };
            } else if (pass == 2 && first && (wrap = match.findWrapping(first.type))) {
              return { sliceDepth, frontierDepth, parent, wrap };
            }
            if (parent && match.matchType(parent.type)) {
              break;
            }
          }
        }
      }
    };
    Fitter.prototype.openMore = function openMore() {
      var ref = this.unplaced;
      var content = ref.content;
      var openStart = ref.openStart;
      var openEnd = ref.openEnd;
      var inner = contentAt(content, openStart);
      if (!inner.childCount || inner.firstChild.isLeaf) {
        return false;
      }
      this.unplaced = new prosemirrorModel.Slice(content, openStart + 1, Math.max(openEnd, inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0));
      return true;
    };
    Fitter.prototype.dropNode = function dropNode() {
      var ref = this.unplaced;
      var content = ref.content;
      var openStart = ref.openStart;
      var openEnd = ref.openEnd;
      var inner = contentAt(content, openStart);
      if (inner.childCount <= 1 && openStart > 0) {
        var openAtEnd = content.size - openStart <= openStart + inner.size;
        this.unplaced = new prosemirrorModel.Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1, openAtEnd ? openStart - 1 : openEnd);
      } else {
        this.unplaced = new prosemirrorModel.Slice(dropFromFragment(content, openStart, 1), openStart, openEnd);
      }
    };
    Fitter.prototype.placeNodes = function placeNodes(ref) {
      var sliceDepth = ref.sliceDepth;
      var frontierDepth = ref.frontierDepth;
      var parent = ref.parent;
      var inject = ref.inject;
      var wrap = ref.wrap;
      while (this.depth > frontierDepth) {
        this.closeFrontierNode();
      }
      if (wrap) {
        for (var i = 0; i < wrap.length; i++) {
          this.openFrontierNode(wrap[i]);
        }
      }
      var slice = this.unplaced, fragment = parent ? parent.content : slice.content;
      var openStart = slice.openStart - sliceDepth;
      var taken = 0, add = [];
      var ref$1 = this.frontier[frontierDepth];
      var match = ref$1.match;
      var type = ref$1.type;
      if (inject) {
        for (var i$1 = 0; i$1 < inject.childCount; i$1++) {
          add.push(inject.child(i$1));
        }
        match = match.matchFragment(inject);
      }
      var openEndCount = fragment.size + sliceDepth - (slice.content.size - slice.openEnd);
      while (taken < fragment.childCount) {
        var next = fragment.child(taken), matches = match.matchType(next.type);
        if (!matches) {
          break;
        }
        taken++;
        if (taken > 1 || openStart == 0 || next.content.size) {
          match = matches;
          add.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0, taken == fragment.childCount ? openEndCount : -1));
        }
      }
      var toEnd = taken == fragment.childCount;
      if (!toEnd) {
        openEndCount = -1;
      }
      this.placed = addToFragment(this.placed, frontierDepth, prosemirrorModel.Fragment.from(add));
      this.frontier[frontierDepth].match = match;
      if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1) {
        this.closeFrontierNode();
      }
      for (var i$2 = 0, cur = fragment; i$2 < openEndCount; i$2++) {
        var node = cur.lastChild;
        this.frontier.push({ type: node.type, match: node.contentMatchAt(node.childCount) });
        cur = node.content;
      }
      this.unplaced = !toEnd ? new prosemirrorModel.Slice(dropFromFragment(slice.content, sliceDepth, taken), slice.openStart, slice.openEnd) : sliceDepth == 0 ? prosemirrorModel.Slice.empty : new prosemirrorModel.Slice(dropFromFragment(slice.content, sliceDepth - 1, 1), sliceDepth - 1, openEndCount < 0 ? slice.openEnd : sliceDepth - 1);
    };
    Fitter.prototype.mustMoveInline = function mustMoveInline() {
      if (!this.$to.parent.isTextblock || this.$to.end() == this.$to.pos) {
        return -1;
      }
      var top = this.frontier[this.depth], level;
      if (!top.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top.type, top.match, false) || this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth) {
        return -1;
      }
      var ref = this.$to;
      var depth = ref.depth;
      var after = this.$to.after(depth);
      while (depth > 1 && after == this.$to.end(--depth)) {
        ++after;
      }
      return after;
    };
    Fitter.prototype.findCloseLevel = function findCloseLevel($to) {
      scan:
        for (var i = Math.min(this.depth, $to.depth); i >= 0; i--) {
          var ref = this.frontier[i];
          var match = ref.match;
          var type = ref.type;
          var dropInner = i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1));
          var fit = contentAfterFits($to, i, type, match, dropInner);
          if (!fit) {
            continue;
          }
          for (var d = i - 1; d >= 0; d--) {
            var ref$1 = this.frontier[d];
            var match$1 = ref$1.match;
            var type$1 = ref$1.type;
            var matches = contentAfterFits($to, d, type$1, match$1, true);
            if (!matches || matches.childCount) {
              continue scan;
            }
          }
          return { depth: i, fit, move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to };
        }
    };
    Fitter.prototype.close = function close($to) {
      var close2 = this.findCloseLevel($to);
      if (!close2) {
        return null;
      }
      while (this.depth > close2.depth) {
        this.closeFrontierNode();
      }
      if (close2.fit.childCount) {
        this.placed = addToFragment(this.placed, close2.depth, close2.fit);
      }
      $to = close2.move;
      for (var d = close2.depth + 1; d <= $to.depth; d++) {
        var node = $to.node(d), add = node.type.contentMatch.fillBefore(node.content, true, $to.index(d));
        this.openFrontierNode(node.type, node.attrs, add);
      }
      return $to;
    };
    Fitter.prototype.openFrontierNode = function openFrontierNode(type, attrs, content) {
      var top = this.frontier[this.depth];
      top.match = top.match.matchType(type);
      this.placed = addToFragment(this.placed, this.depth, prosemirrorModel.Fragment.from(type.create(attrs, content)));
      this.frontier.push({ type, match: type.contentMatch });
    };
    Fitter.prototype.closeFrontierNode = function closeFrontierNode() {
      var open = this.frontier.pop();
      var add = open.match.fillBefore(prosemirrorModel.Fragment.empty, true);
      if (add.childCount) {
        this.placed = addToFragment(this.placed, this.frontier.length, add);
      }
    };
    Object.defineProperties(Fitter.prototype, prototypeAccessors$1);
    function dropFromFragment(fragment, depth, count) {
      if (depth == 0) {
        return fragment.cutByIndex(count);
      }
      return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)));
    }
    function addToFragment(fragment, depth, content) {
      if (depth == 0) {
        return fragment.append(content);
      }
      return fragment.replaceChild(fragment.childCount - 1, fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content)));
    }
    function contentAt(fragment, depth) {
      for (var i = 0; i < depth; i++) {
        fragment = fragment.firstChild.content;
      }
      return fragment;
    }
    function closeNodeStart(node, openStart, openEnd) {
      if (openStart <= 0) {
        return node;
      }
      var frag = node.content;
      if (openStart > 1) {
        frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0));
      }
      if (openStart > 0) {
        frag = node.type.contentMatch.fillBefore(frag).append(frag);
        if (openEnd <= 0) {
          frag = frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(prosemirrorModel.Fragment.empty, true));
        }
      }
      return node.copy(frag);
    }
    function contentAfterFits($to, depth, type, match, open) {
      var node = $to.node(depth), index2 = open ? $to.indexAfter(depth) : $to.index(depth);
      if (index2 == node.childCount && !type.compatibleContent(node.type)) {
        return null;
      }
      var fit = match.fillBefore(node.content, true, index2);
      return fit && !invalidMarks(type, node.content, index2) ? fit : null;
    }
    function invalidMarks(type, fragment, start) {
      for (var i = start; i < fragment.childCount; i++) {
        if (!type.allowsMarks(fragment.child(i).marks)) {
          return true;
        }
      }
      return false;
    }
    Transform.prototype.replaceRange = function(from, to, slice) {
      if (!slice.size) {
        return this.deleteRange(from, to);
      }
      var $from = this.doc.resolve(from), $to = this.doc.resolve(to);
      if (fitsTrivially($from, $to, slice)) {
        return this.step(new ReplaceStep(from, to, slice));
      }
      var targetDepths = coveredDepths($from, this.doc.resolve(to));
      if (targetDepths[targetDepths.length - 1] == 0) {
        targetDepths.pop();
      }
      var preferredTarget = -($from.depth + 1);
      targetDepths.unshift(preferredTarget);
      for (var d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {
        var spec = $from.node(d).type.spec;
        if (spec.defining || spec.isolating) {
          break;
        }
        if (targetDepths.indexOf(d) > -1) {
          preferredTarget = d;
        } else if ($from.before(d) == pos) {
          targetDepths.splice(1, 0, -d);
        }
      }
      var preferredTargetIndex = targetDepths.indexOf(preferredTarget);
      var leftNodes = [], preferredDepth = slice.openStart;
      for (var content = slice.content, i = 0; ; i++) {
        var node = content.firstChild;
        leftNodes.push(node);
        if (i == slice.openStart) {
          break;
        }
        content = node.content;
      }
      if (preferredDepth > 0 && leftNodes[preferredDepth - 1].type.spec.defining && $from.node(preferredTargetIndex).type != leftNodes[preferredDepth - 1].type) {
        preferredDepth -= 1;
      } else if (preferredDepth >= 2 && leftNodes[preferredDepth - 1].isTextblock && leftNodes[preferredDepth - 2].type.spec.defining && $from.node(preferredTargetIndex).type != leftNodes[preferredDepth - 2].type) {
        preferredDepth -= 2;
      }
      for (var j = slice.openStart; j >= 0; j--) {
        var openDepth = (j + preferredDepth + 1) % (slice.openStart + 1);
        var insert = leftNodes[openDepth];
        if (!insert) {
          continue;
        }
        for (var i$1 = 0; i$1 < targetDepths.length; i$1++) {
          var targetDepth = targetDepths[(i$1 + preferredTargetIndex) % targetDepths.length], expand = true;
          if (targetDepth < 0) {
            expand = false;
            targetDepth = -targetDepth;
          }
          var parent = $from.node(targetDepth - 1), index2 = $from.index(targetDepth - 1);
          if (parent.canReplaceWith(index2, index2, insert.type, insert.marks)) {
            return this.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to, new prosemirrorModel.Slice(closeFragment(slice.content, 0, slice.openStart, openDepth), openDepth, slice.openEnd));
          }
        }
      }
      var startSteps = this.steps.length;
      for (var i$2 = targetDepths.length - 1; i$2 >= 0; i$2--) {
        this.replace(from, to, slice);
        if (this.steps.length > startSteps) {
          break;
        }
        var depth = targetDepths[i$2];
        if (depth < 0) {
          continue;
        }
        from = $from.before(depth);
        to = $to.after(depth);
      }
      return this;
    };
    function closeFragment(fragment, depth, oldOpen, newOpen, parent) {
      if (depth < oldOpen) {
        var first = fragment.firstChild;
        fragment = fragment.replaceChild(0, first.copy(closeFragment(first.content, depth + 1, oldOpen, newOpen, first)));
      }
      if (depth > newOpen) {
        var match = parent.contentMatchAt(0);
        var start = match.fillBefore(fragment).append(fragment);
        fragment = start.append(match.matchFragment(start).fillBefore(prosemirrorModel.Fragment.empty, true));
      }
      return fragment;
    }
    Transform.prototype.replaceRangeWith = function(from, to, node) {
      if (!node.isInline && from == to && this.doc.resolve(from).parent.content.size) {
        var point = insertPoint(this.doc, from, node.type);
        if (point != null) {
          from = to = point;
        }
      }
      return this.replaceRange(from, to, new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(node), 0, 0));
    };
    Transform.prototype.deleteRange = function(from, to) {
      var $from = this.doc.resolve(from), $to = this.doc.resolve(to);
      var covered = coveredDepths($from, $to);
      for (var i = 0; i < covered.length; i++) {
        var depth = covered[i], last = i == covered.length - 1;
        if (last && depth == 0 || $from.node(depth).type.contentMatch.validEnd) {
          return this.delete($from.start(depth), $to.end(depth));
        }
        if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1)))) {
          return this.delete($from.before(depth), $to.after(depth));
        }
      }
      for (var d = 1; d <= $from.depth && d <= $to.depth; d++) {
        if (from - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d) {
          return this.delete($from.before(d), to);
        }
      }
      return this.delete(from, to);
    };
    function coveredDepths($from, $to) {
      var result = [], minDepth = Math.min($from.depth, $to.depth);
      for (var d = minDepth; d >= 0; d--) {
        var start = $from.start(d);
        if (start < $from.pos - ($from.depth - d) || $to.end(d) > $to.pos + ($to.depth - d) || $from.node(d).type.spec.isolating || $to.node(d).type.spec.isolating) {
          break;
        }
        if (start == $to.start(d) || d == $from.depth && d == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent && d && $to.start(d - 1) == start - 1) {
          result.push(d);
        }
      }
      return result;
    }
    exports.AddMarkStep = AddMarkStep;
    exports.MapResult = MapResult;
    exports.Mapping = Mapping;
    exports.RemoveMarkStep = RemoveMarkStep;
    exports.ReplaceAroundStep = ReplaceAroundStep;
    exports.ReplaceStep = ReplaceStep;
    exports.Step = Step;
    exports.StepMap = StepMap;
    exports.StepResult = StepResult;
    exports.Transform = Transform;
    exports.TransformError = TransformError;
    exports.canJoin = canJoin;
    exports.canSplit = canSplit;
    exports.dropPoint = dropPoint;
    exports.findWrapping = findWrapping;
    exports.insertPoint = insertPoint;
    exports.joinPoint = joinPoint;
    exports.liftTarget = liftTarget;
    exports.replaceStep = replaceStep;
  }
});

// node_modules/prosemirror-state/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/prosemirror-state/dist/index.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var prosemirrorModel = require_dist();
    var prosemirrorTransform = require_dist2();
    var classesById = Object.create(null);
    var Selection = function Selection2($anchor, $head, ranges) {
      this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];
      this.$anchor = $anchor;
      this.$head = $head;
    };
    var prototypeAccessors = { anchor: { configurable: true }, head: { configurable: true }, from: { configurable: true }, to: { configurable: true }, $from: { configurable: true }, $to: { configurable: true }, empty: { configurable: true } };
    prototypeAccessors.anchor.get = function() {
      return this.$anchor.pos;
    };
    prototypeAccessors.head.get = function() {
      return this.$head.pos;
    };
    prototypeAccessors.from.get = function() {
      return this.$from.pos;
    };
    prototypeAccessors.to.get = function() {
      return this.$to.pos;
    };
    prototypeAccessors.$from.get = function() {
      return this.ranges[0].$from;
    };
    prototypeAccessors.$to.get = function() {
      return this.ranges[0].$to;
    };
    prototypeAccessors.empty.get = function() {
      var ranges = this.ranges;
      for (var i = 0; i < ranges.length; i++) {
        if (ranges[i].$from.pos != ranges[i].$to.pos) {
          return false;
        }
      }
      return true;
    };
    Selection.prototype.content = function content() {
      return this.$from.node(0).slice(this.from, this.to, true);
    };
    Selection.prototype.replace = function replace(tr, content) {
      if (content === void 0)
        content = prosemirrorModel.Slice.empty;
      var lastNode = content.content.lastChild, lastParent = null;
      for (var i = 0; i < content.openEnd; i++) {
        lastParent = lastNode;
        lastNode = lastNode.lastChild;
      }
      var mapFrom = tr.steps.length, ranges = this.ranges;
      for (var i$1 = 0; i$1 < ranges.length; i$1++) {
        var ref = ranges[i$1];
        var $from = ref.$from;
        var $to = ref.$to;
        var mapping = tr.mapping.slice(mapFrom);
        tr.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i$1 ? prosemirrorModel.Slice.empty : content);
        if (i$1 == 0) {
          selectionToInsertionEnd(tr, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1);
        }
      }
    };
    Selection.prototype.replaceWith = function replaceWith(tr, node) {
      var mapFrom = tr.steps.length, ranges = this.ranges;
      for (var i = 0; i < ranges.length; i++) {
        var ref = ranges[i];
        var $from = ref.$from;
        var $to = ref.$to;
        var mapping = tr.mapping.slice(mapFrom);
        var from = mapping.map($from.pos), to = mapping.map($to.pos);
        if (i) {
          tr.deleteRange(from, to);
        } else {
          tr.replaceRangeWith(from, to, node);
          selectionToInsertionEnd(tr, mapFrom, node.isInline ? -1 : 1);
        }
      }
    };
    Selection.findFrom = function findFrom($pos, dir, textOnly) {
      var inner = $pos.parent.inlineContent ? new TextSelection($pos) : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);
      if (inner) {
        return inner;
      }
      for (var depth = $pos.depth - 1; depth >= 0; depth--) {
        var found = dir < 0 ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly) : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);
        if (found) {
          return found;
        }
      }
    };
    Selection.near = function near($pos, bias) {
      if (bias === void 0)
        bias = 1;
      return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0));
    };
    Selection.atStart = function atStart(doc) {
      return findSelectionIn(doc, doc, 0, 0, 1) || new AllSelection(doc);
    };
    Selection.atEnd = function atEnd(doc) {
      return findSelectionIn(doc, doc, doc.content.size, doc.childCount, -1) || new AllSelection(doc);
    };
    Selection.fromJSON = function fromJSON(doc, json) {
      if (!json || !json.type) {
        throw new RangeError("Invalid input for Selection.fromJSON");
      }
      var cls = classesById[json.type];
      if (!cls) {
        throw new RangeError("No selection type " + json.type + " defined");
      }
      return cls.fromJSON(doc, json);
    };
    Selection.jsonID = function jsonID(id, selectionClass) {
      if (id in classesById) {
        throw new RangeError("Duplicate use of selection JSON ID " + id);
      }
      classesById[id] = selectionClass;
      selectionClass.prototype.jsonID = id;
      return selectionClass;
    };
    Selection.prototype.getBookmark = function getBookmark() {
      return TextSelection.between(this.$anchor, this.$head).getBookmark();
    };
    Object.defineProperties(Selection.prototype, prototypeAccessors);
    Selection.prototype.visible = true;
    var SelectionRange = function SelectionRange2($from, $to) {
      this.$from = $from;
      this.$to = $to;
    };
    var TextSelection = /* @__PURE__ */ function(Selection2) {
      function TextSelection2($anchor, $head) {
        if ($head === void 0)
          $head = $anchor;
        Selection2.call(this, $anchor, $head);
      }
      if (Selection2)
        TextSelection2.__proto__ = Selection2;
      TextSelection2.prototype = Object.create(Selection2 && Selection2.prototype);
      TextSelection2.prototype.constructor = TextSelection2;
      var prototypeAccessors$12 = { $cursor: { configurable: true } };
      prototypeAccessors$12.$cursor.get = function() {
        return this.$anchor.pos == this.$head.pos ? this.$head : null;
      };
      TextSelection2.prototype.map = function map2(doc, mapping) {
        var $head = doc.resolve(mapping.map(this.head));
        if (!$head.parent.inlineContent) {
          return Selection2.near($head);
        }
        var $anchor = doc.resolve(mapping.map(this.anchor));
        return new TextSelection2($anchor.parent.inlineContent ? $anchor : $head, $head);
      };
      TextSelection2.prototype.replace = function replace(tr, content) {
        if (content === void 0)
          content = prosemirrorModel.Slice.empty;
        Selection2.prototype.replace.call(this, tr, content);
        if (content == prosemirrorModel.Slice.empty) {
          var marks = this.$from.marksAcross(this.$to);
          if (marks) {
            tr.ensureMarks(marks);
          }
        }
      };
      TextSelection2.prototype.eq = function eq(other) {
        return other instanceof TextSelection2 && other.anchor == this.anchor && other.head == this.head;
      };
      TextSelection2.prototype.getBookmark = function getBookmark() {
        return new TextBookmark(this.anchor, this.head);
      };
      TextSelection2.prototype.toJSON = function toJSON() {
        return { type: "text", anchor: this.anchor, head: this.head };
      };
      TextSelection2.fromJSON = function fromJSON(doc, json) {
        if (typeof json.anchor != "number" || typeof json.head != "number") {
          throw new RangeError("Invalid input for TextSelection.fromJSON");
        }
        return new TextSelection2(doc.resolve(json.anchor), doc.resolve(json.head));
      };
      TextSelection2.create = function create(doc, anchor, head) {
        if (head === void 0)
          head = anchor;
        var $anchor = doc.resolve(anchor);
        return new this($anchor, head == anchor ? $anchor : doc.resolve(head));
      };
      TextSelection2.between = function between($anchor, $head, bias) {
        var dPos = $anchor.pos - $head.pos;
        if (!bias || dPos) {
          bias = dPos >= 0 ? 1 : -1;
        }
        if (!$head.parent.inlineContent) {
          var found = Selection2.findFrom($head, bias, true) || Selection2.findFrom($head, -bias, true);
          if (found) {
            $head = found.$head;
          } else {
            return Selection2.near($head, bias);
          }
        }
        if (!$anchor.parent.inlineContent) {
          if (dPos == 0) {
            $anchor = $head;
          } else {
            $anchor = (Selection2.findFrom($anchor, -bias, true) || Selection2.findFrom($anchor, bias, true)).$anchor;
            if ($anchor.pos < $head.pos != dPos < 0) {
              $anchor = $head;
            }
          }
        }
        return new TextSelection2($anchor, $head);
      };
      Object.defineProperties(TextSelection2.prototype, prototypeAccessors$12);
      return TextSelection2;
    }(Selection);
    Selection.jsonID("text", TextSelection);
    var TextBookmark = function TextBookmark2(anchor, head) {
      this.anchor = anchor;
      this.head = head;
    };
    TextBookmark.prototype.map = function map2(mapping) {
      return new TextBookmark(mapping.map(this.anchor), mapping.map(this.head));
    };
    TextBookmark.prototype.resolve = function resolve2(doc) {
      return TextSelection.between(doc.resolve(this.anchor), doc.resolve(this.head));
    };
    var NodeSelection = /* @__PURE__ */ function(Selection2) {
      function NodeSelection2($pos) {
        var node = $pos.nodeAfter;
        var $end = $pos.node(0).resolve($pos.pos + node.nodeSize);
        Selection2.call(this, $pos, $end);
        this.node = node;
      }
      if (Selection2)
        NodeSelection2.__proto__ = Selection2;
      NodeSelection2.prototype = Object.create(Selection2 && Selection2.prototype);
      NodeSelection2.prototype.constructor = NodeSelection2;
      NodeSelection2.prototype.map = function map2(doc, mapping) {
        var ref = mapping.mapResult(this.anchor);
        var deleted = ref.deleted;
        var pos = ref.pos;
        var $pos = doc.resolve(pos);
        if (deleted) {
          return Selection2.near($pos);
        }
        return new NodeSelection2($pos);
      };
      NodeSelection2.prototype.content = function content() {
        return new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(this.node), 0, 0);
      };
      NodeSelection2.prototype.eq = function eq(other) {
        return other instanceof NodeSelection2 && other.anchor == this.anchor;
      };
      NodeSelection2.prototype.toJSON = function toJSON() {
        return { type: "node", anchor: this.anchor };
      };
      NodeSelection2.prototype.getBookmark = function getBookmark() {
        return new NodeBookmark(this.anchor);
      };
      NodeSelection2.fromJSON = function fromJSON(doc, json) {
        if (typeof json.anchor != "number") {
          throw new RangeError("Invalid input for NodeSelection.fromJSON");
        }
        return new NodeSelection2(doc.resolve(json.anchor));
      };
      NodeSelection2.create = function create(doc, from) {
        return new this(doc.resolve(from));
      };
      NodeSelection2.isSelectable = function isSelectable(node) {
        return !node.isText && node.type.spec.selectable !== false;
      };
      return NodeSelection2;
    }(Selection);
    NodeSelection.prototype.visible = false;
    Selection.jsonID("node", NodeSelection);
    var NodeBookmark = function NodeBookmark2(anchor) {
      this.anchor = anchor;
    };
    NodeBookmark.prototype.map = function map2(mapping) {
      var ref = mapping.mapResult(this.anchor);
      var deleted = ref.deleted;
      var pos = ref.pos;
      return deleted ? new TextBookmark(pos, pos) : new NodeBookmark(pos);
    };
    NodeBookmark.prototype.resolve = function resolve2(doc) {
      var $pos = doc.resolve(this.anchor), node = $pos.nodeAfter;
      if (node && NodeSelection.isSelectable(node)) {
        return new NodeSelection($pos);
      }
      return Selection.near($pos);
    };
    var AllSelection = /* @__PURE__ */ function(Selection2) {
      function AllSelection2(doc) {
        Selection2.call(this, doc.resolve(0), doc.resolve(doc.content.size));
      }
      if (Selection2)
        AllSelection2.__proto__ = Selection2;
      AllSelection2.prototype = Object.create(Selection2 && Selection2.prototype);
      AllSelection2.prototype.constructor = AllSelection2;
      AllSelection2.prototype.replace = function replace(tr, content) {
        if (content === void 0)
          content = prosemirrorModel.Slice.empty;
        if (content == prosemirrorModel.Slice.empty) {
          tr.delete(0, tr.doc.content.size);
          var sel = Selection2.atStart(tr.doc);
          if (!sel.eq(tr.selection)) {
            tr.setSelection(sel);
          }
        } else {
          Selection2.prototype.replace.call(this, tr, content);
        }
      };
      AllSelection2.prototype.toJSON = function toJSON() {
        return { type: "all" };
      };
      AllSelection2.fromJSON = function fromJSON(doc) {
        return new AllSelection2(doc);
      };
      AllSelection2.prototype.map = function map2(doc) {
        return new AllSelection2(doc);
      };
      AllSelection2.prototype.eq = function eq(other) {
        return other instanceof AllSelection2;
      };
      AllSelection2.prototype.getBookmark = function getBookmark() {
        return AllBookmark;
      };
      return AllSelection2;
    }(Selection);
    Selection.jsonID("all", AllSelection);
    var AllBookmark = {
      map: function map2() {
        return this;
      },
      resolve: function resolve2(doc) {
        return new AllSelection(doc);
      }
    };
    function findSelectionIn(doc, node, pos, index2, dir, text) {
      if (node.inlineContent) {
        return TextSelection.create(doc, pos);
      }
      for (var i = index2 - (dir > 0 ? 0 : 1); dir > 0 ? i < node.childCount : i >= 0; i += dir) {
        var child = node.child(i);
        if (!child.isAtom) {
          var inner = findSelectionIn(doc, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text);
          if (inner) {
            return inner;
          }
        } else if (!text && NodeSelection.isSelectable(child)) {
          return NodeSelection.create(doc, pos - (dir < 0 ? child.nodeSize : 0));
        }
        pos += child.nodeSize * dir;
      }
    }
    function selectionToInsertionEnd(tr, startLen, bias) {
      var last = tr.steps.length - 1;
      if (last < startLen) {
        return;
      }
      var step = tr.steps[last];
      if (!(step instanceof prosemirrorTransform.ReplaceStep || step instanceof prosemirrorTransform.ReplaceAroundStep)) {
        return;
      }
      var map2 = tr.mapping.maps[last], end;
      map2.forEach(function(_from, _to, _newFrom, newTo) {
        if (end == null) {
          end = newTo;
        }
      });
      tr.setSelection(Selection.near(tr.doc.resolve(end), bias));
    }
    var UPDATED_SEL = 1;
    var UPDATED_MARKS = 2;
    var UPDATED_SCROLL = 4;
    var Transaction = /* @__PURE__ */ function(Transform) {
      function Transaction2(state) {
        Transform.call(this, state.doc);
        this.time = Date.now();
        this.curSelection = state.selection;
        this.curSelectionFor = 0;
        this.storedMarks = state.storedMarks;
        this.updated = 0;
        this.meta = Object.create(null);
      }
      if (Transform)
        Transaction2.__proto__ = Transform;
      Transaction2.prototype = Object.create(Transform && Transform.prototype);
      Transaction2.prototype.constructor = Transaction2;
      var prototypeAccessors2 = { selection: { configurable: true }, selectionSet: { configurable: true }, storedMarksSet: { configurable: true }, isGeneric: { configurable: true }, scrolledIntoView: { configurable: true } };
      prototypeAccessors2.selection.get = function() {
        if (this.curSelectionFor < this.steps.length) {
          this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));
          this.curSelectionFor = this.steps.length;
        }
        return this.curSelection;
      };
      Transaction2.prototype.setSelection = function setSelection(selection) {
        if (selection.$from.doc != this.doc) {
          throw new RangeError("Selection passed to setSelection must point at the current document");
        }
        this.curSelection = selection;
        this.curSelectionFor = this.steps.length;
        this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS;
        this.storedMarks = null;
        return this;
      };
      prototypeAccessors2.selectionSet.get = function() {
        return (this.updated & UPDATED_SEL) > 0;
      };
      Transaction2.prototype.setStoredMarks = function setStoredMarks(marks) {
        this.storedMarks = marks;
        this.updated |= UPDATED_MARKS;
        return this;
      };
      Transaction2.prototype.ensureMarks = function ensureMarks(marks) {
        if (!prosemirrorModel.Mark.sameSet(this.storedMarks || this.selection.$from.marks(), marks)) {
          this.setStoredMarks(marks);
        }
        return this;
      };
      Transaction2.prototype.addStoredMark = function addStoredMark(mark) {
        return this.ensureMarks(mark.addToSet(this.storedMarks || this.selection.$head.marks()));
      };
      Transaction2.prototype.removeStoredMark = function removeStoredMark(mark) {
        return this.ensureMarks(mark.removeFromSet(this.storedMarks || this.selection.$head.marks()));
      };
      prototypeAccessors2.storedMarksSet.get = function() {
        return (this.updated & UPDATED_MARKS) > 0;
      };
      Transaction2.prototype.addStep = function addStep(step, doc) {
        Transform.prototype.addStep.call(this, step, doc);
        this.updated = this.updated & ~UPDATED_MARKS;
        this.storedMarks = null;
      };
      Transaction2.prototype.setTime = function setTime(time) {
        this.time = time;
        return this;
      };
      Transaction2.prototype.replaceSelection = function replaceSelection(slice) {
        this.selection.replace(this, slice);
        return this;
      };
      Transaction2.prototype.replaceSelectionWith = function replaceSelectionWith(node, inheritMarks) {
        var selection = this.selection;
        if (inheritMarks !== false) {
          node = node.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : selection.$from.marksAcross(selection.$to) || prosemirrorModel.Mark.none));
        }
        selection.replaceWith(this, node);
        return this;
      };
      Transaction2.prototype.deleteSelection = function deleteSelection() {
        this.selection.replace(this);
        return this;
      };
      Transaction2.prototype.insertText = function insertText(text, from, to) {
        if (to === void 0)
          to = from;
        var schema = this.doc.type.schema;
        if (from == null) {
          if (!text) {
            return this.deleteSelection();
          }
          return this.replaceSelectionWith(schema.text(text), true);
        } else {
          if (!text) {
            return this.deleteRange(from, to);
          }
          var marks = this.storedMarks;
          if (!marks) {
            var $from = this.doc.resolve(from);
            marks = to == from ? $from.marks() : $from.marksAcross(this.doc.resolve(to));
          }
          this.replaceRangeWith(from, to, schema.text(text, marks));
          if (!this.selection.empty) {
            this.setSelection(Selection.near(this.selection.$to));
          }
          return this;
        }
      };
      Transaction2.prototype.setMeta = function setMeta(key, value) {
        this.meta[typeof key == "string" ? key : key.key] = value;
        return this;
      };
      Transaction2.prototype.getMeta = function getMeta(key) {
        return this.meta[typeof key == "string" ? key : key.key];
      };
      prototypeAccessors2.isGeneric.get = function() {
        for (var _ in this.meta) {
          return false;
        }
        return true;
      };
      Transaction2.prototype.scrollIntoView = function scrollIntoView() {
        this.updated |= UPDATED_SCROLL;
        return this;
      };
      prototypeAccessors2.scrolledIntoView.get = function() {
        return (this.updated & UPDATED_SCROLL) > 0;
      };
      Object.defineProperties(Transaction2.prototype, prototypeAccessors2);
      return Transaction2;
    }(prosemirrorTransform.Transform);
    function bind(f, self2) {
      return !self2 || !f ? f : f.bind(self2);
    }
    var FieldDesc = function FieldDesc2(name, desc, self2) {
      this.name = name;
      this.init = bind(desc.init, self2);
      this.apply = bind(desc.apply, self2);
    };
    var baseFields = [
      new FieldDesc("doc", {
        init: function init2(config) {
          return config.doc || config.schema.topNodeType.createAndFill();
        },
        apply: function apply(tr) {
          return tr.doc;
        }
      }),
      new FieldDesc("selection", {
        init: function init2(config, instance) {
          return config.selection || Selection.atStart(instance.doc);
        },
        apply: function apply(tr) {
          return tr.selection;
        }
      }),
      new FieldDesc("storedMarks", {
        init: function init2(config) {
          return config.storedMarks || null;
        },
        apply: function apply(tr, _marks, _old, state) {
          return state.selection.$cursor ? tr.storedMarks : null;
        }
      }),
      new FieldDesc("scrollToSelection", {
        init: function init2() {
          return 0;
        },
        apply: function apply(tr, prev) {
          return tr.scrolledIntoView ? prev + 1 : prev;
        }
      })
    ];
    var Configuration = function Configuration2(schema, plugins) {
      var this$1 = this;
      this.schema = schema;
      this.fields = baseFields.concat();
      this.plugins = [];
      this.pluginsByKey = Object.create(null);
      if (plugins) {
        plugins.forEach(function(plugin) {
          if (this$1.pluginsByKey[plugin.key]) {
            throw new RangeError("Adding different instances of a keyed plugin (" + plugin.key + ")");
          }
          this$1.plugins.push(plugin);
          this$1.pluginsByKey[plugin.key] = plugin;
          if (plugin.spec.state) {
            this$1.fields.push(new FieldDesc(plugin.key, plugin.spec.state, plugin));
          }
        });
      }
    };
    var EditorState = function EditorState2(config) {
      this.config = config;
    };
    var prototypeAccessors$1 = { schema: { configurable: true }, plugins: { configurable: true }, tr: { configurable: true } };
    prototypeAccessors$1.schema.get = function() {
      return this.config.schema;
    };
    prototypeAccessors$1.plugins.get = function() {
      return this.config.plugins;
    };
    EditorState.prototype.apply = function apply(tr) {
      return this.applyTransaction(tr).state;
    };
    EditorState.prototype.filterTransaction = function filterTransaction(tr, ignore) {
      if (ignore === void 0)
        ignore = -1;
      for (var i = 0; i < this.config.plugins.length; i++) {
        if (i != ignore) {
          var plugin = this.config.plugins[i];
          if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr, this)) {
            return false;
          }
        }
      }
      return true;
    };
    EditorState.prototype.applyTransaction = function applyTransaction(rootTr) {
      if (!this.filterTransaction(rootTr)) {
        return { state: this, transactions: [] };
      }
      var trs = [rootTr], newState = this.applyInner(rootTr), seen = null;
      for (; ; ) {
        var haveNew = false;
        for (var i = 0; i < this.config.plugins.length; i++) {
          var plugin = this.config.plugins[i];
          if (plugin.spec.appendTransaction) {
            var n = seen ? seen[i].n : 0, oldState = seen ? seen[i].state : this;
            var tr = n < trs.length && plugin.spec.appendTransaction.call(plugin, n ? trs.slice(n) : trs, oldState, newState);
            if (tr && newState.filterTransaction(tr, i)) {
              tr.setMeta("appendedTransaction", rootTr);
              if (!seen) {
                seen = [];
                for (var j = 0; j < this.config.plugins.length; j++) {
                  seen.push(j < i ? { state: newState, n: trs.length } : { state: this, n: 0 });
                }
              }
              trs.push(tr);
              newState = newState.applyInner(tr);
              haveNew = true;
            }
            if (seen) {
              seen[i] = { state: newState, n: trs.length };
            }
          }
        }
        if (!haveNew) {
          return { state: newState, transactions: trs };
        }
      }
    };
    EditorState.prototype.applyInner = function applyInner(tr) {
      if (!tr.before.eq(this.doc)) {
        throw new RangeError("Applying a mismatched transaction");
      }
      var newInstance = new EditorState(this.config), fields = this.config.fields;
      for (var i = 0; i < fields.length; i++) {
        var field = fields[i];
        newInstance[field.name] = field.apply(tr, this[field.name], this, newInstance);
      }
      for (var i$1 = 0; i$1 < applyListeners.length; i$1++) {
        applyListeners[i$1](this, tr, newInstance);
      }
      return newInstance;
    };
    prototypeAccessors$1.tr.get = function() {
      return new Transaction(this);
    };
    EditorState.create = function create(config) {
      var $config = new Configuration(config.doc ? config.doc.type.schema : config.schema, config.plugins);
      var instance = new EditorState($config);
      for (var i = 0; i < $config.fields.length; i++) {
        instance[$config.fields[i].name] = $config.fields[i].init(config, instance);
      }
      return instance;
    };
    EditorState.prototype.reconfigure = function reconfigure(config) {
      var $config = new Configuration(this.schema, config.plugins);
      var fields = $config.fields, instance = new EditorState($config);
      for (var i = 0; i < fields.length; i++) {
        var name = fields[i].name;
        instance[name] = this.hasOwnProperty(name) ? this[name] : fields[i].init(config, instance);
      }
      return instance;
    };
    EditorState.prototype.toJSON = function toJSON(pluginFields) {
      var result = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
      if (this.storedMarks) {
        result.storedMarks = this.storedMarks.map(function(m) {
          return m.toJSON();
        });
      }
      if (pluginFields && typeof pluginFields == "object") {
        for (var prop in pluginFields) {
          if (prop == "doc" || prop == "selection") {
            throw new RangeError("The JSON fields `doc` and `selection` are reserved");
          }
          var plugin = pluginFields[prop], state = plugin.spec.state;
          if (state && state.toJSON) {
            result[prop] = state.toJSON.call(plugin, this[plugin.key]);
          }
        }
      }
      return result;
    };
    EditorState.fromJSON = function fromJSON(config, json, pluginFields) {
      if (!json) {
        throw new RangeError("Invalid input for EditorState.fromJSON");
      }
      if (!config.schema) {
        throw new RangeError("Required config field 'schema' missing");
      }
      var $config = new Configuration(config.schema, config.plugins);
      var instance = new EditorState($config);
      $config.fields.forEach(function(field) {
        if (field.name == "doc") {
          instance.doc = prosemirrorModel.Node.fromJSON(config.schema, json.doc);
        } else if (field.name == "selection") {
          instance.selection = Selection.fromJSON(instance.doc, json.selection);
        } else if (field.name == "storedMarks") {
          if (json.storedMarks) {
            instance.storedMarks = json.storedMarks.map(config.schema.markFromJSON);
          }
        } else {
          if (pluginFields) {
            for (var prop in pluginFields) {
              var plugin = pluginFields[prop], state = plugin.spec.state;
              if (plugin.key == field.name && state && state.fromJSON && Object.prototype.hasOwnProperty.call(json, prop)) {
                instance[field.name] = state.fromJSON.call(plugin, config, json[prop], instance);
                return;
              }
            }
          }
          instance[field.name] = field.init(config, instance);
        }
      });
      return instance;
    };
    EditorState.addApplyListener = function addApplyListener(f) {
      applyListeners.push(f);
    };
    EditorState.removeApplyListener = function removeApplyListener(f) {
      var found = applyListeners.indexOf(f);
      if (found > -1) {
        applyListeners.splice(found, 1);
      }
    };
    Object.defineProperties(EditorState.prototype, prototypeAccessors$1);
    var applyListeners = [];
    function bindProps(obj, self2, target) {
      for (var prop in obj) {
        var val = obj[prop];
        if (val instanceof Function) {
          val = val.bind(self2);
        } else if (prop == "handleDOMEvents") {
          val = bindProps(val, self2, {});
        }
        target[prop] = val;
      }
      return target;
    }
    var Plugin = function Plugin2(spec) {
      this.props = {};
      if (spec.props) {
        bindProps(spec.props, this, this.props);
      }
      this.spec = spec;
      this.key = spec.key ? spec.key.key : createKey("plugin");
    };
    Plugin.prototype.getState = function getState(state) {
      return state[this.key];
    };
    var keys = Object.create(null);
    function createKey(name) {
      if (name in keys) {
        return name + "$" + ++keys[name];
      }
      keys[name] = 0;
      return name + "$";
    }
    var PluginKey = function PluginKey2(name) {
      if (name === void 0)
        name = "key";
      this.key = createKey(name);
    };
    PluginKey.prototype.get = function get2(state) {
      return state.config.pluginsByKey[this.key];
    };
    PluginKey.prototype.getState = function getState(state) {
      return state[this.key];
    };
    exports.AllSelection = AllSelection;
    exports.EditorState = EditorState;
    exports.NodeSelection = NodeSelection;
    exports.Plugin = Plugin;
    exports.PluginKey = PluginKey;
    exports.Selection = Selection;
    exports.SelectionRange = SelectionRange;
    exports.TextSelection = TextSelection;
    exports.Transaction = Transaction;
  }
});

// node_modules/prosemirror-commands/dist/index.js
var require_dist4 = __commonJS({
  "node_modules/prosemirror-commands/dist/index.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var prosemirrorTransform = require_dist2();
    var prosemirrorModel = require_dist();
    var prosemirrorState = require_dist3();
    function deleteSelection(state, dispatch) {
      if (state.selection.empty) {
        return false;
      }
      if (dispatch) {
        dispatch(state.tr.deleteSelection().scrollIntoView());
      }
      return true;
    }
    function joinBackward(state, dispatch, view) {
      var ref = state.selection;
      var $cursor = ref.$cursor;
      if (!$cursor || (view ? !view.endOfTextblock("backward", state) : $cursor.parentOffset > 0)) {
        return false;
      }
      var $cut = findCutBefore($cursor);
      if (!$cut) {
        var range = $cursor.blockRange(), target = range && prosemirrorTransform.liftTarget(range);
        if (target == null) {
          return false;
        }
        if (dispatch) {
          dispatch(state.tr.lift(range, target).scrollIntoView());
        }
        return true;
      }
      var before = $cut.nodeBefore;
      if (!before.type.spec.isolating && deleteBarrier(state, $cut, dispatch)) {
        return true;
      }
      if ($cursor.parent.content.size == 0 && (textblockAt(before, "end") || prosemirrorState.NodeSelection.isSelectable(before))) {
        if (dispatch) {
          var tr = state.tr.deleteRange($cursor.before(), $cursor.after());
          tr.setSelection(textblockAt(before, "end") ? prosemirrorState.Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos, -1)), -1) : prosemirrorState.NodeSelection.create(tr.doc, $cut.pos - before.nodeSize));
          dispatch(tr.scrollIntoView());
        }
        return true;
      }
      if (before.isAtom && $cut.depth == $cursor.depth - 1) {
        if (dispatch) {
          dispatch(state.tr.delete($cut.pos - before.nodeSize, $cut.pos).scrollIntoView());
        }
        return true;
      }
      return false;
    }
    function textblockAt(node, side, only) {
      for (; node; node = side == "start" ? node.firstChild : node.lastChild) {
        if (node.isTextblock) {
          return true;
        }
        if (only && node.childCount != 1) {
          return false;
        }
      }
      return false;
    }
    function selectNodeBackward(state, dispatch, view) {
      var ref = state.selection;
      var $head = ref.$head;
      var empty2 = ref.empty;
      var $cut = $head;
      if (!empty2) {
        return false;
      }
      if ($head.parent.isTextblock) {
        if (view ? !view.endOfTextblock("backward", state) : $head.parentOffset > 0) {
          return false;
        }
        $cut = findCutBefore($head);
      }
      var node = $cut && $cut.nodeBefore;
      if (!node || !prosemirrorState.NodeSelection.isSelectable(node)) {
        return false;
      }
      if (dispatch) {
        dispatch(state.tr.setSelection(prosemirrorState.NodeSelection.create(state.doc, $cut.pos - node.nodeSize)).scrollIntoView());
      }
      return true;
    }
    function findCutBefore($pos) {
      if (!$pos.parent.type.spec.isolating) {
        for (var i = $pos.depth - 1; i >= 0; i--) {
          if ($pos.index(i) > 0) {
            return $pos.doc.resolve($pos.before(i + 1));
          }
          if ($pos.node(i).type.spec.isolating) {
            break;
          }
        }
      }
      return null;
    }
    function joinForward(state, dispatch, view) {
      var ref = state.selection;
      var $cursor = ref.$cursor;
      if (!$cursor || (view ? !view.endOfTextblock("forward", state) : $cursor.parentOffset < $cursor.parent.content.size)) {
        return false;
      }
      var $cut = findCutAfter($cursor);
      if (!$cut) {
        return false;
      }
      var after = $cut.nodeAfter;
      if (deleteBarrier(state, $cut, dispatch)) {
        return true;
      }
      if ($cursor.parent.content.size == 0 && (textblockAt(after, "start") || prosemirrorState.NodeSelection.isSelectable(after))) {
        if (dispatch) {
          var tr = state.tr.deleteRange($cursor.before(), $cursor.after());
          tr.setSelection(textblockAt(after, "start") ? prosemirrorState.Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)), 1) : prosemirrorState.NodeSelection.create(tr.doc, tr.mapping.map($cut.pos)));
          dispatch(tr.scrollIntoView());
        }
        return true;
      }
      if (after.isAtom && $cut.depth == $cursor.depth - 1) {
        if (dispatch) {
          dispatch(state.tr.delete($cut.pos, $cut.pos + after.nodeSize).scrollIntoView());
        }
        return true;
      }
      return false;
    }
    function selectNodeForward(state, dispatch, view) {
      var ref = state.selection;
      var $head = ref.$head;
      var empty2 = ref.empty;
      var $cut = $head;
      if (!empty2) {
        return false;
      }
      if ($head.parent.isTextblock) {
        if (view ? !view.endOfTextblock("forward", state) : $head.parentOffset < $head.parent.content.size) {
          return false;
        }
        $cut = findCutAfter($head);
      }
      var node = $cut && $cut.nodeAfter;
      if (!node || !prosemirrorState.NodeSelection.isSelectable(node)) {
        return false;
      }
      if (dispatch) {
        dispatch(state.tr.setSelection(prosemirrorState.NodeSelection.create(state.doc, $cut.pos)).scrollIntoView());
      }
      return true;
    }
    function findCutAfter($pos) {
      if (!$pos.parent.type.spec.isolating) {
        for (var i = $pos.depth - 1; i >= 0; i--) {
          var parent = $pos.node(i);
          if ($pos.index(i) + 1 < parent.childCount) {
            return $pos.doc.resolve($pos.after(i + 1));
          }
          if (parent.type.spec.isolating) {
            break;
          }
        }
      }
      return null;
    }
    function joinUp(state, dispatch) {
      var sel = state.selection, nodeSel = sel instanceof prosemirrorState.NodeSelection, point;
      if (nodeSel) {
        if (sel.node.isTextblock || !prosemirrorTransform.canJoin(state.doc, sel.from)) {
          return false;
        }
        point = sel.from;
      } else {
        point = prosemirrorTransform.joinPoint(state.doc, sel.from, -1);
        if (point == null) {
          return false;
        }
      }
      if (dispatch) {
        var tr = state.tr.join(point);
        if (nodeSel) {
          tr.setSelection(prosemirrorState.NodeSelection.create(tr.doc, point - state.doc.resolve(point).nodeBefore.nodeSize));
        }
        dispatch(tr.scrollIntoView());
      }
      return true;
    }
    function joinDown(state, dispatch) {
      var sel = state.selection, point;
      if (sel instanceof prosemirrorState.NodeSelection) {
        if (sel.node.isTextblock || !prosemirrorTransform.canJoin(state.doc, sel.to)) {
          return false;
        }
        point = sel.to;
      } else {
        point = prosemirrorTransform.joinPoint(state.doc, sel.to, 1);
        if (point == null) {
          return false;
        }
      }
      if (dispatch) {
        dispatch(state.tr.join(point).scrollIntoView());
      }
      return true;
    }
    function lift(state, dispatch) {
      var ref = state.selection;
      var $from = ref.$from;
      var $to = ref.$to;
      var range = $from.blockRange($to), target = range && prosemirrorTransform.liftTarget(range);
      if (target == null) {
        return false;
      }
      if (dispatch) {
        dispatch(state.tr.lift(range, target).scrollIntoView());
      }
      return true;
    }
    function newlineInCode(state, dispatch) {
      var ref = state.selection;
      var $head = ref.$head;
      var $anchor = ref.$anchor;
      if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) {
        return false;
      }
      if (dispatch) {
        dispatch(state.tr.insertText("\n").scrollIntoView());
      }
      return true;
    }
    function defaultBlockAt(match) {
      for (var i = 0; i < match.edgeCount; i++) {
        var ref = match.edge(i);
        var type = ref.type;
        if (type.isTextblock && !type.hasRequiredAttrs()) {
          return type;
        }
      }
      return null;
    }
    function exitCode(state, dispatch) {
      var ref = state.selection;
      var $head = ref.$head;
      var $anchor = ref.$anchor;
      if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) {
        return false;
      }
      var above = $head.node(-1), after = $head.indexAfter(-1), type = defaultBlockAt(above.contentMatchAt(after));
      if (!above.canReplaceWith(after, after, type)) {
        return false;
      }
      if (dispatch) {
        var pos = $head.after(), tr = state.tr.replaceWith(pos, pos, type.createAndFill());
        tr.setSelection(prosemirrorState.Selection.near(tr.doc.resolve(pos), 1));
        dispatch(tr.scrollIntoView());
      }
      return true;
    }
    function createParagraphNear(state, dispatch) {
      var sel = state.selection;
      var $from = sel.$from;
      var $to = sel.$to;
      if (sel instanceof prosemirrorState.AllSelection || $from.parent.inlineContent || $to.parent.inlineContent) {
        return false;
      }
      var type = defaultBlockAt($to.parent.contentMatchAt($to.indexAfter()));
      if (!type || !type.isTextblock) {
        return false;
      }
      if (dispatch) {
        var side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;
        var tr = state.tr.insert(side, type.createAndFill());
        tr.setSelection(prosemirrorState.TextSelection.create(tr.doc, side + 1));
        dispatch(tr.scrollIntoView());
      }
      return true;
    }
    function liftEmptyBlock(state, dispatch) {
      var ref = state.selection;
      var $cursor = ref.$cursor;
      if (!$cursor || $cursor.parent.content.size) {
        return false;
      }
      if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {
        var before = $cursor.before();
        if (prosemirrorTransform.canSplit(state.doc, before)) {
          if (dispatch) {
            dispatch(state.tr.split(before).scrollIntoView());
          }
          return true;
        }
      }
      var range = $cursor.blockRange(), target = range && prosemirrorTransform.liftTarget(range);
      if (target == null) {
        return false;
      }
      if (dispatch) {
        dispatch(state.tr.lift(range, target).scrollIntoView());
      }
      return true;
    }
    function splitBlock(state, dispatch) {
      var ref = state.selection;
      var $from = ref.$from;
      var $to = ref.$to;
      if (state.selection instanceof prosemirrorState.NodeSelection && state.selection.node.isBlock) {
        if (!$from.parentOffset || !prosemirrorTransform.canSplit(state.doc, $from.pos)) {
          return false;
        }
        if (dispatch) {
          dispatch(state.tr.split($from.pos).scrollIntoView());
        }
        return true;
      }
      if (!$from.parent.isBlock) {
        return false;
      }
      if (dispatch) {
        var atEnd = $to.parentOffset == $to.parent.content.size;
        var tr = state.tr;
        if (state.selection instanceof prosemirrorState.TextSelection || state.selection instanceof prosemirrorState.AllSelection) {
          tr.deleteSelection();
        }
        var deflt = $from.depth == 0 ? null : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));
        var types2 = atEnd && deflt ? [{ type: deflt }] : null;
        var can = prosemirrorTransform.canSplit(tr.doc, tr.mapping.map($from.pos), 1, types2);
        if (!types2 && !can && prosemirrorTransform.canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt && [{ type: deflt }])) {
          types2 = [{ type: deflt }];
          can = true;
        }
        if (can) {
          tr.split(tr.mapping.map($from.pos), 1, types2);
          if (!atEnd && !$from.parentOffset && $from.parent.type != deflt) {
            var first = tr.mapping.map($from.before()), $first = tr.doc.resolve(first);
            if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {
              tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);
            }
          }
        }
        dispatch(tr.scrollIntoView());
      }
      return true;
    }
    function splitBlockKeepMarks(state, dispatch) {
      return splitBlock(state, dispatch && function(tr) {
        var marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();
        if (marks) {
          tr.ensureMarks(marks);
        }
        dispatch(tr);
      });
    }
    function selectParentNode(state, dispatch) {
      var ref = state.selection;
      var $from = ref.$from;
      var to = ref.to;
      var pos;
      var same = $from.sharedDepth(to);
      if (same == 0) {
        return false;
      }
      pos = $from.before(same);
      if (dispatch) {
        dispatch(state.tr.setSelection(prosemirrorState.NodeSelection.create(state.doc, pos)));
      }
      return true;
    }
    function selectAll(state, dispatch) {
      if (dispatch) {
        dispatch(state.tr.setSelection(new prosemirrorState.AllSelection(state.doc)));
      }
      return true;
    }
    function joinMaybeClear(state, $pos, dispatch) {
      var before = $pos.nodeBefore, after = $pos.nodeAfter, index2 = $pos.index();
      if (!before || !after || !before.type.compatibleContent(after.type)) {
        return false;
      }
      if (!before.content.size && $pos.parent.canReplace(index2 - 1, index2)) {
        if (dispatch) {
          dispatch(state.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView());
        }
        return true;
      }
      if (!$pos.parent.canReplace(index2, index2 + 1) || !(after.isTextblock || prosemirrorTransform.canJoin(state.doc, $pos.pos))) {
        return false;
      }
      if (dispatch) {
        dispatch(state.tr.clearIncompatible($pos.pos, before.type, before.contentMatchAt(before.childCount)).join($pos.pos).scrollIntoView());
      }
      return true;
    }
    function deleteBarrier(state, $cut, dispatch) {
      var before = $cut.nodeBefore, after = $cut.nodeAfter, conn, match;
      if (before.type.spec.isolating || after.type.spec.isolating) {
        return false;
      }
      if (joinMaybeClear(state, $cut, dispatch)) {
        return true;
      }
      var canDelAfter = $cut.parent.canReplace($cut.index(), $cut.index() + 1);
      if (canDelAfter && (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(after.type)) && match.matchType(conn[0] || after.type).validEnd) {
        if (dispatch) {
          var end = $cut.pos + after.nodeSize, wrap = prosemirrorModel.Fragment.empty;
          for (var i = conn.length - 1; i >= 0; i--) {
            wrap = prosemirrorModel.Fragment.from(conn[i].create(null, wrap));
          }
          wrap = prosemirrorModel.Fragment.from(before.copy(wrap));
          var tr = state.tr.step(new prosemirrorTransform.ReplaceAroundStep($cut.pos - 1, end, $cut.pos, end, new prosemirrorModel.Slice(wrap, 1, 0), conn.length, true));
          var joinAt = end + 2 * conn.length;
          if (prosemirrorTransform.canJoin(tr.doc, joinAt)) {
            tr.join(joinAt);
          }
          dispatch(tr.scrollIntoView());
        }
        return true;
      }
      var selAfter = prosemirrorState.Selection.findFrom($cut, 1);
      var range = selAfter && selAfter.$from.blockRange(selAfter.$to), target = range && prosemirrorTransform.liftTarget(range);
      if (target != null && target >= $cut.depth) {
        if (dispatch) {
          dispatch(state.tr.lift(range, target).scrollIntoView());
        }
        return true;
      }
      if (canDelAfter && textblockAt(after, "start", true) && textblockAt(before, "end")) {
        var at = before, wrap$1 = [];
        for (; ; ) {
          wrap$1.push(at);
          if (at.isTextblock) {
            break;
          }
          at = at.lastChild;
        }
        var afterText = after, afterDepth = 1;
        for (; !afterText.isTextblock; afterText = afterText.firstChild) {
          afterDepth++;
        }
        if (at.canReplace(at.childCount, at.childCount, afterText.content)) {
          if (dispatch) {
            var end$1 = prosemirrorModel.Fragment.empty;
            for (var i$1 = wrap$1.length - 1; i$1 >= 0; i$1--) {
              end$1 = prosemirrorModel.Fragment.from(wrap$1[i$1].copy(end$1));
            }
            var tr$1 = state.tr.step(new prosemirrorTransform.ReplaceAroundStep($cut.pos - wrap$1.length, $cut.pos + after.nodeSize, $cut.pos + afterDepth, $cut.pos + after.nodeSize - afterDepth, new prosemirrorModel.Slice(end$1, wrap$1.length, 0), 0, true));
            dispatch(tr$1.scrollIntoView());
          }
          return true;
        }
      }
      return false;
    }
    function wrapIn(nodeType, attrs) {
      return function(state, dispatch) {
        var ref = state.selection;
        var $from = ref.$from;
        var $to = ref.$to;
        var range = $from.blockRange($to), wrapping = range && prosemirrorTransform.findWrapping(range, nodeType, attrs);
        if (!wrapping) {
          return false;
        }
        if (dispatch) {
          dispatch(state.tr.wrap(range, wrapping).scrollIntoView());
        }
        return true;
      };
    }
    function setBlockType(nodeType, attrs) {
      return function(state, dispatch) {
        var ref = state.selection;
        var from = ref.from;
        var to = ref.to;
        var applicable = false;
        state.doc.nodesBetween(from, to, function(node, pos) {
          if (applicable) {
            return false;
          }
          if (!node.isTextblock || node.hasMarkup(nodeType, attrs)) {
            return;
          }
          if (node.type == nodeType) {
            applicable = true;
          } else {
            var $pos = state.doc.resolve(pos), index2 = $pos.index();
            applicable = $pos.parent.canReplaceWith(index2, index2 + 1, nodeType);
          }
        });
        if (!applicable) {
          return false;
        }
        if (dispatch) {
          dispatch(state.tr.setBlockType(from, to, nodeType, attrs).scrollIntoView());
        }
        return true;
      };
    }
    function markApplies(doc, ranges, type) {
      var loop = function(i2) {
        var ref = ranges[i2];
        var $from = ref.$from;
        var $to = ref.$to;
        var can = $from.depth == 0 ? doc.type.allowsMarkType(type) : false;
        doc.nodesBetween($from.pos, $to.pos, function(node) {
          if (can) {
            return false;
          }
          can = node.inlineContent && node.type.allowsMarkType(type);
        });
        if (can) {
          return { v: true };
        }
      };
      for (var i = 0; i < ranges.length; i++) {
        var returned = loop(i);
        if (returned)
          return returned.v;
      }
      return false;
    }
    function toggleMark(markType, attrs) {
      return function(state, dispatch) {
        var ref = state.selection;
        var empty2 = ref.empty;
        var $cursor = ref.$cursor;
        var ranges = ref.ranges;
        if (empty2 && !$cursor || !markApplies(state.doc, ranges, markType)) {
          return false;
        }
        if (dispatch) {
          if ($cursor) {
            if (markType.isInSet(state.storedMarks || $cursor.marks())) {
              dispatch(state.tr.removeStoredMark(markType));
            } else {
              dispatch(state.tr.addStoredMark(markType.create(attrs)));
            }
          } else {
            var has = false, tr = state.tr;
            for (var i = 0; !has && i < ranges.length; i++) {
              var ref$1 = ranges[i];
              var $from = ref$1.$from;
              var $to = ref$1.$to;
              has = state.doc.rangeHasMark($from.pos, $to.pos, markType);
            }
            for (var i$1 = 0; i$1 < ranges.length; i$1++) {
              var ref$2 = ranges[i$1];
              var $from$1 = ref$2.$from;
              var $to$1 = ref$2.$to;
              if (has) {
                tr.removeMark($from$1.pos, $to$1.pos, markType);
              } else {
                var from = $from$1.pos, to = $to$1.pos, start = $from$1.nodeAfter, end = $to$1.nodeBefore;
                var spaceStart = start && start.isText ? /^\s*/.exec(start.text)[0].length : 0;
                var spaceEnd = end && end.isText ? /\s*$/.exec(end.text)[0].length : 0;
                if (from + spaceStart < to) {
                  from += spaceStart;
                  to -= spaceEnd;
                }
                tr.addMark(from, to, markType.create(attrs));
              }
            }
            dispatch(tr.scrollIntoView());
          }
        }
        return true;
      };
    }
    function wrapDispatchForJoin(dispatch, isJoinable) {
      return function(tr) {
        if (!tr.isGeneric) {
          return dispatch(tr);
        }
        var ranges = [];
        for (var i = 0; i < tr.mapping.maps.length; i++) {
          var map2 = tr.mapping.maps[i];
          for (var j = 0; j < ranges.length; j++) {
            ranges[j] = map2.map(ranges[j]);
          }
          map2.forEach(function(_s, _e, from2, to2) {
            return ranges.push(from2, to2);
          });
        }
        var joinable = [];
        for (var i$1 = 0; i$1 < ranges.length; i$1 += 2) {
          var from = ranges[i$1], to = ranges[i$1 + 1];
          var $from = tr.doc.resolve(from), depth = $from.sharedDepth(to), parent = $from.node(depth);
          for (var index2 = $from.indexAfter(depth), pos = $from.after(depth + 1); pos <= to; ++index2) {
            var after = parent.maybeChild(index2);
            if (!after) {
              break;
            }
            if (index2 && joinable.indexOf(pos) == -1) {
              var before = parent.child(index2 - 1);
              if (before.type == after.type && isJoinable(before, after)) {
                joinable.push(pos);
              }
            }
            pos += after.nodeSize;
          }
        }
        joinable.sort(function(a, b) {
          return a - b;
        });
        for (var i$2 = joinable.length - 1; i$2 >= 0; i$2--) {
          if (prosemirrorTransform.canJoin(tr.doc, joinable[i$2])) {
            tr.join(joinable[i$2]);
          }
        }
        dispatch(tr);
      };
    }
    function autoJoin(command, isJoinable) {
      if (Array.isArray(isJoinable)) {
        var types2 = isJoinable;
        isJoinable = function(node) {
          return types2.indexOf(node.type.name) > -1;
        };
      }
      return function(state, dispatch, view) {
        return command(state, dispatch && wrapDispatchForJoin(dispatch, isJoinable), view);
      };
    }
    function chainCommands() {
      var commands = [], len = arguments.length;
      while (len--)
        commands[len] = arguments[len];
      return function(state, dispatch, view) {
        for (var i = 0; i < commands.length; i++) {
          if (commands[i](state, dispatch, view)) {
            return true;
          }
        }
        return false;
      };
    }
    var backspace = chainCommands(deleteSelection, joinBackward, selectNodeBackward);
    var del = chainCommands(deleteSelection, joinForward, selectNodeForward);
    var pcBaseKeymap = {
      "Enter": chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),
      "Mod-Enter": exitCode,
      "Backspace": backspace,
      "Mod-Backspace": backspace,
      "Shift-Backspace": backspace,
      "Delete": del,
      "Mod-Delete": del,
      "Mod-a": selectAll
    };
    var macBaseKeymap = {
      "Ctrl-h": pcBaseKeymap["Backspace"],
      "Alt-Backspace": pcBaseKeymap["Mod-Backspace"],
      "Ctrl-d": pcBaseKeymap["Delete"],
      "Ctrl-Alt-Backspace": pcBaseKeymap["Mod-Delete"],
      "Alt-Delete": pcBaseKeymap["Mod-Delete"],
      "Alt-d": pcBaseKeymap["Mod-Delete"]
    };
    for (key in pcBaseKeymap) {
      macBaseKeymap[key] = pcBaseKeymap[key];
    }
    var key;
    var mac = typeof navigator != "undefined" ? /Mac/.test(navigator.platform) : typeof os != "undefined" ? os.platform() == "darwin" : false;
    var baseKeymap = mac ? macBaseKeymap : pcBaseKeymap;
    exports.autoJoin = autoJoin;
    exports.baseKeymap = baseKeymap;
    exports.chainCommands = chainCommands;
    exports.createParagraphNear = createParagraphNear;
    exports.deleteSelection = deleteSelection;
    exports.exitCode = exitCode;
    exports.joinBackward = joinBackward;
    exports.joinDown = joinDown;
    exports.joinForward = joinForward;
    exports.joinUp = joinUp;
    exports.lift = lift;
    exports.liftEmptyBlock = liftEmptyBlock;
    exports.macBaseKeymap = macBaseKeymap;
    exports.newlineInCode = newlineInCode;
    exports.pcBaseKeymap = pcBaseKeymap;
    exports.selectAll = selectAll;
    exports.selectNodeBackward = selectNodeBackward;
    exports.selectNodeForward = selectNodeForward;
    exports.selectParentNode = selectParentNode;
    exports.setBlockType = setBlockType;
    exports.splitBlock = splitBlock;
    exports.splitBlockKeepMarks = splitBlockKeepMarks;
    exports.toggleMark = toggleMark;
    exports.wrapIn = wrapIn;
  }
});

// node_modules/prosemirror-schema-list/dist/index.js
var require_dist5 = __commonJS({
  "node_modules/prosemirror-schema-list/dist/index.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var prosemirrorTransform = require_dist2();
    var prosemirrorModel = require_dist();
    var olDOM = ["ol", 0];
    var ulDOM = ["ul", 0];
    var liDOM = ["li", 0];
    var orderedList = {
      attrs: { order: { default: 1 } },
      parseDOM: [{ tag: "ol", getAttrs: function getAttrs(dom) {
        return { order: dom.hasAttribute("start") ? +dom.getAttribute("start") : 1 };
      } }],
      toDOM: function toDOM(node) {
        return node.attrs.order == 1 ? olDOM : ["ol", { start: node.attrs.order }, 0];
      }
    };
    var bulletList = {
      parseDOM: [{ tag: "ul" }],
      toDOM: function toDOM() {
        return ulDOM;
      }
    };
    var listItem = {
      parseDOM: [{ tag: "li" }],
      toDOM: function toDOM() {
        return liDOM;
      },
      defining: true
    };
    function add(obj, props) {
      var copy2 = {};
      for (var prop in obj) {
        copy2[prop] = obj[prop];
      }
      for (var prop$1 in props) {
        copy2[prop$1] = props[prop$1];
      }
      return copy2;
    }
    function addListNodes(nodes, itemContent, listGroup) {
      return nodes.append({
        ordered_list: add(orderedList, { content: "list_item+", group: listGroup }),
        bullet_list: add(bulletList, { content: "list_item+", group: listGroup }),
        list_item: add(listItem, { content: itemContent })
      });
    }
    function wrapInList(listType, attrs) {
      return function(state, dispatch) {
        var ref = state.selection;
        var $from = ref.$from;
        var $to = ref.$to;
        var range = $from.blockRange($to), doJoin = false, outerRange = range;
        if (!range) {
          return false;
        }
        if (range.depth >= 2 && $from.node(range.depth - 1).type.compatibleContent(listType) && range.startIndex == 0) {
          if ($from.index(range.depth - 1) == 0) {
            return false;
          }
          var $insert = state.doc.resolve(range.start - 2);
          outerRange = new prosemirrorModel.NodeRange($insert, $insert, range.depth);
          if (range.endIndex < range.parent.childCount) {
            range = new prosemirrorModel.NodeRange($from, state.doc.resolve($to.end(range.depth)), range.depth);
          }
          doJoin = true;
        }
        var wrap = prosemirrorTransform.findWrapping(outerRange, listType, attrs, range);
        if (!wrap) {
          return false;
        }
        if (dispatch) {
          dispatch(doWrapInList(state.tr, range, wrap, doJoin, listType).scrollIntoView());
        }
        return true;
      };
    }
    function doWrapInList(tr, range, wrappers, joinBefore, listType) {
      var content = prosemirrorModel.Fragment.empty;
      for (var i = wrappers.length - 1; i >= 0; i--) {
        content = prosemirrorModel.Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));
      }
      tr.step(new prosemirrorTransform.ReplaceAroundStep(range.start - (joinBefore ? 2 : 0), range.end, range.start, range.end, new prosemirrorModel.Slice(content, 0, 0), wrappers.length, true));
      var found = 0;
      for (var i$1 = 0; i$1 < wrappers.length; i$1++) {
        if (wrappers[i$1].type == listType) {
          found = i$1 + 1;
        }
      }
      var splitDepth = wrappers.length - found;
      var splitPos = range.start + wrappers.length - (joinBefore ? 2 : 0), parent = range.parent;
      for (var i$2 = range.startIndex, e = range.endIndex, first = true; i$2 < e; i$2++, first = false) {
        if (!first && prosemirrorTransform.canSplit(tr.doc, splitPos, splitDepth)) {
          tr.split(splitPos, splitDepth);
          splitPos += 2 * splitDepth;
        }
        splitPos += parent.child(i$2).nodeSize;
      }
      return tr;
    }
    function splitListItem(itemType) {
      return function(state, dispatch) {
        var ref = state.selection;
        var $from = ref.$from;
        var $to = ref.$to;
        var node = ref.node;
        if (node && node.isBlock || $from.depth < 2 || !$from.sameParent($to)) {
          return false;
        }
        var grandParent = $from.node(-1);
        if (grandParent.type != itemType) {
          return false;
        }
        if ($from.parent.content.size == 0 && $from.node(-1).childCount == $from.indexAfter(-1)) {
          if ($from.depth == 2 || $from.node(-3).type != itemType || $from.index(-2) != $from.node(-2).childCount - 1) {
            return false;
          }
          if (dispatch) {
            var wrap = prosemirrorModel.Fragment.empty;
            var depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;
            for (var d = $from.depth - depthBefore; d >= $from.depth - 3; d--) {
              wrap = prosemirrorModel.Fragment.from($from.node(d).copy(wrap));
            }
            var depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;
            wrap = wrap.append(prosemirrorModel.Fragment.from(itemType.createAndFill()));
            var start = $from.before($from.depth - (depthBefore - 1));
            var tr$1 = state.tr.replace(start, $from.after(-depthAfter), new prosemirrorModel.Slice(wrap, 4 - depthBefore, 0));
            var sel = -1;
            tr$1.doc.nodesBetween(start, tr$1.doc.content.size, function(node2, pos) {
              if (sel > -1) {
                return false;
              }
              if (node2.isTextblock && node2.content.size == 0) {
                sel = pos + 1;
              }
            });
            if (sel > -1) {
              tr$1.setSelection(state.selection.constructor.near(tr$1.doc.resolve(sel)));
            }
            dispatch(tr$1.scrollIntoView());
          }
          return true;
        }
        var nextType = $to.pos == $from.end() ? grandParent.contentMatchAt(0).defaultType : null;
        var tr = state.tr.delete($from.pos, $to.pos);
        var types2 = nextType && [null, { type: nextType }];
        if (!prosemirrorTransform.canSplit(tr.doc, $from.pos, 2, types2)) {
          return false;
        }
        if (dispatch) {
          dispatch(tr.split($from.pos, 2, types2).scrollIntoView());
        }
        return true;
      };
    }
    function liftListItem(itemType) {
      return function(state, dispatch) {
        var ref = state.selection;
        var $from = ref.$from;
        var $to = ref.$to;
        var range = $from.blockRange($to, function(node) {
          return node.childCount && node.firstChild.type == itemType;
        });
        if (!range) {
          return false;
        }
        if (!dispatch) {
          return true;
        }
        if ($from.node(range.depth - 1).type == itemType) {
          return liftToOuterList(state, dispatch, itemType, range);
        } else {
          return liftOutOfList(state, dispatch, range);
        }
      };
    }
    function liftToOuterList(state, dispatch, itemType, range) {
      var tr = state.tr, end = range.end, endOfList = range.$to.end(range.depth);
      if (end < endOfList) {
        tr.step(new prosemirrorTransform.ReplaceAroundStep(end - 1, endOfList, end, endOfList, new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(itemType.create(null, range.parent.copy())), 1, 0), 1, true));
        range = new prosemirrorModel.NodeRange(tr.doc.resolve(range.$from.pos), tr.doc.resolve(endOfList), range.depth);
      }
      dispatch(tr.lift(range, prosemirrorTransform.liftTarget(range)).scrollIntoView());
      return true;
    }
    function liftOutOfList(state, dispatch, range) {
      var tr = state.tr, list = range.parent;
      for (var pos = range.end, i = range.endIndex - 1, e = range.startIndex; i > e; i--) {
        pos -= list.child(i).nodeSize;
        tr.delete(pos - 1, pos + 1);
      }
      var $start = tr.doc.resolve(range.start), item = $start.nodeAfter;
      if (tr.mapping.map(range.end) != range.start + $start.nodeAfter.nodeSize) {
        return false;
      }
      var atStart = range.startIndex == 0, atEnd = range.endIndex == list.childCount;
      var parent = $start.node(-1), indexBefore = $start.index(-1);
      if (!parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1, item.content.append(atEnd ? prosemirrorModel.Fragment.empty : prosemirrorModel.Fragment.from(list)))) {
        return false;
      }
      var start = $start.pos, end = start + item.nodeSize;
      tr.step(new prosemirrorTransform.ReplaceAroundStep(start - (atStart ? 1 : 0), end + (atEnd ? 1 : 0), start + 1, end - 1, new prosemirrorModel.Slice((atStart ? prosemirrorModel.Fragment.empty : prosemirrorModel.Fragment.from(list.copy(prosemirrorModel.Fragment.empty))).append(atEnd ? prosemirrorModel.Fragment.empty : prosemirrorModel.Fragment.from(list.copy(prosemirrorModel.Fragment.empty))), atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1));
      dispatch(tr.scrollIntoView());
      return true;
    }
    function sinkListItem(itemType) {
      return function(state, dispatch) {
        var ref = state.selection;
        var $from = ref.$from;
        var $to = ref.$to;
        var range = $from.blockRange($to, function(node) {
          return node.childCount && node.firstChild.type == itemType;
        });
        if (!range) {
          return false;
        }
        var startIndex = range.startIndex;
        if (startIndex == 0) {
          return false;
        }
        var parent = range.parent, nodeBefore = parent.child(startIndex - 1);
        if (nodeBefore.type != itemType) {
          return false;
        }
        if (dispatch) {
          var nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type;
          var inner = prosemirrorModel.Fragment.from(nestedBefore ? itemType.create() : null);
          var slice = new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(itemType.create(null, prosemirrorModel.Fragment.from(parent.type.create(null, inner)))), nestedBefore ? 3 : 1, 0);
          var before = range.start, after = range.end;
          dispatch(state.tr.step(new prosemirrorTransform.ReplaceAroundStep(before - (nestedBefore ? 3 : 1), after, before, after, slice, 1, true)).scrollIntoView());
        }
        return true;
      };
    }
    exports.addListNodes = addListNodes;
    exports.bulletList = bulletList;
    exports.liftListItem = liftListItem;
    exports.listItem = listItem;
    exports.orderedList = orderedList;
    exports.sinkListItem = sinkListItem;
    exports.splitListItem = splitListItem;
    exports.wrapInList = wrapInList;
  }
});

// node_modules/prosemirror-view/dist/index.js
var require_dist6 = __commonJS({
  "node_modules/prosemirror-view/dist/index.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var prosemirrorState = require_dist3();
    var prosemirrorModel = require_dist();
    var prosemirrorTransform = require_dist2();
    var result = {};
    if (typeof navigator != "undefined" && typeof document != "undefined") {
      ie_edge = /Edge\/(\d+)/.exec(navigator.userAgent);
      ie_upto10 = /MSIE \d/.test(navigator.userAgent);
      ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
      result.mac = /Mac/.test(navigator.platform);
      ie = result.ie = !!(ie_upto10 || ie_11up || ie_edge);
      result.ie_version = ie_upto10 ? document.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : null;
      result.gecko = !ie && /gecko\/(\d+)/i.test(navigator.userAgent);
      result.gecko_version = result.gecko && +(/Firefox\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1];
      chrome = !ie && /Chrome\/(\d+)/.exec(navigator.userAgent);
      result.chrome = !!chrome;
      result.chrome_version = chrome && +chrome[1];
      result.safari = !ie && /Apple Computer/.test(navigator.vendor);
      result.ios = result.safari && (/Mobile\/\w+/.test(navigator.userAgent) || navigator.maxTouchPoints > 2);
      result.android = /Android \d/.test(navigator.userAgent);
      result.webkit = "webkitFontSmoothing" in document.documentElement.style;
      result.webkit_version = result.webkit && +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1];
    }
    var ie_edge;
    var ie_upto10;
    var ie_11up;
    var ie;
    var chrome;
    var domIndex = function(node) {
      for (var index2 = 0; ; index2++) {
        node = node.previousSibling;
        if (!node) {
          return index2;
        }
      }
    };
    var parentNode = function(node) {
      var parent = node.assignedSlot || node.parentNode;
      return parent && parent.nodeType == 11 ? parent.host : parent;
    };
    var reusedRange = null;
    var textRange = function(node, from, to) {
      var range = reusedRange || (reusedRange = document.createRange());
      range.setEnd(node, to == null ? node.nodeValue.length : to);
      range.setStart(node, from || 0);
      return range;
    };
    var isEquivalentPosition = function(node, off, targetNode, targetOff) {
      return targetNode && (scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1));
    };
    var atomElements = /^(img|br|input|textarea|hr)$/i;
    function scanFor(node, off, targetNode, targetOff, dir) {
      for (; ; ) {
        if (node == targetNode && off == targetOff) {
          return true;
        }
        if (off == (dir < 0 ? 0 : nodeSize(node))) {
          var parent = node.parentNode;
          if (parent.nodeType != 1 || hasBlockDesc(node) || atomElements.test(node.nodeName) || node.contentEditable == "false") {
            return false;
          }
          off = domIndex(node) + (dir < 0 ? 0 : 1);
          node = parent;
        } else if (node.nodeType == 1) {
          node = node.childNodes[off + (dir < 0 ? -1 : 0)];
          if (node.contentEditable == "false") {
            return false;
          }
          off = dir < 0 ? nodeSize(node) : 0;
        } else {
          return false;
        }
      }
    }
    function nodeSize(node) {
      return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
    }
    function isOnEdge(node, offset, parent) {
      for (var atStart = offset == 0, atEnd = offset == nodeSize(node); atStart || atEnd; ) {
        if (node == parent) {
          return true;
        }
        var index2 = domIndex(node);
        node = node.parentNode;
        if (!node) {
          return false;
        }
        atStart = atStart && index2 == 0;
        atEnd = atEnd && index2 == nodeSize(node);
      }
    }
    function hasBlockDesc(dom) {
      var desc;
      for (var cur = dom; cur; cur = cur.parentNode) {
        if (desc = cur.pmViewDesc) {
          break;
        }
      }
      return desc && desc.node && desc.node.isBlock && (desc.dom == dom || desc.contentDOM == dom);
    }
    var selectionCollapsed = function(domSel) {
      var collapsed = domSel.isCollapsed;
      if (collapsed && result.chrome && domSel.rangeCount && !domSel.getRangeAt(0).collapsed) {
        collapsed = false;
      }
      return collapsed;
    };
    function keyEvent(keyCode, key) {
      var event = document.createEvent("Event");
      event.initEvent("keydown", true, true);
      event.keyCode = keyCode;
      event.key = event.code = key;
      return event;
    }
    function windowRect(doc) {
      return {
        left: 0,
        right: doc.documentElement.clientWidth,
        top: 0,
        bottom: doc.documentElement.clientHeight
      };
    }
    function getSide(value, side) {
      return typeof value == "number" ? value : value[side];
    }
    function clientRect(node) {
      var rect = node.getBoundingClientRect();
      var scaleX = rect.width / node.offsetWidth || 1;
      var scaleY = rect.height / node.offsetHeight || 1;
      return {
        left: rect.left,
        right: rect.left + node.clientWidth * scaleX,
        top: rect.top,
        bottom: rect.top + node.clientHeight * scaleY
      };
    }
    function scrollRectIntoView(view, rect, startDOM) {
      var scrollThreshold = view.someProp("scrollThreshold") || 0, scrollMargin = view.someProp("scrollMargin") || 5;
      var doc = view.dom.ownerDocument;
      for (var parent = startDOM || view.dom; ; parent = parentNode(parent)) {
        if (!parent) {
          break;
        }
        if (parent.nodeType != 1) {
          continue;
        }
        var atTop = parent == doc.body || parent.nodeType != 1;
        var bounding = atTop ? windowRect(doc) : clientRect(parent);
        var moveX = 0, moveY = 0;
        if (rect.top < bounding.top + getSide(scrollThreshold, "top")) {
          moveY = -(bounding.top - rect.top + getSide(scrollMargin, "top"));
        } else if (rect.bottom > bounding.bottom - getSide(scrollThreshold, "bottom")) {
          moveY = rect.bottom - bounding.bottom + getSide(scrollMargin, "bottom");
        }
        if (rect.left < bounding.left + getSide(scrollThreshold, "left")) {
          moveX = -(bounding.left - rect.left + getSide(scrollMargin, "left"));
        } else if (rect.right > bounding.right - getSide(scrollThreshold, "right")) {
          moveX = rect.right - bounding.right + getSide(scrollMargin, "right");
        }
        if (moveX || moveY) {
          if (atTop) {
            doc.defaultView.scrollBy(moveX, moveY);
          } else {
            var startX = parent.scrollLeft, startY = parent.scrollTop;
            if (moveY) {
              parent.scrollTop += moveY;
            }
            if (moveX) {
              parent.scrollLeft += moveX;
            }
            var dX = parent.scrollLeft - startX, dY = parent.scrollTop - startY;
            rect = { left: rect.left - dX, top: rect.top - dY, right: rect.right - dX, bottom: rect.bottom - dY };
          }
        }
        if (atTop) {
          break;
        }
      }
    }
    function storeScrollPos(view) {
      var rect = view.dom.getBoundingClientRect(), startY = Math.max(0, rect.top);
      var refDOM, refTop;
      for (var x = (rect.left + rect.right) / 2, y = startY + 1; y < Math.min(innerHeight, rect.bottom); y += 5) {
        var dom = view.root.elementFromPoint(x, y);
        if (dom == view.dom || !view.dom.contains(dom)) {
          continue;
        }
        var localRect = dom.getBoundingClientRect();
        if (localRect.top >= startY - 20) {
          refDOM = dom;
          refTop = localRect.top;
          break;
        }
      }
      return { refDOM, refTop, stack: scrollStack(view.dom) };
    }
    function scrollStack(dom) {
      var stack = [], doc = dom.ownerDocument;
      for (; dom; dom = parentNode(dom)) {
        stack.push({ dom, top: dom.scrollTop, left: dom.scrollLeft });
        if (dom == doc) {
          break;
        }
      }
      return stack;
    }
    function resetScrollPos(ref) {
      var refDOM = ref.refDOM;
      var refTop = ref.refTop;
      var stack = ref.stack;
      var newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;
      restoreScrollStack(stack, newRefTop == 0 ? 0 : newRefTop - refTop);
    }
    function restoreScrollStack(stack, dTop) {
      for (var i = 0; i < stack.length; i++) {
        var ref = stack[i];
        var dom = ref.dom;
        var top = ref.top;
        var left = ref.left;
        if (dom.scrollTop != top + dTop) {
          dom.scrollTop = top + dTop;
        }
        if (dom.scrollLeft != left) {
          dom.scrollLeft = left;
        }
      }
    }
    var preventScrollSupported = null;
    function focusPreventScroll(dom) {
      if (dom.setActive) {
        return dom.setActive();
      }
      if (preventScrollSupported) {
        return dom.focus(preventScrollSupported);
      }
      var stored = scrollStack(dom);
      dom.focus(preventScrollSupported == null ? {
        get preventScroll() {
          preventScrollSupported = { preventScroll: true };
          return true;
        }
      } : void 0);
      if (!preventScrollSupported) {
        preventScrollSupported = false;
        restoreScrollStack(stored, 0);
      }
    }
    function findOffsetInNode(node, coords) {
      var closest, dxClosest = 2e8, coordsClosest, offset = 0;
      var rowBot = coords.top, rowTop = coords.top;
      for (var child = node.firstChild, childIndex = 0; child; child = child.nextSibling, childIndex++) {
        var rects = void 0;
        if (child.nodeType == 1) {
          rects = child.getClientRects();
        } else if (child.nodeType == 3) {
          rects = textRange(child).getClientRects();
        } else {
          continue;
        }
        for (var i = 0; i < rects.length; i++) {
          var rect = rects[i];
          if (rect.top <= rowBot && rect.bottom >= rowTop) {
            rowBot = Math.max(rect.bottom, rowBot);
            rowTop = Math.min(rect.top, rowTop);
            var dx = rect.left > coords.left ? rect.left - coords.left : rect.right < coords.left ? coords.left - rect.right : 0;
            if (dx < dxClosest) {
              closest = child;
              dxClosest = dx;
              coordsClosest = dx && closest.nodeType == 3 ? { left: rect.right < coords.left ? rect.right : rect.left, top: coords.top } : coords;
              if (child.nodeType == 1 && dx) {
                offset = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0);
              }
              continue;
            }
          }
          if (!closest && (coords.left >= rect.right && coords.top >= rect.top || coords.left >= rect.left && coords.top >= rect.bottom)) {
            offset = childIndex + 1;
          }
        }
      }
      if (closest && closest.nodeType == 3) {
        return findOffsetInText(closest, coordsClosest);
      }
      if (!closest || dxClosest && closest.nodeType == 1) {
        return { node, offset };
      }
      return findOffsetInNode(closest, coordsClosest);
    }
    function findOffsetInText(node, coords) {
      var len = node.nodeValue.length;
      var range = document.createRange();
      for (var i = 0; i < len; i++) {
        range.setEnd(node, i + 1);
        range.setStart(node, i);
        var rect = singleRect(range, 1);
        if (rect.top == rect.bottom) {
          continue;
        }
        if (inRect(coords, rect)) {
          return { node, offset: i + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0) };
        }
      }
      return { node, offset: 0 };
    }
    function inRect(coords, rect) {
      return coords.left >= rect.left - 1 && coords.left <= rect.right + 1 && coords.top >= rect.top - 1 && coords.top <= rect.bottom + 1;
    }
    function targetKludge(dom, coords) {
      var parent = dom.parentNode;
      if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left) {
        return parent;
      }
      return dom;
    }
    function posFromElement(view, elt, coords) {
      var ref = findOffsetInNode(elt, coords);
      var node = ref.node;
      var offset = ref.offset;
      var bias = -1;
      if (node.nodeType == 1 && !node.firstChild) {
        var rect = node.getBoundingClientRect();
        bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1;
      }
      return view.docView.posFromDOM(node, offset, bias);
    }
    function posFromCaret(view, node, offset, coords) {
      var outside = -1;
      for (var cur = node; ; ) {
        if (cur == view.dom) {
          break;
        }
        var desc = view.docView.nearestDesc(cur, true);
        if (!desc) {
          return null;
        }
        if (desc.node.isBlock && desc.parent) {
          var rect = desc.dom.getBoundingClientRect();
          if (rect.left > coords.left || rect.top > coords.top) {
            outside = desc.posBefore;
          } else if (rect.right < coords.left || rect.bottom < coords.top) {
            outside = desc.posAfter;
          } else {
            break;
          }
        }
        cur = desc.dom.parentNode;
      }
      return outside > -1 ? outside : view.docView.posFromDOM(node, offset);
    }
    function elementFromPoint(element, coords, box) {
      var len = element.childNodes.length;
      if (len && box.top < box.bottom) {
        for (var startI = Math.max(0, Math.min(len - 1, Math.floor(len * (coords.top - box.top) / (box.bottom - box.top)) - 2)), i = startI; ; ) {
          var child = element.childNodes[i];
          if (child.nodeType == 1) {
            var rects = child.getClientRects();
            for (var j = 0; j < rects.length; j++) {
              var rect = rects[j];
              if (inRect(coords, rect)) {
                return elementFromPoint(child, coords, rect);
              }
            }
          }
          if ((i = (i + 1) % len) == startI) {
            break;
          }
        }
      }
      return element;
    }
    function posAtCoords(view, coords) {
      var assign, assign$1;
      var doc = view.dom.ownerDocument, node, offset;
      if (doc.caretPositionFromPoint) {
        try {
          var pos$1 = doc.caretPositionFromPoint(coords.left, coords.top);
          if (pos$1) {
            assign = pos$1, node = assign.offsetNode, offset = assign.offset;
          }
        } catch (_) {
        }
      }
      if (!node && doc.caretRangeFromPoint) {
        var range = doc.caretRangeFromPoint(coords.left, coords.top);
        if (range) {
          assign$1 = range, node = assign$1.startContainer, offset = assign$1.startOffset;
        }
      }
      var elt = (view.root.elementFromPoint ? view.root : doc).elementFromPoint(coords.left, coords.top + 1), pos;
      if (!elt || !view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {
        var box = view.dom.getBoundingClientRect();
        if (!inRect(coords, box)) {
          return null;
        }
        elt = elementFromPoint(view.dom, coords, box);
        if (!elt) {
          return null;
        }
      }
      if (result.safari) {
        for (var p = elt; node && p; p = parentNode(p)) {
          if (p.draggable) {
            node = offset = null;
          }
        }
      }
      elt = targetKludge(elt, coords);
      if (node) {
        if (result.gecko && node.nodeType == 1) {
          offset = Math.min(offset, node.childNodes.length);
          if (offset < node.childNodes.length) {
            var next = node.childNodes[offset], box$1;
            if (next.nodeName == "IMG" && (box$1 = next.getBoundingClientRect()).right <= coords.left && box$1.bottom > coords.top) {
              offset++;
            }
          }
        }
        if (node == view.dom && offset == node.childNodes.length - 1 && node.lastChild.nodeType == 1 && coords.top > node.lastChild.getBoundingClientRect().bottom) {
          pos = view.state.doc.content.size;
        } else if (offset == 0 || node.nodeType != 1 || node.childNodes[offset - 1].nodeName != "BR") {
          pos = posFromCaret(view, node, offset, coords);
        }
      }
      if (pos == null) {
        pos = posFromElement(view, elt, coords);
      }
      var desc = view.docView.nearestDesc(elt, true);
      return { pos, inside: desc ? desc.posAtStart - desc.border : -1 };
    }
    function singleRect(object2, bias) {
      var rects = object2.getClientRects();
      return !rects.length ? object2.getBoundingClientRect() : rects[bias < 0 ? 0 : rects.length - 1];
    }
    var BIDI = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
    function coordsAtPos(view, pos, side) {
      var ref = view.docView.domFromPos(pos, side < 0 ? -1 : 1);
      var node = ref.node;
      var offset = ref.offset;
      var supportEmptyRange = result.webkit || result.gecko;
      if (node.nodeType == 3) {
        if (supportEmptyRange && (BIDI.test(node.nodeValue) || (side < 0 ? !offset : offset == node.nodeValue.length))) {
          var rect = singleRect(textRange(node, offset, offset), side);
          if (result.gecko && offset && /\s/.test(node.nodeValue[offset - 1]) && offset < node.nodeValue.length) {
            var rectBefore = singleRect(textRange(node, offset - 1, offset - 1), -1);
            if (rectBefore.top == rect.top) {
              var rectAfter = singleRect(textRange(node, offset, offset + 1), -1);
              if (rectAfter.top != rect.top) {
                return flattenV(rectAfter, rectAfter.left < rectBefore.left);
              }
            }
          }
          return rect;
        } else {
          var from = offset, to = offset, takeSide = side < 0 ? 1 : -1;
          if (side < 0 && !offset) {
            to++;
            takeSide = -1;
          } else if (side >= 0 && offset == node.nodeValue.length) {
            from--;
            takeSide = 1;
          } else if (side < 0) {
            from--;
          } else {
            to++;
          }
          return flattenV(singleRect(textRange(node, from, to), takeSide), takeSide < 0);
        }
      }
      if (!view.state.doc.resolve(pos).parent.inlineContent) {
        if (offset && (side < 0 || offset == nodeSize(node))) {
          var before = node.childNodes[offset - 1];
          if (before.nodeType == 1) {
            return flattenH(before.getBoundingClientRect(), false);
          }
        }
        if (offset < nodeSize(node)) {
          var after = node.childNodes[offset];
          if (after.nodeType == 1) {
            return flattenH(after.getBoundingClientRect(), true);
          }
        }
        return flattenH(node.getBoundingClientRect(), side >= 0);
      }
      if (offset && (side < 0 || offset == nodeSize(node))) {
        var before$1 = node.childNodes[offset - 1];
        var target = before$1.nodeType == 3 ? textRange(before$1, nodeSize(before$1) - (supportEmptyRange ? 0 : 1)) : before$1.nodeType == 1 && (before$1.nodeName != "BR" || !before$1.nextSibling) ? before$1 : null;
        if (target) {
          return flattenV(singleRect(target, 1), false);
        }
      }
      if (offset < nodeSize(node)) {
        var after$1 = node.childNodes[offset];
        while (after$1.pmViewDesc && after$1.pmViewDesc.ignoreForCoords) {
          after$1 = after$1.nextSibling;
        }
        var target$1 = !after$1 ? null : after$1.nodeType == 3 ? textRange(after$1, 0, supportEmptyRange ? 0 : 1) : after$1.nodeType == 1 ? after$1 : null;
        if (target$1) {
          return flattenV(singleRect(target$1, -1), true);
        }
      }
      return flattenV(singleRect(node.nodeType == 3 ? textRange(node) : node, -side), side >= 0);
    }
    function flattenV(rect, left) {
      if (rect.width == 0) {
        return rect;
      }
      var x = left ? rect.left : rect.right;
      return { top: rect.top, bottom: rect.bottom, left: x, right: x };
    }
    function flattenH(rect, top) {
      if (rect.height == 0) {
        return rect;
      }
      var y = top ? rect.top : rect.bottom;
      return { top: y, bottom: y, left: rect.left, right: rect.right };
    }
    function withFlushedState(view, state, f) {
      var viewState = view.state, active = view.root.activeElement;
      if (viewState != state) {
        view.updateState(state);
      }
      if (active != view.dom) {
        view.focus();
      }
      try {
        return f();
      } finally {
        if (viewState != state) {
          view.updateState(viewState);
        }
        if (active != view.dom && active) {
          active.focus();
        }
      }
    }
    function endOfTextblockVertical(view, state, dir) {
      var sel = state.selection;
      var $pos = dir == "up" ? sel.$from : sel.$to;
      return withFlushedState(view, state, function() {
        var ref = view.docView.domFromPos($pos.pos, dir == "up" ? -1 : 1);
        var dom = ref.node;
        for (; ; ) {
          var nearest = view.docView.nearestDesc(dom, true);
          if (!nearest) {
            break;
          }
          if (nearest.node.isBlock) {
            dom = nearest.dom;
            break;
          }
          dom = nearest.dom.parentNode;
        }
        var coords = coordsAtPos(view, $pos.pos, 1);
        for (var child = dom.firstChild; child; child = child.nextSibling) {
          var boxes = void 0;
          if (child.nodeType == 1) {
            boxes = child.getClientRects();
          } else if (child.nodeType == 3) {
            boxes = textRange(child, 0, child.nodeValue.length).getClientRects();
          } else {
            continue;
          }
          for (var i = 0; i < boxes.length; i++) {
            var box = boxes[i];
            if (box.bottom > box.top + 1 && (dir == "up" ? coords.top - box.top > (box.bottom - coords.top) * 2 : box.bottom - coords.bottom > (coords.bottom - box.top) * 2)) {
              return false;
            }
          }
        }
        return true;
      });
    }
    var maybeRTL = /[\u0590-\u08ac]/;
    function endOfTextblockHorizontal(view, state, dir) {
      var ref = state.selection;
      var $head = ref.$head;
      if (!$head.parent.isTextblock) {
        return false;
      }
      var offset = $head.parentOffset, atStart = !offset, atEnd = offset == $head.parent.content.size;
      var sel = view.root.getSelection();
      if (!maybeRTL.test($head.parent.textContent) || !sel.modify) {
        return dir == "left" || dir == "backward" ? atStart : atEnd;
      }
      return withFlushedState(view, state, function() {
        var oldRange = sel.getRangeAt(0), oldNode = sel.focusNode, oldOff = sel.focusOffset;
        var oldBidiLevel = sel.caretBidiLevel;
        sel.modify("move", dir, "character");
        var parentDOM = $head.depth ? view.docView.domAfterPos($head.before()) : view.dom;
        var result2 = !parentDOM.contains(sel.focusNode.nodeType == 1 ? sel.focusNode : sel.focusNode.parentNode) || oldNode == sel.focusNode && oldOff == sel.focusOffset;
        sel.removeAllRanges();
        sel.addRange(oldRange);
        if (oldBidiLevel != null) {
          sel.caretBidiLevel = oldBidiLevel;
        }
        return result2;
      });
    }
    var cachedState = null;
    var cachedDir = null;
    var cachedResult = false;
    function endOfTextblock(view, state, dir) {
      if (cachedState == state && cachedDir == dir) {
        return cachedResult;
      }
      cachedState = state;
      cachedDir = dir;
      return cachedResult = dir == "up" || dir == "down" ? endOfTextblockVertical(view, state, dir) : endOfTextblockHorizontal(view, state, dir);
    }
    var NOT_DIRTY = 0;
    var CHILD_DIRTY = 1;
    var CONTENT_DIRTY = 2;
    var NODE_DIRTY = 3;
    var ViewDesc = function ViewDesc2(parent, children, dom, contentDOM) {
      this.parent = parent;
      this.children = children;
      this.dom = dom;
      dom.pmViewDesc = this;
      this.contentDOM = contentDOM;
      this.dirty = NOT_DIRTY;
    };
    var prototypeAccessors = { size: { configurable: true }, border: { configurable: true }, posBefore: { configurable: true }, posAtStart: { configurable: true }, posAfter: { configurable: true }, posAtEnd: { configurable: true }, contentLost: { configurable: true }, domAtom: { configurable: true }, ignoreForCoords: { configurable: true } };
    ViewDesc.prototype.matchesWidget = function matchesWidget() {
      return false;
    };
    ViewDesc.prototype.matchesMark = function matchesMark() {
      return false;
    };
    ViewDesc.prototype.matchesNode = function matchesNode() {
      return false;
    };
    ViewDesc.prototype.matchesHack = function matchesHack(_nodeName) {
      return false;
    };
    ViewDesc.prototype.parseRule = function parseRule() {
      return null;
    };
    ViewDesc.prototype.stopEvent = function stopEvent() {
      return false;
    };
    prototypeAccessors.size.get = function() {
      var size = 0;
      for (var i = 0; i < this.children.length; i++) {
        size += this.children[i].size;
      }
      return size;
    };
    prototypeAccessors.border.get = function() {
      return 0;
    };
    ViewDesc.prototype.destroy = function destroy() {
      this.parent = null;
      if (this.dom.pmViewDesc == this) {
        this.dom.pmViewDesc = null;
      }
      for (var i = 0; i < this.children.length; i++) {
        this.children[i].destroy();
      }
    };
    ViewDesc.prototype.posBeforeChild = function posBeforeChild(child) {
      for (var i = 0, pos = this.posAtStart; i < this.children.length; i++) {
        var cur = this.children[i];
        if (cur == child) {
          return pos;
        }
        pos += cur.size;
      }
    };
    prototypeAccessors.posBefore.get = function() {
      return this.parent.posBeforeChild(this);
    };
    prototypeAccessors.posAtStart.get = function() {
      return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
    };
    prototypeAccessors.posAfter.get = function() {
      return this.posBefore + this.size;
    };
    prototypeAccessors.posAtEnd.get = function() {
      return this.posAtStart + this.size - 2 * this.border;
    };
    ViewDesc.prototype.localPosFromDOM = function localPosFromDOM(dom, offset, bias) {
      if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {
        if (bias < 0) {
          var domBefore, desc;
          if (dom == this.contentDOM) {
            domBefore = dom.childNodes[offset - 1];
          } else {
            while (dom.parentNode != this.contentDOM) {
              dom = dom.parentNode;
            }
            domBefore = dom.previousSibling;
          }
          while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this)) {
            domBefore = domBefore.previousSibling;
          }
          return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart;
        } else {
          var domAfter, desc$1;
          if (dom == this.contentDOM) {
            domAfter = dom.childNodes[offset];
          } else {
            while (dom.parentNode != this.contentDOM) {
              dom = dom.parentNode;
            }
            domAfter = dom.nextSibling;
          }
          while (domAfter && !((desc$1 = domAfter.pmViewDesc) && desc$1.parent == this)) {
            domAfter = domAfter.nextSibling;
          }
          return domAfter ? this.posBeforeChild(desc$1) : this.posAtEnd;
        }
      }
      var atEnd;
      if (dom == this.dom && this.contentDOM) {
        atEnd = offset > domIndex(this.contentDOM);
      } else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {
        atEnd = dom.compareDocumentPosition(this.contentDOM) & 2;
      } else if (this.dom.firstChild) {
        if (offset == 0) {
          for (var search = dom; ; search = search.parentNode) {
            if (search == this.dom) {
              atEnd = false;
              break;
            }
            if (search.parentNode.firstChild != search) {
              break;
            }
          }
        }
        if (atEnd == null && offset == dom.childNodes.length) {
          for (var search$1 = dom; ; search$1 = search$1.parentNode) {
            if (search$1 == this.dom) {
              atEnd = true;
              break;
            }
            if (search$1.parentNode.lastChild != search$1) {
              break;
            }
          }
        }
      }
      return (atEnd == null ? bias > 0 : atEnd) ? this.posAtEnd : this.posAtStart;
    };
    ViewDesc.prototype.nearestDesc = function nearestDesc(dom, onlyNodes) {
      for (var first = true, cur = dom; cur; cur = cur.parentNode) {
        var desc = this.getDesc(cur);
        if (desc && (!onlyNodes || desc.node)) {
          if (first && desc.nodeDOM && !(desc.nodeDOM.nodeType == 1 ? desc.nodeDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode) : desc.nodeDOM == dom)) {
            first = false;
          } else {
            return desc;
          }
        }
      }
    };
    ViewDesc.prototype.getDesc = function getDesc(dom) {
      var desc = dom.pmViewDesc;
      for (var cur = desc; cur; cur = cur.parent) {
        if (cur == this) {
          return desc;
        }
      }
    };
    ViewDesc.prototype.posFromDOM = function posFromDOM(dom, offset, bias) {
      for (var scan = dom; scan; scan = scan.parentNode) {
        var desc = this.getDesc(scan);
        if (desc) {
          return desc.localPosFromDOM(dom, offset, bias);
        }
      }
      return -1;
    };
    ViewDesc.prototype.descAt = function descAt(pos) {
      for (var i = 0, offset = 0; i < this.children.length; i++) {
        var child = this.children[i], end = offset + child.size;
        if (offset == pos && end != offset) {
          while (!child.border && child.children.length) {
            child = child.children[0];
          }
          return child;
        }
        if (pos < end) {
          return child.descAt(pos - offset - child.border);
        }
        offset = end;
      }
    };
    ViewDesc.prototype.domFromPos = function domFromPos(pos, side) {
      if (!this.contentDOM) {
        return { node: this.dom, offset: 0 };
      }
      var i = 0, offset = 0;
      for (var curPos = 0; i < this.children.length; i++) {
        var child = this.children[i], end = curPos + child.size;
        if (end > pos || child instanceof TrailingHackViewDesc) {
          offset = pos - curPos;
          break;
        }
        curPos = end;
      }
      if (offset) {
        return this.children[i].domFromPos(offset - this.children[i].border, side);
      }
      for (var prev = void 0; i && !(prev = this.children[i - 1]).size && prev instanceof WidgetViewDesc && prev.widget.type.side >= 0; i--) {
      }
      if (side <= 0) {
        var prev$1, enter = true;
        for (; ; i--, enter = false) {
          prev$1 = i ? this.children[i - 1] : null;
          if (!prev$1 || prev$1.dom.parentNode == this.contentDOM) {
            break;
          }
        }
        if (prev$1 && side && enter && !prev$1.border && !prev$1.domAtom) {
          return prev$1.domFromPos(prev$1.size, side);
        }
        return { node: this.contentDOM, offset: prev$1 ? domIndex(prev$1.dom) + 1 : 0 };
      } else {
        var next, enter$1 = true;
        for (; ; i++, enter$1 = false) {
          next = i < this.children.length ? this.children[i] : null;
          if (!next || next.dom.parentNode == this.contentDOM) {
            break;
          }
        }
        if (next && enter$1 && !next.border && !next.domAtom) {
          return next.domFromPos(0, side);
        }
        return { node: this.contentDOM, offset: next ? domIndex(next.dom) : this.contentDOM.childNodes.length };
      }
    };
    ViewDesc.prototype.parseRange = function parseRange(from, to, base2) {
      if (base2 === void 0)
        base2 = 0;
      if (this.children.length == 0) {
        return { node: this.contentDOM, from, to, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
      }
      var fromOffset = -1, toOffset = -1;
      for (var offset = base2, i = 0; ; i++) {
        var child = this.children[i], end = offset + child.size;
        if (fromOffset == -1 && from <= end) {
          var childBase = offset + child.border;
          if (from >= childBase && to <= end - child.border && child.node && child.contentDOM && this.contentDOM.contains(child.contentDOM)) {
            return child.parseRange(from, to, childBase);
          }
          from = offset;
          for (var j = i; j > 0; j--) {
            var prev = this.children[j - 1];
            if (prev.size && prev.dom.parentNode == this.contentDOM && !prev.emptyChildAt(1)) {
              fromOffset = domIndex(prev.dom) + 1;
              break;
            }
            from -= prev.size;
          }
          if (fromOffset == -1) {
            fromOffset = 0;
          }
        }
        if (fromOffset > -1 && (end > to || i == this.children.length - 1)) {
          to = end;
          for (var j$1 = i + 1; j$1 < this.children.length; j$1++) {
            var next = this.children[j$1];
            if (next.size && next.dom.parentNode == this.contentDOM && !next.emptyChildAt(-1)) {
              toOffset = domIndex(next.dom);
              break;
            }
            to += next.size;
          }
          if (toOffset == -1) {
            toOffset = this.contentDOM.childNodes.length;
          }
          break;
        }
        offset = end;
      }
      return { node: this.contentDOM, from, to, fromOffset, toOffset };
    };
    ViewDesc.prototype.emptyChildAt = function emptyChildAt(side) {
      if (this.border || !this.contentDOM || !this.children.length) {
        return false;
      }
      var child = this.children[side < 0 ? 0 : this.children.length - 1];
      return child.size == 0 || child.emptyChildAt(side);
    };
    ViewDesc.prototype.domAfterPos = function domAfterPos(pos) {
      var ref = this.domFromPos(pos, 0);
      var node = ref.node;
      var offset = ref.offset;
      if (node.nodeType != 1 || offset == node.childNodes.length) {
        throw new RangeError("No node after pos " + pos);
      }
      return node.childNodes[offset];
    };
    ViewDesc.prototype.setSelection = function setSelection(anchor, head, root, force) {
      var from = Math.min(anchor, head), to = Math.max(anchor, head);
      for (var i = 0, offset = 0; i < this.children.length; i++) {
        var child = this.children[i], end = offset + child.size;
        if (from > offset && to < end) {
          return child.setSelection(anchor - offset - child.border, head - offset - child.border, root, force);
        }
        offset = end;
      }
      var anchorDOM = this.domFromPos(anchor, anchor ? -1 : 1);
      var headDOM = head == anchor ? anchorDOM : this.domFromPos(head, head ? -1 : 1);
      var domSel = root.getSelection();
      var brKludge = false;
      if ((result.gecko || result.safari) && anchor == head) {
        var node = anchorDOM.node;
        var offset$1 = anchorDOM.offset;
        if (node.nodeType == 3) {
          brKludge = offset$1 && node.nodeValue[offset$1 - 1] == "\n";
          if (brKludge && offset$1 == node.nodeValue.length) {
            for (var scan = node, after = void 0; scan; scan = scan.parentNode) {
              if (after = scan.nextSibling) {
                if (after.nodeName == "BR") {
                  anchorDOM = headDOM = { node: after.parentNode, offset: domIndex(after) + 1 };
                }
                break;
              }
              var desc = scan.pmViewDesc;
              if (desc && desc.node && desc.node.isBlock) {
                break;
              }
            }
          }
        } else {
          var prev = node.childNodes[offset$1 - 1];
          brKludge = prev && (prev.nodeName == "BR" || prev.contentEditable == "false");
        }
      }
      if (result.gecko && domSel.focusNode && domSel.focusNode != headDOM.node && domSel.focusNode.nodeType == 1) {
        var after$1 = domSel.focusNode.childNodes[domSel.focusOffset];
        if (after$1 && after$1.contentEditable == "false") {
          force = true;
        }
      }
      if (!(force || brKludge && result.safari) && isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset) && isEquivalentPosition(headDOM.node, headDOM.offset, domSel.focusNode, domSel.focusOffset)) {
        return;
      }
      var domSelExtended = false;
      if ((domSel.extend || anchor == head) && !brKludge) {
        domSel.collapse(anchorDOM.node, anchorDOM.offset);
        try {
          if (anchor != head) {
            domSel.extend(headDOM.node, headDOM.offset);
          }
          domSelExtended = true;
        } catch (err) {
          if (!(err instanceof DOMException)) {
            throw err;
          }
        }
      }
      if (!domSelExtended) {
        if (anchor > head) {
          var tmp = anchorDOM;
          anchorDOM = headDOM;
          headDOM = tmp;
        }
        var range = document.createRange();
        range.setEnd(headDOM.node, headDOM.offset);
        range.setStart(anchorDOM.node, anchorDOM.offset);
        domSel.removeAllRanges();
        domSel.addRange(range);
      }
    };
    ViewDesc.prototype.ignoreMutation = function ignoreMutation(mutation) {
      return !this.contentDOM && mutation.type != "selection";
    };
    prototypeAccessors.contentLost.get = function() {
      return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
    };
    ViewDesc.prototype.markDirty = function markDirty(from, to) {
      for (var offset = 0, i = 0; i < this.children.length; i++) {
        var child = this.children[i], end = offset + child.size;
        if (offset == end ? from <= end && to >= offset : from < end && to > offset) {
          var startInside = offset + child.border, endInside = end - child.border;
          if (from >= startInside && to <= endInside) {
            this.dirty = from == offset || to == end ? CONTENT_DIRTY : CHILD_DIRTY;
            if (from == startInside && to == endInside && (child.contentLost || child.dom.parentNode != this.contentDOM)) {
              child.dirty = NODE_DIRTY;
            } else {
              child.markDirty(from - startInside, to - startInside);
            }
            return;
          } else {
            child.dirty = child.dom == child.contentDOM && child.dom.parentNode == this.contentDOM ? CONTENT_DIRTY : NODE_DIRTY;
          }
        }
        offset = end;
      }
      this.dirty = CONTENT_DIRTY;
    };
    ViewDesc.prototype.markParentsDirty = function markParentsDirty() {
      var level = 1;
      for (var node = this.parent; node; node = node.parent, level++) {
        var dirty = level == 1 ? CONTENT_DIRTY : CHILD_DIRTY;
        if (node.dirty < dirty) {
          node.dirty = dirty;
        }
      }
    };
    prototypeAccessors.domAtom.get = function() {
      return false;
    };
    prototypeAccessors.ignoreForCoords.get = function() {
      return false;
    };
    Object.defineProperties(ViewDesc.prototype, prototypeAccessors);
    var nothing = [];
    var WidgetViewDesc = /* @__PURE__ */ function(ViewDesc2) {
      function WidgetViewDesc2(parent, widget, view, pos) {
        var self2, dom = widget.type.toDOM;
        if (typeof dom == "function") {
          dom = dom(view, function() {
            if (!self2) {
              return pos;
            }
            if (self2.parent) {
              return self2.parent.posBeforeChild(self2);
            }
          });
        }
        if (!widget.type.spec.raw) {
          if (dom.nodeType != 1) {
            var wrap = document.createElement("span");
            wrap.appendChild(dom);
            dom = wrap;
          }
          dom.contentEditable = false;
          dom.classList.add("ProseMirror-widget");
        }
        ViewDesc2.call(this, parent, nothing, dom, null);
        this.widget = widget;
        self2 = this;
      }
      if (ViewDesc2)
        WidgetViewDesc2.__proto__ = ViewDesc2;
      WidgetViewDesc2.prototype = Object.create(ViewDesc2 && ViewDesc2.prototype);
      WidgetViewDesc2.prototype.constructor = WidgetViewDesc2;
      var prototypeAccessors$12 = { domAtom: { configurable: true } };
      WidgetViewDesc2.prototype.matchesWidget = function matchesWidget(widget) {
        return this.dirty == NOT_DIRTY && widget.type.eq(this.widget.type);
      };
      WidgetViewDesc2.prototype.parseRule = function parseRule() {
        return { ignore: true };
      };
      WidgetViewDesc2.prototype.stopEvent = function stopEvent(event) {
        var stop = this.widget.spec.stopEvent;
        return stop ? stop(event) : false;
      };
      WidgetViewDesc2.prototype.ignoreMutation = function ignoreMutation(mutation) {
        return mutation.type != "selection" || this.widget.spec.ignoreSelection;
      };
      prototypeAccessors$12.domAtom.get = function() {
        return true;
      };
      Object.defineProperties(WidgetViewDesc2.prototype, prototypeAccessors$12);
      return WidgetViewDesc2;
    }(ViewDesc);
    var CompositionViewDesc = /* @__PURE__ */ function(ViewDesc2) {
      function CompositionViewDesc2(parent, dom, textDOM, text) {
        ViewDesc2.call(this, parent, nothing, dom, null);
        this.textDOM = textDOM;
        this.text = text;
      }
      if (ViewDesc2)
        CompositionViewDesc2.__proto__ = ViewDesc2;
      CompositionViewDesc2.prototype = Object.create(ViewDesc2 && ViewDesc2.prototype);
      CompositionViewDesc2.prototype.constructor = CompositionViewDesc2;
      var prototypeAccessors$22 = { size: { configurable: true } };
      prototypeAccessors$22.size.get = function() {
        return this.text.length;
      };
      CompositionViewDesc2.prototype.localPosFromDOM = function localPosFromDOM(dom, offset) {
        if (dom != this.textDOM) {
          return this.posAtStart + (offset ? this.size : 0);
        }
        return this.posAtStart + offset;
      };
      CompositionViewDesc2.prototype.domFromPos = function domFromPos(pos) {
        return { node: this.textDOM, offset: pos };
      };
      CompositionViewDesc2.prototype.ignoreMutation = function ignoreMutation(mut) {
        return mut.type === "characterData" && mut.target.nodeValue == mut.oldValue;
      };
      Object.defineProperties(CompositionViewDesc2.prototype, prototypeAccessors$22);
      return CompositionViewDesc2;
    }(ViewDesc);
    var MarkViewDesc = /* @__PURE__ */ function(ViewDesc2) {
      function MarkViewDesc2(parent, mark, dom, contentDOM) {
        ViewDesc2.call(this, parent, [], dom, contentDOM);
        this.mark = mark;
      }
      if (ViewDesc2)
        MarkViewDesc2.__proto__ = ViewDesc2;
      MarkViewDesc2.prototype = Object.create(ViewDesc2 && ViewDesc2.prototype);
      MarkViewDesc2.prototype.constructor = MarkViewDesc2;
      MarkViewDesc2.create = function create(parent, mark, inline, view) {
        var custom = view.nodeViews[mark.type.name];
        var spec = custom && custom(mark, view, inline);
        if (!spec || !spec.dom) {
          spec = prosemirrorModel.DOMSerializer.renderSpec(document, mark.type.spec.toDOM(mark, inline));
        }
        return new MarkViewDesc2(parent, mark, spec.dom, spec.contentDOM || spec.dom);
      };
      MarkViewDesc2.prototype.parseRule = function parseRule() {
        return { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
      };
      MarkViewDesc2.prototype.matchesMark = function matchesMark(mark) {
        return this.dirty != NODE_DIRTY && this.mark.eq(mark);
      };
      MarkViewDesc2.prototype.markDirty = function markDirty(from, to) {
        ViewDesc2.prototype.markDirty.call(this, from, to);
        if (this.dirty != NOT_DIRTY) {
          var parent = this.parent;
          while (!parent.node) {
            parent = parent.parent;
          }
          if (parent.dirty < this.dirty) {
            parent.dirty = this.dirty;
          }
          this.dirty = NOT_DIRTY;
        }
      };
      MarkViewDesc2.prototype.slice = function slice(from, to, view) {
        var copy2 = MarkViewDesc2.create(this.parent, this.mark, true, view);
        var nodes = this.children, size = this.size;
        if (to < size) {
          nodes = replaceNodes(nodes, to, size, view);
        }
        if (from > 0) {
          nodes = replaceNodes(nodes, 0, from, view);
        }
        for (var i = 0; i < nodes.length; i++) {
          nodes[i].parent = copy2;
        }
        copy2.children = nodes;
        return copy2;
      };
      return MarkViewDesc2;
    }(ViewDesc);
    var NodeViewDesc = /* @__PURE__ */ function(ViewDesc2) {
      function NodeViewDesc2(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos) {
        ViewDesc2.call(this, parent, node.isLeaf ? nothing : [], dom, contentDOM);
        this.nodeDOM = nodeDOM;
        this.node = node;
        this.outerDeco = outerDeco;
        this.innerDeco = innerDeco;
        if (contentDOM) {
          this.updateChildren(view, pos);
        }
      }
      if (ViewDesc2)
        NodeViewDesc2.__proto__ = ViewDesc2;
      NodeViewDesc2.prototype = Object.create(ViewDesc2 && ViewDesc2.prototype);
      NodeViewDesc2.prototype.constructor = NodeViewDesc2;
      var prototypeAccessors$3 = { size: { configurable: true }, border: { configurable: true }, domAtom: { configurable: true } };
      NodeViewDesc2.create = function create(parent, node, outerDeco, innerDeco, view, pos) {
        var assign;
        var custom = view.nodeViews[node.type.name], descObj;
        var spec = custom && custom(node, view, function() {
          if (!descObj) {
            return pos;
          }
          if (descObj.parent) {
            return descObj.parent.posBeforeChild(descObj);
          }
        }, outerDeco, innerDeco);
        var dom = spec && spec.dom, contentDOM = spec && spec.contentDOM;
        if (node.isText) {
          if (!dom) {
            dom = document.createTextNode(node.text);
          } else if (dom.nodeType != 3) {
            throw new RangeError("Text must be rendered as a DOM text node");
          }
        } else if (!dom) {
          assign = prosemirrorModel.DOMSerializer.renderSpec(document, node.type.spec.toDOM(node)), dom = assign.dom, contentDOM = assign.contentDOM;
        }
        if (!contentDOM && !node.isText && dom.nodeName != "BR") {
          if (!dom.hasAttribute("contenteditable")) {
            dom.contentEditable = false;
          }
          if (node.type.spec.draggable) {
            dom.draggable = true;
          }
        }
        var nodeDOM = dom;
        dom = applyOuterDeco(dom, outerDeco, node);
        if (spec) {
          return descObj = new CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view, pos + 1);
        } else if (node.isText) {
          return new TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view);
        } else {
          return new NodeViewDesc2(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos + 1);
        }
      };
      NodeViewDesc2.prototype.parseRule = function parseRule() {
        var this$1 = this;
        if (this.node.type.spec.reparseInView) {
          return null;
        }
        var rule = { node: this.node.type.name, attrs: this.node.attrs };
        if (this.node.type.spec.code) {
          rule.preserveWhitespace = "full";
        }
        if (this.contentDOM && !this.contentLost) {
          rule.contentElement = this.contentDOM;
        } else {
          rule.getContent = function() {
            return this$1.contentDOM ? prosemirrorModel.Fragment.empty : this$1.node.content;
          };
        }
        return rule;
      };
      NodeViewDesc2.prototype.matchesNode = function matchesNode(node, outerDeco, innerDeco) {
        return this.dirty == NOT_DIRTY && node.eq(this.node) && sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco);
      };
      prototypeAccessors$3.size.get = function() {
        return this.node.nodeSize;
      };
      prototypeAccessors$3.border.get = function() {
        return this.node.isLeaf ? 0 : 1;
      };
      NodeViewDesc2.prototype.updateChildren = function updateChildren(view, pos) {
        var this$1 = this;
        var inline = this.node.inlineContent, off = pos;
        var composition = view.composing && this.localCompositionInfo(view, pos);
        var localComposition = composition && composition.pos > -1 ? composition : null;
        var compositionInChild = composition && composition.pos < 0;
        var updater = new ViewTreeUpdater(this, localComposition && localComposition.node);
        iterDeco(this.node, this.innerDeco, function(widget, i, insideNode) {
          if (widget.spec.marks) {
            updater.syncToMarks(widget.spec.marks, inline, view);
          } else if (widget.type.side >= 0 && !insideNode) {
            updater.syncToMarks(i == this$1.node.childCount ? prosemirrorModel.Mark.none : this$1.node.child(i).marks, inline, view);
          }
          updater.placeWidget(widget, view, off);
        }, function(child, outerDeco, innerDeco, i) {
          updater.syncToMarks(child.marks, inline, view);
          var compIndex;
          if (updater.findNodeMatch(child, outerDeco, innerDeco, i))
            ;
          else if (compositionInChild && view.state.selection.from > off && view.state.selection.to < off + child.nodeSize && (compIndex = updater.findIndexWithChild(composition.node)) > -1 && updater.updateNodeAt(child, outerDeco, innerDeco, compIndex, view))
            ;
          else if (updater.updateNextNode(child, outerDeco, innerDeco, view, i))
            ;
          else {
            updater.addNode(child, outerDeco, innerDeco, view, off);
          }
          off += child.nodeSize;
        });
        updater.syncToMarks(nothing, inline, view);
        if (this.node.isTextblock) {
          updater.addTextblockHacks();
        }
        updater.destroyRest();
        if (updater.changed || this.dirty == CONTENT_DIRTY) {
          if (localComposition) {
            this.protectLocalComposition(view, localComposition);
          }
          renderDescs(this.contentDOM, this.children, view);
          if (result.ios) {
            iosHacks(this.dom);
          }
        }
      };
      NodeViewDesc2.prototype.localCompositionInfo = function localCompositionInfo(view, pos) {
        var ref = view.state.selection;
        var from = ref.from;
        var to = ref.to;
        if (!(view.state.selection instanceof prosemirrorState.TextSelection) || from < pos || to > pos + this.node.content.size) {
          return;
        }
        var sel = view.root.getSelection();
        var textNode = nearbyTextNode(sel.focusNode, sel.focusOffset);
        if (!textNode || !this.dom.contains(textNode.parentNode)) {
          return;
        }
        if (this.node.inlineContent) {
          var text = textNode.nodeValue;
          var textPos = findTextInFragment(this.node.content, text, from - pos, to - pos);
          return textPos < 0 ? null : { node: textNode, pos: textPos, text };
        } else {
          return { node: textNode, pos: -1 };
        }
      };
      NodeViewDesc2.prototype.protectLocalComposition = function protectLocalComposition(view, ref) {
        var node = ref.node;
        var pos = ref.pos;
        var text = ref.text;
        if (this.getDesc(node)) {
          return;
        }
        var topNode = node;
        for (; ; topNode = topNode.parentNode) {
          if (topNode.parentNode == this.contentDOM) {
            break;
          }
          while (topNode.previousSibling) {
            topNode.parentNode.removeChild(topNode.previousSibling);
          }
          while (topNode.nextSibling) {
            topNode.parentNode.removeChild(topNode.nextSibling);
          }
          if (topNode.pmViewDesc) {
            topNode.pmViewDesc = null;
          }
        }
        var desc = new CompositionViewDesc(this, topNode, node, text);
        view.compositionNodes.push(desc);
        this.children = replaceNodes(this.children, pos, pos + text.length, view, desc);
      };
      NodeViewDesc2.prototype.update = function update(node, outerDeco, innerDeco, view) {
        if (this.dirty == NODE_DIRTY || !node.sameMarkup(this.node)) {
          return false;
        }
        this.updateInner(node, outerDeco, innerDeco, view);
        return true;
      };
      NodeViewDesc2.prototype.updateInner = function updateInner(node, outerDeco, innerDeco, view) {
        this.updateOuterDeco(outerDeco);
        this.node = node;
        this.innerDeco = innerDeco;
        if (this.contentDOM) {
          this.updateChildren(view, this.posAtStart);
        }
        this.dirty = NOT_DIRTY;
      };
      NodeViewDesc2.prototype.updateOuterDeco = function updateOuterDeco(outerDeco) {
        if (sameOuterDeco(outerDeco, this.outerDeco)) {
          return;
        }
        var needsWrap = this.nodeDOM.nodeType != 1;
        var oldDOM = this.dom;
        this.dom = patchOuterDeco(this.dom, this.nodeDOM, computeOuterDeco(this.outerDeco, this.node, needsWrap), computeOuterDeco(outerDeco, this.node, needsWrap));
        if (this.dom != oldDOM) {
          oldDOM.pmViewDesc = null;
          this.dom.pmViewDesc = this;
        }
        this.outerDeco = outerDeco;
      };
      NodeViewDesc2.prototype.selectNode = function selectNode() {
        this.nodeDOM.classList.add("ProseMirror-selectednode");
        if (this.contentDOM || !this.node.type.spec.draggable) {
          this.dom.draggable = true;
        }
      };
      NodeViewDesc2.prototype.deselectNode = function deselectNode() {
        this.nodeDOM.classList.remove("ProseMirror-selectednode");
        if (this.contentDOM || !this.node.type.spec.draggable) {
          this.dom.removeAttribute("draggable");
        }
      };
      prototypeAccessors$3.domAtom.get = function() {
        return this.node.isAtom;
      };
      Object.defineProperties(NodeViewDesc2.prototype, prototypeAccessors$3);
      return NodeViewDesc2;
    }(ViewDesc);
    function docViewDesc(doc, outerDeco, innerDeco, dom, view) {
      applyOuterDeco(dom, outerDeco, doc);
      return new NodeViewDesc(null, doc, outerDeco, innerDeco, dom, dom, dom, view, 0);
    }
    var TextViewDesc = /* @__PURE__ */ function(NodeViewDesc2) {
      function TextViewDesc2(parent, node, outerDeco, innerDeco, dom, nodeDOM, view) {
        NodeViewDesc2.call(this, parent, node, outerDeco, innerDeco, dom, null, nodeDOM, view);
      }
      if (NodeViewDesc2)
        TextViewDesc2.__proto__ = NodeViewDesc2;
      TextViewDesc2.prototype = Object.create(NodeViewDesc2 && NodeViewDesc2.prototype);
      TextViewDesc2.prototype.constructor = TextViewDesc2;
      var prototypeAccessors$4 = { domAtom: { configurable: true } };
      TextViewDesc2.prototype.parseRule = function parseRule() {
        var skip = this.nodeDOM.parentNode;
        while (skip && skip != this.dom && !skip.pmIsDeco) {
          skip = skip.parentNode;
        }
        return { skip: skip || true };
      };
      TextViewDesc2.prototype.update = function update(node, outerDeco, _, view) {
        if (this.dirty == NODE_DIRTY || this.dirty != NOT_DIRTY && !this.inParent() || !node.sameMarkup(this.node)) {
          return false;
        }
        this.updateOuterDeco(outerDeco);
        if ((this.dirty != NOT_DIRTY || node.text != this.node.text) && node.text != this.nodeDOM.nodeValue) {
          this.nodeDOM.nodeValue = node.text;
          if (view.trackWrites == this.nodeDOM) {
            view.trackWrites = null;
          }
        }
        this.node = node;
        this.dirty = NOT_DIRTY;
        return true;
      };
      TextViewDesc2.prototype.inParent = function inParent() {
        var parentDOM = this.parent.contentDOM;
        for (var n = this.nodeDOM; n; n = n.parentNode) {
          if (n == parentDOM) {
            return true;
          }
        }
        return false;
      };
      TextViewDesc2.prototype.domFromPos = function domFromPos(pos) {
        return { node: this.nodeDOM, offset: pos };
      };
      TextViewDesc2.prototype.localPosFromDOM = function localPosFromDOM(dom, offset, bias) {
        if (dom == this.nodeDOM) {
          return this.posAtStart + Math.min(offset, this.node.text.length);
        }
        return NodeViewDesc2.prototype.localPosFromDOM.call(this, dom, offset, bias);
      };
      TextViewDesc2.prototype.ignoreMutation = function ignoreMutation(mutation) {
        return mutation.type != "characterData" && mutation.type != "selection";
      };
      TextViewDesc2.prototype.slice = function slice(from, to, view) {
        var node = this.node.cut(from, to), dom = document.createTextNode(node.text);
        return new TextViewDesc2(this.parent, node, this.outerDeco, this.innerDeco, dom, dom, view);
      };
      TextViewDesc2.prototype.markDirty = function markDirty(from, to) {
        NodeViewDesc2.prototype.markDirty.call(this, from, to);
        if (this.dom != this.nodeDOM && (from == 0 || to == this.nodeDOM.nodeValue.length)) {
          this.dirty = NODE_DIRTY;
        }
      };
      prototypeAccessors$4.domAtom.get = function() {
        return false;
      };
      Object.defineProperties(TextViewDesc2.prototype, prototypeAccessors$4);
      return TextViewDesc2;
    }(NodeViewDesc);
    var TrailingHackViewDesc = /* @__PURE__ */ function(ViewDesc2) {
      function TrailingHackViewDesc2() {
        ViewDesc2.apply(this, arguments);
      }
      if (ViewDesc2)
        TrailingHackViewDesc2.__proto__ = ViewDesc2;
      TrailingHackViewDesc2.prototype = Object.create(ViewDesc2 && ViewDesc2.prototype);
      TrailingHackViewDesc2.prototype.constructor = TrailingHackViewDesc2;
      var prototypeAccessors$5 = { domAtom: { configurable: true }, ignoreForCoords: { configurable: true } };
      TrailingHackViewDesc2.prototype.parseRule = function parseRule() {
        return { ignore: true };
      };
      TrailingHackViewDesc2.prototype.matchesHack = function matchesHack(nodeName) {
        return this.dirty == NOT_DIRTY && this.dom.nodeName == nodeName;
      };
      prototypeAccessors$5.domAtom.get = function() {
        return true;
      };
      prototypeAccessors$5.ignoreForCoords.get = function() {
        return this.dom.nodeName == "IMG";
      };
      Object.defineProperties(TrailingHackViewDesc2.prototype, prototypeAccessors$5);
      return TrailingHackViewDesc2;
    }(ViewDesc);
    var CustomNodeViewDesc = /* @__PURE__ */ function(NodeViewDesc2) {
      function CustomNodeViewDesc2(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view, pos) {
        NodeViewDesc2.call(this, parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos);
        this.spec = spec;
      }
      if (NodeViewDesc2)
        CustomNodeViewDesc2.__proto__ = NodeViewDesc2;
      CustomNodeViewDesc2.prototype = Object.create(NodeViewDesc2 && NodeViewDesc2.prototype);
      CustomNodeViewDesc2.prototype.constructor = CustomNodeViewDesc2;
      CustomNodeViewDesc2.prototype.update = function update(node, outerDeco, innerDeco, view) {
        if (this.dirty == NODE_DIRTY) {
          return false;
        }
        if (this.spec.update) {
          var result2 = this.spec.update(node, outerDeco, innerDeco);
          if (result2) {
            this.updateInner(node, outerDeco, innerDeco, view);
          }
          return result2;
        } else if (!this.contentDOM && !node.isLeaf) {
          return false;
        } else {
          return NodeViewDesc2.prototype.update.call(this, node, outerDeco, innerDeco, view);
        }
      };
      CustomNodeViewDesc2.prototype.selectNode = function selectNode() {
        this.spec.selectNode ? this.spec.selectNode() : NodeViewDesc2.prototype.selectNode.call(this);
      };
      CustomNodeViewDesc2.prototype.deselectNode = function deselectNode() {
        this.spec.deselectNode ? this.spec.deselectNode() : NodeViewDesc2.prototype.deselectNode.call(this);
      };
      CustomNodeViewDesc2.prototype.setSelection = function setSelection(anchor, head, root, force) {
        this.spec.setSelection ? this.spec.setSelection(anchor, head, root) : NodeViewDesc2.prototype.setSelection.call(this, anchor, head, root, force);
      };
      CustomNodeViewDesc2.prototype.destroy = function destroy() {
        if (this.spec.destroy) {
          this.spec.destroy();
        }
        NodeViewDesc2.prototype.destroy.call(this);
      };
      CustomNodeViewDesc2.prototype.stopEvent = function stopEvent(event) {
        return this.spec.stopEvent ? this.spec.stopEvent(event) : false;
      };
      CustomNodeViewDesc2.prototype.ignoreMutation = function ignoreMutation(mutation) {
        return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : NodeViewDesc2.prototype.ignoreMutation.call(this, mutation);
      };
      return CustomNodeViewDesc2;
    }(NodeViewDesc);
    function renderDescs(parentDOM, descs, view) {
      var dom = parentDOM.firstChild, written = false;
      for (var i = 0; i < descs.length; i++) {
        var desc = descs[i], childDOM = desc.dom;
        if (childDOM.parentNode == parentDOM) {
          while (childDOM != dom) {
            dom = rm(dom);
            written = true;
          }
          dom = dom.nextSibling;
        } else {
          written = true;
          parentDOM.insertBefore(childDOM, dom);
        }
        if (desc instanceof MarkViewDesc) {
          var pos = dom ? dom.previousSibling : parentDOM.lastChild;
          renderDescs(desc.contentDOM, desc.children, view);
          dom = pos ? pos.nextSibling : parentDOM.firstChild;
        }
      }
      while (dom) {
        dom = rm(dom);
        written = true;
      }
      if (written && view.trackWrites == parentDOM) {
        view.trackWrites = null;
      }
    }
    function OuterDecoLevel(nodeName) {
      if (nodeName) {
        this.nodeName = nodeName;
      }
    }
    OuterDecoLevel.prototype = Object.create(null);
    var noDeco = [new OuterDecoLevel()];
    function computeOuterDeco(outerDeco, node, needsWrap) {
      if (outerDeco.length == 0) {
        return noDeco;
      }
      var top = needsWrap ? noDeco[0] : new OuterDecoLevel(), result2 = [top];
      for (var i = 0; i < outerDeco.length; i++) {
        var attrs = outerDeco[i].type.attrs;
        if (!attrs) {
          continue;
        }
        if (attrs.nodeName) {
          result2.push(top = new OuterDecoLevel(attrs.nodeName));
        }
        for (var name in attrs) {
          var val = attrs[name];
          if (val == null) {
            continue;
          }
          if (needsWrap && result2.length == 1) {
            result2.push(top = new OuterDecoLevel(node.isInline ? "span" : "div"));
          }
          if (name == "class") {
            top.class = (top.class ? top.class + " " : "") + val;
          } else if (name == "style") {
            top.style = (top.style ? top.style + ";" : "") + val;
          } else if (name != "nodeName") {
            top[name] = val;
          }
        }
      }
      return result2;
    }
    function patchOuterDeco(outerDOM, nodeDOM, prevComputed, curComputed) {
      if (prevComputed == noDeco && curComputed == noDeco) {
        return nodeDOM;
      }
      var curDOM = nodeDOM;
      for (var i = 0; i < curComputed.length; i++) {
        var deco = curComputed[i], prev = prevComputed[i];
        if (i) {
          var parent = void 0;
          if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM && (parent = curDOM.parentNode) && parent.tagName.toLowerCase() == deco.nodeName) {
            curDOM = parent;
          } else {
            parent = document.createElement(deco.nodeName);
            parent.pmIsDeco = true;
            parent.appendChild(curDOM);
            prev = noDeco[0];
            curDOM = parent;
          }
        }
        patchAttributes(curDOM, prev || noDeco[0], deco);
      }
      return curDOM;
    }
    function patchAttributes(dom, prev, cur) {
      for (var name in prev) {
        if (name != "class" && name != "style" && name != "nodeName" && !(name in cur)) {
          dom.removeAttribute(name);
        }
      }
      for (var name$1 in cur) {
        if (name$1 != "class" && name$1 != "style" && name$1 != "nodeName" && cur[name$1] != prev[name$1]) {
          dom.setAttribute(name$1, cur[name$1]);
        }
      }
      if (prev.class != cur.class) {
        var prevList = prev.class ? prev.class.split(" ").filter(Boolean) : nothing;
        var curList = cur.class ? cur.class.split(" ").filter(Boolean) : nothing;
        for (var i = 0; i < prevList.length; i++) {
          if (curList.indexOf(prevList[i]) == -1) {
            dom.classList.remove(prevList[i]);
          }
        }
        for (var i$1 = 0; i$1 < curList.length; i$1++) {
          if (prevList.indexOf(curList[i$1]) == -1) {
            dom.classList.add(curList[i$1]);
          }
        }
      }
      if (prev.style != cur.style) {
        if (prev.style) {
          var prop2 = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, m;
          while (m = prop2.exec(prev.style)) {
            dom.style.removeProperty(m[1]);
          }
        }
        if (cur.style) {
          dom.style.cssText += cur.style;
        }
      }
    }
    function applyOuterDeco(dom, deco, node) {
      return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node, dom.nodeType != 1));
    }
    function sameOuterDeco(a, b) {
      if (a.length != b.length) {
        return false;
      }
      for (var i = 0; i < a.length; i++) {
        if (!a[i].type.eq(b[i].type)) {
          return false;
        }
      }
      return true;
    }
    function rm(dom) {
      var next = dom.nextSibling;
      dom.parentNode.removeChild(dom);
      return next;
    }
    var ViewTreeUpdater = function ViewTreeUpdater2(top, lockedNode) {
      this.top = top;
      this.lock = lockedNode;
      this.index = 0;
      this.stack = [];
      this.changed = false;
      this.preMatch = preMatch(top.node.content, top.children);
    };
    ViewTreeUpdater.prototype.destroyBetween = function destroyBetween(start, end) {
      if (start == end) {
        return;
      }
      for (var i = start; i < end; i++) {
        this.top.children[i].destroy();
      }
      this.top.children.splice(start, end - start);
      this.changed = true;
    };
    ViewTreeUpdater.prototype.destroyRest = function destroyRest() {
      this.destroyBetween(this.index, this.top.children.length);
    };
    ViewTreeUpdater.prototype.syncToMarks = function syncToMarks(marks, inline, view) {
      var keep = 0, depth = this.stack.length >> 1;
      var maxKeep = Math.min(depth, marks.length);
      while (keep < maxKeep && (keep == depth - 1 ? this.top : this.stack[keep + 1 << 1]).matchesMark(marks[keep]) && marks[keep].type.spec.spanning !== false) {
        keep++;
      }
      while (keep < depth) {
        this.destroyRest();
        this.top.dirty = NOT_DIRTY;
        this.index = this.stack.pop();
        this.top = this.stack.pop();
        depth--;
      }
      while (depth < marks.length) {
        this.stack.push(this.top, this.index + 1);
        var found = -1;
        for (var i = this.index; i < Math.min(this.index + 3, this.top.children.length); i++) {
          if (this.top.children[i].matchesMark(marks[depth])) {
            found = i;
            break;
          }
        }
        if (found > -1) {
          if (found > this.index) {
            this.changed = true;
            this.destroyBetween(this.index, found);
          }
          this.top = this.top.children[this.index];
        } else {
          var markDesc = MarkViewDesc.create(this.top, marks[depth], inline, view);
          this.top.children.splice(this.index, 0, markDesc);
          this.top = markDesc;
          this.changed = true;
        }
        this.index = 0;
        depth++;
      }
    };
    ViewTreeUpdater.prototype.findNodeMatch = function findNodeMatch(node, outerDeco, innerDeco, index2) {
      var children = this.top.children, found = -1;
      if (index2 >= this.preMatch.index) {
        for (var i = this.index; i < children.length; i++) {
          if (children[i].matchesNode(node, outerDeco, innerDeco)) {
            found = i;
            break;
          }
        }
      } else {
        for (var i$1 = this.index, e = Math.min(children.length, i$1 + 1); i$1 < e; i$1++) {
          var child = children[i$1];
          if (child.matchesNode(node, outerDeco, innerDeco) && !this.preMatch.matched.has(child)) {
            found = i$1;
            break;
          }
        }
      }
      if (found < 0) {
        return false;
      }
      this.destroyBetween(this.index, found);
      this.index++;
      return true;
    };
    ViewTreeUpdater.prototype.updateNodeAt = function updateNodeAt(node, outerDeco, innerDeco, index2, view) {
      var child = this.top.children[index2];
      if (!child.update(node, outerDeco, innerDeco, view)) {
        return false;
      }
      this.destroyBetween(this.index, index2);
      this.index = index2 + 1;
      return true;
    };
    ViewTreeUpdater.prototype.findIndexWithChild = function findIndexWithChild(domNode) {
      for (; ; ) {
        var parent = domNode.parentNode;
        if (!parent) {
          return -1;
        }
        if (parent == this.top.contentDOM) {
          var desc = domNode.pmViewDesc;
          if (desc) {
            for (var i = this.index; i < this.top.children.length; i++) {
              if (this.top.children[i] == desc) {
                return i;
              }
            }
          }
          return -1;
        }
        domNode = parent;
      }
    };
    ViewTreeUpdater.prototype.updateNextNode = function updateNextNode(node, outerDeco, innerDeco, view, index2) {
      for (var i = this.index; i < this.top.children.length; i++) {
        var next = this.top.children[i];
        if (next instanceof NodeViewDesc) {
          var preMatch2 = this.preMatch.matched.get(next);
          if (preMatch2 != null && preMatch2 != index2) {
            return false;
          }
          var nextDOM = next.dom;
          var locked = this.lock && (nextDOM == this.lock || nextDOM.nodeType == 1 && nextDOM.contains(this.lock.parentNode)) && !(node.isText && next.node && next.node.isText && next.nodeDOM.nodeValue == node.text && next.dirty != NODE_DIRTY && sameOuterDeco(outerDeco, next.outerDeco));
          if (!locked && next.update(node, outerDeco, innerDeco, view)) {
            this.destroyBetween(this.index, i);
            if (next.dom != nextDOM) {
              this.changed = true;
            }
            this.index++;
            return true;
          }
          break;
        }
      }
      return false;
    };
    ViewTreeUpdater.prototype.addNode = function addNode(node, outerDeco, innerDeco, view, pos) {
      this.top.children.splice(this.index++, 0, NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos));
      this.changed = true;
    };
    ViewTreeUpdater.prototype.placeWidget = function placeWidget(widget, view, pos) {
      var next = this.index < this.top.children.length ? this.top.children[this.index] : null;
      if (next && next.matchesWidget(widget) && (widget == next.widget || !next.widget.type.toDOM.parentNode)) {
        this.index++;
      } else {
        var desc = new WidgetViewDesc(this.top, widget, view, pos);
        this.top.children.splice(this.index++, 0, desc);
        this.changed = true;
      }
    };
    ViewTreeUpdater.prototype.addTextblockHacks = function addTextblockHacks() {
      var lastChild = this.top.children[this.index - 1];
      while (lastChild instanceof MarkViewDesc) {
        lastChild = lastChild.children[lastChild.children.length - 1];
      }
      if (!lastChild || !(lastChild instanceof TextViewDesc) || /\n$/.test(lastChild.node.text)) {
        if ((result.safari || result.chrome) && lastChild && lastChild.dom.contentEditable == "false") {
          this.addHackNode("IMG");
        }
        this.addHackNode("BR");
      }
    };
    ViewTreeUpdater.prototype.addHackNode = function addHackNode(nodeName) {
      if (this.index < this.top.children.length && this.top.children[this.index].matchesHack(nodeName)) {
        this.index++;
      } else {
        var dom = document.createElement(nodeName);
        if (nodeName == "IMG") {
          dom.className = "ProseMirror-separator";
        }
        if (nodeName == "BR") {
          dom.className = "ProseMirror-trailingBreak";
        }
        this.top.children.splice(this.index++, 0, new TrailingHackViewDesc(this.top, nothing, dom, null));
        this.changed = true;
      }
    };
    function preMatch(frag, descs) {
      var fI = frag.childCount, dI = descs.length, matched = new Map();
      for (; fI > 0 && dI > 0; dI--) {
        var desc = descs[dI - 1], node = desc.node;
        if (!node) {
          continue;
        }
        if (node != frag.child(fI - 1)) {
          break;
        }
        --fI;
        matched.set(desc, fI);
      }
      return { index: fI, matched };
    }
    function compareSide(a, b) {
      return a.type.side - b.type.side;
    }
    function iterDeco(parent, deco, onWidget, onNode) {
      var locals = deco.locals(parent), offset = 0;
      if (locals.length == 0) {
        for (var i = 0; i < parent.childCount; i++) {
          var child = parent.child(i);
          onNode(child, locals, deco.forChild(offset, child), i);
          offset += child.nodeSize;
        }
        return;
      }
      var decoIndex = 0, active = [], restNode = null;
      for (var parentIndex = 0; ; ) {
        if (decoIndex < locals.length && locals[decoIndex].to == offset) {
          var widget = locals[decoIndex++], widgets = void 0;
          while (decoIndex < locals.length && locals[decoIndex].to == offset) {
            (widgets || (widgets = [widget])).push(locals[decoIndex++]);
          }
          if (widgets) {
            widgets.sort(compareSide);
            for (var i$1 = 0; i$1 < widgets.length; i$1++) {
              onWidget(widgets[i$1], parentIndex, !!restNode);
            }
          } else {
            onWidget(widget, parentIndex, !!restNode);
          }
        }
        var child$1 = void 0, index2 = void 0;
        if (restNode) {
          index2 = -1;
          child$1 = restNode;
          restNode = null;
        } else if (parentIndex < parent.childCount) {
          index2 = parentIndex;
          child$1 = parent.child(parentIndex++);
        } else {
          break;
        }
        for (var i$2 = 0; i$2 < active.length; i$2++) {
          if (active[i$2].to <= offset) {
            active.splice(i$2--, 1);
          }
        }
        while (decoIndex < locals.length && locals[decoIndex].from <= offset && locals[decoIndex].to > offset) {
          active.push(locals[decoIndex++]);
        }
        var end = offset + child$1.nodeSize;
        if (child$1.isText) {
          var cutAt = end;
          if (decoIndex < locals.length && locals[decoIndex].from < cutAt) {
            cutAt = locals[decoIndex].from;
          }
          for (var i$3 = 0; i$3 < active.length; i$3++) {
            if (active[i$3].to < cutAt) {
              cutAt = active[i$3].to;
            }
          }
          if (cutAt < end) {
            restNode = child$1.cut(cutAt - offset);
            child$1 = child$1.cut(0, cutAt - offset);
            end = cutAt;
            index2 = -1;
          }
        }
        var outerDeco = !active.length ? nothing : child$1.isInline && !child$1.isLeaf ? active.filter(function(d) {
          return !d.inline;
        }) : active.slice();
        onNode(child$1, outerDeco, deco.forChild(offset, child$1), index2);
        offset = end;
      }
    }
    function iosHacks(dom) {
      if (dom.nodeName == "UL" || dom.nodeName == "OL") {
        var oldCSS = dom.style.cssText;
        dom.style.cssText = oldCSS + "; list-style: square !important";
        window.getComputedStyle(dom).listStyle;
        dom.style.cssText = oldCSS;
      }
    }
    function nearbyTextNode(node, offset) {
      for (; ; ) {
        if (node.nodeType == 3) {
          return node;
        }
        if (node.nodeType == 1 && offset > 0) {
          if (node.childNodes.length > offset && node.childNodes[offset].nodeType == 3) {
            return node.childNodes[offset];
          }
          node = node.childNodes[offset - 1];
          offset = nodeSize(node);
        } else if (node.nodeType == 1 && offset < node.childNodes.length) {
          node = node.childNodes[offset];
          offset = 0;
        } else {
          return null;
        }
      }
    }
    function findTextInFragment(frag, text, from, to) {
      for (var i = 0, pos = 0; i < frag.childCount && pos <= to; ) {
        var child = frag.child(i++), childStart = pos;
        pos += child.nodeSize;
        if (!child.isText) {
          continue;
        }
        var str = child.text;
        while (i < frag.childCount) {
          var next = frag.child(i++);
          pos += next.nodeSize;
          if (!next.isText) {
            break;
          }
          str += next.text;
        }
        if (pos >= from) {
          var found = str.lastIndexOf(text, to - childStart);
          if (found >= 0 && found + text.length + childStart >= from) {
            return childStart + found;
          }
        }
      }
      return -1;
    }
    function replaceNodes(nodes, from, to, view, replacement) {
      var result2 = [];
      for (var i = 0, off = 0; i < nodes.length; i++) {
        var child = nodes[i], start = off, end = off += child.size;
        if (start >= to || end <= from) {
          result2.push(child);
        } else {
          if (start < from) {
            result2.push(child.slice(0, from - start, view));
          }
          if (replacement) {
            result2.push(replacement);
            replacement = null;
          }
          if (end > to) {
            result2.push(child.slice(to - start, child.size, view));
          }
        }
      }
      return result2;
    }
    function selectionFromDOM(view, origin) {
      var domSel = view.root.getSelection(), doc = view.state.doc;
      if (!domSel.focusNode) {
        return null;
      }
      var nearestDesc = view.docView.nearestDesc(domSel.focusNode), inWidget = nearestDesc && nearestDesc.size == 0;
      var head = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);
      if (head < 0) {
        return null;
      }
      var $head = doc.resolve(head), $anchor, selection;
      if (selectionCollapsed(domSel)) {
        $anchor = $head;
        while (nearestDesc && !nearestDesc.node) {
          nearestDesc = nearestDesc.parent;
        }
        if (nearestDesc && nearestDesc.node.isAtom && prosemirrorState.NodeSelection.isSelectable(nearestDesc.node) && nearestDesc.parent && !(nearestDesc.node.isInline && isOnEdge(domSel.focusNode, domSel.focusOffset, nearestDesc.dom))) {
          var pos = nearestDesc.posBefore;
          selection = new prosemirrorState.NodeSelection(head == pos ? $head : doc.resolve(pos));
        }
      } else {
        var anchor = view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);
        if (anchor < 0) {
          return null;
        }
        $anchor = doc.resolve(anchor);
      }
      if (!selection) {
        var bias = origin == "pointer" || view.state.selection.head < $head.pos && !inWidget ? 1 : -1;
        selection = selectionBetween(view, $anchor, $head, bias);
      }
      return selection;
    }
    function editorOwnsSelection(view) {
      return view.editable ? view.hasFocus() : hasSelection(view) && document.activeElement && document.activeElement.contains(view.dom);
    }
    function selectionToDOM(view, force) {
      var sel = view.state.selection;
      syncNodeSelection(view, sel);
      if (!editorOwnsSelection(view)) {
        return;
      }
      if (!force && view.mouseDown && view.mouseDown.allowDefault) {
        view.mouseDown.delayedSelectionSync = true;
        view.domObserver.setCurSelection();
        return;
      }
      view.domObserver.disconnectSelection();
      if (view.cursorWrapper) {
        selectCursorWrapper(view);
      } else {
        var anchor = sel.anchor;
        var head = sel.head;
        var resetEditableFrom, resetEditableTo;
        if (brokenSelectBetweenUneditable && !(sel instanceof prosemirrorState.TextSelection)) {
          if (!sel.$from.parent.inlineContent) {
            resetEditableFrom = temporarilyEditableNear(view, sel.from);
          }
          if (!sel.empty && !sel.$from.parent.inlineContent) {
            resetEditableTo = temporarilyEditableNear(view, sel.to);
          }
        }
        view.docView.setSelection(anchor, head, view.root, force);
        if (brokenSelectBetweenUneditable) {
          if (resetEditableFrom) {
            resetEditable(resetEditableFrom);
          }
          if (resetEditableTo) {
            resetEditable(resetEditableTo);
          }
        }
        if (sel.visible) {
          view.dom.classList.remove("ProseMirror-hideselection");
        } else {
          view.dom.classList.add("ProseMirror-hideselection");
          if ("onselectionchange" in document) {
            removeClassOnSelectionChange(view);
          }
        }
      }
      view.domObserver.setCurSelection();
      view.domObserver.connectSelection();
    }
    var brokenSelectBetweenUneditable = result.safari || result.chrome && result.chrome_version < 63;
    function temporarilyEditableNear(view, pos) {
      var ref = view.docView.domFromPos(pos, 0);
      var node = ref.node;
      var offset = ref.offset;
      var after = offset < node.childNodes.length ? node.childNodes[offset] : null;
      var before = offset ? node.childNodes[offset - 1] : null;
      if (result.safari && after && after.contentEditable == "false") {
        return setEditable(after);
      }
      if ((!after || after.contentEditable == "false") && (!before || before.contentEditable == "false")) {
        if (after) {
          return setEditable(after);
        } else if (before) {
          return setEditable(before);
        }
      }
    }
    function setEditable(element) {
      element.contentEditable = "true";
      if (result.safari && element.draggable) {
        element.draggable = false;
        element.wasDraggable = true;
      }
      return element;
    }
    function resetEditable(element) {
      element.contentEditable = "false";
      if (element.wasDraggable) {
        element.draggable = true;
        element.wasDraggable = null;
      }
    }
    function removeClassOnSelectionChange(view) {
      var doc = view.dom.ownerDocument;
      doc.removeEventListener("selectionchange", view.hideSelectionGuard);
      var domSel = view.root.getSelection();
      var node = domSel.anchorNode, offset = domSel.anchorOffset;
      doc.addEventListener("selectionchange", view.hideSelectionGuard = function() {
        if (domSel.anchorNode != node || domSel.anchorOffset != offset) {
          doc.removeEventListener("selectionchange", view.hideSelectionGuard);
          setTimeout(function() {
            if (!editorOwnsSelection(view) || view.state.selection.visible) {
              view.dom.classList.remove("ProseMirror-hideselection");
            }
          }, 20);
        }
      });
    }
    function selectCursorWrapper(view) {
      var domSel = view.root.getSelection(), range = document.createRange();
      var node = view.cursorWrapper.dom, img = node.nodeName == "IMG";
      if (img) {
        range.setEnd(node.parentNode, domIndex(node) + 1);
      } else {
        range.setEnd(node, 0);
      }
      range.collapse(false);
      domSel.removeAllRanges();
      domSel.addRange(range);
      if (!img && !view.state.selection.visible && result.ie && result.ie_version <= 11) {
        node.disabled = true;
        node.disabled = false;
      }
    }
    function syncNodeSelection(view, sel) {
      if (sel instanceof prosemirrorState.NodeSelection) {
        var desc = view.docView.descAt(sel.from);
        if (desc != view.lastSelectedViewDesc) {
          clearNodeSelection(view);
          if (desc) {
            desc.selectNode();
          }
          view.lastSelectedViewDesc = desc;
        }
      } else {
        clearNodeSelection(view);
      }
    }
    function clearNodeSelection(view) {
      if (view.lastSelectedViewDesc) {
        if (view.lastSelectedViewDesc.parent) {
          view.lastSelectedViewDesc.deselectNode();
        }
        view.lastSelectedViewDesc = null;
      }
    }
    function selectionBetween(view, $anchor, $head, bias) {
      return view.someProp("createSelectionBetween", function(f) {
        return f(view, $anchor, $head);
      }) || prosemirrorState.TextSelection.between($anchor, $head, bias);
    }
    function hasFocusAndSelection(view) {
      if (view.editable && view.root.activeElement != view.dom) {
        return false;
      }
      return hasSelection(view);
    }
    function hasSelection(view) {
      var sel = view.root.getSelection();
      if (!sel.anchorNode) {
        return false;
      }
      try {
        return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) && (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode));
      } catch (_) {
        return false;
      }
    }
    function anchorInRightPlace(view) {
      var anchorDOM = view.docView.domFromPos(view.state.selection.anchor, 0);
      var domSel = view.root.getSelection();
      return isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset);
    }
    function moveSelectionBlock(state, dir) {
      var ref = state.selection;
      var $anchor = ref.$anchor;
      var $head = ref.$head;
      var $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);
      var $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;
      return $start && prosemirrorState.Selection.findFrom($start, dir);
    }
    function apply(view, sel) {
      view.dispatch(view.state.tr.setSelection(sel).scrollIntoView());
      return true;
    }
    function selectHorizontally(view, dir, mods) {
      var sel = view.state.selection;
      if (sel instanceof prosemirrorState.TextSelection) {
        if (!sel.empty || mods.indexOf("s") > -1) {
          return false;
        } else if (view.endOfTextblock(dir > 0 ? "right" : "left")) {
          var next = moveSelectionBlock(view.state, dir);
          if (next && next instanceof prosemirrorState.NodeSelection) {
            return apply(view, next);
          }
          return false;
        } else if (!(result.mac && mods.indexOf("m") > -1)) {
          var $head = sel.$head, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter, desc;
          if (!node || node.isText) {
            return false;
          }
          var nodePos = dir < 0 ? $head.pos - node.nodeSize : $head.pos;
          if (!(node.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM)) {
            return false;
          }
          if (prosemirrorState.NodeSelection.isSelectable(node)) {
            return apply(view, new prosemirrorState.NodeSelection(dir < 0 ? view.state.doc.resolve($head.pos - node.nodeSize) : $head));
          } else if (result.webkit) {
            return apply(view, new prosemirrorState.TextSelection(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + node.nodeSize)));
          } else {
            return false;
          }
        }
      } else if (sel instanceof prosemirrorState.NodeSelection && sel.node.isInline) {
        return apply(view, new prosemirrorState.TextSelection(dir > 0 ? sel.$to : sel.$from));
      } else {
        var next$1 = moveSelectionBlock(view.state, dir);
        if (next$1) {
          return apply(view, next$1);
        }
        return false;
      }
    }
    function nodeLen(node) {
      return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
    }
    function isIgnorable(dom) {
      var desc = dom.pmViewDesc;
      return desc && desc.size == 0 && (dom.nextSibling || dom.nodeName != "BR");
    }
    function skipIgnoredNodesLeft(view) {
      var sel = view.root.getSelection();
      var node = sel.focusNode, offset = sel.focusOffset;
      if (!node) {
        return;
      }
      var moveNode, moveOffset, force = false;
      if (result.gecko && node.nodeType == 1 && offset < nodeLen(node) && isIgnorable(node.childNodes[offset])) {
        force = true;
      }
      for (; ; ) {
        if (offset > 0) {
          if (node.nodeType != 1) {
            break;
          } else {
            var before = node.childNodes[offset - 1];
            if (isIgnorable(before)) {
              moveNode = node;
              moveOffset = --offset;
            } else if (before.nodeType == 3) {
              node = before;
              offset = node.nodeValue.length;
            } else {
              break;
            }
          }
        } else if (isBlockNode(node)) {
          break;
        } else {
          var prev = node.previousSibling;
          while (prev && isIgnorable(prev)) {
            moveNode = node.parentNode;
            moveOffset = domIndex(prev);
            prev = prev.previousSibling;
          }
          if (!prev) {
            node = node.parentNode;
            if (node == view.dom) {
              break;
            }
            offset = 0;
          } else {
            node = prev;
            offset = nodeLen(node);
          }
        }
      }
      if (force) {
        setSelFocus(view, sel, node, offset);
      } else if (moveNode) {
        setSelFocus(view, sel, moveNode, moveOffset);
      }
    }
    function skipIgnoredNodesRight(view) {
      var sel = view.root.getSelection();
      var node = sel.focusNode, offset = sel.focusOffset;
      if (!node) {
        return;
      }
      var len = nodeLen(node);
      var moveNode, moveOffset;
      for (; ; ) {
        if (offset < len) {
          if (node.nodeType != 1) {
            break;
          }
          var after = node.childNodes[offset];
          if (isIgnorable(after)) {
            moveNode = node;
            moveOffset = ++offset;
          } else {
            break;
          }
        } else if (isBlockNode(node)) {
          break;
        } else {
          var next = node.nextSibling;
          while (next && isIgnorable(next)) {
            moveNode = next.parentNode;
            moveOffset = domIndex(next) + 1;
            next = next.nextSibling;
          }
          if (!next) {
            node = node.parentNode;
            if (node == view.dom) {
              break;
            }
            offset = len = 0;
          } else {
            node = next;
            offset = 0;
            len = nodeLen(node);
          }
        }
      }
      if (moveNode) {
        setSelFocus(view, sel, moveNode, moveOffset);
      }
    }
    function isBlockNode(dom) {
      var desc = dom.pmViewDesc;
      return desc && desc.node && desc.node.isBlock;
    }
    function setSelFocus(view, sel, node, offset) {
      if (selectionCollapsed(sel)) {
        var range = document.createRange();
        range.setEnd(node, offset);
        range.setStart(node, offset);
        sel.removeAllRanges();
        sel.addRange(range);
      } else if (sel.extend) {
        sel.extend(node, offset);
      }
      view.domObserver.setCurSelection();
      var state = view.state;
      setTimeout(function() {
        if (view.state == state) {
          selectionToDOM(view);
        }
      }, 50);
    }
    function selectVertically(view, dir, mods) {
      var sel = view.state.selection;
      if (sel instanceof prosemirrorState.TextSelection && !sel.empty || mods.indexOf("s") > -1) {
        return false;
      }
      if (result.mac && mods.indexOf("m") > -1) {
        return false;
      }
      var $from = sel.$from;
      var $to = sel.$to;
      if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? "up" : "down")) {
        var next = moveSelectionBlock(view.state, dir);
        if (next && next instanceof prosemirrorState.NodeSelection) {
          return apply(view, next);
        }
      }
      if (!$from.parent.inlineContent) {
        var side = dir < 0 ? $from : $to;
        var beyond = sel instanceof prosemirrorState.AllSelection ? prosemirrorState.Selection.near(side, dir) : prosemirrorState.Selection.findFrom(side, dir);
        return beyond ? apply(view, beyond) : false;
      }
      return false;
    }
    function stopNativeHorizontalDelete(view, dir) {
      if (!(view.state.selection instanceof prosemirrorState.TextSelection)) {
        return true;
      }
      var ref = view.state.selection;
      var $head = ref.$head;
      var $anchor = ref.$anchor;
      var empty3 = ref.empty;
      if (!$head.sameParent($anchor)) {
        return true;
      }
      if (!empty3) {
        return false;
      }
      if (view.endOfTextblock(dir > 0 ? "forward" : "backward")) {
        return true;
      }
      var nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);
      if (nextNode && !nextNode.isText) {
        var tr = view.state.tr;
        if (dir < 0) {
          tr.delete($head.pos - nextNode.nodeSize, $head.pos);
        } else {
          tr.delete($head.pos, $head.pos + nextNode.nodeSize);
        }
        view.dispatch(tr);
        return true;
      }
      return false;
    }
    function switchEditable(view, node, state) {
      view.domObserver.stop();
      node.contentEditable = state;
      view.domObserver.start();
    }
    function safariDownArrowBug(view) {
      if (!result.safari || view.state.selection.$head.parentOffset > 0) {
        return;
      }
      var ref = view.root.getSelection();
      var focusNode = ref.focusNode;
      var focusOffset = ref.focusOffset;
      if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 && focusNode.firstChild && focusNode.firstChild.contentEditable == "false") {
        var child = focusNode.firstChild;
        switchEditable(view, child, true);
        setTimeout(function() {
          return switchEditable(view, child, false);
        }, 20);
      }
    }
    function getMods(event) {
      var result2 = "";
      if (event.ctrlKey) {
        result2 += "c";
      }
      if (event.metaKey) {
        result2 += "m";
      }
      if (event.altKey) {
        result2 += "a";
      }
      if (event.shiftKey) {
        result2 += "s";
      }
      return result2;
    }
    function captureKeyDown(view, event) {
      var code = event.keyCode, mods = getMods(event);
      if (code == 8 || result.mac && code == 72 && mods == "c") {
        return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodesLeft(view);
      } else if (code == 46 || result.mac && code == 68 && mods == "c") {
        return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodesRight(view);
      } else if (code == 13 || code == 27) {
        return true;
      } else if (code == 37) {
        return selectHorizontally(view, -1, mods) || skipIgnoredNodesLeft(view);
      } else if (code == 39) {
        return selectHorizontally(view, 1, mods) || skipIgnoredNodesRight(view);
      } else if (code == 38) {
        return selectVertically(view, -1, mods) || skipIgnoredNodesLeft(view);
      } else if (code == 40) {
        return safariDownArrowBug(view) || selectVertically(view, 1, mods) || skipIgnoredNodesRight(view);
      } else if (mods == (result.mac ? "m" : "c") && (code == 66 || code == 73 || code == 89 || code == 90)) {
        return true;
      }
      return false;
    }
    function parseBetween(view, from_, to_) {
      var ref = view.docView.parseRange(from_, to_);
      var parent = ref.node;
      var fromOffset = ref.fromOffset;
      var toOffset = ref.toOffset;
      var from = ref.from;
      var to = ref.to;
      var domSel = view.root.getSelection(), find = null, anchor = domSel.anchorNode;
      if (anchor && view.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {
        find = [{ node: anchor, offset: domSel.anchorOffset }];
        if (!selectionCollapsed(domSel)) {
          find.push({ node: domSel.focusNode, offset: domSel.focusOffset });
        }
      }
      if (result.chrome && view.lastKeyCode === 8) {
        for (var off = toOffset; off > fromOffset; off--) {
          var node = parent.childNodes[off - 1], desc = node.pmViewDesc;
          if (node.nodeName == "BR" && !desc) {
            toOffset = off;
            break;
          }
          if (!desc || desc.size) {
            break;
          }
        }
      }
      var startDoc = view.state.doc;
      var parser = view.someProp("domParser") || prosemirrorModel.DOMParser.fromSchema(view.state.schema);
      var $from = startDoc.resolve(from);
      var sel = null, doc = parser.parse(parent, {
        topNode: $from.parent,
        topMatch: $from.parent.contentMatchAt($from.index()),
        topOpen: true,
        from: fromOffset,
        to: toOffset,
        preserveWhitespace: $from.parent.type.spec.code ? "full" : true,
        editableContent: true,
        findPositions: find,
        ruleFromNode,
        context: $from
      });
      if (find && find[0].pos != null) {
        var anchor$1 = find[0].pos, head = find[1] && find[1].pos;
        if (head == null) {
          head = anchor$1;
        }
        sel = { anchor: anchor$1 + from, head: head + from };
      }
      return { doc, sel, from, to };
    }
    function ruleFromNode(dom) {
      var desc = dom.pmViewDesc;
      if (desc) {
        return desc.parseRule();
      } else if (dom.nodeName == "BR" && dom.parentNode) {
        if (result.safari && /^(ul|ol)$/i.test(dom.parentNode.nodeName)) {
          var skip = document.createElement("div");
          skip.appendChild(document.createElement("li"));
          return { skip };
        } else if (dom.parentNode.lastChild == dom || result.safari && /^(tr|table)$/i.test(dom.parentNode.nodeName)) {
          return { ignore: true };
        }
      } else if (dom.nodeName == "IMG" && dom.getAttribute("mark-placeholder")) {
        return { ignore: true };
      }
    }
    function readDOMChange(view, from, to, typeOver, addedNodes) {
      if (from < 0) {
        var origin = view.lastSelectionTime > Date.now() - 50 ? view.lastSelectionOrigin : null;
        var newSel = selectionFromDOM(view, origin);
        if (newSel && !view.state.selection.eq(newSel)) {
          var tr$1 = view.state.tr.setSelection(newSel);
          if (origin == "pointer") {
            tr$1.setMeta("pointer", true);
          } else if (origin == "key") {
            tr$1.scrollIntoView();
          }
          view.dispatch(tr$1);
        }
        return;
      }
      var $before = view.state.doc.resolve(from);
      var shared = $before.sharedDepth(to);
      from = $before.before(shared + 1);
      to = view.state.doc.resolve(to).after(shared + 1);
      var sel = view.state.selection;
      var parse = parseBetween(view, from, to);
      if (result.chrome && view.cursorWrapper && parse.sel && parse.sel.anchor == view.cursorWrapper.deco.from) {
        var text = view.cursorWrapper.deco.type.toDOM.nextSibling;
        var size = text && text.nodeValue ? text.nodeValue.length : 1;
        parse.sel = { anchor: parse.sel.anchor + size, head: parse.sel.anchor + size };
      }
      var doc = view.state.doc, compare = doc.slice(parse.from, parse.to);
      var preferredPos, preferredSide;
      if (view.lastKeyCode === 8 && Date.now() - 100 < view.lastKeyCodeTime) {
        preferredPos = view.state.selection.to;
        preferredSide = "end";
      } else {
        preferredPos = view.state.selection.from;
        preferredSide = "start";
      }
      view.lastKeyCode = null;
      var change = findDiff(compare.content, parse.doc.content, parse.from, preferredPos, preferredSide);
      if (!change) {
        if (typeOver && sel instanceof prosemirrorState.TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor) && !view.composing && !(parse.sel && parse.sel.anchor != parse.sel.head)) {
          change = { start: sel.from, endA: sel.to, endB: sel.to };
        } else if ((result.ios && view.lastIOSEnter > Date.now() - 225 || result.android) && addedNodes.some(function(n) {
          return n.nodeName == "DIV" || n.nodeName == "P";
        }) && view.someProp("handleKeyDown", function(f) {
          return f(view, keyEvent(13, "Enter"));
        })) {
          view.lastIOSEnter = 0;
          return;
        } else {
          if (parse.sel) {
            var sel$1 = resolveSelection(view, view.state.doc, parse.sel);
            if (sel$1 && !sel$1.eq(view.state.selection)) {
              view.dispatch(view.state.tr.setSelection(sel$1));
            }
          }
          return;
        }
      }
      view.domChangeCount++;
      if (view.state.selection.from < view.state.selection.to && change.start == change.endB && view.state.selection instanceof prosemirrorState.TextSelection) {
        if (change.start > view.state.selection.from && change.start <= view.state.selection.from + 2) {
          change.start = view.state.selection.from;
        } else if (change.endA < view.state.selection.to && change.endA >= view.state.selection.to - 2) {
          change.endB += view.state.selection.to - change.endA;
          change.endA = view.state.selection.to;
        }
      }
      if (result.ie && result.ie_version <= 11 && change.endB == change.start + 1 && change.endA == change.start && change.start > parse.from && parse.doc.textBetween(change.start - parse.from - 1, change.start - parse.from + 1) == " \xA0") {
        change.start--;
        change.endA--;
        change.endB--;
      }
      var $from = parse.doc.resolveNoCache(change.start - parse.from);
      var $to = parse.doc.resolveNoCache(change.endB - parse.from);
      var inlineChange = $from.sameParent($to) && $from.parent.inlineContent;
      var nextSel;
      if ((result.ios && view.lastIOSEnter > Date.now() - 225 && (!inlineChange || addedNodes.some(function(n) {
        return n.nodeName == "DIV" || n.nodeName == "P";
      })) || !inlineChange && $from.pos < parse.doc.content.size && (nextSel = prosemirrorState.Selection.findFrom(parse.doc.resolve($from.pos + 1), 1, true)) && nextSel.head == $to.pos) && view.someProp("handleKeyDown", function(f) {
        return f(view, keyEvent(13, "Enter"));
      })) {
        view.lastIOSEnter = 0;
        return;
      }
      if (view.state.selection.anchor > change.start && looksLikeJoin(doc, change.start, change.endA, $from, $to) && view.someProp("handleKeyDown", function(f) {
        return f(view, keyEvent(8, "Backspace"));
      })) {
        if (result.android && result.chrome) {
          view.domObserver.suppressSelectionUpdates();
        }
        return;
      }
      if (result.chrome && result.android && change.toB == change.from) {
        view.lastAndroidDelete = Date.now();
      }
      if (result.android && !inlineChange && $from.start() != $to.start() && $to.parentOffset == 0 && $from.depth == $to.depth && parse.sel && parse.sel.anchor == parse.sel.head && parse.sel.head == change.endA) {
        change.endB -= 2;
        $to = parse.doc.resolveNoCache(change.endB - parse.from);
        setTimeout(function() {
          view.someProp("handleKeyDown", function(f) {
            return f(view, keyEvent(13, "Enter"));
          });
        }, 20);
      }
      var chFrom = change.start, chTo = change.endA;
      var tr, storedMarks, markChange, $from1;
      if (inlineChange) {
        if ($from.pos == $to.pos) {
          if (result.ie && result.ie_version <= 11 && $from.parentOffset == 0) {
            view.domObserver.suppressSelectionUpdates();
            setTimeout(function() {
              return selectionToDOM(view);
            }, 20);
          }
          tr = view.state.tr.delete(chFrom, chTo);
          storedMarks = doc.resolve(change.start).marksAcross(doc.resolve(change.endA));
        } else if (change.endA == change.endB && ($from1 = doc.resolve(change.start)) && (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset), $from1.parent.content.cut($from1.parentOffset, change.endA - $from1.start())))) {
          tr = view.state.tr;
          if (markChange.type == "add") {
            tr.addMark(chFrom, chTo, markChange.mark);
          } else {
            tr.removeMark(chFrom, chTo, markChange.mark);
          }
        } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {
          var text$1 = $from.parent.textBetween($from.parentOffset, $to.parentOffset);
          if (view.someProp("handleTextInput", function(f) {
            return f(view, chFrom, chTo, text$1);
          })) {
            return;
          }
          tr = view.state.tr.insertText(text$1, chFrom, chTo);
        }
      }
      if (!tr) {
        tr = view.state.tr.replace(chFrom, chTo, parse.doc.slice(change.start - parse.from, change.endB - parse.from));
      }
      if (parse.sel) {
        var sel$2 = resolveSelection(view, tr.doc, parse.sel);
        if (sel$2 && !(result.chrome && result.android && view.composing && sel$2.empty && (change.start != change.endB || view.lastAndroidDelete < Date.now() - 100) && (sel$2.head == chFrom || sel$2.head == tr.mapping.map(chTo) - 1) || result.ie && sel$2.empty && sel$2.head == chFrom)) {
          tr.setSelection(sel$2);
        }
      }
      if (storedMarks) {
        tr.ensureMarks(storedMarks);
      }
      view.dispatch(tr.scrollIntoView());
    }
    function resolveSelection(view, doc, parsedSel) {
      if (Math.max(parsedSel.anchor, parsedSel.head) > doc.content.size) {
        return null;
      }
      return selectionBetween(view, doc.resolve(parsedSel.anchor), doc.resolve(parsedSel.head));
    }
    function isMarkChange(cur, prev) {
      var curMarks = cur.firstChild.marks, prevMarks = prev.firstChild.marks;
      var added = curMarks, removed = prevMarks, type, mark, update;
      for (var i = 0; i < prevMarks.length; i++) {
        added = prevMarks[i].removeFromSet(added);
      }
      for (var i$1 = 0; i$1 < curMarks.length; i$1++) {
        removed = curMarks[i$1].removeFromSet(removed);
      }
      if (added.length == 1 && removed.length == 0) {
        mark = added[0];
        type = "add";
        update = function(node) {
          return node.mark(mark.addToSet(node.marks));
        };
      } else if (added.length == 0 && removed.length == 1) {
        mark = removed[0];
        type = "remove";
        update = function(node) {
          return node.mark(mark.removeFromSet(node.marks));
        };
      } else {
        return null;
      }
      var updated = [];
      for (var i$2 = 0; i$2 < prev.childCount; i$2++) {
        updated.push(update(prev.child(i$2)));
      }
      if (prosemirrorModel.Fragment.from(updated).eq(cur)) {
        return { mark, type };
      }
    }
    function looksLikeJoin(old, start, end, $newStart, $newEnd) {
      if (!$newStart.parent.isTextblock || end - start <= $newEnd.pos - $newStart.pos || skipClosingAndOpening($newStart, true, false) < $newEnd.pos) {
        return false;
      }
      var $start = old.resolve(start);
      if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock) {
        return false;
      }
      var $next = old.resolve(skipClosingAndOpening($start, true, true));
      if (!$next.parent.isTextblock || $next.pos > end || skipClosingAndOpening($next, true, false) < end) {
        return false;
      }
      return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content);
    }
    function skipClosingAndOpening($pos, fromEnd, mayOpen) {
      var depth = $pos.depth, end = fromEnd ? $pos.end() : $pos.pos;
      while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {
        depth--;
        end++;
        fromEnd = false;
      }
      if (mayOpen) {
        var next = $pos.node(depth).maybeChild($pos.indexAfter(depth));
        while (next && !next.isLeaf) {
          next = next.firstChild;
          end++;
        }
      }
      return end;
    }
    function findDiff(a, b, pos, preferredPos, preferredSide) {
      var start = a.findDiffStart(b, pos);
      if (start == null) {
        return null;
      }
      var ref = a.findDiffEnd(b, pos + a.size, pos + b.size);
      var endA = ref.a;
      var endB = ref.b;
      if (preferredSide == "end") {
        var adjust = Math.max(0, start - Math.min(endA, endB));
        preferredPos -= endA + adjust - start;
      }
      if (endA < start && a.size < b.size) {
        var move = preferredPos <= start && preferredPos >= endA ? start - preferredPos : 0;
        start -= move;
        endB = start + (endB - endA);
        endA = start;
      } else if (endB < start) {
        var move$1 = preferredPos <= start && preferredPos >= endB ? start - preferredPos : 0;
        start -= move$1;
        endA = start + (endA - endB);
        endB = start;
      }
      return { start, endA, endB };
    }
    function serializeForClipboard(view, slice) {
      var context = [];
      var content = slice.content;
      var openStart = slice.openStart;
      var openEnd = slice.openEnd;
      while (openStart > 1 && openEnd > 1 && content.childCount == 1 && content.firstChild.childCount == 1) {
        openStart--;
        openEnd--;
        var node = content.firstChild;
        context.push(node.type.name, node.attrs != node.type.defaultAttrs ? node.attrs : null);
        content = node.content;
      }
      var serializer = view.someProp("clipboardSerializer") || prosemirrorModel.DOMSerializer.fromSchema(view.state.schema);
      var doc = detachedDoc(), wrap = doc.createElement("div");
      wrap.appendChild(serializer.serializeFragment(content, { document: doc }));
      var firstChild = wrap.firstChild, needsWrap;
      while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])) {
        for (var i = needsWrap.length - 1; i >= 0; i--) {
          var wrapper = doc.createElement(needsWrap[i]);
          while (wrap.firstChild) {
            wrapper.appendChild(wrap.firstChild);
          }
          wrap.appendChild(wrapper);
          if (needsWrap[i] != "tbody") {
            openStart++;
            openEnd++;
          }
        }
        firstChild = wrap.firstChild;
      }
      if (firstChild && firstChild.nodeType == 1) {
        firstChild.setAttribute("data-pm-slice", openStart + " " + openEnd + " " + JSON.stringify(context));
      }
      var text = view.someProp("clipboardTextSerializer", function(f) {
        return f(slice);
      }) || slice.content.textBetween(0, slice.content.size, "\n\n");
      return { dom: wrap, text };
    }
    function parseFromClipboard(view, text, html, plainText, $context) {
      var dom, inCode = $context.parent.type.spec.code, slice;
      if (!html && !text) {
        return null;
      }
      var asText = text && (plainText || inCode || !html);
      if (asText) {
        view.someProp("transformPastedText", function(f) {
          text = f(text, inCode || plainText);
        });
        if (inCode) {
          return text ? new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(view.state.schema.text(text.replace(/\r\n?/g, "\n"))), 0, 0) : prosemirrorModel.Slice.empty;
        }
        var parsed = view.someProp("clipboardTextParser", function(f) {
          return f(text, $context, plainText);
        });
        if (parsed) {
          slice = parsed;
        } else {
          var marks = $context.marks();
          var ref = view.state;
          var schema = ref.schema;
          var serializer = prosemirrorModel.DOMSerializer.fromSchema(schema);
          dom = document.createElement("div");
          text.trim().split(/(?:\r\n?|\n)+/).forEach(function(block) {
            var p = dom.appendChild(document.createElement("p"));
            if (block) {
              p.appendChild(serializer.serializeNode(schema.text(block, marks)));
            }
          });
        }
      } else {
        view.someProp("transformPastedHTML", function(f) {
          html = f(html);
        });
        dom = readHTML(html);
        if (result.webkit) {
          restoreReplacedSpaces(dom);
        }
      }
      var contextNode = dom && dom.querySelector("[data-pm-slice]");
      var sliceData = contextNode && /^(\d+) (\d+) (.*)/.exec(contextNode.getAttribute("data-pm-slice"));
      if (!slice) {
        var parser = view.someProp("clipboardParser") || view.someProp("domParser") || prosemirrorModel.DOMParser.fromSchema(view.state.schema);
        slice = parser.parseSlice(dom, { preserveWhitespace: !!(asText || sliceData), context: $context });
      }
      if (sliceData) {
        slice = addContext(closeSlice(slice, +sliceData[1], +sliceData[2]), sliceData[3]);
      } else {
        slice = prosemirrorModel.Slice.maxOpen(normalizeSiblings(slice.content, $context), false);
      }
      view.someProp("transformPasted", function(f) {
        slice = f(slice);
      });
      return slice;
    }
    function normalizeSiblings(fragment, $context) {
      if (fragment.childCount < 2) {
        return fragment;
      }
      var loop = function(d2) {
        var parent = $context.node(d2);
        var match = parent.contentMatchAt($context.index(d2));
        var lastWrap = void 0, result2 = [];
        fragment.forEach(function(node) {
          if (!result2) {
            return;
          }
          var wrap = match.findWrapping(node.type), inLast;
          if (!wrap) {
            return result2 = null;
          }
          if (inLast = result2.length && lastWrap.length && addToSibling(wrap, lastWrap, node, result2[result2.length - 1], 0)) {
            result2[result2.length - 1] = inLast;
          } else {
            if (result2.length) {
              result2[result2.length - 1] = closeRight(result2[result2.length - 1], lastWrap.length);
            }
            var wrapped = withWrappers(node, wrap);
            result2.push(wrapped);
            match = match.matchType(wrapped.type, wrapped.attrs);
            lastWrap = wrap;
          }
        });
        if (result2) {
          return { v: prosemirrorModel.Fragment.from(result2) };
        }
      };
      for (var d = $context.depth; d >= 0; d--) {
        var returned = loop(d);
        if (returned)
          return returned.v;
      }
      return fragment;
    }
    function withWrappers(node, wrap, from) {
      if (from === void 0)
        from = 0;
      for (var i = wrap.length - 1; i >= from; i--) {
        node = wrap[i].create(null, prosemirrorModel.Fragment.from(node));
      }
      return node;
    }
    function addToSibling(wrap, lastWrap, node, sibling, depth) {
      if (depth < wrap.length && depth < lastWrap.length && wrap[depth] == lastWrap[depth]) {
        var inner = addToSibling(wrap, lastWrap, node, sibling.lastChild, depth + 1);
        if (inner) {
          return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner));
        }
        var match = sibling.contentMatchAt(sibling.childCount);
        if (match.matchType(depth == wrap.length - 1 ? node.type : wrap[depth + 1])) {
          return sibling.copy(sibling.content.append(prosemirrorModel.Fragment.from(withWrappers(node, wrap, depth + 1))));
        }
      }
    }
    function closeRight(node, depth) {
      if (depth == 0) {
        return node;
      }
      var fragment = node.content.replaceChild(node.childCount - 1, closeRight(node.lastChild, depth - 1));
      var fill = node.contentMatchAt(node.childCount).fillBefore(prosemirrorModel.Fragment.empty, true);
      return node.copy(fragment.append(fill));
    }
    function closeRange(fragment, side, from, to, depth, openEnd) {
      var node = side < 0 ? fragment.firstChild : fragment.lastChild, inner = node.content;
      if (depth < to - 1) {
        inner = closeRange(inner, side, from, to, depth + 1, openEnd);
      }
      if (depth >= from) {
        inner = side < 0 ? node.contentMatchAt(0).fillBefore(inner, fragment.childCount > 1 || openEnd <= depth).append(inner) : inner.append(node.contentMatchAt(node.childCount).fillBefore(prosemirrorModel.Fragment.empty, true));
      }
      return fragment.replaceChild(side < 0 ? 0 : fragment.childCount - 1, node.copy(inner));
    }
    function closeSlice(slice, openStart, openEnd) {
      if (openStart < slice.openStart) {
        slice = new prosemirrorModel.Slice(closeRange(slice.content, -1, openStart, slice.openStart, 0, slice.openEnd), openStart, slice.openEnd);
      }
      if (openEnd < slice.openEnd) {
        slice = new prosemirrorModel.Slice(closeRange(slice.content, 1, openEnd, slice.openEnd, 0, 0), slice.openStart, openEnd);
      }
      return slice;
    }
    var wrapMap = {
      thead: ["table"],
      tbody: ["table"],
      tfoot: ["table"],
      caption: ["table"],
      colgroup: ["table"],
      col: ["table", "colgroup"],
      tr: ["table", "tbody"],
      td: ["table", "tbody", "tr"],
      th: ["table", "tbody", "tr"]
    };
    var _detachedDoc = null;
    function detachedDoc() {
      return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument("title"));
    }
    function readHTML(html) {
      var metas = /^(\s*<meta [^>]*>)*/.exec(html);
      if (metas) {
        html = html.slice(metas[0].length);
      }
      var elt = detachedDoc().createElement("div");
      var firstTag = /<([a-z][^>\s]+)/i.exec(html), wrap;
      if (wrap = firstTag && wrapMap[firstTag[1].toLowerCase()]) {
        html = wrap.map(function(n) {
          return "<" + n + ">";
        }).join("") + html + wrap.map(function(n) {
          return "</" + n + ">";
        }).reverse().join("");
      }
      elt.innerHTML = html;
      if (wrap) {
        for (var i = 0; i < wrap.length; i++) {
          elt = elt.querySelector(wrap[i]) || elt;
        }
      }
      return elt;
    }
    function restoreReplacedSpaces(dom) {
      var nodes = dom.querySelectorAll(result.chrome ? "span:not([class]):not([style])" : "span.Apple-converted-space");
      for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        if (node.childNodes.length == 1 && node.textContent == "\xA0" && node.parentNode) {
          node.parentNode.replaceChild(dom.ownerDocument.createTextNode(" "), node);
        }
      }
    }
    function addContext(slice, context) {
      if (!slice.size) {
        return slice;
      }
      var schema = slice.content.firstChild.type.schema, array;
      try {
        array = JSON.parse(context);
      } catch (e) {
        return slice;
      }
      var content = slice.content;
      var openStart = slice.openStart;
      var openEnd = slice.openEnd;
      for (var i = array.length - 2; i >= 0; i -= 2) {
        var type = schema.nodes[array[i]];
        if (!type || type.hasRequiredAttrs()) {
          break;
        }
        content = prosemirrorModel.Fragment.from(type.create(array[i + 1], content));
        openStart++;
        openEnd++;
      }
      return new prosemirrorModel.Slice(content, openStart, openEnd);
    }
    var observeOptions = {
      childList: true,
      characterData: true,
      characterDataOldValue: true,
      attributes: true,
      attributeOldValue: true,
      subtree: true
    };
    var useCharData = result.ie && result.ie_version <= 11;
    var SelectionState = function SelectionState2() {
      this.anchorNode = this.anchorOffset = this.focusNode = this.focusOffset = null;
    };
    SelectionState.prototype.set = function set(sel) {
      this.anchorNode = sel.anchorNode;
      this.anchorOffset = sel.anchorOffset;
      this.focusNode = sel.focusNode;
      this.focusOffset = sel.focusOffset;
    };
    SelectionState.prototype.eq = function eq(sel) {
      return sel.anchorNode == this.anchorNode && sel.anchorOffset == this.anchorOffset && sel.focusNode == this.focusNode && sel.focusOffset == this.focusOffset;
    };
    var DOMObserver = function DOMObserver2(view, handleDOMChange) {
      var this$1 = this;
      this.view = view;
      this.handleDOMChange = handleDOMChange;
      this.queue = [];
      this.flushingSoon = -1;
      this.observer = window.MutationObserver && new window.MutationObserver(function(mutations) {
        for (var i = 0; i < mutations.length; i++) {
          this$1.queue.push(mutations[i]);
        }
        if (result.ie && result.ie_version <= 11 && mutations.some(function(m) {
          return m.type == "childList" && m.removedNodes.length || m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length;
        })) {
          this$1.flushSoon();
        } else {
          this$1.flush();
        }
      });
      this.currentSelection = new SelectionState();
      if (useCharData) {
        this.onCharData = function(e) {
          this$1.queue.push({ target: e.target, type: "characterData", oldValue: e.prevValue });
          this$1.flushSoon();
        };
      }
      this.onSelectionChange = this.onSelectionChange.bind(this);
      this.suppressingSelectionUpdates = false;
    };
    DOMObserver.prototype.flushSoon = function flushSoon() {
      var this$1 = this;
      if (this.flushingSoon < 0) {
        this.flushingSoon = window.setTimeout(function() {
          this$1.flushingSoon = -1;
          this$1.flush();
        }, 20);
      }
    };
    DOMObserver.prototype.forceFlush = function forceFlush() {
      if (this.flushingSoon > -1) {
        window.clearTimeout(this.flushingSoon);
        this.flushingSoon = -1;
        this.flush();
      }
    };
    DOMObserver.prototype.start = function start() {
      if (this.observer) {
        this.observer.observe(this.view.dom, observeOptions);
      }
      if (useCharData) {
        this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
      }
      this.connectSelection();
    };
    DOMObserver.prototype.stop = function stop() {
      var this$1 = this;
      if (this.observer) {
        var take = this.observer.takeRecords();
        if (take.length) {
          for (var i = 0; i < take.length; i++) {
            this.queue.push(take[i]);
          }
          window.setTimeout(function() {
            return this$1.flush();
          }, 20);
        }
        this.observer.disconnect();
      }
      if (useCharData) {
        this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
      }
      this.disconnectSelection();
    };
    DOMObserver.prototype.connectSelection = function connectSelection() {
      this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
    };
    DOMObserver.prototype.disconnectSelection = function disconnectSelection() {
      this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
    };
    DOMObserver.prototype.suppressSelectionUpdates = function suppressSelectionUpdates() {
      var this$1 = this;
      this.suppressingSelectionUpdates = true;
      setTimeout(function() {
        return this$1.suppressingSelectionUpdates = false;
      }, 50);
    };
    DOMObserver.prototype.onSelectionChange = function onSelectionChange() {
      if (!hasFocusAndSelection(this.view)) {
        return;
      }
      if (this.suppressingSelectionUpdates) {
        return selectionToDOM(this.view);
      }
      if (result.ie && result.ie_version <= 11 && !this.view.state.selection.empty) {
        var sel = this.view.root.getSelection();
        if (sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset)) {
          return this.flushSoon();
        }
      }
      this.flush();
    };
    DOMObserver.prototype.setCurSelection = function setCurSelection() {
      this.currentSelection.set(this.view.root.getSelection());
    };
    DOMObserver.prototype.ignoreSelectionChange = function ignoreSelectionChange(sel) {
      if (sel.rangeCount == 0) {
        return true;
      }
      var container = sel.getRangeAt(0).commonAncestorContainer;
      var desc = this.view.docView.nearestDesc(container);
      if (desc && desc.ignoreMutation({ type: "selection", target: container.nodeType == 3 ? container.parentNode : container })) {
        this.setCurSelection();
        return true;
      }
    };
    DOMObserver.prototype.flush = function flush() {
      if (!this.view.docView || this.flushingSoon > -1) {
        return;
      }
      var mutations = this.observer ? this.observer.takeRecords() : [];
      if (this.queue.length) {
        mutations = this.queue.concat(mutations);
        this.queue.length = 0;
      }
      var sel = this.view.root.getSelection();
      var newSel = !this.suppressingSelectionUpdates && !this.currentSelection.eq(sel) && hasSelection(this.view) && !this.ignoreSelectionChange(sel);
      var from = -1, to = -1, typeOver = false, added = [];
      if (this.view.editable) {
        for (var i = 0; i < mutations.length; i++) {
          var result$1 = this.registerMutation(mutations[i], added);
          if (result$1) {
            from = from < 0 ? result$1.from : Math.min(result$1.from, from);
            to = to < 0 ? result$1.to : Math.max(result$1.to, to);
            if (result$1.typeOver) {
              typeOver = true;
            }
          }
        }
      }
      if (result.gecko && added.length > 1) {
        var brs = added.filter(function(n) {
          return n.nodeName == "BR";
        });
        if (brs.length == 2) {
          var a = brs[0];
          var b = brs[1];
          if (a.parentNode && a.parentNode.parentNode == b.parentNode) {
            b.remove();
          } else {
            a.remove();
          }
        }
      }
      if (from > -1 || newSel) {
        if (from > -1) {
          this.view.docView.markDirty(from, to);
          checkCSS(this.view);
        }
        this.handleDOMChange(from, to, typeOver, added);
        if (this.view.docView.dirty) {
          this.view.updateState(this.view.state);
        } else if (!this.currentSelection.eq(sel)) {
          selectionToDOM(this.view);
        }
        this.currentSelection.set(sel);
      }
    };
    DOMObserver.prototype.registerMutation = function registerMutation(mut, added) {
      if (added.indexOf(mut.target) > -1) {
        return null;
      }
      var desc = this.view.docView.nearestDesc(mut.target);
      if (mut.type == "attributes" && (desc == this.view.docView || mut.attributeName == "contenteditable" || mut.attributeName == "style" && !mut.oldValue && !mut.target.getAttribute("style"))) {
        return null;
      }
      if (!desc || desc.ignoreMutation(mut)) {
        return null;
      }
      if (mut.type == "childList") {
        for (var i = 0; i < mut.addedNodes.length; i++) {
          added.push(mut.addedNodes[i]);
        }
        if (desc.contentDOM && desc.contentDOM != desc.dom && !desc.contentDOM.contains(mut.target)) {
          return { from: desc.posBefore, to: desc.posAfter };
        }
        var prev = mut.previousSibling, next = mut.nextSibling;
        if (result.ie && result.ie_version <= 11 && mut.addedNodes.length) {
          for (var i$1 = 0; i$1 < mut.addedNodes.length; i$1++) {
            var ref = mut.addedNodes[i$1];
            var previousSibling = ref.previousSibling;
            var nextSibling = ref.nextSibling;
            if (!previousSibling || Array.prototype.indexOf.call(mut.addedNodes, previousSibling) < 0) {
              prev = previousSibling;
            }
            if (!nextSibling || Array.prototype.indexOf.call(mut.addedNodes, nextSibling) < 0) {
              next = nextSibling;
            }
          }
        }
        var fromOffset = prev && prev.parentNode == mut.target ? domIndex(prev) + 1 : 0;
        var from = desc.localPosFromDOM(mut.target, fromOffset, -1);
        var toOffset = next && next.parentNode == mut.target ? domIndex(next) : mut.target.childNodes.length;
        var to = desc.localPosFromDOM(mut.target, toOffset, 1);
        return { from, to };
      } else if (mut.type == "attributes") {
        return { from: desc.posAtStart - desc.border, to: desc.posAtEnd + desc.border };
      } else {
        return {
          from: desc.posAtStart,
          to: desc.posAtEnd,
          typeOver: mut.target.nodeValue == mut.oldValue
        };
      }
    };
    var cssChecked = false;
    function checkCSS(view) {
      if (cssChecked) {
        return;
      }
      cssChecked = true;
      if (getComputedStyle(view.dom).whiteSpace == "normal") {
        console["warn"]("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.");
      }
    }
    var handlers = {};
    var editHandlers = {};
    function initInput(view) {
      view.shiftKey = false;
      view.mouseDown = null;
      view.lastKeyCode = null;
      view.lastKeyCodeTime = 0;
      view.lastClick = { time: 0, x: 0, y: 0, type: "" };
      view.lastSelectionOrigin = null;
      view.lastSelectionTime = 0;
      view.lastIOSEnter = 0;
      view.lastIOSEnterFallbackTimeout = null;
      view.lastAndroidDelete = 0;
      view.composing = false;
      view.composingTimeout = null;
      view.compositionNodes = [];
      view.compositionEndedAt = -2e8;
      view.domObserver = new DOMObserver(view, function(from, to, typeOver, added) {
        return readDOMChange(view, from, to, typeOver, added);
      });
      view.domObserver.start();
      view.domChangeCount = 0;
      view.eventHandlers = Object.create(null);
      var loop = function(event2) {
        var handler2 = handlers[event2];
        view.dom.addEventListener(event2, view.eventHandlers[event2] = function(event3) {
          if (eventBelongsToView(view, event3) && !runCustomHandler(view, event3) && (view.editable || !(event3.type in editHandlers))) {
            handler2(view, event3);
          }
        });
      };
      for (var event in handlers)
        loop(event);
      if (result.safari) {
        view.dom.addEventListener("input", function() {
          return null;
        });
      }
      ensureListeners(view);
    }
    function setSelectionOrigin(view, origin) {
      view.lastSelectionOrigin = origin;
      view.lastSelectionTime = Date.now();
    }
    function destroyInput(view) {
      view.domObserver.stop();
      for (var type in view.eventHandlers) {
        view.dom.removeEventListener(type, view.eventHandlers[type]);
      }
      clearTimeout(view.composingTimeout);
      clearTimeout(view.lastIOSEnterFallbackTimeout);
    }
    function ensureListeners(view) {
      view.someProp("handleDOMEvents", function(currentHandlers) {
        for (var type in currentHandlers) {
          if (!view.eventHandlers[type]) {
            view.dom.addEventListener(type, view.eventHandlers[type] = function(event) {
              return runCustomHandler(view, event);
            });
          }
        }
      });
    }
    function runCustomHandler(view, event) {
      return view.someProp("handleDOMEvents", function(handlers2) {
        var handler2 = handlers2[event.type];
        return handler2 ? handler2(view, event) || event.defaultPrevented : false;
      });
    }
    function eventBelongsToView(view, event) {
      if (!event.bubbles) {
        return true;
      }
      if (event.defaultPrevented) {
        return false;
      }
      for (var node = event.target; node != view.dom; node = node.parentNode) {
        if (!node || node.nodeType == 11 || node.pmViewDesc && node.pmViewDesc.stopEvent(event)) {
          return false;
        }
      }
      return true;
    }
    function dispatchEvent(view, event) {
      if (!runCustomHandler(view, event) && handlers[event.type] && (view.editable || !(event.type in editHandlers))) {
        handlers[event.type](view, event);
      }
    }
    editHandlers.keydown = function(view, event) {
      view.shiftKey = event.keyCode == 16 || event.shiftKey;
      if (inOrNearComposition(view, event)) {
        return;
      }
      if (event.keyCode != 229) {
        view.domObserver.forceFlush();
      }
      view.lastKeyCode = event.keyCode;
      view.lastKeyCodeTime = Date.now();
      if (result.ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {
        var now = Date.now();
        view.lastIOSEnter = now;
        view.lastIOSEnterFallbackTimeout = setTimeout(function() {
          if (view.lastIOSEnter == now) {
            view.someProp("handleKeyDown", function(f) {
              return f(view, keyEvent(13, "Enter"));
            });
            view.lastIOSEnter = 0;
          }
        }, 200);
      } else if (view.someProp("handleKeyDown", function(f) {
        return f(view, event);
      }) || captureKeyDown(view, event)) {
        event.preventDefault();
      } else {
        setSelectionOrigin(view, "key");
      }
    };
    editHandlers.keyup = function(view, e) {
      if (e.keyCode == 16) {
        view.shiftKey = false;
      }
    };
    editHandlers.keypress = function(view, event) {
      if (inOrNearComposition(view, event) || !event.charCode || event.ctrlKey && !event.altKey || result.mac && event.metaKey) {
        return;
      }
      if (view.someProp("handleKeyPress", function(f) {
        return f(view, event);
      })) {
        event.preventDefault();
        return;
      }
      var sel = view.state.selection;
      if (!(sel instanceof prosemirrorState.TextSelection) || !sel.$from.sameParent(sel.$to)) {
        var text = String.fromCharCode(event.charCode);
        if (!view.someProp("handleTextInput", function(f) {
          return f(view, sel.$from.pos, sel.$to.pos, text);
        })) {
          view.dispatch(view.state.tr.insertText(text).scrollIntoView());
        }
        event.preventDefault();
      }
    };
    function eventCoords(event) {
      return { left: event.clientX, top: event.clientY };
    }
    function isNear(event, click) {
      var dx = click.x - event.clientX, dy = click.y - event.clientY;
      return dx * dx + dy * dy < 100;
    }
    function runHandlerOnContext(view, propName, pos, inside, event) {
      if (inside == -1) {
        return false;
      }
      var $pos = view.state.doc.resolve(inside);
      var loop = function(i2) {
        if (view.someProp(propName, function(f) {
          return i2 > $pos.depth ? f(view, pos, $pos.nodeAfter, $pos.before(i2), event, true) : f(view, pos, $pos.node(i2), $pos.before(i2), event, false);
        })) {
          return { v: true };
        }
      };
      for (var i = $pos.depth + 1; i > 0; i--) {
        var returned = loop(i);
        if (returned)
          return returned.v;
      }
      return false;
    }
    function updateSelection(view, selection, origin) {
      if (!view.focused) {
        view.focus();
      }
      var tr = view.state.tr.setSelection(selection);
      if (origin == "pointer") {
        tr.setMeta("pointer", true);
      }
      view.dispatch(tr);
    }
    function selectClickedLeaf(view, inside) {
      if (inside == -1) {
        return false;
      }
      var $pos = view.state.doc.resolve(inside), node = $pos.nodeAfter;
      if (node && node.isAtom && prosemirrorState.NodeSelection.isSelectable(node)) {
        updateSelection(view, new prosemirrorState.NodeSelection($pos), "pointer");
        return true;
      }
      return false;
    }
    function selectClickedNode(view, inside) {
      if (inside == -1) {
        return false;
      }
      var sel = view.state.selection, selectedNode, selectAt;
      if (sel instanceof prosemirrorState.NodeSelection) {
        selectedNode = sel.node;
      }
      var $pos = view.state.doc.resolve(inside);
      for (var i = $pos.depth + 1; i > 0; i--) {
        var node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
        if (prosemirrorState.NodeSelection.isSelectable(node)) {
          if (selectedNode && sel.$from.depth > 0 && i >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos) {
            selectAt = $pos.before(sel.$from.depth);
          } else {
            selectAt = $pos.before(i);
          }
          break;
        }
      }
      if (selectAt != null) {
        updateSelection(view, prosemirrorState.NodeSelection.create(view.state.doc, selectAt), "pointer");
        return true;
      } else {
        return false;
      }
    }
    function handleSingleClick(view, pos, inside, event, selectNode) {
      return runHandlerOnContext(view, "handleClickOn", pos, inside, event) || view.someProp("handleClick", function(f) {
        return f(view, pos, event);
      }) || (selectNode ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside));
    }
    function handleDoubleClick(view, pos, inside, event) {
      return runHandlerOnContext(view, "handleDoubleClickOn", pos, inside, event) || view.someProp("handleDoubleClick", function(f) {
        return f(view, pos, event);
      });
    }
    function handleTripleClick(view, pos, inside, event) {
      return runHandlerOnContext(view, "handleTripleClickOn", pos, inside, event) || view.someProp("handleTripleClick", function(f) {
        return f(view, pos, event);
      }) || defaultTripleClick(view, inside, event);
    }
    function defaultTripleClick(view, inside, event) {
      if (event.button != 0) {
        return false;
      }
      var doc = view.state.doc;
      if (inside == -1) {
        if (doc.inlineContent) {
          updateSelection(view, prosemirrorState.TextSelection.create(doc, 0, doc.content.size), "pointer");
          return true;
        }
        return false;
      }
      var $pos = doc.resolve(inside);
      for (var i = $pos.depth + 1; i > 0; i--) {
        var node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
        var nodePos = $pos.before(i);
        if (node.inlineContent) {
          updateSelection(view, prosemirrorState.TextSelection.create(doc, nodePos + 1, nodePos + 1 + node.content.size), "pointer");
        } else if (prosemirrorState.NodeSelection.isSelectable(node)) {
          updateSelection(view, prosemirrorState.NodeSelection.create(doc, nodePos), "pointer");
        } else {
          continue;
        }
        return true;
      }
    }
    function forceDOMFlush(view) {
      return endComposition(view);
    }
    var selectNodeModifier = result.mac ? "metaKey" : "ctrlKey";
    handlers.mousedown = function(view, event) {
      view.shiftKey = event.shiftKey;
      var flushed = forceDOMFlush(view);
      var now = Date.now(), type = "singleClick";
      if (now - view.lastClick.time < 500 && isNear(event, view.lastClick) && !event[selectNodeModifier]) {
        if (view.lastClick.type == "singleClick") {
          type = "doubleClick";
        } else if (view.lastClick.type == "doubleClick") {
          type = "tripleClick";
        }
      }
      view.lastClick = { time: now, x: event.clientX, y: event.clientY, type };
      var pos = view.posAtCoords(eventCoords(event));
      if (!pos) {
        return;
      }
      if (type == "singleClick") {
        if (view.mouseDown) {
          view.mouseDown.done();
        }
        view.mouseDown = new MouseDown(view, pos, event, flushed);
      } else if ((type == "doubleClick" ? handleDoubleClick : handleTripleClick)(view, pos.pos, pos.inside, event)) {
        event.preventDefault();
      } else {
        setSelectionOrigin(view, "pointer");
      }
    };
    var MouseDown = function MouseDown2(view, pos, event, flushed) {
      var this$1 = this;
      this.view = view;
      this.startDoc = view.state.doc;
      this.pos = pos;
      this.event = event;
      this.flushed = flushed;
      this.selectNode = event[selectNodeModifier];
      this.allowDefault = event.shiftKey;
      this.delayedSelectionSync = false;
      var targetNode, targetPos;
      if (pos.inside > -1) {
        targetNode = view.state.doc.nodeAt(pos.inside);
        targetPos = pos.inside;
      } else {
        var $pos = view.state.doc.resolve(pos.pos);
        targetNode = $pos.parent;
        targetPos = $pos.depth ? $pos.before() : 0;
      }
      this.mightDrag = null;
      var target = flushed ? null : event.target;
      var targetDesc = target ? view.docView.nearestDesc(target, true) : null;
      this.target = targetDesc ? targetDesc.dom : null;
      var ref = view.state;
      var selection = ref.selection;
      if (event.button == 0 && targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false || selection instanceof prosemirrorState.NodeSelection && selection.from <= targetPos && selection.to > targetPos) {
        this.mightDrag = {
          node: targetNode,
          pos: targetPos,
          addAttr: this.target && !this.target.draggable,
          setUneditable: this.target && result.gecko && !this.target.hasAttribute("contentEditable")
        };
      }
      if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {
        this.view.domObserver.stop();
        if (this.mightDrag.addAttr) {
          this.target.draggable = true;
        }
        if (this.mightDrag.setUneditable) {
          setTimeout(function() {
            if (this$1.view.mouseDown == this$1) {
              this$1.target.setAttribute("contentEditable", "false");
            }
          }, 20);
        }
        this.view.domObserver.start();
      }
      view.root.addEventListener("mouseup", this.up = this.up.bind(this));
      view.root.addEventListener("mousemove", this.move = this.move.bind(this));
      setSelectionOrigin(view, "pointer");
    };
    MouseDown.prototype.done = function done() {
      var this$1 = this;
      this.view.root.removeEventListener("mouseup", this.up);
      this.view.root.removeEventListener("mousemove", this.move);
      if (this.mightDrag && this.target) {
        this.view.domObserver.stop();
        if (this.mightDrag.addAttr) {
          this.target.removeAttribute("draggable");
        }
        if (this.mightDrag.setUneditable) {
          this.target.removeAttribute("contentEditable");
        }
        this.view.domObserver.start();
      }
      if (this.delayedSelectionSync) {
        setTimeout(function() {
          return selectionToDOM(this$1.view);
        });
      }
      this.view.mouseDown = null;
    };
    MouseDown.prototype.up = function up(event) {
      this.done();
      if (!this.view.dom.contains(event.target.nodeType == 3 ? event.target.parentNode : event.target)) {
        return;
      }
      var pos = this.pos;
      if (this.view.state.doc != this.startDoc) {
        pos = this.view.posAtCoords(eventCoords(event));
      }
      if (this.allowDefault || !pos) {
        setSelectionOrigin(this.view, "pointer");
      } else if (handleSingleClick(this.view, pos.pos, pos.inside, event, this.selectNode)) {
        event.preventDefault();
      } else if (event.button == 0 && (this.flushed || result.safari && this.mightDrag && !this.mightDrag.node.isAtom || result.chrome && !(this.view.state.selection instanceof prosemirrorState.TextSelection) && Math.min(Math.abs(pos.pos - this.view.state.selection.from), Math.abs(pos.pos - this.view.state.selection.to)) <= 2)) {
        updateSelection(this.view, prosemirrorState.Selection.near(this.view.state.doc.resolve(pos.pos)), "pointer");
        event.preventDefault();
      } else {
        setSelectionOrigin(this.view, "pointer");
      }
    };
    MouseDown.prototype.move = function move(event) {
      if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 || Math.abs(this.event.y - event.clientY) > 4)) {
        this.allowDefault = true;
      }
      setSelectionOrigin(this.view, "pointer");
      if (event.buttons == 0) {
        this.done();
      }
    };
    handlers.touchdown = function(view) {
      forceDOMFlush(view);
      setSelectionOrigin(view, "pointer");
    };
    handlers.contextmenu = function(view) {
      return forceDOMFlush(view);
    };
    function inOrNearComposition(view, event) {
      if (view.composing) {
        return true;
      }
      if (result.safari && Math.abs(event.timeStamp - view.compositionEndedAt) < 500) {
        view.compositionEndedAt = -2e8;
        return true;
      }
      return false;
    }
    var timeoutComposition = result.android ? 5e3 : -1;
    editHandlers.compositionstart = editHandlers.compositionupdate = function(view) {
      if (!view.composing) {
        view.domObserver.flush();
        var state = view.state;
        var $pos = state.selection.$from;
        if (state.selection.empty && (state.storedMarks || !$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some(function(m) {
          return m.type.spec.inclusive === false;
        }))) {
          view.markCursor = view.state.storedMarks || $pos.marks();
          endComposition(view, true);
          view.markCursor = null;
        } else {
          endComposition(view);
          if (result.gecko && state.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {
            var sel = view.root.getSelection();
            for (var node = sel.focusNode, offset = sel.focusOffset; node && node.nodeType == 1 && offset != 0; ) {
              var before = offset < 0 ? node.lastChild : node.childNodes[offset - 1];
              if (!before) {
                break;
              }
              if (before.nodeType == 3) {
                sel.collapse(before, before.nodeValue.length);
                break;
              } else {
                node = before;
                offset = -1;
              }
            }
          }
        }
        view.composing = true;
      }
      scheduleComposeEnd(view, timeoutComposition);
    };
    editHandlers.compositionend = function(view, event) {
      if (view.composing) {
        view.composing = false;
        view.compositionEndedAt = event.timeStamp;
        scheduleComposeEnd(view, 20);
      }
    };
    function scheduleComposeEnd(view, delay) {
      clearTimeout(view.composingTimeout);
      if (delay > -1) {
        view.composingTimeout = setTimeout(function() {
          return endComposition(view);
        }, delay);
      }
    }
    function clearComposition(view) {
      if (view.composing) {
        view.composing = false;
        view.compositionEndedAt = timestampFromCustomEvent();
      }
      while (view.compositionNodes.length > 0) {
        view.compositionNodes.pop().markParentsDirty();
      }
    }
    function timestampFromCustomEvent() {
      var event = document.createEvent("Event");
      event.initEvent("event", true, true);
      return event.timeStamp;
    }
    function endComposition(view, forceUpdate) {
      view.domObserver.forceFlush();
      clearComposition(view);
      if (forceUpdate || view.docView.dirty) {
        var sel = selectionFromDOM(view);
        if (sel && !sel.eq(view.state.selection)) {
          view.dispatch(view.state.tr.setSelection(sel));
        } else {
          view.updateState(view.state);
        }
        return true;
      }
      return false;
    }
    function captureCopy(view, dom) {
      if (!view.dom.parentNode) {
        return;
      }
      var wrap = view.dom.parentNode.appendChild(document.createElement("div"));
      wrap.appendChild(dom);
      wrap.style.cssText = "position: fixed; left: -10000px; top: 10px";
      var sel = getSelection(), range = document.createRange();
      range.selectNodeContents(dom);
      view.dom.blur();
      sel.removeAllRanges();
      sel.addRange(range);
      setTimeout(function() {
        if (wrap.parentNode) {
          wrap.parentNode.removeChild(wrap);
        }
        view.focus();
      }, 50);
    }
    var brokenClipboardAPI = result.ie && result.ie_version < 15 || result.ios && result.webkit_version < 604;
    handlers.copy = editHandlers.cut = function(view, e) {
      var sel = view.state.selection, cut = e.type == "cut";
      if (sel.empty) {
        return;
      }
      var data = brokenClipboardAPI ? null : e.clipboardData;
      var slice = sel.content();
      var ref = serializeForClipboard(view, slice);
      var dom = ref.dom;
      var text = ref.text;
      if (data) {
        e.preventDefault();
        data.clearData();
        data.setData("text/html", dom.innerHTML);
        data.setData("text/plain", text);
      } else {
        captureCopy(view, dom);
      }
      if (cut) {
        view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
      }
    };
    function sliceSingleNode(slice) {
      return slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1 ? slice.content.firstChild : null;
    }
    function capturePaste(view, e) {
      if (!view.dom.parentNode) {
        return;
      }
      var plainText = view.shiftKey || view.state.selection.$from.parent.type.spec.code;
      var target = view.dom.parentNode.appendChild(document.createElement(plainText ? "textarea" : "div"));
      if (!plainText) {
        target.contentEditable = "true";
      }
      target.style.cssText = "position: fixed; left: -10000px; top: 10px";
      target.focus();
      setTimeout(function() {
        view.focus();
        if (target.parentNode) {
          target.parentNode.removeChild(target);
        }
        if (plainText) {
          doPaste(view, target.value, null, e);
        } else {
          doPaste(view, target.textContent, target.innerHTML, e);
        }
      }, 50);
    }
    function doPaste(view, text, html, e) {
      var slice = parseFromClipboard(view, text, html, view.shiftKey, view.state.selection.$from);
      if (view.someProp("handlePaste", function(f) {
        return f(view, e, slice || prosemirrorModel.Slice.empty);
      })) {
        return true;
      }
      if (!slice) {
        return false;
      }
      var singleNode = sliceSingleNode(slice);
      var tr = singleNode ? view.state.tr.replaceSelectionWith(singleNode, view.shiftKey) : view.state.tr.replaceSelection(slice);
      view.dispatch(tr.scrollIntoView().setMeta("paste", true).setMeta("uiEvent", "paste"));
      return true;
    }
    editHandlers.paste = function(view, e) {
      var data = brokenClipboardAPI ? null : e.clipboardData;
      if (data && doPaste(view, data.getData("text/plain"), data.getData("text/html"), e)) {
        e.preventDefault();
      } else {
        capturePaste(view, e);
      }
    };
    var Dragging = function Dragging2(slice, move) {
      this.slice = slice;
      this.move = move;
    };
    var dragCopyModifier = result.mac ? "altKey" : "ctrlKey";
    handlers.dragstart = function(view, e) {
      var mouseDown = view.mouseDown;
      if (mouseDown) {
        mouseDown.done();
      }
      if (!e.dataTransfer) {
        return;
      }
      var sel = view.state.selection;
      var pos = sel.empty ? null : view.posAtCoords(eventCoords(e));
      if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof prosemirrorState.NodeSelection ? sel.to - 1 : sel.to))
        ;
      else if (mouseDown && mouseDown.mightDrag) {
        view.dispatch(view.state.tr.setSelection(prosemirrorState.NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos)));
      } else if (e.target && e.target.nodeType == 1) {
        var desc = view.docView.nearestDesc(e.target, true);
        if (desc && desc.node.type.spec.draggable && desc != view.docView) {
          view.dispatch(view.state.tr.setSelection(prosemirrorState.NodeSelection.create(view.state.doc, desc.posBefore)));
        }
      }
      var slice = view.state.selection.content();
      var ref = serializeForClipboard(view, slice);
      var dom = ref.dom;
      var text = ref.text;
      e.dataTransfer.clearData();
      e.dataTransfer.setData(brokenClipboardAPI ? "Text" : "text/html", dom.innerHTML);
      e.dataTransfer.effectAllowed = "copyMove";
      if (!brokenClipboardAPI) {
        e.dataTransfer.setData("text/plain", text);
      }
      view.dragging = new Dragging(slice, !e[dragCopyModifier]);
    };
    handlers.dragend = function(view) {
      var dragging = view.dragging;
      window.setTimeout(function() {
        if (view.dragging == dragging) {
          view.dragging = null;
        }
      }, 50);
    };
    editHandlers.dragover = editHandlers.dragenter = function(_, e) {
      return e.preventDefault();
    };
    editHandlers.drop = function(view, e) {
      var dragging = view.dragging;
      view.dragging = null;
      if (!e.dataTransfer) {
        return;
      }
      var eventPos = view.posAtCoords(eventCoords(e));
      if (!eventPos) {
        return;
      }
      var $mouse = view.state.doc.resolve(eventPos.pos);
      if (!$mouse) {
        return;
      }
      var slice = dragging && dragging.slice;
      if (slice) {
        view.someProp("transformPasted", function(f) {
          slice = f(slice);
        });
      } else {
        slice = parseFromClipboard(view, e.dataTransfer.getData(brokenClipboardAPI ? "Text" : "text/plain"), brokenClipboardAPI ? null : e.dataTransfer.getData("text/html"), false, $mouse);
      }
      var move = dragging && !e[dragCopyModifier];
      if (view.someProp("handleDrop", function(f) {
        return f(view, e, slice || prosemirrorModel.Slice.empty, move);
      })) {
        e.preventDefault();
        return;
      }
      if (!slice) {
        return;
      }
      e.preventDefault();
      var insertPos = slice ? prosemirrorTransform.dropPoint(view.state.doc, $mouse.pos, slice) : $mouse.pos;
      if (insertPos == null) {
        insertPos = $mouse.pos;
      }
      var tr = view.state.tr;
      if (move) {
        tr.deleteSelection();
      }
      var pos = tr.mapping.map(insertPos);
      var isNode = slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1;
      var beforeInsert = tr.doc;
      if (isNode) {
        tr.replaceRangeWith(pos, pos, slice.content.firstChild);
      } else {
        tr.replaceRange(pos, pos, slice);
      }
      if (tr.doc.eq(beforeInsert)) {
        return;
      }
      var $pos = tr.doc.resolve(pos);
      if (isNode && prosemirrorState.NodeSelection.isSelectable(slice.content.firstChild) && $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice.content.firstChild)) {
        tr.setSelection(new prosemirrorState.NodeSelection($pos));
      } else {
        var end = tr.mapping.map(insertPos);
        tr.mapping.maps[tr.mapping.maps.length - 1].forEach(function(_from, _to, _newFrom, newTo) {
          return end = newTo;
        });
        tr.setSelection(selectionBetween(view, $pos, tr.doc.resolve(end)));
      }
      view.focus();
      view.dispatch(tr.setMeta("uiEvent", "drop"));
    };
    handlers.focus = function(view) {
      if (!view.focused) {
        view.domObserver.stop();
        view.dom.classList.add("ProseMirror-focused");
        view.domObserver.start();
        view.focused = true;
        setTimeout(function() {
          if (view.docView && view.hasFocus() && !view.domObserver.currentSelection.eq(view.root.getSelection())) {
            selectionToDOM(view);
          }
        }, 20);
      }
    };
    handlers.blur = function(view, e) {
      if (view.focused) {
        view.domObserver.stop();
        view.dom.classList.remove("ProseMirror-focused");
        view.domObserver.start();
        if (e.relatedTarget && view.dom.contains(e.relatedTarget)) {
          view.domObserver.currentSelection.set({});
        }
        view.focused = false;
      }
    };
    handlers.beforeinput = function(view, event) {
      if (result.chrome && result.android && event.inputType == "deleteContentBackward") {
        var domChangeCount = view.domChangeCount;
        setTimeout(function() {
          if (view.domChangeCount != domChangeCount) {
            return;
          }
          view.dom.blur();
          view.focus();
          if (view.someProp("handleKeyDown", function(f) {
            return f(view, keyEvent(8, "Backspace"));
          })) {
            return;
          }
          var ref = view.state.selection;
          var $cursor = ref.$cursor;
          if ($cursor && $cursor.pos > 0) {
            view.dispatch(view.state.tr.delete($cursor.pos - 1, $cursor.pos).scrollIntoView());
          }
        }, 50);
      }
    };
    for (prop in editHandlers) {
      handlers[prop] = editHandlers[prop];
    }
    var prop;
    function compareObjs(a, b) {
      if (a == b) {
        return true;
      }
      for (var p in a) {
        if (a[p] !== b[p]) {
          return false;
        }
      }
      for (var p$1 in b) {
        if (!(p$1 in a)) {
          return false;
        }
      }
      return true;
    }
    var WidgetType = function WidgetType2(toDOM, spec) {
      this.spec = spec || noSpec;
      this.side = this.spec.side || 0;
      this.toDOM = toDOM;
    };
    WidgetType.prototype.map = function map2(mapping, span, offset, oldOffset) {
      var ref = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1);
      var pos = ref.pos;
      var deleted = ref.deleted;
      return deleted ? null : new Decoration(pos - offset, pos - offset, this);
    };
    WidgetType.prototype.valid = function valid() {
      return true;
    };
    WidgetType.prototype.eq = function eq(other) {
      return this == other || other instanceof WidgetType && (this.spec.key && this.spec.key == other.spec.key || this.toDOM == other.toDOM && compareObjs(this.spec, other.spec));
    };
    var InlineType = function InlineType2(attrs, spec) {
      this.spec = spec || noSpec;
      this.attrs = attrs;
    };
    InlineType.prototype.map = function map2(mapping, span, offset, oldOffset) {
      var from = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset;
      var to = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset;
      return from >= to ? null : new Decoration(from, to, this);
    };
    InlineType.prototype.valid = function valid(_, span) {
      return span.from < span.to;
    };
    InlineType.prototype.eq = function eq(other) {
      return this == other || other instanceof InlineType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
    };
    InlineType.is = function is(span) {
      return span.type instanceof InlineType;
    };
    var NodeType = function NodeType2(attrs, spec) {
      this.spec = spec || noSpec;
      this.attrs = attrs;
    };
    NodeType.prototype.map = function map2(mapping, span, offset, oldOffset) {
      var from = mapping.mapResult(span.from + oldOffset, 1);
      if (from.deleted) {
        return null;
      }
      var to = mapping.mapResult(span.to + oldOffset, -1);
      if (to.deleted || to.pos <= from.pos) {
        return null;
      }
      return new Decoration(from.pos - offset, to.pos - offset, this);
    };
    NodeType.prototype.valid = function valid(node, span) {
      var ref = node.content.findIndex(span.from);
      var index2 = ref.index;
      var offset = ref.offset;
      var child;
      return offset == span.from && !(child = node.child(index2)).isText && offset + child.nodeSize == span.to;
    };
    NodeType.prototype.eq = function eq(other) {
      return this == other || other instanceof NodeType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
    };
    var Decoration = function Decoration2(from, to, type) {
      this.from = from;
      this.to = to;
      this.type = type;
    };
    var prototypeAccessors$1 = { spec: { configurable: true }, inline: { configurable: true } };
    Decoration.prototype.copy = function copy2(from, to) {
      return new Decoration(from, to, this.type);
    };
    Decoration.prototype.eq = function eq(other, offset) {
      if (offset === void 0)
        offset = 0;
      return this.type.eq(other.type) && this.from + offset == other.from && this.to + offset == other.to;
    };
    Decoration.prototype.map = function map2(mapping, offset, oldOffset) {
      return this.type.map(mapping, this, offset, oldOffset);
    };
    Decoration.widget = function widget(pos, toDOM, spec) {
      return new Decoration(pos, pos, new WidgetType(toDOM, spec));
    };
    Decoration.inline = function inline(from, to, attrs, spec) {
      return new Decoration(from, to, new InlineType(attrs, spec));
    };
    Decoration.node = function node(from, to, attrs, spec) {
      return new Decoration(from, to, new NodeType(attrs, spec));
    };
    prototypeAccessors$1.spec.get = function() {
      return this.type.spec;
    };
    prototypeAccessors$1.inline.get = function() {
      return this.type instanceof InlineType;
    };
    Object.defineProperties(Decoration.prototype, prototypeAccessors$1);
    var none = [];
    var noSpec = {};
    var DecorationSet = function DecorationSet2(local, children) {
      this.local = local && local.length ? local : none;
      this.children = children && children.length ? children : none;
    };
    DecorationSet.create = function create(doc, decorations) {
      return decorations.length ? buildTree(decorations, doc, 0, noSpec) : empty2;
    };
    DecorationSet.prototype.find = function find(start, end, predicate) {
      var result2 = [];
      this.findInner(start == null ? 0 : start, end == null ? 1e9 : end, result2, 0, predicate);
      return result2;
    };
    DecorationSet.prototype.findInner = function findInner(start, end, result2, offset, predicate) {
      for (var i = 0; i < this.local.length; i++) {
        var span = this.local[i];
        if (span.from <= end && span.to >= start && (!predicate || predicate(span.spec))) {
          result2.push(span.copy(span.from + offset, span.to + offset));
        }
      }
      for (var i$1 = 0; i$1 < this.children.length; i$1 += 3) {
        if (this.children[i$1] < end && this.children[i$1 + 1] > start) {
          var childOff = this.children[i$1] + 1;
          this.children[i$1 + 2].findInner(start - childOff, end - childOff, result2, offset + childOff, predicate);
        }
      }
    };
    DecorationSet.prototype.map = function map2(mapping, doc, options2) {
      if (this == empty2 || mapping.maps.length == 0) {
        return this;
      }
      return this.mapInner(mapping, doc, 0, 0, options2 || noSpec);
    };
    DecorationSet.prototype.mapInner = function mapInner(mapping, node, offset, oldOffset, options2) {
      var newLocal;
      for (var i = 0; i < this.local.length; i++) {
        var mapped = this.local[i].map(mapping, offset, oldOffset);
        if (mapped && mapped.type.valid(node, mapped)) {
          (newLocal || (newLocal = [])).push(mapped);
        } else if (options2.onRemove) {
          options2.onRemove(this.local[i].spec);
        }
      }
      if (this.children.length) {
        return mapChildren(this.children, newLocal, mapping, node, offset, oldOffset, options2);
      } else {
        return newLocal ? new DecorationSet(newLocal.sort(byPos)) : empty2;
      }
    };
    DecorationSet.prototype.add = function add(doc, decorations) {
      if (!decorations.length) {
        return this;
      }
      if (this == empty2) {
        return DecorationSet.create(doc, decorations);
      }
      return this.addInner(doc, decorations, 0);
    };
    DecorationSet.prototype.addInner = function addInner(doc, decorations, offset) {
      var this$1 = this;
      var children, childIndex = 0;
      doc.forEach(function(childNode, childOffset) {
        var baseOffset = childOffset + offset, found;
        if (!(found = takeSpansForNode(decorations, childNode, baseOffset))) {
          return;
        }
        if (!children) {
          children = this$1.children.slice();
        }
        while (childIndex < children.length && children[childIndex] < childOffset) {
          childIndex += 3;
        }
        if (children[childIndex] == childOffset) {
          children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found, baseOffset + 1);
        } else {
          children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found, childNode, baseOffset + 1, noSpec));
        }
        childIndex += 3;
      });
      var local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset);
      for (var i = 0; i < local.length; i++) {
        if (!local[i].type.valid(doc, local[i])) {
          local.splice(i--, 1);
        }
      }
      return new DecorationSet(local.length ? this.local.concat(local).sort(byPos) : this.local, children || this.children);
    };
    DecorationSet.prototype.remove = function remove(decorations) {
      if (decorations.length == 0 || this == empty2) {
        return this;
      }
      return this.removeInner(decorations, 0);
    };
    DecorationSet.prototype.removeInner = function removeInner(decorations, offset) {
      var children = this.children, local = this.local;
      for (var i = 0; i < children.length; i += 3) {
        var found = void 0, from = children[i] + offset, to = children[i + 1] + offset;
        for (var j = 0, span = void 0; j < decorations.length; j++) {
          if (span = decorations[j]) {
            if (span.from > from && span.to < to) {
              decorations[j] = null;
              (found || (found = [])).push(span);
            }
          }
        }
        if (!found) {
          continue;
        }
        if (children == this.children) {
          children = this.children.slice();
        }
        var removed = children[i + 2].removeInner(found, from + 1);
        if (removed != empty2) {
          children[i + 2] = removed;
        } else {
          children.splice(i, 3);
          i -= 3;
        }
      }
      if (local.length) {
        for (var i$1 = 0, span$1 = void 0; i$1 < decorations.length; i$1++) {
          if (span$1 = decorations[i$1]) {
            for (var j$1 = 0; j$1 < local.length; j$1++) {
              if (local[j$1].eq(span$1, offset)) {
                if (local == this.local) {
                  local = this.local.slice();
                }
                local.splice(j$1--, 1);
              }
            }
          }
        }
      }
      if (children == this.children && local == this.local) {
        return this;
      }
      return local.length || children.length ? new DecorationSet(local, children) : empty2;
    };
    DecorationSet.prototype.forChild = function forChild(offset, node) {
      if (this == empty2) {
        return this;
      }
      if (node.isLeaf) {
        return DecorationSet.empty;
      }
      var child, local;
      for (var i = 0; i < this.children.length; i += 3) {
        if (this.children[i] >= offset) {
          if (this.children[i] == offset) {
            child = this.children[i + 2];
          }
          break;
        }
      }
      var start = offset + 1, end = start + node.content.size;
      for (var i$1 = 0; i$1 < this.local.length; i$1++) {
        var dec = this.local[i$1];
        if (dec.from < end && dec.to > start && dec.type instanceof InlineType) {
          var from = Math.max(start, dec.from) - start, to = Math.min(end, dec.to) - start;
          if (from < to) {
            (local || (local = [])).push(dec.copy(from, to));
          }
        }
      }
      if (local) {
        var localSet = new DecorationSet(local.sort(byPos));
        return child ? new DecorationGroup([localSet, child]) : localSet;
      }
      return child || empty2;
    };
    DecorationSet.prototype.eq = function eq(other) {
      if (this == other) {
        return true;
      }
      if (!(other instanceof DecorationSet) || this.local.length != other.local.length || this.children.length != other.children.length) {
        return false;
      }
      for (var i = 0; i < this.local.length; i++) {
        if (!this.local[i].eq(other.local[i])) {
          return false;
        }
      }
      for (var i$1 = 0; i$1 < this.children.length; i$1 += 3) {
        if (this.children[i$1] != other.children[i$1] || this.children[i$1 + 1] != other.children[i$1 + 1] || !this.children[i$1 + 2].eq(other.children[i$1 + 2])) {
          return false;
        }
      }
      return true;
    };
    DecorationSet.prototype.locals = function locals(node) {
      return removeOverlap(this.localsInner(node));
    };
    DecorationSet.prototype.localsInner = function localsInner(node) {
      if (this == empty2) {
        return none;
      }
      if (node.inlineContent || !this.local.some(InlineType.is)) {
        return this.local;
      }
      var result2 = [];
      for (var i = 0; i < this.local.length; i++) {
        if (!(this.local[i].type instanceof InlineType)) {
          result2.push(this.local[i]);
        }
      }
      return result2;
    };
    var empty2 = new DecorationSet();
    DecorationSet.empty = empty2;
    DecorationSet.removeOverlap = removeOverlap;
    var DecorationGroup = function DecorationGroup2(members) {
      this.members = members;
    };
    DecorationGroup.prototype.map = function map2(mapping, doc) {
      var mappedDecos = this.members.map(function(member) {
        return member.map(mapping, doc, noSpec);
      });
      return DecorationGroup.from(mappedDecos);
    };
    DecorationGroup.prototype.forChild = function forChild(offset, child) {
      if (child.isLeaf) {
        return DecorationSet.empty;
      }
      var found = [];
      for (var i = 0; i < this.members.length; i++) {
        var result2 = this.members[i].forChild(offset, child);
        if (result2 == empty2) {
          continue;
        }
        if (result2 instanceof DecorationGroup) {
          found = found.concat(result2.members);
        } else {
          found.push(result2);
        }
      }
      return DecorationGroup.from(found);
    };
    DecorationGroup.prototype.eq = function eq(other) {
      if (!(other instanceof DecorationGroup) || other.members.length != this.members.length) {
        return false;
      }
      for (var i = 0; i < this.members.length; i++) {
        if (!this.members[i].eq(other.members[i])) {
          return false;
        }
      }
      return true;
    };
    DecorationGroup.prototype.locals = function locals(node) {
      var result2, sorted = true;
      for (var i = 0; i < this.members.length; i++) {
        var locals2 = this.members[i].localsInner(node);
        if (!locals2.length) {
          continue;
        }
        if (!result2) {
          result2 = locals2;
        } else {
          if (sorted) {
            result2 = result2.slice();
            sorted = false;
          }
          for (var j = 0; j < locals2.length; j++) {
            result2.push(locals2[j]);
          }
        }
      }
      return result2 ? removeOverlap(sorted ? result2 : result2.sort(byPos)) : none;
    };
    DecorationGroup.from = function from(members) {
      switch (members.length) {
        case 0:
          return empty2;
        case 1:
          return members[0];
        default:
          return new DecorationGroup(members);
      }
    };
    function mapChildren(oldChildren, newLocal, mapping, node, offset, oldOffset, options2) {
      var children = oldChildren.slice();
      var shift = function(oldStart, oldEnd, newStart, newEnd) {
        for (var i2 = 0; i2 < children.length; i2 += 3) {
          var end = children[i2 + 1], dSize = void 0;
          if (end == -1 || oldStart > end + oldOffset) {
            continue;
          }
          if (oldEnd >= children[i2] + oldOffset) {
            children[i2 + 1] = -1;
          } else if (newStart >= offset && (dSize = newEnd - newStart - (oldEnd - oldStart))) {
            children[i2] += dSize;
            children[i2 + 1] += dSize;
          }
        }
      };
      for (var i = 0; i < mapping.maps.length; i++) {
        mapping.maps[i].forEach(shift);
      }
      var mustRebuild = false;
      for (var i$1 = 0; i$1 < children.length; i$1 += 3) {
        if (children[i$1 + 1] == -1) {
          var from = mapping.map(oldChildren[i$1] + oldOffset), fromLocal = from - offset;
          if (fromLocal < 0 || fromLocal >= node.content.size) {
            mustRebuild = true;
            continue;
          }
          var to = mapping.map(oldChildren[i$1 + 1] + oldOffset, -1), toLocal = to - offset;
          var ref = node.content.findIndex(fromLocal);
          var index2 = ref.index;
          var childOffset = ref.offset;
          var childNode = node.maybeChild(index2);
          if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {
            var mapped = children[i$1 + 2].mapInner(mapping, childNode, from + 1, oldChildren[i$1] + oldOffset + 1, options2);
            if (mapped != empty2) {
              children[i$1] = fromLocal;
              children[i$1 + 1] = toLocal;
              children[i$1 + 2] = mapped;
            } else {
              children[i$1 + 1] = -2;
              mustRebuild = true;
            }
          } else {
            mustRebuild = true;
          }
        }
      }
      if (mustRebuild) {
        var decorations = mapAndGatherRemainingDecorations(children, oldChildren, newLocal || [], mapping, offset, oldOffset, options2);
        var built = buildTree(decorations, node, 0, options2);
        newLocal = built.local;
        for (var i$2 = 0; i$2 < children.length; i$2 += 3) {
          if (children[i$2 + 1] < 0) {
            children.splice(i$2, 3);
            i$2 -= 3;
          }
        }
        for (var i$3 = 0, j = 0; i$3 < built.children.length; i$3 += 3) {
          var from$1 = built.children[i$3];
          while (j < children.length && children[j] < from$1) {
            j += 3;
          }
          children.splice(j, 0, built.children[i$3], built.children[i$3 + 1], built.children[i$3 + 2]);
        }
      }
      return new DecorationSet(newLocal && newLocal.sort(byPos), children);
    }
    function moveSpans(spans, offset) {
      if (!offset || !spans.length) {
        return spans;
      }
      var result2 = [];
      for (var i = 0; i < spans.length; i++) {
        var span = spans[i];
        result2.push(new Decoration(span.from + offset, span.to + offset, span.type));
      }
      return result2;
    }
    function mapAndGatherRemainingDecorations(children, oldChildren, decorations, mapping, offset, oldOffset, options2) {
      function gather(set, oldOffset2) {
        for (var i2 = 0; i2 < set.local.length; i2++) {
          var mapped = set.local[i2].map(mapping, offset, oldOffset2);
          if (mapped) {
            decorations.push(mapped);
          } else if (options2.onRemove) {
            options2.onRemove(set.local[i2].spec);
          }
        }
        for (var i$1 = 0; i$1 < set.children.length; i$1 += 3) {
          gather(set.children[i$1 + 2], set.children[i$1] + oldOffset2 + 1);
        }
      }
      for (var i = 0; i < children.length; i += 3) {
        if (children[i + 1] == -1) {
          gather(children[i + 2], oldChildren[i] + oldOffset + 1);
        }
      }
      return decorations;
    }
    function takeSpansForNode(spans, node, offset) {
      if (node.isLeaf) {
        return null;
      }
      var end = offset + node.nodeSize, found = null;
      for (var i = 0, span = void 0; i < spans.length; i++) {
        if ((span = spans[i]) && span.from > offset && span.to < end) {
          (found || (found = [])).push(span);
          spans[i] = null;
        }
      }
      return found;
    }
    function withoutNulls(array) {
      var result2 = [];
      for (var i = 0; i < array.length; i++) {
        if (array[i] != null) {
          result2.push(array[i]);
        }
      }
      return result2;
    }
    function buildTree(spans, node, offset, options2) {
      var children = [], hasNulls = false;
      node.forEach(function(childNode, localStart) {
        var found = takeSpansForNode(spans, childNode, localStart + offset);
        if (found) {
          hasNulls = true;
          var subtree = buildTree(found, childNode, offset + localStart + 1, options2);
          if (subtree != empty2) {
            children.push(localStart, localStart + childNode.nodeSize, subtree);
          }
        }
      });
      var locals = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset).sort(byPos);
      for (var i = 0; i < locals.length; i++) {
        if (!locals[i].type.valid(node, locals[i])) {
          if (options2.onRemove) {
            options2.onRemove(locals[i].spec);
          }
          locals.splice(i--, 1);
        }
      }
      return locals.length || children.length ? new DecorationSet(locals, children) : empty2;
    }
    function byPos(a, b) {
      return a.from - b.from || a.to - b.to;
    }
    function removeOverlap(spans) {
      var working = spans;
      for (var i = 0; i < working.length - 1; i++) {
        var span = working[i];
        if (span.from != span.to) {
          for (var j = i + 1; j < working.length; j++) {
            var next = working[j];
            if (next.from == span.from) {
              if (next.to != span.to) {
                if (working == spans) {
                  working = spans.slice();
                }
                working[j] = next.copy(next.from, span.to);
                insertAhead(working, j + 1, next.copy(span.to, next.to));
              }
              continue;
            } else {
              if (next.from < span.to) {
                if (working == spans) {
                  working = spans.slice();
                }
                working[i] = span.copy(span.from, next.from);
                insertAhead(working, j, span.copy(next.from, span.to));
              }
              break;
            }
          }
        }
      }
      return working;
    }
    function insertAhead(array, i, deco) {
      while (i < array.length && byPos(deco, array[i]) > 0) {
        i++;
      }
      array.splice(i, 0, deco);
    }
    function viewDecorations(view) {
      var found = [];
      view.someProp("decorations", function(f) {
        var result2 = f(view.state);
        if (result2 && result2 != empty2) {
          found.push(result2);
        }
      });
      if (view.cursorWrapper) {
        found.push(DecorationSet.create(view.state.doc, [view.cursorWrapper.deco]));
      }
      return DecorationGroup.from(found);
    }
    var EditorView = function EditorView2(place, props) {
      this._props = props;
      this.state = props.state;
      this.directPlugins = props.plugins || [];
      this.directPlugins.forEach(checkStateComponent);
      this.dispatch = this.dispatch.bind(this);
      this._root = null;
      this.focused = false;
      this.trackWrites = null;
      this.dom = place && place.mount || document.createElement("div");
      if (place) {
        if (place.appendChild) {
          place.appendChild(this.dom);
        } else if (place.apply) {
          place(this.dom);
        } else if (place.mount) {
          this.mounted = true;
        }
      }
      this.editable = getEditable(this);
      this.markCursor = null;
      this.cursorWrapper = null;
      updateCursorWrapper(this);
      this.nodeViews = buildNodeViews(this);
      this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this);
      this.lastSelectedViewDesc = null;
      this.dragging = null;
      initInput(this);
      this.prevDirectPlugins = [];
      this.pluginViews = [];
      this.updatePluginViews();
    };
    var prototypeAccessors$2 = { props: { configurable: true }, root: { configurable: true } };
    prototypeAccessors$2.props.get = function() {
      if (this._props.state != this.state) {
        var prev = this._props;
        this._props = {};
        for (var name in prev) {
          this._props[name] = prev[name];
        }
        this._props.state = this.state;
      }
      return this._props;
    };
    EditorView.prototype.update = function update(props) {
      if (props.handleDOMEvents != this._props.handleDOMEvents) {
        ensureListeners(this);
      }
      this._props = props;
      if (props.plugins) {
        props.plugins.forEach(checkStateComponent);
        this.directPlugins = props.plugins;
      }
      this.updateStateInner(props.state, true);
    };
    EditorView.prototype.setProps = function setProps(props) {
      var updated = {};
      for (var name in this._props) {
        updated[name] = this._props[name];
      }
      updated.state = this.state;
      for (var name$1 in props) {
        updated[name$1] = props[name$1];
      }
      this.update(updated);
    };
    EditorView.prototype.updateState = function updateState(state) {
      this.updateStateInner(state, this.state.plugins != state.plugins);
    };
    EditorView.prototype.updateStateInner = function updateStateInner(state, reconfigured) {
      var this$1 = this;
      var prev = this.state, redraw = false, updateSel = false;
      if (state.storedMarks && this.composing) {
        clearComposition(this);
        updateSel = true;
      }
      this.state = state;
      if (reconfigured) {
        var nodeViews = buildNodeViews(this);
        if (changedNodeViews(nodeViews, this.nodeViews)) {
          this.nodeViews = nodeViews;
          redraw = true;
        }
        ensureListeners(this);
      }
      this.editable = getEditable(this);
      updateCursorWrapper(this);
      var innerDeco = viewDecorations(this), outerDeco = computeDocDeco(this);
      var scroll = reconfigured ? "reset" : state.scrollToSelection > prev.scrollToSelection ? "to selection" : "preserve";
      var updateDoc = redraw || !this.docView.matchesNode(state.doc, outerDeco, innerDeco);
      if (updateDoc || !state.selection.eq(prev.selection)) {
        updateSel = true;
      }
      var oldScrollPos = scroll == "preserve" && updateSel && this.dom.style.overflowAnchor == null && storeScrollPos(this);
      if (updateSel) {
        this.domObserver.stop();
        var forceSelUpdate = updateDoc && (result.ie || result.chrome) && !this.composing && !prev.selection.empty && !state.selection.empty && selectionContextChanged(prev.selection, state.selection);
        if (updateDoc) {
          var chromeKludge = result.chrome ? this.trackWrites = this.root.getSelection().focusNode : null;
          if (redraw || !this.docView.update(state.doc, outerDeco, innerDeco, this)) {
            this.docView.updateOuterDeco([]);
            this.docView.destroy();
            this.docView = docViewDesc(state.doc, outerDeco, innerDeco, this.dom, this);
          }
          if (chromeKludge && !this.trackWrites) {
            forceSelUpdate = true;
          }
        }
        if (forceSelUpdate || !(this.mouseDown && this.domObserver.currentSelection.eq(this.root.getSelection()) && anchorInRightPlace(this))) {
          selectionToDOM(this, forceSelUpdate);
        } else {
          syncNodeSelection(this, state.selection);
          this.domObserver.setCurSelection();
        }
        this.domObserver.start();
      }
      this.updatePluginViews(prev);
      if (scroll == "reset") {
        this.dom.scrollTop = 0;
      } else if (scroll == "to selection") {
        var startDOM = this.root.getSelection().focusNode;
        if (this.someProp("handleScrollToSelection", function(f) {
          return f(this$1);
        }))
          ;
        else if (state.selection instanceof prosemirrorState.NodeSelection) {
          scrollRectIntoView(this, this.docView.domAfterPos(state.selection.from).getBoundingClientRect(), startDOM);
        } else {
          scrollRectIntoView(this, this.coordsAtPos(state.selection.head, 1), startDOM);
        }
      } else if (oldScrollPos) {
        resetScrollPos(oldScrollPos);
      }
    };
    EditorView.prototype.destroyPluginViews = function destroyPluginViews() {
      var view;
      while (view = this.pluginViews.pop()) {
        if (view.destroy) {
          view.destroy();
        }
      }
    };
    EditorView.prototype.updatePluginViews = function updatePluginViews(prevState) {
      if (!prevState || prevState.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
        this.prevDirectPlugins = this.directPlugins;
        this.destroyPluginViews();
        for (var i = 0; i < this.directPlugins.length; i++) {
          var plugin = this.directPlugins[i];
          if (plugin.spec.view) {
            this.pluginViews.push(plugin.spec.view(this));
          }
        }
        for (var i$1 = 0; i$1 < this.state.plugins.length; i$1++) {
          var plugin$1 = this.state.plugins[i$1];
          if (plugin$1.spec.view) {
            this.pluginViews.push(plugin$1.spec.view(this));
          }
        }
      } else {
        for (var i$2 = 0; i$2 < this.pluginViews.length; i$2++) {
          var pluginView = this.pluginViews[i$2];
          if (pluginView.update) {
            pluginView.update(this, prevState);
          }
        }
      }
    };
    EditorView.prototype.someProp = function someProp(propName, f) {
      var prop2 = this._props && this._props[propName], value;
      if (prop2 != null && (value = f ? f(prop2) : prop2)) {
        return value;
      }
      for (var i = 0; i < this.directPlugins.length; i++) {
        var prop$1 = this.directPlugins[i].props[propName];
        if (prop$1 != null && (value = f ? f(prop$1) : prop$1)) {
          return value;
        }
      }
      var plugins = this.state.plugins;
      if (plugins) {
        for (var i$1 = 0; i$1 < plugins.length; i$1++) {
          var prop$2 = plugins[i$1].props[propName];
          if (prop$2 != null && (value = f ? f(prop$2) : prop$2)) {
            return value;
          }
        }
      }
    };
    EditorView.prototype.hasFocus = function hasFocus() {
      return this.root.activeElement == this.dom;
    };
    EditorView.prototype.focus = function focus() {
      this.domObserver.stop();
      if (this.editable) {
        focusPreventScroll(this.dom);
      }
      selectionToDOM(this);
      this.domObserver.start();
    };
    prototypeAccessors$2.root.get = function() {
      var cached = this._root;
      if (cached == null) {
        for (var search = this.dom.parentNode; search; search = search.parentNode) {
          if (search.nodeType == 9 || search.nodeType == 11 && search.host) {
            if (!search.getSelection) {
              Object.getPrototypeOf(search).getSelection = function() {
                return document.getSelection();
              };
            }
            return this._root = search;
          }
        }
      }
      return cached || document;
    };
    EditorView.prototype.posAtCoords = function posAtCoords$1(coords) {
      return posAtCoords(this, coords);
    };
    EditorView.prototype.coordsAtPos = function coordsAtPos$1(pos, side) {
      if (side === void 0)
        side = 1;
      return coordsAtPos(this, pos, side);
    };
    EditorView.prototype.domAtPos = function domAtPos(pos, side) {
      if (side === void 0)
        side = 0;
      return this.docView.domFromPos(pos, side);
    };
    EditorView.prototype.nodeDOM = function nodeDOM(pos) {
      var desc = this.docView.descAt(pos);
      return desc ? desc.nodeDOM : null;
    };
    EditorView.prototype.posAtDOM = function posAtDOM(node, offset, bias) {
      if (bias === void 0)
        bias = -1;
      var pos = this.docView.posFromDOM(node, offset, bias);
      if (pos == null) {
        throw new RangeError("DOM position not inside the editor");
      }
      return pos;
    };
    EditorView.prototype.endOfTextblock = function endOfTextblock$1(dir, state) {
      return endOfTextblock(this, state || this.state, dir);
    };
    EditorView.prototype.destroy = function destroy() {
      if (!this.docView) {
        return;
      }
      destroyInput(this);
      this.destroyPluginViews();
      if (this.mounted) {
        this.docView.update(this.state.doc, [], viewDecorations(this), this);
        this.dom.textContent = "";
      } else if (this.dom.parentNode) {
        this.dom.parentNode.removeChild(this.dom);
      }
      this.docView.destroy();
      this.docView = null;
    };
    EditorView.prototype.dispatchEvent = function dispatchEvent$1(event) {
      return dispatchEvent(this, event);
    };
    EditorView.prototype.dispatch = function dispatch(tr) {
      var dispatchTransaction = this._props.dispatchTransaction;
      if (dispatchTransaction) {
        dispatchTransaction.call(this, tr);
      } else {
        this.updateState(this.state.apply(tr));
      }
    };
    Object.defineProperties(EditorView.prototype, prototypeAccessors$2);
    function computeDocDeco(view) {
      var attrs = Object.create(null);
      attrs.class = "ProseMirror";
      attrs.contenteditable = String(view.editable);
      attrs.translate = "no";
      view.someProp("attributes", function(value) {
        if (typeof value == "function") {
          value = value(view.state);
        }
        if (value) {
          for (var attr in value) {
            if (attr == "class") {
              attrs.class += " " + value[attr];
            } else if (!attrs[attr] && attr != "contenteditable" && attr != "nodeName") {
              attrs[attr] = String(value[attr]);
            }
          }
        }
      });
      return [Decoration.node(0, view.state.doc.content.size, attrs)];
    }
    function updateCursorWrapper(view) {
      if (view.markCursor) {
        var dom = document.createElement("img");
        dom.className = "ProseMirror-separator";
        dom.setAttribute("mark-placeholder", "true");
        view.cursorWrapper = { dom, deco: Decoration.widget(view.state.selection.head, dom, { raw: true, marks: view.markCursor }) };
      } else {
        view.cursorWrapper = null;
      }
    }
    function getEditable(view) {
      return !view.someProp("editable", function(value) {
        return value(view.state) === false;
      });
    }
    function selectionContextChanged(sel1, sel2) {
      var depth = Math.min(sel1.$anchor.sharedDepth(sel1.head), sel2.$anchor.sharedDepth(sel2.head));
      return sel1.$anchor.start(depth) != sel2.$anchor.start(depth);
    }
    function buildNodeViews(view) {
      var result2 = {};
      view.someProp("nodeViews", function(obj) {
        for (var prop2 in obj) {
          if (!Object.prototype.hasOwnProperty.call(result2, prop2)) {
            result2[prop2] = obj[prop2];
          }
        }
      });
      return result2;
    }
    function changedNodeViews(a, b) {
      var nA = 0, nB = 0;
      for (var prop2 in a) {
        if (a[prop2] != b[prop2]) {
          return true;
        }
        nA++;
      }
      for (var _ in b) {
        nB++;
      }
      return nA != nB;
    }
    function checkStateComponent(plugin) {
      if (plugin.spec.state || plugin.spec.filterTransaction || plugin.spec.appendTransaction) {
        throw new RangeError("Plugins passed directly to the view must not have a state component");
      }
    }
    exports.Decoration = Decoration;
    exports.DecorationSet = DecorationSet;
    exports.EditorView = EditorView;
    exports.__endComposition = endComposition;
    exports.__parseFromClipboard = parseFromClipboard;
    exports.__serializeForClipboard = serializeForClipboard;
  }
});

// node_modules/w3c-keyname/index.cjs
var require_w3c_keyname = __commonJS({
  "node_modules/w3c-keyname/index.cjs"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var base2 = {
      8: "Backspace",
      9: "Tab",
      10: "Enter",
      12: "NumLock",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      44: "PrintScreen",
      45: "Insert",
      46: "Delete",
      59: ";",
      61: "=",
      91: "Meta",
      92: "Meta",
      106: "*",
      107: "+",
      108: ",",
      109: "-",
      110: ".",
      111: "/",
      144: "NumLock",
      145: "ScrollLock",
      160: "Shift",
      161: "Shift",
      162: "Control",
      163: "Control",
      164: "Alt",
      165: "Alt",
      173: "-",
      186: ";",
      187: "=",
      188: ",",
      189: "-",
      190: ".",
      191: "/",
      192: "`",
      219: "[",
      220: "\\",
      221: "]",
      222: "'",
      229: "q"
    };
    var shift = {
      48: ")",
      49: "!",
      50: "@",
      51: "#",
      52: "$",
      53: "%",
      54: "^",
      55: "&",
      56: "*",
      57: "(",
      59: ":",
      61: "+",
      173: "_",
      186: ":",
      187: "+",
      188: "<",
      189: "_",
      190: ">",
      191: "?",
      192: "~",
      219: "{",
      220: "|",
      221: "}",
      222: '"',
      229: "Q"
    };
    var chrome = typeof navigator != "undefined" && /Chrome\/(\d+)/.exec(navigator.userAgent);
    var safari = typeof navigator != "undefined" && /Apple Computer/.test(navigator.vendor);
    var gecko = typeof navigator != "undefined" && /Gecko\/\d+/.test(navigator.userAgent);
    var mac = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
    var ie = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
    var brokenModifierNames = chrome && (mac || +chrome[1] < 57) || gecko && mac;
    for (i = 0; i < 10; i++)
      base2[48 + i] = base2[96 + i] = String(i);
    var i;
    for (i = 1; i <= 24; i++)
      base2[i + 111] = "F" + i;
    var i;
    for (i = 65; i <= 90; i++) {
      base2[i] = String.fromCharCode(i + 32);
      shift[i] = String.fromCharCode(i);
    }
    var i;
    for (code in base2)
      if (!shift.hasOwnProperty(code))
        shift[code] = base2[code];
    var code;
    function keyName(event) {
      var ignoreKey = brokenModifierNames && (event.ctrlKey || event.altKey || event.metaKey) || (safari || ie) && event.shiftKey && event.key && event.key.length == 1;
      var name = !ignoreKey && event.key || (event.shiftKey ? shift : base2)[event.keyCode] || event.key || "Unidentified";
      if (name == "Esc")
        name = "Escape";
      if (name == "Del")
        name = "Delete";
      if (name == "Left")
        name = "ArrowLeft";
      if (name == "Up")
        name = "ArrowUp";
      if (name == "Right")
        name = "ArrowRight";
      if (name == "Down")
        name = "ArrowDown";
      return name;
    }
    exports.base = base2;
    exports.keyName = keyName;
    exports.shift = shift;
  }
});

// node_modules/prosemirror-keymap/dist/index.js
var require_dist7 = __commonJS({
  "node_modules/prosemirror-keymap/dist/index.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var w3cKeyname = require_w3c_keyname();
    var prosemirrorState = require_dist3();
    var mac = typeof navigator != "undefined" ? /Mac/.test(navigator.platform) : false;
    function normalizeKeyName(name) {
      var parts = name.split(/-(?!$)/), result = parts[parts.length - 1];
      if (result == "Space") {
        result = " ";
      }
      var alt, ctrl, shift, meta;
      for (var i = 0; i < parts.length - 1; i++) {
        var mod = parts[i];
        if (/^(cmd|meta|m)$/i.test(mod)) {
          meta = true;
        } else if (/^a(lt)?$/i.test(mod)) {
          alt = true;
        } else if (/^(c|ctrl|control)$/i.test(mod)) {
          ctrl = true;
        } else if (/^s(hift)?$/i.test(mod)) {
          shift = true;
        } else if (/^mod$/i.test(mod)) {
          if (mac) {
            meta = true;
          } else {
            ctrl = true;
          }
        } else {
          throw new Error("Unrecognized modifier name: " + mod);
        }
      }
      if (alt) {
        result = "Alt-" + result;
      }
      if (ctrl) {
        result = "Ctrl-" + result;
      }
      if (meta) {
        result = "Meta-" + result;
      }
      if (shift) {
        result = "Shift-" + result;
      }
      return result;
    }
    function normalize2(map2) {
      var copy2 = Object.create(null);
      for (var prop in map2) {
        copy2[normalizeKeyName(prop)] = map2[prop];
      }
      return copy2;
    }
    function modifiers(name, event, shift) {
      if (event.altKey) {
        name = "Alt-" + name;
      }
      if (event.ctrlKey) {
        name = "Ctrl-" + name;
      }
      if (event.metaKey) {
        name = "Meta-" + name;
      }
      if (shift !== false && event.shiftKey) {
        name = "Shift-" + name;
      }
      return name;
    }
    function keymap(bindings) {
      return new prosemirrorState.Plugin({ props: { handleKeyDown: keydownHandler(bindings) } });
    }
    function keydownHandler(bindings) {
      var map2 = normalize2(bindings);
      return function(view, event) {
        var name = w3cKeyname.keyName(event), isChar = name.length == 1 && name != " ", baseName;
        var direct = map2[modifiers(name, event, !isChar)];
        if (direct && direct(view.state, view.dispatch, view)) {
          return true;
        }
        if (isChar && (event.shiftKey || event.altKey || event.metaKey || name.charCodeAt(0) > 127) && (baseName = w3cKeyname.base[event.keyCode]) && baseName != name) {
          var fromCode = map2[modifiers(baseName, event, true)];
          if (fromCode && fromCode(view.state, view.dispatch, view)) {
            return true;
          }
        } else if (isChar && event.shiftKey) {
          var withShift = map2[modifiers(name, event, true)];
          if (withShift && withShift(view.state, view.dispatch, view)) {
            return true;
          }
        }
        return false;
      };
    }
    exports.keydownHandler = keydownHandler;
    exports.keymap = keymap;
  }
});

// node_modules/@tiptap/core/dist/tiptap-core.cjs.js
var require_tiptap_core_cjs = __commonJS({
  "node_modules/@tiptap/core/dist/tiptap-core.cjs.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var prosemirrorState = require_dist3();
    var prosemirrorTransform = require_dist2();
    var prosemirrorCommands = require_dist4();
    var prosemirrorModel = require_dist();
    var prosemirrorSchemaList = require_dist5();
    var prosemirrorView = require_dist6();
    var prosemirrorKeymap = require_dist7();
    function getType2(value) {
      return Object.prototype.toString.call(value).slice(8, -1);
    }
    function isPlainObject(value) {
      if (getType2(value) !== "Object")
        return false;
      return value.constructor === Object && Object.getPrototypeOf(value) === Object.prototype;
    }
    function mergeDeep(target, source) {
      const output = { ...target };
      if (isPlainObject(target) && isPlainObject(source)) {
        Object.keys(source).forEach((key) => {
          if (isPlainObject(source[key])) {
            if (!(key in target)) {
              Object.assign(output, { [key]: source[key] });
            } else {
              output[key] = mergeDeep(target[key], source[key]);
            }
          } else {
            Object.assign(output, { [key]: source[key] });
          }
        });
      }
      return output;
    }
    var Extension = class {
      constructor(config = {}) {
        this.type = "extension";
        this.name = "extension";
        this.parent = null;
        this.child = null;
        this.config = {
          name: this.name,
          defaultOptions: {}
        };
        this.config = {
          ...this.config,
          ...config
        };
        this.name = this.config.name;
        this.options = this.config.defaultOptions;
      }
      static create(config = {}) {
        return new Extension(config);
      }
      configure(options2 = {}) {
        const extension = this.extend();
        extension.options = mergeDeep(this.options, options2);
        return extension;
      }
      extend(extendedConfig = {}) {
        const extension = new Extension(extendedConfig);
        extension.parent = this;
        this.child = extension;
        extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
        extension.options = extendedConfig.defaultOptions ? extendedConfig.defaultOptions : extension.parent.options;
        return extension;
      }
    };
    function getTextBetween(startNode, range, options2) {
      const { from, to } = range;
      const { blockSeparator = "\n\n", textSerializers = {} } = options2 || {};
      let text = "";
      let separated = true;
      startNode.nodesBetween(from, to, (node, pos, parent, index2) => {
        var _a;
        const textSerializer = textSerializers === null || textSerializers === void 0 ? void 0 : textSerializers[node.type.name];
        if (textSerializer) {
          if (node.isBlock && !separated) {
            text += blockSeparator;
            separated = true;
          }
          text += textSerializer({
            node,
            pos,
            parent,
            index: index2
          });
        } else if (node.isText) {
          text += (_a = node === null || node === void 0 ? void 0 : node.text) === null || _a === void 0 ? void 0 : _a.slice(Math.max(from, pos) - pos, to - pos);
          separated = false;
        } else if (node.isBlock && !separated) {
          text += blockSeparator;
          separated = true;
        }
      });
      return text;
    }
    function getTextSeralizersFromSchema(schema) {
      return Object.fromEntries(Object.entries(schema.nodes).filter(([, node]) => node.spec.toText).map(([name, node]) => [name, node.spec.toText]));
    }
    var ClipboardTextSerializer = Extension.create({
      name: "clipboardTextSerializer",
      addProseMirrorPlugins() {
        return [
          new prosemirrorState.Plugin({
            key: new prosemirrorState.PluginKey("clipboardTextSerializer"),
            props: {
              clipboardTextSerializer: () => {
                const { editor } = this;
                const { state, schema } = editor;
                const { doc, selection } = state;
                const { from, to } = selection;
                const textSerializers = getTextSeralizersFromSchema(schema);
                const range = { from, to };
                return getTextBetween(doc, range, {
                  textSerializers
                });
              }
            }
          })
        ];
      }
    });
    var blur = () => ({ editor, view }) => {
      requestAnimationFrame(() => {
        if (!editor.isDestroyed) {
          view.dom.blur();
        }
      });
      return true;
    };
    var blur$1 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      blur
    });
    var clearContent = (emitUpdate = false) => ({ commands }) => {
      return commands.setContent("", emitUpdate);
    };
    var clearContent$1 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      clearContent
    });
    var clearNodes = () => ({ state, tr, dispatch }) => {
      const { selection } = tr;
      const { ranges } = selection;
      ranges.forEach((range) => {
        state.doc.nodesBetween(range.$from.pos, range.$to.pos, (node, pos) => {
          if (node.type.isText) {
            return;
          }
          const $fromPos = tr.doc.resolve(tr.mapping.map(pos));
          const $toPos = tr.doc.resolve(tr.mapping.map(pos + node.nodeSize));
          const nodeRange = $fromPos.blockRange($toPos);
          if (!nodeRange) {
            return;
          }
          const targetLiftDepth = prosemirrorTransform.liftTarget(nodeRange);
          if (node.type.isTextblock && dispatch) {
            const { defaultType } = $fromPos.parent.contentMatchAt($fromPos.index());
            tr.setNodeMarkup(nodeRange.start, defaultType);
          }
          if ((targetLiftDepth || targetLiftDepth === 0) && dispatch) {
            tr.lift(nodeRange, targetLiftDepth);
          }
        });
      });
      return true;
    };
    var clearNodes$1 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      clearNodes
    });
    var command = (fn) => (props) => {
      return fn(props);
    };
    var command$1 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      command
    });
    var createParagraphNear = () => ({ state, dispatch }) => {
      return prosemirrorCommands.createParagraphNear(state, dispatch);
    };
    var createParagraphNear$1 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      createParagraphNear
    });
    function getNodeType(nameOrType, schema) {
      if (typeof nameOrType === "string") {
        if (!schema.nodes[nameOrType]) {
          throw Error(`There is no node type named '${nameOrType}'. Maybe you forgot to add the extension?`);
        }
        return schema.nodes[nameOrType];
      }
      return nameOrType;
    }
    var deleteNode = (typeOrName) => ({ tr, state, dispatch }) => {
      const type = getNodeType(typeOrName, state.schema);
      const $pos = tr.selection.$anchor;
      for (let depth = $pos.depth; depth > 0; depth -= 1) {
        const node = $pos.node(depth);
        if (node.type === type) {
          if (dispatch) {
            const from = $pos.before(depth);
            const to = $pos.after(depth);
            tr.delete(from, to).scrollIntoView();
          }
          return true;
        }
      }
      return false;
    };
    var deleteNode$1 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      deleteNode
    });
    var deleteRange = (range) => ({ tr, dispatch }) => {
      const { from, to } = range;
      if (dispatch) {
        tr.delete(from, to);
      }
      return true;
    };
    var deleteRange$1 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      deleteRange
    });
    var deleteSelection = () => ({ state, dispatch }) => {
      return prosemirrorCommands.deleteSelection(state, dispatch);
    };
    var deleteSelection$1 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      deleteSelection
    });
    var enter = () => ({ commands }) => {
      return commands.keyboardShortcut("Enter");
    };
    var enter$1 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      enter
    });
    var exitCode = () => ({ state, dispatch }) => {
      return prosemirrorCommands.exitCode(state, dispatch);
    };
    var exitCode$1 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      exitCode
    });
    function getMarkType(nameOrType, schema) {
      if (typeof nameOrType === "string") {
        if (!schema.marks[nameOrType]) {
          throw Error(`There is no mark type named '${nameOrType}'. Maybe you forgot to add the extension?`);
        }
        return schema.marks[nameOrType];
      }
      return nameOrType;
    }
    function isRegExp(value) {
      return Object.prototype.toString.call(value) === "[object RegExp]";
    }
    function objectIncludes(object1, object2, options2 = { strict: true }) {
      const keys = Object.keys(object2);
      if (!keys.length) {
        return true;
      }
      return keys.every((key) => {
        if (options2.strict) {
          return object2[key] === object1[key];
        }
        if (isRegExp(object2[key])) {
          return object2[key].test(object1[key]);
        }
        return object2[key] === object1[key];
      });
    }
    function findMarkInSet(marks, type, attributes = {}) {
      return marks.find((item) => {
        return item.type === type && objectIncludes(item.attrs, attributes);
      });
    }
    function isMarkInSet(marks, type, attributes = {}) {
      return !!findMarkInSet(marks, type, attributes);
    }
    function getMarkRange($pos, type, attributes = {}) {
      if (!$pos || !type) {
        return;
      }
      const start = $pos.parent.childAfter($pos.parentOffset);
      if (!start.node) {
        return;
      }
      const mark = findMarkInSet(start.node.marks, type, attributes);
      if (!mark) {
        return;
      }
      let startIndex = $pos.index();
      let startPos = $pos.start() + start.offset;
      let endIndex = startIndex + 1;
      let endPos = startPos + start.node.nodeSize;
      findMarkInSet(start.node.marks, type, attributes);
      while (startIndex > 0 && mark.isInSet($pos.parent.child(startIndex - 1).marks)) {
        startIndex -= 1;
        startPos -= $pos.parent.child(startIndex).nodeSize;
      }
      while (endIndex < $pos.parent.childCount && isMarkInSet($pos.parent.child(endIndex).marks, type, attributes)) {
        endPos += $pos.parent.child(endIndex).nodeSize;
        endIndex += 1;
      }
      return {
        from: startPos,
        to: endPos
      };
    }
    var extendMarkRange = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {
      const type = getMarkType(typeOrName, state.schema);
      const { doc, selection } = tr;
      const { $from, from, to } = selection;
      if (dispatch) {
        const range = getMarkRange($from, type, attributes);
        if (range && range.from <= from && range.to >= to) {
          const newSelection = prosemirrorState.TextSelection.create(doc, range.from, range.to);
          tr.setSelection(newSelection);
        }
      }
      return true;
    };
    var extendMarkRange$1 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      extendMarkRange
    });
    var first = (commands) => (props) => {
      const items = typeof commands === "function" ? commands(props) : commands;
      for (let i = 0; i < items.length; i += 1) {
        if (items[i](props)) {
          return true;
        }
      }
      return false;
    };
    var first$1 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      first
    });
    function minMax(value = 0, min = 0, max = 0) {
      return Math.min(Math.max(value, min), max);
    }
    function isClass(value) {
      var _a;
      if (((_a = value.constructor) === null || _a === void 0 ? void 0 : _a.toString().substring(0, 5)) !== "class") {
        return false;
      }
      return true;
    }
    function isObject$1(value) {
      return value && typeof value === "object" && !Array.isArray(value) && !isClass(value);
    }
    function isTextSelection(value) {
      return isObject$1(value) && value instanceof prosemirrorState.TextSelection;
    }
    function isiOS() {
      return [
        "iPad Simulator",
        "iPhone Simulator",
        "iPod Simulator",
        "iPad",
        "iPhone",
        "iPod"
      ].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document;
    }
    function resolveSelection(state, position = null) {
      if (!position) {
        return null;
      }
      if (position === "start" || position === true) {
        return {
          from: 0,
          to: 0
        };
      }
      if (position === "end") {
        const { size } = state.doc.content;
        return {
          from: size,
          to: size
        };
      }
      return {
        from: position,
        to: position
      };
    }
    var focus = (position = null) => ({ editor, view, tr, dispatch }) => {
      const delayedFocus = () => {
        if (isiOS()) {
          view.dom.focus();
        }
        requestAnimationFrame(() => {
          if (!editor.isDestroyed) {
            view.focus();
            editor.commands.scrollIntoView();
          }
        });
      };
      if (view.hasFocus() && position === null || position === false) {
        return true;
      }
      if (dispatch && position === null && !isTextSelection(editor.state.selection)) {
        delayedFocus();
        return true;
      }
      const { from, to } = resolveSelection(editor.state, position) || editor.state.selection;
      const { doc, storedMarks } = tr;
      const minPos = prosemirrorState.Selection.atStart(doc).from;
      const maxPos = prosemirrorState.Selection.atEnd(doc).to;
      const resolvedFrom = minMax(from, minPos, maxPos);
      const resolvedEnd = minMax(to, minPos, maxPos);
      const selection = prosemirrorState.TextSelection.create(doc, resolvedFrom, resolvedEnd);
      const isSameSelection = editor.state.selection.eq(selection);
      if (dispatch) {
        if (!isSameSelection) {
          tr.setSelection(selection);
        }
        if (isSameSelection && storedMarks) {
          tr.setStoredMarks(storedMarks);
        }
        delayedFocus();
      }
      return true;
    };
    var focus$1 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      focus
    });
    var forEach = (items, fn) => (props) => {
      return items.every((item, index2) => fn(item, { ...props, index: index2 }));
    };
    var forEach$1 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      forEach
    });
    var insertContent = (value, options2) => ({ tr, commands }) => {
      return commands.insertContentAt({ from: tr.selection.from, to: tr.selection.to }, value, options2);
    };
    var insertContent$1 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      insertContent
    });
    function elementFromString(value) {
      const wrappedValue = `<body>${value}</body>`;
      return new window.DOMParser().parseFromString(wrappedValue, "text/html").body;
    }
    function createNodeFromContent(content, schema, options2) {
      options2 = {
        slice: true,
        parseOptions: {},
        ...options2
      };
      if (typeof content === "object" && content !== null) {
        try {
          if (Array.isArray(content)) {
            return prosemirrorModel.Fragment.fromArray(content.map((item) => schema.nodeFromJSON(item)));
          }
          return schema.nodeFromJSON(content);
        } catch (error2) {
          console.warn("[tiptap warn]: Invalid content.", "Passed value:", content, "Error:", error2);
          return createNodeFromContent("", schema, options2);
        }
      }
      if (typeof content === "string") {
        const parser = prosemirrorModel.DOMParser.fromSchema(schema);
        return options2.slice ? parser.parseSlice(elementFromString(content), options2.parseOptions).content : parser.parse(elementFromString(content), options2.parseOptions);
      }
      return createNodeFromContent("", schema, options2);
    }
    function selectionToInsertionEnd(tr, startLen, bias) {
      const last = tr.steps.length - 1;
      if (last < startLen) {
        return;
      }
      const step = tr.steps[last];
      if (!(step instanceof prosemirrorTransform.ReplaceStep || step instanceof prosemirrorTransform.ReplaceAroundStep)) {
        return;
      }
      const map2 = tr.mapping.maps[last];
      let end = 0;
      map2.forEach((_from, _to, _newFrom, newTo) => {
        if (end === 0) {
          end = newTo;
        }
      });
      tr.setSelection(prosemirrorState.Selection.near(tr.doc.resolve(end), bias));
    }
    var insertContentAt = (position, value, options2) => ({ tr, dispatch, editor }) => {
      if (dispatch) {
        const content = createNodeFromContent(value, editor.schema, {
          parseOptions: {
            preserveWhitespace: "full"
          },
          ...options2 || {}
        });
        if (content.toString() === "<>") {
          return true;
        }
        const { from, to } = typeof position === "number" ? { from: position, to: position } : position;
        tr.replaceWith(from, to, content);
        selectionToInsertionEnd(tr, tr.steps.length - 1, 1);
      }
      return true;
    };
    var insertContentAt$1 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      insertContentAt
    });
    var joinBackward = () => ({ state, dispatch }) => {
      return prosemirrorCommands.joinBackward(state, dispatch);
    };
    var joinBackward$1 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      joinBackward
    });
    var joinForward = () => ({ state, dispatch }) => {
      return prosemirrorCommands.joinForward(state, dispatch);
    };
    var joinForward$1 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      joinForward
    });
    var mac = typeof navigator !== "undefined" ? /Mac/.test(navigator.platform) : false;
    function normalizeKeyName(name) {
      const parts = name.split(/-(?!$)/);
      let result = parts[parts.length - 1];
      if (result === "Space") {
        result = " ";
      }
      let alt;
      let ctrl;
      let shift;
      let meta;
      for (let i = 0; i < parts.length - 1; i += 1) {
        const mod = parts[i];
        if (/^(cmd|meta|m)$/i.test(mod)) {
          meta = true;
        } else if (/^a(lt)?$/i.test(mod)) {
          alt = true;
        } else if (/^(c|ctrl|control)$/i.test(mod)) {
          ctrl = true;
        } else if (/^s(hift)?$/i.test(mod)) {
          shift = true;
        } else if (/^mod$/i.test(mod)) {
          if (mac) {
            meta = true;
          } else {
            ctrl = true;
          }
        } else {
          throw new Error(`Unrecognized modifier name: ${mod}`);
        }
      }
      if (alt) {
        result = `Alt-${result}`;
      }
      if (ctrl) {
        result = `Ctrl-${result}`;
      }
      if (meta) {
        result = `Meta-${result}`;
      }
      if (shift) {
        result = `Shift-${result}`;
      }
      return result;
    }
    var keyboardShortcut = (name) => ({ editor, view, tr, dispatch }) => {
      const keys = normalizeKeyName(name).split(/-(?!$)/);
      const key = keys.find((item) => !["Alt", "Ctrl", "Meta", "Shift"].includes(item));
      const event = new KeyboardEvent("keydown", {
        key: key === "Space" ? " " : key,
        altKey: keys.includes("Alt"),
        ctrlKey: keys.includes("Ctrl"),
        metaKey: keys.includes("Meta"),
        shiftKey: keys.includes("Shift"),
        bubbles: true,
        cancelable: true
      });
      const capturedTransaction = editor.captureTransaction(() => {
        view.someProp("handleKeyDown", (f) => f(view, event));
      });
      capturedTransaction === null || capturedTransaction === void 0 ? void 0 : capturedTransaction.steps.forEach((step) => {
        const newStep = step.map(tr.mapping);
        if (newStep && dispatch) {
          tr.maybeStep(newStep);
        }
      });
      return true;
    };
    var keyboardShortcut$1 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      keyboardShortcut
    });
    function isNodeActive(state, typeOrName, attributes = {}) {
      const { from, to, empty: empty2 } = state.selection;
      const type = typeOrName ? getNodeType(typeOrName, state.schema) : null;
      const nodeRanges = [];
      state.doc.nodesBetween(from, to, (node, pos) => {
        if (node.isText) {
          return;
        }
        const relativeFrom = Math.max(from, pos);
        const relativeTo = Math.min(to, pos + node.nodeSize);
        nodeRanges.push({
          node,
          from: relativeFrom,
          to: relativeTo
        });
      });
      const selectionRange = to - from;
      const matchedNodeRanges = nodeRanges.filter((nodeRange) => {
        if (!type) {
          return true;
        }
        return type.name === nodeRange.node.type.name;
      }).filter((nodeRange) => objectIncludes(nodeRange.node.attrs, attributes, { strict: false }));
      if (empty2) {
        return !!matchedNodeRanges.length;
      }
      const range = matchedNodeRanges.reduce((sum, nodeRange) => sum + nodeRange.to - nodeRange.from, 0);
      return range >= selectionRange;
    }
    var lift = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
      const type = getNodeType(typeOrName, state.schema);
      const isActive2 = isNodeActive(state, type, attributes);
      if (!isActive2) {
        return false;
      }
      return prosemirrorCommands.lift(state, dispatch);
    };
    var lift$1 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      lift
    });
    var liftEmptyBlock = () => ({ state, dispatch }) => {
      return prosemirrorCommands.liftEmptyBlock(state, dispatch);
    };
    var liftEmptyBlock$1 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      liftEmptyBlock
    });
    var liftListItem = (typeOrName) => ({ state, dispatch }) => {
      const type = getNodeType(typeOrName, state.schema);
      return prosemirrorSchemaList.liftListItem(type)(state, dispatch);
    };
    var liftListItem$1 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      liftListItem
    });
    var newlineInCode = () => ({ state, dispatch }) => {
      return prosemirrorCommands.newlineInCode(state, dispatch);
    };
    var newlineInCode$1 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      newlineInCode
    });
    function getSchemaTypeNameByName(name, schema) {
      if (schema.nodes[name]) {
        return "node";
      }
      if (schema.marks[name]) {
        return "mark";
      }
      return null;
    }
    function deleteProps(obj, propOrProps) {
      const props = typeof propOrProps === "string" ? [propOrProps] : propOrProps;
      return Object.keys(obj).reduce((newObj, prop) => {
        if (!props.includes(prop)) {
          newObj[prop] = obj[prop];
        }
        return newObj;
      }, {});
    }
    var resetAttributes = (typeOrName, attributes) => ({ tr, state, dispatch }) => {
      let nodeType = null;
      let markType = null;
      const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
      if (!schemaType) {
        return false;
      }
      if (schemaType === "node") {
        nodeType = getNodeType(typeOrName, state.schema);
      }
      if (schemaType === "mark") {
        markType = getMarkType(typeOrName, state.schema);
      }
      if (dispatch) {
        tr.selection.ranges.forEach((range) => {
          state.doc.nodesBetween(range.$from.pos, range.$to.pos, (node, pos) => {
            if (nodeType && nodeType === node.type) {
              tr.setNodeMarkup(pos, void 0, deleteProps(node.attrs, attributes));
            }
            if (markType && node.marks.length) {
              node.marks.forEach((mark) => {
                if (markType === mark.type) {
                  tr.addMark(pos, pos + node.nodeSize, markType.create(deleteProps(mark.attrs, attributes)));
                }
              });
            }
          });
        });
      }
      return true;
    };
    var resetAttributes$1 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      resetAttributes
    });
    var scrollIntoView = () => ({ tr, dispatch }) => {
      if (dispatch) {
        tr.scrollIntoView();
      }
      return true;
    };
    var scrollIntoView$1 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      scrollIntoView
    });
    var selectAll = () => ({ tr, commands }) => {
      return commands.setTextSelection({
        from: 0,
        to: tr.doc.content.size
      });
    };
    var selectAll$1 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      selectAll
    });
    var selectNodeBackward = () => ({ state, dispatch }) => {
      return prosemirrorCommands.selectNodeBackward(state, dispatch);
    };
    var selectNodeBackward$1 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      selectNodeBackward
    });
    var selectNodeForward = () => ({ state, dispatch }) => {
      return prosemirrorCommands.selectNodeForward(state, dispatch);
    };
    var selectNodeForward$1 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      selectNodeForward
    });
    var selectParentNode = () => ({ state, dispatch }) => {
      return prosemirrorCommands.selectParentNode(state, dispatch);
    };
    var selectParentNode$1 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      selectParentNode
    });
    function createDocument(content, schema, parseOptions = {}) {
      return createNodeFromContent(content, schema, { slice: false, parseOptions });
    }
    var setContent = (content, emitUpdate = false, parseOptions = {}) => ({ tr, editor, dispatch }) => {
      const { doc } = tr;
      const document2 = createDocument(content, editor.schema, parseOptions);
      const selection = prosemirrorState.TextSelection.create(doc, 0, doc.content.size);
      if (dispatch) {
        tr.setSelection(selection).replaceSelectionWith(document2, false).setMeta("preventUpdate", !emitUpdate);
      }
      return true;
    };
    var setContent$1 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      setContent
    });
    function getMarkAttributes(state, typeOrName) {
      const type = getMarkType(typeOrName, state.schema);
      const { from, to, empty: empty2 } = state.selection;
      const marks = [];
      if (empty2) {
        marks.push(...state.selection.$head.marks());
      } else {
        state.doc.nodesBetween(from, to, (node) => {
          marks.push(...node.marks);
        });
      }
      const mark = marks.find((markItem) => markItem.type.name === type.name);
      if (!mark) {
        return {};
      }
      return { ...mark.attrs };
    }
    var setMark = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {
      const { selection } = tr;
      const { empty: empty2, ranges } = selection;
      const type = getMarkType(typeOrName, state.schema);
      if (dispatch) {
        if (empty2) {
          const oldAttributes = getMarkAttributes(state, type);
          tr.addStoredMark(type.create({
            ...oldAttributes,
            ...attributes
          }));
        } else {
          ranges.forEach((range) => {
            const from = range.$from.pos;
            const to = range.$to.pos;
            state.doc.nodesBetween(from, to, (node, pos) => {
              const trimmedFrom = Math.max(pos, from);
              const trimmedTo = Math.min(pos + node.nodeSize, to);
              const someHasMark = node.marks.find((mark) => mark.type === type);
              if (someHasMark) {
                node.marks.forEach((mark) => {
                  if (type === mark.type) {
                    tr.addMark(trimmedFrom, trimmedTo, type.create({
                      ...mark.attrs,
                      ...attributes
                    }));
                  }
                });
              } else {
                tr.addMark(trimmedFrom, trimmedTo, type.create(attributes));
              }
            });
          });
        }
      }
      return true;
    };
    var setMark$1 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      setMark
    });
    var setMeta = (key, value) => ({ tr }) => {
      tr.setMeta(key, value);
      return true;
    };
    var setMeta$1 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      setMeta
    });
    var setNode = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
      const type = getNodeType(typeOrName, state.schema);
      return prosemirrorCommands.setBlockType(type, attributes)(state, dispatch);
    };
    var setNode$1 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      setNode
    });
    var setNodeSelection = (position) => ({ tr, dispatch }) => {
      if (dispatch) {
        const { doc } = tr;
        const minPos = prosemirrorState.Selection.atStart(doc).from;
        const maxPos = prosemirrorState.Selection.atEnd(doc).to;
        const resolvedPos = minMax(position, minPos, maxPos);
        const selection = prosemirrorState.NodeSelection.create(doc, resolvedPos);
        tr.setSelection(selection);
      }
      return true;
    };
    var setNodeSelection$1 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      setNodeSelection
    });
    var setTextSelection = (position) => ({ tr, dispatch }) => {
      if (dispatch) {
        const { doc } = tr;
        const { from, to } = typeof position === "number" ? { from: position, to: position } : position;
        const minPos = prosemirrorState.Selection.atStart(doc).from;
        const maxPos = prosemirrorState.Selection.atEnd(doc).to;
        const resolvedFrom = minMax(from, minPos, maxPos);
        const resolvedEnd = minMax(to, minPos, maxPos);
        const selection = prosemirrorState.TextSelection.create(doc, resolvedFrom, resolvedEnd);
        tr.setSelection(selection);
      }
      return true;
    };
    var setTextSelection$1 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      setTextSelection
    });
    var sinkListItem = (typeOrName) => ({ state, dispatch }) => {
      const type = getNodeType(typeOrName, state.schema);
      return prosemirrorSchemaList.sinkListItem(type)(state, dispatch);
    };
    var sinkListItem$1 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      sinkListItem
    });
    function getSplittedAttributes(extensionAttributes, typeName, attributes) {
      return Object.fromEntries(Object.entries(attributes).filter(([name]) => {
        const extensionAttribute = extensionAttributes.find((item) => {
          return item.type === typeName && item.name === name;
        });
        if (!extensionAttribute) {
          return false;
        }
        return extensionAttribute.attribute.keepOnSplit;
      }));
    }
    function defaultBlockAt(match) {
      for (let i = 0; i < match.edgeCount; i += 1) {
        const { type } = match.edge(i);
        if (type.isTextblock && !type.hasRequiredAttrs()) {
          return type;
        }
      }
      return null;
    }
    function ensureMarks(state, splittableMarks) {
      const marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();
      if (marks) {
        const filteredMarks = marks.filter((mark) => splittableMarks === null || splittableMarks === void 0 ? void 0 : splittableMarks.includes(mark.type.name));
        state.tr.ensureMarks(filteredMarks);
      }
    }
    var splitBlock = ({ keepMarks = true } = {}) => ({ tr, state, dispatch, editor }) => {
      const { selection, doc } = tr;
      const { $from, $to } = selection;
      const extensionAttributes = editor.extensionManager.attributes;
      const newAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
      if (selection instanceof prosemirrorState.NodeSelection && selection.node.isBlock) {
        if (!$from.parentOffset || !prosemirrorTransform.canSplit(doc, $from.pos)) {
          return false;
        }
        if (dispatch) {
          if (keepMarks) {
            ensureMarks(state, editor.extensionManager.splittableMarks);
          }
          tr.split($from.pos).scrollIntoView();
        }
        return true;
      }
      if (!$from.parent.isBlock) {
        return false;
      }
      if (dispatch) {
        const atEnd = $to.parentOffset === $to.parent.content.size;
        if (selection instanceof prosemirrorState.TextSelection) {
          tr.deleteSelection();
        }
        const deflt = $from.depth === 0 ? void 0 : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));
        let types2 = atEnd && deflt ? [{
          type: deflt,
          attrs: newAttributes
        }] : void 0;
        let can = prosemirrorTransform.canSplit(tr.doc, tr.mapping.map($from.pos), 1, types2);
        if (!types2 && !can && prosemirrorTransform.canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : void 0)) {
          can = true;
          types2 = deflt ? [{
            type: deflt,
            attrs: newAttributes
          }] : void 0;
        }
        if (can) {
          tr.split(tr.mapping.map($from.pos), 1, types2);
          if (deflt && !atEnd && !$from.parentOffset && $from.parent.type !== deflt) {
            const first2 = tr.mapping.map($from.before());
            const $first = tr.doc.resolve(first2);
            if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {
              tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);
            }
          }
        }
        if (keepMarks) {
          ensureMarks(state, editor.extensionManager.splittableMarks);
        }
        tr.scrollIntoView();
      }
      return true;
    };
    var splitBlock$1 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      splitBlock
    });
    var splitListItem = (typeOrName) => ({ tr, state, dispatch, editor }) => {
      var _a;
      const type = getNodeType(typeOrName, state.schema);
      const { $from, $to } = state.selection;
      const node = state.selection.node;
      if (node && node.isBlock || $from.depth < 2 || !$from.sameParent($to)) {
        return false;
      }
      const grandParent = $from.node(-1);
      if (grandParent.type !== type) {
        return false;
      }
      const extensionAttributes = editor.extensionManager.attributes;
      if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {
        if ($from.depth === 2 || $from.node(-3).type !== type || $from.index(-2) !== $from.node(-2).childCount - 1) {
          return false;
        }
        if (dispatch) {
          let wrap = prosemirrorModel.Fragment.empty;
          const depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;
          for (let d = $from.depth - depthBefore; d >= $from.depth - 3; d -= 1) {
            wrap = prosemirrorModel.Fragment.from($from.node(d).copy(wrap));
          }
          const depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;
          const newNextTypeAttributes2 = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
          const nextType2 = ((_a = type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.createAndFill(newNextTypeAttributes2)) || void 0;
          wrap = wrap.append(prosemirrorModel.Fragment.from(type.createAndFill(null, nextType2) || void 0));
          const start = $from.before($from.depth - (depthBefore - 1));
          tr.replace(start, $from.after(-depthAfter), new prosemirrorModel.Slice(wrap, 4 - depthBefore, 0));
          let sel = -1;
          tr.doc.nodesBetween(start, tr.doc.content.size, (n, pos) => {
            if (sel > -1) {
              return false;
            }
            if (n.isTextblock && n.content.size === 0) {
              sel = pos + 1;
            }
          });
          if (sel > -1) {
            tr.setSelection(prosemirrorState.TextSelection.near(tr.doc.resolve(sel)));
          }
          tr.scrollIntoView();
        }
        return true;
      }
      const nextType = $to.pos === $from.end() ? grandParent.contentMatchAt(0).defaultType : null;
      const newTypeAttributes = getSplittedAttributes(extensionAttributes, grandParent.type.name, grandParent.attrs);
      const newNextTypeAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
      tr.delete($from.pos, $to.pos);
      const types2 = nextType ? [{ type, attrs: newTypeAttributes }, { type: nextType, attrs: newNextTypeAttributes }] : [{ type, attrs: newTypeAttributes }];
      if (!prosemirrorTransform.canSplit(tr.doc, $from.pos, 2)) {
        return false;
      }
      if (dispatch) {
        tr.split($from.pos, 2, types2).scrollIntoView();
      }
      return true;
    };
    var splitListItem$1 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      splitListItem
    });
    function findParentNodeClosestToPos($pos, predicate) {
      for (let i = $pos.depth; i > 0; i -= 1) {
        const node = $pos.node(i);
        if (predicate(node)) {
          return {
            pos: i > 0 ? $pos.before(i) : 0,
            start: $pos.start(i),
            depth: i,
            node
          };
        }
      }
    }
    function findParentNode(predicate) {
      return (selection) => findParentNodeClosestToPos(selection.$from, predicate);
    }
    function splitExtensions(extensions2) {
      const baseExtensions = extensions2.filter((extension) => extension.type === "extension");
      const nodeExtensions = extensions2.filter((extension) => extension.type === "node");
      const markExtensions = extensions2.filter((extension) => extension.type === "mark");
      return {
        baseExtensions,
        nodeExtensions,
        markExtensions
      };
    }
    function isObject(value) {
      return typeof value === "function";
    }
    function callOrReturn(value, context = void 0, ...props) {
      if (isObject(value)) {
        if (context) {
          return value.bind(context)(...props);
        }
        return value(...props);
      }
      return value;
    }
    function getExtensionField(extension, field, context = {}) {
      if (extension.config[field] === void 0 && extension.parent) {
        return getExtensionField(extension.parent, field, context);
      }
      if (typeof extension.config[field] === "function") {
        const value = extension.config[field].bind({
          ...context,
          parent: extension.parent ? getExtensionField(extension.parent, field, context) : null
        });
        return value;
      }
      return extension.config[field];
    }
    function isList(name, extensions2) {
      const { nodeExtensions } = splitExtensions(extensions2);
      const extension = nodeExtensions.find((item) => item.name === name);
      if (!extension) {
        return false;
      }
      const context = {
        name: extension.name,
        options: extension.options
      };
      const group = callOrReturn(getExtensionField(extension, "group", context));
      if (typeof group !== "string") {
        return false;
      }
      return group.split(" ").includes("list");
    }
    var toggleList = (listTypeOrName, itemTypeOrName) => ({ editor, tr, state, dispatch, chain, commands, can }) => {
      const { extensions: extensions2 } = editor.extensionManager;
      const listType = getNodeType(listTypeOrName, state.schema);
      const itemType = getNodeType(itemTypeOrName, state.schema);
      const { selection } = state;
      const { $from, $to } = selection;
      const range = $from.blockRange($to);
      if (!range) {
        return false;
      }
      const parentList = findParentNode((node) => isList(node.type.name, extensions2))(selection);
      if (range.depth >= 1 && parentList && range.depth - parentList.depth <= 1) {
        if (parentList.node.type === listType) {
          return commands.liftListItem(itemType);
        }
        if (isList(parentList.node.type.name, extensions2) && listType.validContent(parentList.node.content) && dispatch) {
          tr.setNodeMarkup(parentList.pos, listType);
          return true;
        }
      }
      const canWrapInList = can().wrapInList(listType);
      if (!canWrapInList) {
        return chain().clearNodes().wrapInList(listType).run();
      }
      return commands.wrapInList(listType);
    };
    var toggleList$1 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      toggleList
    });
    function isMarkActive(state, typeOrName, attributes = {}) {
      const { empty: empty2, ranges } = state.selection;
      const type = typeOrName ? getMarkType(typeOrName, state.schema) : null;
      if (empty2) {
        return !!(state.storedMarks || state.selection.$from.marks()).filter((mark) => {
          if (!type) {
            return true;
          }
          return type.name === mark.type.name;
        }).find((mark) => objectIncludes(mark.attrs, attributes, { strict: false }));
      }
      let selectionRange = 0;
      const markRanges = [];
      ranges.forEach(({ $from, $to }) => {
        const from = $from.pos;
        const to = $to.pos;
        state.doc.nodesBetween(from, to, (node, pos) => {
          if (!node.isText && !node.marks.length) {
            return;
          }
          const relativeFrom = Math.max(from, pos);
          const relativeTo = Math.min(to, pos + node.nodeSize);
          const range2 = relativeTo - relativeFrom;
          selectionRange += range2;
          markRanges.push(...node.marks.map((mark) => ({
            mark,
            from: relativeFrom,
            to: relativeTo
          })));
        });
      });
      if (selectionRange === 0) {
        return false;
      }
      const matchedRange = markRanges.filter((markRange) => {
        if (!type) {
          return true;
        }
        return type.name === markRange.mark.type.name;
      }).filter((markRange) => objectIncludes(markRange.mark.attrs, attributes, { strict: false })).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
      const excludedRange = markRanges.filter((markRange) => {
        if (!type) {
          return true;
        }
        return markRange.mark.type !== type && markRange.mark.type.excludes(type);
      }).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
      const range = matchedRange > 0 ? matchedRange + excludedRange : matchedRange;
      return range >= selectionRange;
    }
    var toggleMark = (typeOrName, attributes = {}, options2 = {}) => ({ state, commands }) => {
      const { extendEmptyMarkRange = false } = options2;
      const type = getMarkType(typeOrName, state.schema);
      const isActive2 = isMarkActive(state, type, attributes);
      if (isActive2) {
        return commands.unsetMark(type, { extendEmptyMarkRange });
      }
      return commands.setMark(type, attributes);
    };
    var toggleMark$1 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      toggleMark
    });
    var toggleNode = (typeOrName, toggleTypeOrName, attributes = {}) => ({ state, commands }) => {
      const type = getNodeType(typeOrName, state.schema);
      const toggleType = getNodeType(toggleTypeOrName, state.schema);
      const isActive2 = isNodeActive(state, type, attributes);
      if (isActive2) {
        return commands.setNode(toggleType);
      }
      return commands.setNode(type, attributes);
    };
    var toggleNode$1 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      toggleNode
    });
    var toggleWrap = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
      const type = getNodeType(typeOrName, state.schema);
      const isActive2 = isNodeActive(state, type, attributes);
      if (isActive2) {
        return prosemirrorCommands.lift(state, dispatch);
      }
      return prosemirrorCommands.wrapIn(type, attributes)(state, dispatch);
    };
    var toggleWrap$1 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      toggleWrap
    });
    var undoInputRule = () => ({ state, dispatch }) => {
      const plugins = state.plugins;
      for (let i = 0; i < plugins.length; i += 1) {
        const plugin = plugins[i];
        let undoable;
        if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {
          if (dispatch) {
            const tr = state.tr;
            const toUndo = undoable.transform;
            for (let j = toUndo.steps.length - 1; j >= 0; j -= 1) {
              tr.step(toUndo.steps[j].invert(toUndo.docs[j]));
            }
            if (undoable.text) {
              const marks = tr.doc.resolve(undoable.from).marks();
              tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));
            } else {
              tr.delete(undoable.from, undoable.to);
            }
          }
          return true;
        }
      }
      return false;
    };
    var undoInputRule$1 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      undoInputRule
    });
    var unsetAllMarks = () => ({ tr, state, dispatch }) => {
      const { selection } = tr;
      const { empty: empty2, ranges } = selection;
      if (empty2) {
        return true;
      }
      if (dispatch) {
        Object.entries(state.schema.marks).forEach(([, mark]) => {
          ranges.forEach((range) => {
            tr.removeMark(range.$from.pos, range.$to.pos, mark);
          });
        });
      }
      return true;
    };
    var unsetAllMarks$1 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      unsetAllMarks
    });
    var unsetMark = (typeOrName, options2 = {}) => ({ tr, state, dispatch }) => {
      var _a;
      const { extendEmptyMarkRange = false } = options2;
      const { selection } = tr;
      const type = getMarkType(typeOrName, state.schema);
      const { $from, empty: empty2, ranges } = selection;
      if (!dispatch) {
        return true;
      }
      if (empty2 && extendEmptyMarkRange) {
        let { from, to } = selection;
        const attrs = (_a = $from.marks().find((mark) => mark.type === type)) === null || _a === void 0 ? void 0 : _a.attrs;
        const range = getMarkRange($from, type, attrs);
        if (range) {
          from = range.from;
          to = range.to;
        }
        tr.removeMark(from, to, type);
      } else {
        ranges.forEach((range) => {
          tr.removeMark(range.$from.pos, range.$to.pos, type);
        });
      }
      tr.removeStoredMark(type);
      return true;
    };
    var unsetMark$1 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      unsetMark
    });
    var updateAttributes = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {
      let nodeType = null;
      let markType = null;
      const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
      if (!schemaType) {
        return false;
      }
      if (schemaType === "node") {
        nodeType = getNodeType(typeOrName, state.schema);
      }
      if (schemaType === "mark") {
        markType = getMarkType(typeOrName, state.schema);
      }
      if (dispatch) {
        tr.selection.ranges.forEach((range) => {
          const from = range.$from.pos;
          const to = range.$to.pos;
          state.doc.nodesBetween(from, to, (node, pos) => {
            if (nodeType && nodeType === node.type) {
              tr.setNodeMarkup(pos, void 0, {
                ...node.attrs,
                ...attributes
              });
            }
            if (markType && node.marks.length) {
              node.marks.forEach((mark) => {
                if (markType === mark.type) {
                  const trimmedFrom = Math.max(pos, from);
                  const trimmedTo = Math.min(pos + node.nodeSize, to);
                  tr.addMark(trimmedFrom, trimmedTo, markType.create({
                    ...mark.attrs,
                    ...attributes
                  }));
                }
              });
            }
          });
        });
      }
      return true;
    };
    var updateAttributes$1 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      updateAttributes
    });
    var wrapIn = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
      const type = getNodeType(typeOrName, state.schema);
      const isActive2 = isNodeActive(state, type, attributes);
      if (isActive2) {
        return false;
      }
      return prosemirrorCommands.wrapIn(type, attributes)(state, dispatch);
    };
    var wrapIn$1 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      wrapIn
    });
    var wrapInList = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
      const type = getNodeType(typeOrName, state.schema);
      return prosemirrorSchemaList.wrapInList(type, attributes)(state, dispatch);
    };
    var wrapInList$1 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      wrapInList
    });
    var Commands = Extension.create({
      name: "commands",
      addCommands() {
        return {
          ...blur$1,
          ...clearContent$1,
          ...clearNodes$1,
          ...command$1,
          ...createParagraphNear$1,
          ...deleteNode$1,
          ...deleteRange$1,
          ...deleteSelection$1,
          ...enter$1,
          ...exitCode$1,
          ...extendMarkRange$1,
          ...first$1,
          ...focus$1,
          ...forEach$1,
          ...insertContent$1,
          ...insertContentAt$1,
          ...joinBackward$1,
          ...joinForward$1,
          ...keyboardShortcut$1,
          ...lift$1,
          ...liftEmptyBlock$1,
          ...liftListItem$1,
          ...newlineInCode$1,
          ...resetAttributes$1,
          ...scrollIntoView$1,
          ...selectAll$1,
          ...selectNodeBackward$1,
          ...selectNodeForward$1,
          ...selectParentNode$1,
          ...setContent$1,
          ...setMark$1,
          ...setMeta$1,
          ...setNode$1,
          ...setNodeSelection$1,
          ...setTextSelection$1,
          ...sinkListItem$1,
          ...splitBlock$1,
          ...splitListItem$1,
          ...toggleList$1,
          ...toggleMark$1,
          ...toggleNode$1,
          ...toggleWrap$1,
          ...undoInputRule$1,
          ...unsetAllMarks$1,
          ...unsetMark$1,
          ...updateAttributes$1,
          ...wrapIn$1,
          ...wrapInList$1
        };
      }
    });
    var Editable = Extension.create({
      name: "editable",
      addProseMirrorPlugins() {
        return [
          new prosemirrorState.Plugin({
            key: new prosemirrorState.PluginKey("editable"),
            props: {
              editable: () => this.editor.options.editable
            }
          })
        ];
      }
    });
    var FocusEvents = Extension.create({
      name: "focusEvents",
      addProseMirrorPlugins() {
        const { editor } = this;
        return [
          new prosemirrorState.Plugin({
            key: new prosemirrorState.PluginKey("focusEvents"),
            props: {
              handleDOMEvents: {
                focus: (view, event) => {
                  editor.isFocused = true;
                  const transaction = editor.state.tr.setMeta("focus", { event }).setMeta("addToHistory", false);
                  view.dispatch(transaction);
                  return false;
                },
                blur: (view, event) => {
                  editor.isFocused = false;
                  const transaction = editor.state.tr.setMeta("blur", { event }).setMeta("addToHistory", false);
                  view.dispatch(transaction);
                  return false;
                }
              }
            }
          })
        ];
      }
    });
    var Keymap = Extension.create({
      name: "keymap",
      addKeyboardShortcuts() {
        const handleBackspace = () => this.editor.commands.first(({ commands }) => [
          () => commands.undoInputRule(),
          () => commands.deleteSelection(),
          () => commands.joinBackward(),
          () => commands.selectNodeBackward()
        ]);
        const handleDelete = () => this.editor.commands.first(({ commands }) => [
          () => commands.deleteSelection(),
          () => commands.joinForward(),
          () => commands.selectNodeForward()
        ]);
        return {
          Enter: () => this.editor.commands.first(({ commands }) => [
            () => commands.newlineInCode(),
            () => commands.createParagraphNear(),
            () => commands.liftEmptyBlock(),
            () => commands.splitBlock()
          ]),
          "Mod-Enter": () => this.editor.commands.exitCode(),
          Backspace: handleBackspace,
          "Mod-Backspace": handleBackspace,
          "Shift-Backspace": handleBackspace,
          Delete: handleDelete,
          "Mod-Delete": handleDelete,
          "Mod-a": () => this.editor.commands.selectAll()
        };
      }
    });
    var Tabindex = Extension.create({
      name: "tabindex",
      addProseMirrorPlugins() {
        return [
          new prosemirrorState.Plugin({
            key: new prosemirrorState.PluginKey("tabindex"),
            props: {
              attributes: {
                tabindex: "0"
              }
            }
          })
        ];
      }
    });
    var extensions = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      ClipboardTextSerializer,
      Commands,
      Editable,
      FocusEvents,
      Keymap,
      Tabindex
    });
    function getNodeAttributes(state, typeOrName) {
      const type = getNodeType(typeOrName, state.schema);
      const { from, to } = state.selection;
      const nodes = [];
      state.doc.nodesBetween(from, to, (node2) => {
        nodes.push(node2);
      });
      const node = nodes.reverse().find((nodeItem) => nodeItem.type.name === type.name);
      if (!node) {
        return {};
      }
      return { ...node.attrs };
    }
    function getAttributes(state, typeOrName) {
      const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
      if (schemaType === "node") {
        return getNodeAttributes(state, typeOrName);
      }
      if (schemaType === "mark") {
        return getMarkAttributes(state, typeOrName);
      }
      return {};
    }
    function isActive(state, name, attributes = {}) {
      if (!name) {
        return isNodeActive(state, null, attributes) || isMarkActive(state, null, attributes);
      }
      const schemaType = getSchemaTypeNameByName(name, state.schema);
      if (schemaType === "node") {
        return isNodeActive(state, name, attributes);
      }
      if (schemaType === "mark") {
        return isMarkActive(state, name, attributes);
      }
      return false;
    }
    function removeElement(element) {
      if (element === null || element === void 0 ? void 0 : element.parentNode) {
        element.parentNode.removeChild(element);
      }
    }
    function getHTMLFromFragment(fragment, schema) {
      const documentFragment = prosemirrorModel.DOMSerializer.fromSchema(schema).serializeFragment(fragment);
      const temporaryDocument = document.implementation.createHTMLDocument();
      const container = temporaryDocument.createElement("div");
      container.appendChild(documentFragment);
      return container.innerHTML;
    }
    function getText(node, options2) {
      const range = {
        from: 0,
        to: node.content.size
      };
      return getTextBetween(node, range, options2);
    }
    function isNodeEmpty(node) {
      var _a;
      const defaultContent = (_a = node.type.createAndFill()) === null || _a === void 0 ? void 0 : _a.toJSON();
      const content = node.toJSON();
      return JSON.stringify(defaultContent) === JSON.stringify(content);
    }
    function createStyleTag(style2) {
      const tipTapStyleTag = document.querySelector("style[data-tiptap-style]");
      if (tipTapStyleTag !== null) {
        return tipTapStyleTag;
      }
      const styleNode = document.createElement("style");
      styleNode.setAttribute("data-tiptap-style", "");
      styleNode.innerHTML = style2;
      document.getElementsByTagName("head")[0].appendChild(styleNode);
      return styleNode;
    }
    function createChainableState(config) {
      const { state, transaction } = config;
      let { selection } = transaction;
      let { doc } = transaction;
      let { storedMarks } = transaction;
      return {
        ...state,
        schema: state.schema,
        plugins: state.plugins,
        apply: state.apply.bind(state),
        applyTransaction: state.applyTransaction.bind(state),
        reconfigure: state.reconfigure.bind(state),
        toJSON: state.toJSON.bind(state),
        get storedMarks() {
          return storedMarks;
        },
        get selection() {
          return selection;
        },
        get doc() {
          return doc;
        },
        get tr() {
          selection = transaction.selection;
          doc = transaction.doc;
          storedMarks = transaction.storedMarks;
          return transaction;
        }
      };
    }
    var CommandManager = class {
      constructor(editor, commands) {
        this.editor = editor;
        this.commands = commands;
      }
      createCommands() {
        const { commands, editor } = this;
        const { state, view } = editor;
        const { tr } = state;
        const props = this.buildProps(tr);
        return Object.fromEntries(Object.entries(commands).map(([name, command2]) => {
          const method = (...args) => {
            const callback = command2(...args)(props);
            if (!tr.getMeta("preventDispatch")) {
              view.dispatch(tr);
            }
            return callback;
          };
          return [name, method];
        }));
      }
      createChain(startTr, shouldDispatch = true) {
        const { commands, editor } = this;
        const { state, view } = editor;
        const callbacks = [];
        const hasStartTransaction = !!startTr;
        const tr = startTr || state.tr;
        const run3 = () => {
          if (!hasStartTransaction && shouldDispatch && !tr.getMeta("preventDispatch")) {
            view.dispatch(tr);
          }
          return callbacks.every((callback) => callback === true);
        };
        const chain = {
          ...Object.fromEntries(Object.entries(commands).map(([name, command2]) => {
            const chainedCommand = (...args) => {
              const props = this.buildProps(tr, shouldDispatch);
              const callback = command2(...args)(props);
              callbacks.push(callback);
              return chain;
            };
            return [name, chainedCommand];
          })),
          run: run3
        };
        return chain;
      }
      createCan(startTr) {
        const { commands, editor } = this;
        const { state } = editor;
        const dispatch = void 0;
        const tr = startTr || state.tr;
        const props = this.buildProps(tr, dispatch);
        const formattedCommands = Object.fromEntries(Object.entries(commands).map(([name, command2]) => {
          return [name, (...args) => command2(...args)({ ...props, dispatch })];
        }));
        return {
          ...formattedCommands,
          chain: () => this.createChain(tr, dispatch)
        };
      }
      buildProps(tr, shouldDispatch = true) {
        const { editor, commands } = this;
        const { state, view } = editor;
        if (state.storedMarks) {
          tr.setStoredMarks(state.storedMarks);
        }
        const props = {
          tr,
          editor,
          view,
          state: createChainableState({
            state,
            transaction: tr
          }),
          dispatch: shouldDispatch ? () => void 0 : void 0,
          chain: () => this.createChain(tr),
          can: () => this.createCan(tr),
          get commands() {
            return Object.fromEntries(Object.entries(commands).map(([name, command2]) => {
              return [name, (...args) => command2(...args)(props)];
            }));
          }
        };
        return props;
      }
    };
    var InputRule = class {
      constructor(config) {
        this.find = config.find;
        this.handler = config.handler;
      }
    };
    var inputRuleMatcherHandler = (text, find) => {
      if (isRegExp(find)) {
        return find.exec(text);
      }
      const inputRuleMatch = find(text);
      if (!inputRuleMatch) {
        return null;
      }
      const result = [];
      result.push(inputRuleMatch.text);
      result.index = inputRuleMatch.index;
      result.input = text;
      result.data = inputRuleMatch.data;
      if (inputRuleMatch.replaceWith) {
        if (!inputRuleMatch.text.includes(inputRuleMatch.replaceWith)) {
          console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".');
        }
        result.push(inputRuleMatch.replaceWith);
      }
      return result;
    };
    function run$1(config) {
      var _a;
      const { view, from, to, text, rules, plugin } = config;
      if (view.composing) {
        return false;
      }
      const $from = view.state.doc.resolve(from);
      if ($from.parent.type.spec.code || !!((_a = $from.nodeBefore || $from.nodeAfter) === null || _a === void 0 ? void 0 : _a.marks.find((mark) => mark.type.spec.code))) {
        return false;
      }
      let matched = false;
      const maxMatch = 500;
      const textBefore = $from.parent.textBetween(Math.max(0, $from.parentOffset - maxMatch), $from.parentOffset, void 0, "\uFFFC") + text;
      rules.forEach((rule) => {
        if (matched) {
          return;
        }
        const match = inputRuleMatcherHandler(textBefore, rule.find);
        if (!match) {
          return;
        }
        const tr = view.state.tr;
        const state = createChainableState({
          state: view.state,
          transaction: tr
        });
        const range = {
          from: from - (match[0].length - text.length),
          to
        };
        rule.handler({
          state,
          range,
          match
        });
        if (!tr.steps.length) {
          return;
        }
        tr.setMeta(plugin, {
          transform: tr,
          from,
          to,
          text
        });
        view.dispatch(tr);
        matched = true;
      });
      return matched;
    }
    function inputRulesPlugin(rules) {
      const plugin = new prosemirrorState.Plugin({
        state: {
          init() {
            return null;
          },
          apply(tr, prev) {
            const stored = tr.getMeta(this);
            if (stored) {
              return stored;
            }
            return tr.selectionSet || tr.docChanged ? null : prev;
          }
        },
        props: {
          handleTextInput(view, from, to, text) {
            return run$1({
              view,
              from,
              to,
              text,
              rules,
              plugin
            });
          },
          handleDOMEvents: {
            compositionend: (view) => {
              setTimeout(() => {
                const { $cursor } = view.state.selection;
                if ($cursor) {
                  run$1({
                    view,
                    from: $cursor.pos,
                    to: $cursor.pos,
                    text: "",
                    rules,
                    plugin
                  });
                }
              });
              return false;
            }
          },
          handleKeyDown(view, event) {
            if (event.key !== "Enter") {
              return false;
            }
            const { $cursor } = view.state.selection;
            if ($cursor) {
              return run$1({
                view,
                from: $cursor.pos,
                to: $cursor.pos,
                text: "\n",
                rules,
                plugin
              });
            }
            return false;
          }
        },
        isInputRules: true
      });
      return plugin;
    }
    var PasteRule = class {
      constructor(config) {
        this.find = config.find;
        this.handler = config.handler;
      }
    };
    var pasteRuleMatcherHandler = (text, find) => {
      if (isRegExp(find)) {
        return [...text.matchAll(find)];
      }
      const matches = find(text);
      if (!matches) {
        return [];
      }
      return matches.map((pasteRuleMatch) => {
        const result = [];
        result.push(pasteRuleMatch.text);
        result.index = pasteRuleMatch.index;
        result.input = text;
        result.data = pasteRuleMatch.data;
        if (pasteRuleMatch.replaceWith) {
          if (!pasteRuleMatch.text.includes(pasteRuleMatch.replaceWith)) {
            console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".');
          }
          result.push(pasteRuleMatch.replaceWith);
        }
        return result;
      });
    };
    function run2(config) {
      const { state, from, to, rules } = config;
      state.doc.nodesBetween(from, to, (node, pos) => {
        if (!node.isTextblock || node.type.spec.code) {
          return;
        }
        const resolvedFrom = Math.max(from, pos);
        const resolvedTo = Math.min(to, pos + node.content.size);
        const textToMatch = node.textBetween(resolvedFrom - pos, resolvedTo - pos, void 0, "\uFFFC");
        rules.forEach((rule) => {
          const matches = pasteRuleMatcherHandler(textToMatch, rule.find);
          matches.forEach((match) => {
            if (match.index === void 0) {
              return;
            }
            const start = resolvedFrom + match.index + 1;
            const end = start + match[0].length;
            const range = {
              from: state.tr.mapping.map(start),
              to: state.tr.mapping.map(end)
            };
            rule.handler({
              state,
              range,
              match
            });
          });
        });
      });
    }
    function pasteRulesPlugin(rules) {
      const plugin = new prosemirrorState.Plugin({
        appendTransaction: (transactions, oldState, state) => {
          const transaction = transactions[0];
          if (!transaction.getMeta("paste")) {
            return;
          }
          const { doc, before } = transaction;
          const from = before.content.findDiffStart(doc.content);
          const to = before.content.findDiffEnd(doc.content);
          if (!from || !to || from === to.b) {
            return;
          }
          const tr = state.tr;
          const chainableState = createChainableState({
            state,
            transaction: tr
          });
          run2({
            state: chainableState,
            from: Math.max(from - 1, 0),
            to: to.b,
            rules,
            plugin
          });
          if (!tr.steps.length) {
            return;
          }
          return tr;
        },
        isPasteRules: true
      });
      return plugin;
    }
    function getAttributesFromExtensions(extensions2) {
      const extensionAttributes = [];
      const { nodeExtensions, markExtensions } = splitExtensions(extensions2);
      const nodeAndMarkExtensions = [...nodeExtensions, ...markExtensions];
      const defaultAttribute = {
        default: null,
        rendered: true,
        renderHTML: null,
        parseHTML: null,
        keepOnSplit: true
      };
      extensions2.forEach((extension) => {
        const context = {
          name: extension.name,
          options: extension.options
        };
        const addGlobalAttributes = getExtensionField(extension, "addGlobalAttributes", context);
        if (!addGlobalAttributes) {
          return;
        }
        const globalAttributes = addGlobalAttributes();
        globalAttributes.forEach((globalAttribute) => {
          globalAttribute.types.forEach((type) => {
            Object.entries(globalAttribute.attributes).forEach(([name, attribute]) => {
              extensionAttributes.push({
                type,
                name,
                attribute: {
                  ...defaultAttribute,
                  ...attribute
                }
              });
            });
          });
        });
      });
      nodeAndMarkExtensions.forEach((extension) => {
        const context = {
          name: extension.name,
          options: extension.options
        };
        const addAttributes = getExtensionField(extension, "addAttributes", context);
        if (!addAttributes) {
          return;
        }
        const attributes = addAttributes();
        Object.entries(attributes).forEach(([name, attribute]) => {
          extensionAttributes.push({
            type: extension.name,
            name,
            attribute: {
              ...defaultAttribute,
              ...attribute
            }
          });
        });
      });
      return extensionAttributes;
    }
    function mergeAttributes(...objects) {
      return objects.filter((item) => !!item).reduce((items, item) => {
        const mergedAttributes = { ...items };
        Object.entries(item).forEach(([key, value]) => {
          const exists = mergedAttributes[key];
          if (!exists) {
            mergedAttributes[key] = value;
            return;
          }
          if (key === "class") {
            mergedAttributes[key] = [mergedAttributes[key], value].join(" ");
          } else if (key === "style") {
            mergedAttributes[key] = [mergedAttributes[key], value].join("; ");
          } else {
            mergedAttributes[key] = value;
          }
        });
        return mergedAttributes;
      }, {});
    }
    function getRenderedAttributes(nodeOrMark, extensionAttributes) {
      return extensionAttributes.filter((item) => item.attribute.rendered).map((item) => {
        if (!item.attribute.renderHTML) {
          return {
            [item.name]: nodeOrMark.attrs[item.name]
          };
        }
        return item.attribute.renderHTML(nodeOrMark.attrs) || {};
      }).reduce((attributes, attribute) => mergeAttributes(attributes, attribute), {});
    }
    function isEmptyObject(value = {}) {
      return Object.keys(value).length === 0 && value.constructor === Object;
    }
    function fromString(value) {
      if (typeof value !== "string") {
        return value;
      }
      if (value.match(/^\d*(\.\d+)?$/)) {
        return Number(value);
      }
      if (value === "true") {
        return true;
      }
      if (value === "false") {
        return false;
      }
      return value;
    }
    function injectExtensionAttributesToParseRule(parseRule, extensionAttributes) {
      if (parseRule.style) {
        return parseRule;
      }
      return {
        ...parseRule,
        getAttrs: (node) => {
          const oldAttributes = parseRule.getAttrs ? parseRule.getAttrs(node) : parseRule.attrs;
          if (oldAttributes === false) {
            return false;
          }
          const newAttributes = extensionAttributes.filter((item) => item.attribute.rendered).reduce((items, item) => {
            const value = item.attribute.parseHTML ? item.attribute.parseHTML(node) : fromString(node.getAttribute(item.name));
            if (isObject$1(value)) {
              console.warn(`[tiptap warn]: BREAKING CHANGE: "parseHTML" for your attribute "${item.name}" returns an object but should return the value itself. If this is expected you can ignore this message. This warning will be removed in one of the next releases. Further information: https://github.com/ueberdosis/tiptap/issues/1863`);
            }
            if (value === null || value === void 0) {
              return items;
            }
            return {
              ...items,
              [item.name]: value
            };
          }, {});
          return { ...oldAttributes, ...newAttributes };
        }
      };
    }
    function cleanUpSchemaItem(data) {
      return Object.fromEntries(Object.entries(data).filter(([key, value]) => {
        if (key === "attrs" && isEmptyObject(value)) {
          return false;
        }
        return value !== null && value !== void 0;
      }));
    }
    function getSchemaByResolvedExtensions(extensions2) {
      var _a;
      const allAttributes = getAttributesFromExtensions(extensions2);
      const { nodeExtensions, markExtensions } = splitExtensions(extensions2);
      const topNode = (_a = nodeExtensions.find((extension) => getExtensionField(extension, "topNode"))) === null || _a === void 0 ? void 0 : _a.name;
      const nodes = Object.fromEntries(nodeExtensions.map((extension) => {
        const extensionAttributes = allAttributes.filter((attribute) => attribute.type === extension.name);
        const context = {
          name: extension.name,
          options: extension.options
        };
        const extraNodeFields = extensions2.reduce((fields, e) => {
          const extendNodeSchema = getExtensionField(e, "extendNodeSchema", context);
          return {
            ...fields,
            ...extendNodeSchema ? extendNodeSchema(extension) : {}
          };
        }, {});
        const schema = cleanUpSchemaItem({
          ...extraNodeFields,
          content: callOrReturn(getExtensionField(extension, "content", context)),
          marks: callOrReturn(getExtensionField(extension, "marks", context)),
          group: callOrReturn(getExtensionField(extension, "group", context)),
          inline: callOrReturn(getExtensionField(extension, "inline", context)),
          atom: callOrReturn(getExtensionField(extension, "atom", context)),
          selectable: callOrReturn(getExtensionField(extension, "selectable", context)),
          draggable: callOrReturn(getExtensionField(extension, "draggable", context)),
          code: callOrReturn(getExtensionField(extension, "code", context)),
          defining: callOrReturn(getExtensionField(extension, "defining", context)),
          isolating: callOrReturn(getExtensionField(extension, "isolating", context)),
          attrs: Object.fromEntries(extensionAttributes.map((extensionAttribute) => {
            var _a2;
            return [extensionAttribute.name, { default: (_a2 = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a2 === void 0 ? void 0 : _a2.default }];
          }))
        });
        const parseHTML = callOrReturn(getExtensionField(extension, "parseHTML", context));
        if (parseHTML) {
          schema.parseDOM = parseHTML.map((parseRule) => injectExtensionAttributesToParseRule(parseRule, extensionAttributes));
        }
        const renderHTML = getExtensionField(extension, "renderHTML", context);
        if (renderHTML) {
          schema.toDOM = (node) => renderHTML({
            node,
            HTMLAttributes: getRenderedAttributes(node, extensionAttributes)
          });
        }
        const renderText = getExtensionField(extension, "renderText", context);
        if (renderText) {
          schema.toText = renderText;
        }
        return [extension.name, schema];
      }));
      const marks = Object.fromEntries(markExtensions.map((extension) => {
        const extensionAttributes = allAttributes.filter((attribute) => attribute.type === extension.name);
        const context = {
          name: extension.name,
          options: extension.options
        };
        const extraMarkFields = extensions2.reduce((fields, e) => {
          const extendMarkSchema = getExtensionField(e, "extendMarkSchema", context);
          return {
            ...fields,
            ...extendMarkSchema ? extendMarkSchema(extension) : {}
          };
        }, {});
        const schema = cleanUpSchemaItem({
          ...extraMarkFields,
          inclusive: callOrReturn(getExtensionField(extension, "inclusive", context)),
          excludes: callOrReturn(getExtensionField(extension, "excludes", context)),
          group: callOrReturn(getExtensionField(extension, "group", context)),
          spanning: callOrReturn(getExtensionField(extension, "spanning", context)),
          code: callOrReturn(getExtensionField(extension, "code", context)),
          attrs: Object.fromEntries(extensionAttributes.map((extensionAttribute) => {
            var _a2;
            return [extensionAttribute.name, { default: (_a2 = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a2 === void 0 ? void 0 : _a2.default }];
          }))
        });
        const parseHTML = callOrReturn(getExtensionField(extension, "parseHTML", context));
        if (parseHTML) {
          schema.parseDOM = parseHTML.map((parseRule) => injectExtensionAttributesToParseRule(parseRule, extensionAttributes));
        }
        const renderHTML = getExtensionField(extension, "renderHTML", context);
        if (renderHTML) {
          schema.toDOM = (mark) => renderHTML({
            mark,
            HTMLAttributes: getRenderedAttributes(mark, extensionAttributes)
          });
        }
        return [extension.name, schema];
      }));
      return new prosemirrorModel.Schema({
        topNode,
        nodes,
        marks
      });
    }
    function getSchemaTypeByName(name, schema) {
      return schema.nodes[name] || schema.marks[name] || null;
    }
    var ExtensionManager = class {
      constructor(extensions2, editor) {
        this.splittableMarks = [];
        this.editor = editor;
        this.extensions = ExtensionManager.resolve(extensions2);
        this.schema = getSchemaByResolvedExtensions(this.extensions);
        this.extensions.forEach((extension) => {
          var _a;
          const context = {
            name: extension.name,
            options: extension.options,
            editor: this.editor,
            type: getSchemaTypeByName(extension.name, this.schema)
          };
          if (extension.type === "mark") {
            const keepOnSplit = (_a = callOrReturn(getExtensionField(extension, "keepOnSplit", context))) !== null && _a !== void 0 ? _a : true;
            if (keepOnSplit) {
              this.splittableMarks.push(extension.name);
            }
          }
          const onBeforeCreate = getExtensionField(extension, "onBeforeCreate", context);
          if (onBeforeCreate) {
            this.editor.on("beforeCreate", onBeforeCreate);
          }
          const onCreate = getExtensionField(extension, "onCreate", context);
          if (onCreate) {
            this.editor.on("create", onCreate);
          }
          const onUpdate = getExtensionField(extension, "onUpdate", context);
          if (onUpdate) {
            this.editor.on("update", onUpdate);
          }
          const onSelectionUpdate = getExtensionField(extension, "onSelectionUpdate", context);
          if (onSelectionUpdate) {
            this.editor.on("selectionUpdate", onSelectionUpdate);
          }
          const onTransaction = getExtensionField(extension, "onTransaction", context);
          if (onTransaction) {
            this.editor.on("transaction", onTransaction);
          }
          const onFocus = getExtensionField(extension, "onFocus", context);
          if (onFocus) {
            this.editor.on("focus", onFocus);
          }
          const onBlur = getExtensionField(extension, "onBlur", context);
          if (onBlur) {
            this.editor.on("blur", onBlur);
          }
          const onDestroy = getExtensionField(extension, "onDestroy", context);
          if (onDestroy) {
            this.editor.on("destroy", onDestroy);
          }
        });
      }
      static resolve(extensions2) {
        return ExtensionManager.sort(ExtensionManager.flatten(extensions2));
      }
      static flatten(extensions2) {
        return extensions2.map((extension) => {
          const context = {
            name: extension.name,
            options: extension.options
          };
          const addExtensions = getExtensionField(extension, "addExtensions", context);
          if (addExtensions) {
            return [
              extension,
              ...this.flatten(addExtensions())
            ];
          }
          return extension;
        }).flat(10);
      }
      static sort(extensions2) {
        const defaultPriority = 100;
        return extensions2.sort((a, b) => {
          const priorityA = getExtensionField(a, "priority") || defaultPriority;
          const priorityB = getExtensionField(b, "priority") || defaultPriority;
          if (priorityA > priorityB) {
            return -1;
          }
          if (priorityA < priorityB) {
            return 1;
          }
          return 0;
        });
      }
      get commands() {
        return this.extensions.reduce((commands, extension) => {
          const context = {
            name: extension.name,
            options: extension.options,
            editor: this.editor,
            type: getSchemaTypeByName(extension.name, this.schema)
          };
          const addCommands = getExtensionField(extension, "addCommands", context);
          if (!addCommands) {
            return commands;
          }
          return {
            ...commands,
            ...addCommands()
          };
        }, {});
      }
      get plugins() {
        const extensions2 = ExtensionManager.sort([...this.extensions].reverse());
        const inputRules = [];
        const pasteRules = [];
        const allPlugins = extensions2.map((extension) => {
          const context = {
            name: extension.name,
            options: extension.options,
            editor: this.editor,
            type: getSchemaTypeByName(extension.name, this.schema)
          };
          const plugins = [];
          const addKeyboardShortcuts = getExtensionField(extension, "addKeyboardShortcuts", context);
          if (addKeyboardShortcuts) {
            const bindings = Object.fromEntries(Object.entries(addKeyboardShortcuts()).map(([shortcut, method]) => {
              return [shortcut, () => method({ editor: this.editor })];
            }));
            const keyMapPlugin = prosemirrorKeymap.keymap(bindings);
            plugins.push(keyMapPlugin);
          }
          const addInputRules = getExtensionField(extension, "addInputRules", context);
          if (this.editor.options.enableInputRules && addInputRules) {
            inputRules.push(...addInputRules());
          }
          const addPasteRules = getExtensionField(extension, "addPasteRules", context);
          if (this.editor.options.enablePasteRules && addPasteRules) {
            pasteRules.push(...addPasteRules());
          }
          const addProseMirrorPlugins = getExtensionField(extension, "addProseMirrorPlugins", context);
          if (addProseMirrorPlugins) {
            const proseMirrorPlugins = addProseMirrorPlugins();
            plugins.push(...proseMirrorPlugins);
          }
          return plugins;
        }).flat();
        return [
          inputRulesPlugin(inputRules),
          pasteRulesPlugin(pasteRules),
          ...allPlugins
        ];
      }
      get attributes() {
        return getAttributesFromExtensions(this.extensions);
      }
      get nodeViews() {
        const { editor } = this;
        const { nodeExtensions } = splitExtensions(this.extensions);
        return Object.fromEntries(nodeExtensions.filter((extension) => !!getExtensionField(extension, "addNodeView")).map((extension) => {
          const extensionAttributes = this.attributes.filter((attribute) => attribute.type === extension.name);
          const context = {
            name: extension.name,
            options: extension.options,
            editor,
            type: getNodeType(extension.name, this.schema)
          };
          const addNodeView = getExtensionField(extension, "addNodeView", context);
          if (!addNodeView) {
            return [];
          }
          const nodeview = (node, view, getPos, decorations) => {
            const HTMLAttributes = getRenderedAttributes(node, extensionAttributes);
            return addNodeView()({
              editor,
              node,
              getPos,
              decorations,
              HTMLAttributes,
              extension
            });
          };
          return [extension.name, nodeview];
        }));
      }
    };
    var EventEmitter = class {
      constructor() {
        this.callbacks = {};
      }
      on(event, fn) {
        if (!this.callbacks[event]) {
          this.callbacks[event] = [];
        }
        this.callbacks[event].push(fn);
        return this;
      }
      emit(event, ...args) {
        const callbacks = this.callbacks[event];
        if (callbacks) {
          callbacks.forEach((callback) => callback.apply(this, args));
        }
        return this;
      }
      off(event, fn) {
        const callbacks = this.callbacks[event];
        if (callbacks) {
          if (fn) {
            this.callbacks[event] = callbacks.filter((callback) => callback !== fn);
          } else {
            delete this.callbacks[event];
          }
        }
        return this;
      }
      removeAllListeners() {
        this.callbacks = {};
      }
    };
    var style = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}

.tippy-box[data-animation=fade][data-state=hidden] {
  opacity: 0
}`;
    var Editor = class extends EventEmitter {
      constructor(options2 = {}) {
        super();
        this.isFocused = false;
        this.options = {
          element: document.createElement("div"),
          content: "",
          injectCSS: true,
          extensions: [],
          autofocus: false,
          editable: true,
          editorProps: {},
          parseOptions: {},
          enableInputRules: true,
          enablePasteRules: true,
          enableCoreExtensions: true,
          onBeforeCreate: () => null,
          onCreate: () => null,
          onUpdate: () => null,
          onSelectionUpdate: () => null,
          onTransaction: () => null,
          onFocus: () => null,
          onBlur: () => null,
          onDestroy: () => null
        };
        this.isCapturingTransaction = false;
        this.capturedTransaction = null;
        this.setOptions(options2);
        this.createExtensionManager();
        this.createCommandManager();
        this.createSchema();
        this.on("beforeCreate", this.options.onBeforeCreate);
        this.emit("beforeCreate", { editor: this });
        this.createView();
        this.injectCSS();
        this.on("create", this.options.onCreate);
        this.on("update", this.options.onUpdate);
        this.on("selectionUpdate", this.options.onSelectionUpdate);
        this.on("transaction", this.options.onTransaction);
        this.on("focus", this.options.onFocus);
        this.on("blur", this.options.onBlur);
        this.on("destroy", this.options.onDestroy);
        window.setTimeout(() => {
          if (this.isDestroyed) {
            return;
          }
          this.commands.focus(this.options.autofocus);
          this.emit("create", { editor: this });
        }, 0);
      }
      get commands() {
        return this.commandManager.createCommands();
      }
      chain() {
        return this.commandManager.createChain();
      }
      can() {
        return this.commandManager.createCan();
      }
      injectCSS() {
        if (this.options.injectCSS && document) {
          this.css = createStyleTag(style);
        }
      }
      setOptions(options2 = {}) {
        this.options = {
          ...this.options,
          ...options2
        };
        if (!this.view || !this.state || this.isDestroyed) {
          return;
        }
        if (this.options.editorProps) {
          this.view.setProps(this.options.editorProps);
        }
        this.view.updateState(this.state);
      }
      setEditable(editable) {
        this.setOptions({ editable });
      }
      get isEditable() {
        return this.options.editable && this.view && this.view.editable;
      }
      get state() {
        return this.view.state;
      }
      registerPlugin(plugin, handlePlugins) {
        const plugins = isObject(handlePlugins) ? handlePlugins(plugin, this.state.plugins) : [...this.state.plugins, plugin];
        const state = this.state.reconfigure({ plugins });
        this.view.updateState(state);
      }
      unregisterPlugin(nameOrPluginKey) {
        if (this.isDestroyed) {
          return;
        }
        const name = typeof nameOrPluginKey === "string" ? `${nameOrPluginKey}$` : nameOrPluginKey.key;
        const state = this.state.reconfigure({
          plugins: this.state.plugins.filter((plugin) => !plugin.key.startsWith(name))
        });
        this.view.updateState(state);
      }
      createExtensionManager() {
        const coreExtensions = this.options.enableCoreExtensions ? Object.values(extensions) : [];
        const allExtensions = [...coreExtensions, ...this.options.extensions].filter((extension) => {
          return ["extension", "node", "mark"].includes(extension === null || extension === void 0 ? void 0 : extension.type);
        });
        this.extensionManager = new ExtensionManager(allExtensions, this);
      }
      createCommandManager() {
        this.commandManager = new CommandManager(this, this.extensionManager.commands);
      }
      createSchema() {
        this.schema = this.extensionManager.schema;
      }
      createView() {
        this.view = new prosemirrorView.EditorView(this.options.element, {
          ...this.options.editorProps,
          dispatchTransaction: this.dispatchTransaction.bind(this),
          state: prosemirrorState.EditorState.create({
            doc: createDocument(this.options.content, this.schema, this.options.parseOptions)
          })
        });
        const newState = this.state.reconfigure({
          plugins: this.extensionManager.plugins
        });
        this.view.updateState(newState);
        this.createNodeViews();
        const dom = this.view.dom;
        dom.editor = this;
      }
      createNodeViews() {
        this.view.setProps({
          nodeViews: this.extensionManager.nodeViews
        });
      }
      captureTransaction(fn) {
        this.isCapturingTransaction = true;
        fn();
        this.isCapturingTransaction = false;
        const tr = this.capturedTransaction;
        this.capturedTransaction = null;
        return tr;
      }
      dispatchTransaction(transaction) {
        if (this.isCapturingTransaction) {
          if (!this.capturedTransaction) {
            this.capturedTransaction = transaction;
            return;
          }
          transaction.steps.forEach((step) => {
            var _a;
            return (_a = this.capturedTransaction) === null || _a === void 0 ? void 0 : _a.step(step);
          });
          return;
        }
        const state = this.state.apply(transaction);
        const selectionHasChanged = !this.state.selection.eq(state.selection);
        this.view.updateState(state);
        this.emit("transaction", {
          editor: this,
          transaction
        });
        if (selectionHasChanged) {
          this.emit("selectionUpdate", {
            editor: this,
            transaction
          });
        }
        const focus2 = transaction.getMeta("focus");
        const blur2 = transaction.getMeta("blur");
        if (focus2) {
          this.emit("focus", {
            editor: this,
            event: focus2.event,
            transaction
          });
        }
        if (blur2) {
          this.emit("blur", {
            editor: this,
            event: blur2.event,
            transaction
          });
        }
        if (!transaction.docChanged || transaction.getMeta("preventUpdate")) {
          return;
        }
        this.emit("update", {
          editor: this,
          transaction
        });
      }
      getAttributes(nameOrType) {
        return getAttributes(this.state, nameOrType);
      }
      isActive(nameOrAttributes, attributesOrUndefined) {
        const name = typeof nameOrAttributes === "string" ? nameOrAttributes : null;
        const attributes = typeof nameOrAttributes === "string" ? attributesOrUndefined : nameOrAttributes;
        return isActive(this.state, name, attributes);
      }
      getJSON() {
        return this.state.doc.toJSON();
      }
      getHTML() {
        return getHTMLFromFragment(this.state.doc.content, this.schema);
      }
      getText(options2) {
        const { blockSeparator = "\n\n", textSerializers = {} } = options2 || {};
        return getText(this.state.doc, {
          blockSeparator,
          textSerializers: {
            ...textSerializers,
            ...getTextSeralizersFromSchema(this.schema)
          }
        });
      }
      get isEmpty() {
        return isNodeEmpty(this.state.doc);
      }
      getCharacterCount() {
        return this.state.doc.content.size - 2;
      }
      destroy() {
        this.emit("destroy");
        if (this.view) {
          this.view.destroy();
        }
        this.removeAllListeners();
        removeElement(this.css);
      }
      get isDestroyed() {
        var _a;
        return !((_a = this.view) === null || _a === void 0 ? void 0 : _a.docView);
      }
    };
    var Node = class {
      constructor(config = {}) {
        this.type = "node";
        this.name = "node";
        this.parent = null;
        this.child = null;
        this.config = {
          name: this.name,
          defaultOptions: {}
        };
        this.config = {
          ...this.config,
          ...config
        };
        this.name = this.config.name;
        this.options = this.config.defaultOptions;
      }
      static create(config = {}) {
        return new Node(config);
      }
      configure(options2 = {}) {
        const extension = this.extend();
        extension.options = mergeDeep(this.options, options2);
        return extension;
      }
      extend(extendedConfig = {}) {
        const extension = new Node(extendedConfig);
        extension.parent = this;
        this.child = extension;
        extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
        extension.options = extendedConfig.defaultOptions ? extendedConfig.defaultOptions : extension.parent.options;
        return extension;
      }
    };
    var Mark = class {
      constructor(config = {}) {
        this.type = "mark";
        this.name = "mark";
        this.parent = null;
        this.child = null;
        this.config = {
          name: this.name,
          defaultOptions: {}
        };
        this.config = {
          ...this.config,
          ...config
        };
        this.name = this.config.name;
        this.options = this.config.defaultOptions;
      }
      static create(config = {}) {
        return new Mark(config);
      }
      configure(options2 = {}) {
        const extension = this.extend();
        extension.options = mergeDeep(this.options, options2);
        return extension;
      }
      extend(extendedConfig = {}) {
        const extension = new Mark(extendedConfig);
        extension.parent = this;
        this.child = extension;
        extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
        extension.options = extendedConfig.defaultOptions ? extendedConfig.defaultOptions : extension.parent.options;
        return extension;
      }
    };
    var NodeView = class {
      constructor(component, props, options2) {
        this.isDragging = false;
        this.component = component;
        this.editor = props.editor;
        this.options = {
          stopEvent: null,
          ignoreMutation: null,
          ...options2
        };
        this.extension = props.extension;
        this.node = props.node;
        this.decorations = props.decorations;
        this.getPos = props.getPos;
        this.mount();
      }
      mount() {
        return;
      }
      get dom() {
        return null;
      }
      get contentDOM() {
        return null;
      }
      onDragStart(event) {
        var _a, _b, _c;
        const { view } = this.editor;
        const target = event.target;
        const dragHandle = target.nodeType === 3 ? (_a = target.parentElement) === null || _a === void 0 ? void 0 : _a.closest("[data-drag-handle]") : target.closest("[data-drag-handle]");
        if (!this.dom || ((_b = this.contentDOM) === null || _b === void 0 ? void 0 : _b.contains(target)) || !dragHandle) {
          return;
        }
        let x = 0;
        let y = 0;
        if (this.dom !== dragHandle) {
          const domBox = this.dom.getBoundingClientRect();
          const handleBox = dragHandle.getBoundingClientRect();
          x = handleBox.x - domBox.x + event.offsetX;
          y = handleBox.y - domBox.y + event.offsetY;
        }
        (_c = event.dataTransfer) === null || _c === void 0 ? void 0 : _c.setDragImage(this.dom, x, y);
        const selection = prosemirrorState.NodeSelection.create(view.state.doc, this.getPos());
        const transaction = view.state.tr.setSelection(selection);
        view.dispatch(transaction);
      }
      stopEvent(event) {
        var _a;
        if (!this.dom) {
          return false;
        }
        if (typeof this.options.stopEvent === "function") {
          return this.options.stopEvent({ event });
        }
        const target = event.target;
        const isInElement = this.dom.contains(target) && !((_a = this.contentDOM) === null || _a === void 0 ? void 0 : _a.contains(target));
        if (!isInElement) {
          return false;
        }
        const isInput = ["INPUT", "BUTTON", "SELECT", "TEXTAREA"].includes(target.tagName) || target.isContentEditable;
        if (isInput) {
          return true;
        }
        const { isEditable } = this.editor;
        const { isDragging } = this;
        const isDraggable = !!this.node.type.spec.draggable;
        const isSelectable = prosemirrorState.NodeSelection.isSelectable(this.node);
        const isCopyEvent = event.type === "copy";
        const isPasteEvent = event.type === "paste";
        const isCutEvent = event.type === "cut";
        const isClickEvent = event.type === "mousedown";
        const isDragEvent = event.type.startsWith("drag") || event.type === "drop";
        if (!isDraggable && isSelectable && isDragEvent) {
          event.preventDefault();
        }
        if (isDraggable && isDragEvent && !isDragging) {
          event.preventDefault();
          return false;
        }
        if (isDraggable && isEditable && !isDragging && isClickEvent) {
          const dragHandle = target.closest("[data-drag-handle]");
          const isValidDragHandle = dragHandle && (this.dom === dragHandle || this.dom.contains(dragHandle));
          if (isValidDragHandle) {
            this.isDragging = true;
            document.addEventListener("dragend", () => {
              this.isDragging = false;
            }, { once: true });
            document.addEventListener("mouseup", () => {
              this.isDragging = false;
            }, { once: true });
          }
        }
        if (isDragging || isCopyEvent || isPasteEvent || isCutEvent || isClickEvent && isSelectable) {
          return false;
        }
        return true;
      }
      ignoreMutation(mutation) {
        if (!this.dom || !this.contentDOM) {
          return true;
        }
        if (typeof this.options.ignoreMutation === "function") {
          return this.options.ignoreMutation({ mutation });
        }
        if (this.node.isLeaf || this.node.isAtom) {
          return true;
        }
        if (mutation.type === "selection") {
          return false;
        }
        if (this.dom.contains(mutation.target) && mutation.type === "childList" && isiOS()) {
          const changedNodes = [
            ...Array.from(mutation.addedNodes),
            ...Array.from(mutation.removedNodes)
          ];
          if (changedNodes.every((node) => node.isContentEditable)) {
            return false;
          }
        }
        if (this.contentDOM === mutation.target && mutation.type === "attributes") {
          return true;
        }
        if (this.contentDOM.contains(mutation.target)) {
          return false;
        }
        return true;
      }
      updateAttributes(attributes) {
        this.editor.commands.command(({ tr }) => {
          const pos = this.getPos();
          tr.setNodeMarkup(pos, void 0, {
            ...this.node.attrs,
            ...attributes
          });
          return true;
        });
      }
      deleteNode() {
        const from = this.getPos();
        const to = from + this.node.nodeSize;
        this.editor.commands.deleteRange({ from, to });
      }
    };
    var Tracker = class {
      constructor(transaction) {
        this.transaction = transaction;
        this.currentStep = this.transaction.steps.length;
      }
      map(position) {
        let deleted = false;
        const mappedPosition = this.transaction.steps.slice(this.currentStep).reduce((newPosition, step) => {
          const mapResult = step.getMap().mapResult(newPosition);
          if (mapResult.deleted) {
            deleted = true;
          }
          return mapResult.pos;
        }, position);
        return {
          position: mappedPosition,
          deleted
        };
      }
    };
    function nodeInputRule(config) {
      return new InputRule({
        find: config.find,
        handler: ({ state, range, match }) => {
          const attributes = callOrReturn(config.getAttributes, void 0, match) || {};
          const { tr } = state;
          const start = range.from;
          let end = range.to;
          if (match[1]) {
            const offset = match[0].lastIndexOf(match[1]);
            let matchStart = start + offset;
            if (matchStart > end) {
              matchStart = end;
            } else {
              end = matchStart + match[1].length;
            }
            const lastChar = match[0][match[0].length - 1];
            tr.insertText(lastChar, start + match[0].length - 1);
            tr.replaceWith(matchStart, end, config.type.create(attributes));
          } else if (match[0]) {
            tr.replaceWith(start, end, config.type.create(attributes));
          }
        }
      });
    }
    function getMarksBetween(from, to, state) {
      const marks = [];
      state.doc.nodesBetween(from, to, (node, pos) => {
        marks.push(...node.marks.map((mark) => ({
          from: pos,
          to: pos + node.nodeSize,
          mark
        })));
      });
      return marks;
    }
    function markInputRule(config) {
      return new InputRule({
        find: config.find,
        handler: ({ state, range, match }) => {
          const attributes = callOrReturn(config.getAttributes, void 0, match);
          if (attributes === false || attributes === null) {
            return;
          }
          const { tr } = state;
          const captureGroup = match[match.length - 1];
          const fullMatch = match[0];
          let markEnd = range.to;
          if (captureGroup) {
            const startSpaces = fullMatch.search(/\S/);
            const textStart = range.from + fullMatch.indexOf(captureGroup);
            const textEnd = textStart + captureGroup.length;
            const excludedMarks = getMarksBetween(range.from, range.to, state).filter((item) => {
              const { excluded } = item.mark.type;
              return excluded.find((type) => type.name === config.type.name);
            }).filter((item) => item.to > textStart);
            if (excludedMarks.length) {
              return null;
            }
            if (textEnd < range.to) {
              tr.delete(textEnd, range.to);
            }
            if (textStart > range.from) {
              tr.delete(range.from + startSpaces, textStart);
            }
            markEnd = range.from + startSpaces + captureGroup.length;
            tr.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));
            tr.removeStoredMark(config.type);
          }
        }
      });
    }
    function textblockTypeInputRule(config) {
      return new InputRule({
        find: config.find,
        handler: ({ state, range, match }) => {
          const $start = state.doc.resolve(range.from);
          const attributes = callOrReturn(config.getAttributes, void 0, match) || {};
          if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), config.type)) {
            return null;
          }
          state.tr.delete(range.from, range.to).setBlockType(range.from, range.from, config.type, attributes);
        }
      });
    }
    function textInputRule(config) {
      return new InputRule({
        find: config.find,
        handler: ({ state, range, match }) => {
          let insert = config.replace;
          let start = range.from;
          const end = range.to;
          if (match[1]) {
            const offset = match[0].lastIndexOf(match[1]);
            insert += match[0].slice(offset + match[1].length);
            start += offset;
            const cutOff = start - end;
            if (cutOff > 0) {
              insert = match[0].slice(offset - cutOff, offset) + insert;
              start = end;
            }
          }
          state.tr.insertText(insert, start, end);
        }
      });
    }
    function wrappingInputRule(config) {
      return new InputRule({
        find: config.find,
        handler: ({ state, range, match }) => {
          const attributes = callOrReturn(config.getAttributes, void 0, match) || {};
          const tr = state.tr.delete(range.from, range.to);
          const $start = tr.doc.resolve(range.from);
          const blockRange = $start.blockRange();
          const wrapping = blockRange && prosemirrorTransform.findWrapping(blockRange, config.type, attributes);
          if (!wrapping) {
            return null;
          }
          tr.wrap(blockRange, wrapping);
          const before = tr.doc.resolve(range.from - 1).nodeBefore;
          if (before && before.type === config.type && prosemirrorTransform.canJoin(tr.doc, range.from - 1) && (!config.joinPredicate || config.joinPredicate(match, before))) {
            tr.join(range.from - 1);
          }
        }
      });
    }
    function markPasteRule(config) {
      return new PasteRule({
        find: config.find,
        handler: ({ state, range, match }) => {
          const attributes = callOrReturn(config.getAttributes, void 0, match);
          if (attributes === false || attributes === null) {
            return;
          }
          const { tr } = state;
          const captureGroup = match[match.length - 1];
          const fullMatch = match[0];
          let markEnd = range.to;
          if (captureGroup) {
            const startSpaces = fullMatch.search(/\S/);
            const textStart = range.from + fullMatch.indexOf(captureGroup);
            const textEnd = textStart + captureGroup.length;
            const excludedMarks = getMarksBetween(range.from, range.to, state).filter((item) => {
              const { excluded } = item.mark.type;
              return excluded.find((type) => type.name === config.type.name);
            }).filter((item) => item.to > textStart);
            if (excludedMarks.length) {
              return null;
            }
            if (textEnd < range.to) {
              tr.delete(textEnd, range.to);
            }
            if (textStart > range.from) {
              tr.delete(range.from + startSpaces, textStart);
            }
            markEnd = range.from + startSpaces + captureGroup.length;
            tr.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));
            tr.removeStoredMark(config.type);
          }
        }
      });
    }
    function textPasteRule(config) {
      return new PasteRule({
        find: config.find,
        handler: ({ state, range, match }) => {
          let insert = config.replace;
          let start = range.from;
          const end = range.to;
          if (match[1]) {
            const offset = match[0].lastIndexOf(match[1]);
            insert += match[0].slice(offset + match[1].length);
            start += offset;
            const cutOff = start - end;
            if (cutOff > 0) {
              insert = match[0].slice(offset - cutOff, offset) + insert;
              start = end;
            }
          }
          state.tr.insertText(insert, start, end);
        }
      });
    }
    function findChildren(node, predicate) {
      const nodesWithPos = [];
      node.descendants((child, pos) => {
        if (predicate(child)) {
          nodesWithPos.push({
            node: child,
            pos
          });
        }
      });
      return nodesWithPos;
    }
    function findChildrenInRange(node, range, predicate) {
      const nodesWithPos = [];
      node.nodesBetween(range.from, range.to, (child, pos) => {
        if (predicate(child)) {
          nodesWithPos.push({
            node: child,
            pos
          });
        }
      });
      return nodesWithPos;
    }
    function getSchema(extensions2) {
      const resolvedExtensions = ExtensionManager.resolve(extensions2);
      return getSchemaByResolvedExtensions(resolvedExtensions);
    }
    function generateHTML(doc, extensions2) {
      const schema = getSchema(extensions2);
      const contentNode = prosemirrorModel.Node.fromJSON(schema, doc);
      return getHTMLFromFragment(contentNode.content, schema);
    }
    function generateJSON(html, extensions2) {
      const schema = getSchema(extensions2);
      const dom = elementFromString(html);
      return prosemirrorModel.DOMParser.fromSchema(schema).parse(dom).toJSON();
    }
    function generateText(doc, extensions2, options2) {
      const { blockSeparator = "\n\n", textSerializers = {} } = options2 || {};
      const schema = getSchema(extensions2);
      const contentNode = prosemirrorModel.Node.fromJSON(schema, doc);
      return getText(contentNode, {
        blockSeparator,
        textSerializers: {
          ...textSerializers,
          ...getTextSeralizersFromSchema(schema)
        }
      });
    }
    function getDebugJSON(node, startOffset = 0) {
      const isTopNode = node.type === node.type.schema.topNodeType;
      const increment = isTopNode ? 0 : 1;
      const from = startOffset;
      const to = from + node.nodeSize;
      const marks = node.marks.map((mark) => ({
        type: mark.type.name,
        attrs: { ...mark.attrs }
      }));
      const attrs = { ...node.attrs };
      const output = {
        type: node.type.name,
        from,
        to
      };
      if (Object.keys(attrs).length) {
        output.attrs = attrs;
      }
      if (marks.length) {
        output.marks = marks;
      }
      if (node.content.childCount) {
        output.content = [];
        node.forEach((child, offset) => {
          var _a;
          (_a = output.content) === null || _a === void 0 ? void 0 : _a.push(getDebugJSON(child, startOffset + offset + increment));
        });
      }
      if (node.text) {
        output.text = node.text;
      }
      return output;
    }
    function isNodeSelection(value) {
      return isObject$1(value) && value instanceof prosemirrorState.NodeSelection;
    }
    function posToDOMRect(view, from, to) {
      const start = view.coordsAtPos(from);
      const end = view.coordsAtPos(to, -1);
      const top = Math.min(start.top, end.top);
      const bottom = Math.max(start.bottom, end.bottom);
      const left = Math.min(start.left, end.left);
      const right = Math.max(start.right, end.right);
      const width = right - left;
      const height = bottom - top;
      const x = left;
      const y = top;
      const data = {
        top,
        bottom,
        left,
        right,
        width,
        height,
        x,
        y
      };
      return {
        ...data,
        toJSON: () => data
      };
    }
    exports.Editor = Editor;
    exports.Extension = Extension;
    exports.InputRule = InputRule;
    exports.Mark = Mark;
    exports.Node = Node;
    exports.NodeView = NodeView;
    exports.PasteRule = PasteRule;
    exports.Tracker = Tracker;
    exports.callOrReturn = callOrReturn;
    exports.extensions = extensions;
    exports.findChildren = findChildren;
    exports.findChildrenInRange = findChildrenInRange;
    exports.findParentNode = findParentNode;
    exports.findParentNodeClosestToPos = findParentNodeClosestToPos;
    exports.generateHTML = generateHTML;
    exports.generateJSON = generateJSON;
    exports.generateText = generateText;
    exports.getAttributes = getAttributes;
    exports.getDebugJSON = getDebugJSON;
    exports.getExtensionField = getExtensionField;
    exports.getHTMLFromFragment = getHTMLFromFragment;
    exports.getMarkAttributes = getMarkAttributes;
    exports.getMarkRange = getMarkRange;
    exports.getMarkType = getMarkType;
    exports.getMarksBetween = getMarksBetween;
    exports.getNodeAttributes = getNodeAttributes;
    exports.getNodeType = getNodeType;
    exports.getSchema = getSchema;
    exports.getText = getText;
    exports.getTextBetween = getTextBetween;
    exports.inputRulesPlugin = inputRulesPlugin;
    exports.isActive = isActive;
    exports.isList = isList;
    exports.isMarkActive = isMarkActive;
    exports.isNodeActive = isNodeActive;
    exports.isNodeEmpty = isNodeEmpty;
    exports.isNodeSelection = isNodeSelection;
    exports.isTextSelection = isTextSelection;
    exports.markInputRule = markInputRule;
    exports.markPasteRule = markPasteRule;
    exports.mergeAttributes = mergeAttributes;
    exports.nodeInputRule = nodeInputRule;
    exports.pasteRulesPlugin = pasteRulesPlugin;
    exports.posToDOMRect = posToDOMRect;
    exports.textInputRule = textInputRule;
    exports.textPasteRule = textPasteRule;
    exports.textblockTypeInputRule = textblockTypeInputRule;
    exports.wrappingInputRule = wrappingInputRule;
  }
});

// node_modules/@tiptap/extension-blockquote/dist/tiptap-extension-blockquote.cjs.js
var require_tiptap_extension_blockquote_cjs = __commonJS({
  "node_modules/@tiptap/extension-blockquote/dist/tiptap-extension-blockquote.cjs.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_tiptap_core_cjs();
    var inputRegex = /^\s*>\s$/gm;
    var Blockquote = core.Node.create({
      name: "blockquote",
      defaultOptions: {
        HTMLAttributes: {}
      },
      content: "block*",
      group: "block",
      defining: true,
      parseHTML() {
        return [
          { tag: "blockquote" }
        ];
      },
      renderHTML({ HTMLAttributes }) {
        return ["blockquote", core.mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
      },
      addCommands() {
        return {
          setBlockquote: () => ({ commands }) => {
            return commands.wrapIn("blockquote");
          },
          toggleBlockquote: () => ({ commands }) => {
            return commands.toggleWrap("blockquote");
          },
          unsetBlockquote: () => ({ commands }) => {
            return commands.lift("blockquote");
          }
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Shift-b": () => this.editor.commands.toggleBlockquote()
        };
      },
      addInputRules() {
        return [
          core.wrappingInputRule({
            find: inputRegex,
            type: this.type
          })
        ];
      }
    });
    exports.Blockquote = Blockquote;
    exports["default"] = Blockquote;
    exports.inputRegex = inputRegex;
  }
});

// node_modules/@tiptap/extension-bold/dist/tiptap-extension-bold.cjs.js
var require_tiptap_extension_bold_cjs = __commonJS({
  "node_modules/@tiptap/extension-bold/dist/tiptap-extension-bold.cjs.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_tiptap_core_cjs();
    var starInputRegex = /(?:^|\s)((?:\*\*)((?:[^*]+))(?:\*\*))$/gm;
    var starPasteRegex = /(?:^|\s)((?:\*\*)((?:[^*]+))(?:\*\*))/gm;
    var underscoreInputRegex = /(?:^|\s)((?:__)((?:[^__]+))(?:__))$/gm;
    var underscorePasteRegex = /(?:^|\s)((?:__)((?:[^__]+))(?:__))/gm;
    var Bold = core.Mark.create({
      name: "bold",
      defaultOptions: {
        HTMLAttributes: {}
      },
      parseHTML() {
        return [
          {
            tag: "strong"
          },
          {
            tag: "b",
            getAttrs: (node) => node.style.fontWeight !== "normal" && null
          },
          {
            style: "font-weight",
            getAttrs: (value) => /^(bold(er)?|[5-9]\d{2,})$/.test(value) && null
          }
        ];
      },
      renderHTML({ HTMLAttributes }) {
        return ["strong", core.mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
      },
      addCommands() {
        return {
          setBold: () => ({ commands }) => {
            return commands.setMark("bold");
          },
          toggleBold: () => ({ commands }) => {
            return commands.toggleMark("bold");
          },
          unsetBold: () => ({ commands }) => {
            return commands.unsetMark("bold");
          }
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-b": () => this.editor.commands.toggleBold()
        };
      },
      addInputRules() {
        return [
          core.markInputRule({
            find: starInputRegex,
            type: this.type
          }),
          core.markInputRule({
            find: underscoreInputRegex,
            type: this.type
          })
        ];
      },
      addPasteRules() {
        return [
          core.markPasteRule({
            find: starPasteRegex,
            type: this.type
          }),
          core.markPasteRule({
            find: underscorePasteRegex,
            type: this.type
          })
        ];
      }
    });
    exports.Bold = Bold;
    exports["default"] = Bold;
    exports.starInputRegex = starInputRegex;
    exports.starPasteRegex = starPasteRegex;
    exports.underscoreInputRegex = underscoreInputRegex;
    exports.underscorePasteRegex = underscorePasteRegex;
  }
});

// node_modules/@tiptap/extension-bullet-list/dist/tiptap-extension-bullet-list.cjs.js
var require_tiptap_extension_bullet_list_cjs = __commonJS({
  "node_modules/@tiptap/extension-bullet-list/dist/tiptap-extension-bullet-list.cjs.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_tiptap_core_cjs();
    var inputRegex = /^\s*([-+*])\s$/;
    var BulletList = core.Node.create({
      name: "bulletList",
      defaultOptions: {
        HTMLAttributes: {}
      },
      group: "block list",
      content: "listItem+",
      parseHTML() {
        return [
          { tag: "ul" }
        ];
      },
      renderHTML({ HTMLAttributes }) {
        return ["ul", core.mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
      },
      addCommands() {
        return {
          toggleBulletList: () => ({ commands }) => {
            return commands.toggleList("bulletList", "listItem");
          }
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Shift-8": () => this.editor.commands.toggleBulletList()
        };
      },
      addInputRules() {
        return [
          core.wrappingInputRule({
            find: inputRegex,
            type: this.type
          })
        ];
      }
    });
    exports.BulletList = BulletList;
    exports["default"] = BulletList;
    exports.inputRegex = inputRegex;
  }
});

// node_modules/@tiptap/extension-code/dist/tiptap-extension-code.cjs.js
var require_tiptap_extension_code_cjs = __commonJS({
  "node_modules/@tiptap/extension-code/dist/tiptap-extension-code.cjs.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_tiptap_core_cjs();
    var inputRegex = /(?:^|\s)((?:`)((?:[^`]+))(?:`))$/gm;
    var pasteRegex = /(?:^|\s)((?:`)((?:[^`]+))(?:`))/gm;
    var Code2 = core.Mark.create({
      name: "code",
      defaultOptions: {
        HTMLAttributes: {}
      },
      excludes: "_",
      code: true,
      parseHTML() {
        return [
          { tag: "code" }
        ];
      },
      renderHTML({ HTMLAttributes }) {
        return ["code", core.mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
      },
      addCommands() {
        return {
          setCode: () => ({ commands }) => {
            return commands.setMark("code");
          },
          toggleCode: () => ({ commands }) => {
            return commands.toggleMark("code");
          },
          unsetCode: () => ({ commands }) => {
            return commands.unsetMark("code");
          }
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-e": () => this.editor.commands.toggleCode()
        };
      },
      addInputRules() {
        return [
          core.markInputRule({
            find: inputRegex,
            type: this.type
          })
        ];
      },
      addPasteRules() {
        return [
          core.markPasteRule({
            find: pasteRegex,
            type: this.type
          })
        ];
      }
    });
    exports.Code = Code2;
    exports["default"] = Code2;
    exports.inputRegex = inputRegex;
    exports.pasteRegex = pasteRegex;
  }
});

// node_modules/@tiptap/extension-code-block/dist/tiptap-extension-code-block.cjs.js
var require_tiptap_extension_code_block_cjs = __commonJS({
  "node_modules/@tiptap/extension-code-block/dist/tiptap-extension-code-block.cjs.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_tiptap_core_cjs();
    var backtickInputRegex = /^```(?<language>[a-z]*)?[\s\n]$/;
    var tildeInputRegex = /^~~~(?<language>[a-z]*)?[\s\n]$/;
    var CodeBlock = core.Node.create({
      name: "codeBlock",
      defaultOptions: {
        languageClassPrefix: "language-",
        HTMLAttributes: {}
      },
      content: "text*",
      marks: "",
      group: "block",
      code: true,
      defining: true,
      addAttributes() {
        return {
          language: {
            default: null,
            parseHTML: (element) => {
              var _a;
              const { languageClassPrefix } = this.options;
              const classNames = [...((_a = element.firstElementChild) === null || _a === void 0 ? void 0 : _a.classList) || []];
              const languages = classNames.filter((className) => className.startsWith(languageClassPrefix)).map((className) => className.replace(languageClassPrefix, ""));
              const language = languages[0];
              if (!language) {
                return null;
              }
              return language;
            },
            renderHTML: (attributes) => {
              if (!attributes.language) {
                return null;
              }
              return {
                class: this.options.languageClassPrefix + attributes.language
              };
            }
          }
        };
      },
      parseHTML() {
        return [
          {
            tag: "pre",
            preserveWhitespace: "full"
          }
        ];
      },
      renderHTML({ HTMLAttributes }) {
        return ["pre", this.options.HTMLAttributes, ["code", HTMLAttributes, 0]];
      },
      addCommands() {
        return {
          setCodeBlock: (attributes) => ({ commands }) => {
            return commands.setNode("codeBlock", attributes);
          },
          toggleCodeBlock: (attributes) => ({ commands }) => {
            return commands.toggleNode("codeBlock", "paragraph", attributes);
          }
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Alt-c": () => this.editor.commands.toggleCodeBlock(),
          Backspace: () => {
            const { empty: empty2, $anchor } = this.editor.state.selection;
            const isAtStart = $anchor.pos === 1;
            if (!empty2 || $anchor.parent.type.name !== this.name) {
              return false;
            }
            if (isAtStart || !$anchor.parent.textContent.length) {
              return this.editor.commands.clearNodes();
            }
            return false;
          }
        };
      },
      addInputRules() {
        return [
          core.textblockTypeInputRule({
            find: backtickInputRegex,
            type: this.type,
            getAttributes: ({ groups }) => groups
          }),
          core.textblockTypeInputRule({
            find: tildeInputRegex,
            type: this.type,
            getAttributes: ({ groups }) => groups
          })
        ];
      }
    });
    exports.CodeBlock = CodeBlock;
    exports.backtickInputRegex = backtickInputRegex;
    exports["default"] = CodeBlock;
    exports.tildeInputRegex = tildeInputRegex;
  }
});

// node_modules/@tiptap/extension-document/dist/tiptap-extension-document.cjs.js
var require_tiptap_extension_document_cjs = __commonJS({
  "node_modules/@tiptap/extension-document/dist/tiptap-extension-document.cjs.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_tiptap_core_cjs();
    var Document = core.Node.create({
      name: "doc",
      topNode: true,
      content: "block+"
    });
    exports.Document = Document;
    exports.default = Document;
  }
});

// node_modules/prosemirror-dropcursor/dist/index.js
var require_dist8 = __commonJS({
  "node_modules/prosemirror-dropcursor/dist/index.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var prosemirrorState = require_dist3();
    var prosemirrorTransform = require_dist2();
    function dropCursor(options2) {
      if (options2 === void 0)
        options2 = {};
      return new prosemirrorState.Plugin({
        view: function view(editorView) {
          return new DropCursorView(editorView, options2);
        }
      });
    }
    var DropCursorView = function DropCursorView2(editorView, options2) {
      var this$1 = this;
      this.editorView = editorView;
      this.width = options2.width || 1;
      this.color = options2.color || "black";
      this.class = options2.class;
      this.cursorPos = null;
      this.element = null;
      this.timeout = null;
      this.handlers = ["dragover", "dragend", "drop", "dragleave"].map(function(name) {
        var handler2 = function(e) {
          return this$1[name](e);
        };
        editorView.dom.addEventListener(name, handler2);
        return { name, handler: handler2 };
      });
    };
    DropCursorView.prototype.destroy = function destroy() {
      var this$1 = this;
      this.handlers.forEach(function(ref) {
        var name = ref.name;
        var handler2 = ref.handler;
        return this$1.editorView.dom.removeEventListener(name, handler2);
      });
    };
    DropCursorView.prototype.update = function update(editorView, prevState) {
      if (this.cursorPos != null && prevState.doc != editorView.state.doc) {
        if (this.cursorPos > editorView.state.doc.content.size) {
          this.setCursor(null);
        } else {
          this.updateOverlay();
        }
      }
    };
    DropCursorView.prototype.setCursor = function setCursor(pos) {
      if (pos == this.cursorPos) {
        return;
      }
      this.cursorPos = pos;
      if (pos == null) {
        this.element.parentNode.removeChild(this.element);
        this.element = null;
      } else {
        this.updateOverlay();
      }
    };
    DropCursorView.prototype.updateOverlay = function updateOverlay() {
      var $pos = this.editorView.state.doc.resolve(this.cursorPos), rect;
      if (!$pos.parent.inlineContent) {
        var before = $pos.nodeBefore, after = $pos.nodeAfter;
        if (before || after) {
          var nodeRect = this.editorView.nodeDOM(this.cursorPos - (before ? before.nodeSize : 0)).getBoundingClientRect();
          var top = before ? nodeRect.bottom : nodeRect.top;
          if (before && after) {
            top = (top + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2;
          }
          rect = { left: nodeRect.left, right: nodeRect.right, top: top - this.width / 2, bottom: top + this.width / 2 };
        }
      }
      if (!rect) {
        var coords = this.editorView.coordsAtPos(this.cursorPos);
        rect = { left: coords.left - this.width / 2, right: coords.left + this.width / 2, top: coords.top, bottom: coords.bottom };
      }
      var parent = this.editorView.dom.offsetParent;
      if (!this.element) {
        this.element = parent.appendChild(document.createElement("div"));
        if (this.class) {
          this.element.className = this.class;
        }
        this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none; background-color: " + this.color;
      }
      var parentLeft, parentTop;
      if (!parent || parent == document.body && getComputedStyle(parent).position == "static") {
        parentLeft = -pageXOffset;
        parentTop = -pageYOffset;
      } else {
        var rect$1 = parent.getBoundingClientRect();
        parentLeft = rect$1.left - parent.scrollLeft;
        parentTop = rect$1.top - parent.scrollTop;
      }
      this.element.style.left = rect.left - parentLeft + "px";
      this.element.style.top = rect.top - parentTop + "px";
      this.element.style.width = rect.right - rect.left + "px";
      this.element.style.height = rect.bottom - rect.top + "px";
    };
    DropCursorView.prototype.scheduleRemoval = function scheduleRemoval(timeout) {
      var this$1 = this;
      clearTimeout(this.timeout);
      this.timeout = setTimeout(function() {
        return this$1.setCursor(null);
      }, timeout);
    };
    DropCursorView.prototype.dragover = function dragover(event) {
      if (!this.editorView.editable) {
        return;
      }
      var pos = this.editorView.posAtCoords({ left: event.clientX, top: event.clientY });
      if (pos) {
        var target = pos.pos;
        if (this.editorView.dragging && this.editorView.dragging.slice) {
          target = prosemirrorTransform.dropPoint(this.editorView.state.doc, target, this.editorView.dragging.slice);
          if (target == null) {
            return this.setCursor(null);
          }
        }
        this.setCursor(target);
        this.scheduleRemoval(5e3);
      }
    };
    DropCursorView.prototype.dragend = function dragend() {
      this.scheduleRemoval(20);
    };
    DropCursorView.prototype.drop = function drop() {
      this.scheduleRemoval(20);
    };
    DropCursorView.prototype.dragleave = function dragleave(event) {
      if (event.target == this.editorView.dom || !this.editorView.dom.contains(event.relatedTarget)) {
        this.setCursor(null);
      }
    };
    exports.dropCursor = dropCursor;
  }
});

// node_modules/@tiptap/extension-dropcursor/dist/tiptap-extension-dropcursor.cjs.js
var require_tiptap_extension_dropcursor_cjs = __commonJS({
  "node_modules/@tiptap/extension-dropcursor/dist/tiptap-extension-dropcursor.cjs.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_tiptap_core_cjs();
    var prosemirrorDropcursor = require_dist8();
    var Dropcursor = core.Extension.create({
      name: "dropCursor",
      defaultOptions: {
        color: "currentColor",
        width: 1,
        class: null
      },
      addProseMirrorPlugins() {
        return [
          prosemirrorDropcursor.dropCursor(this.options)
        ];
      }
    });
    exports.Dropcursor = Dropcursor;
    exports["default"] = Dropcursor;
  }
});

// node_modules/prosemirror-gapcursor/dist/index.js
var require_dist9 = __commonJS({
  "node_modules/prosemirror-gapcursor/dist/index.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var prosemirrorKeymap = require_dist7();
    var prosemirrorState = require_dist3();
    var prosemirrorView = require_dist6();
    var prosemirrorModel = require_dist();
    var GapCursor = /* @__PURE__ */ function(Selection) {
      function GapCursor2($pos) {
        Selection.call(this, $pos, $pos);
      }
      if (Selection)
        GapCursor2.__proto__ = Selection;
      GapCursor2.prototype = Object.create(Selection && Selection.prototype);
      GapCursor2.prototype.constructor = GapCursor2;
      GapCursor2.prototype.map = function map2(doc, mapping) {
        var $pos = doc.resolve(mapping.map(this.head));
        return GapCursor2.valid($pos) ? new GapCursor2($pos) : Selection.near($pos);
      };
      GapCursor2.prototype.content = function content() {
        return prosemirrorModel.Slice.empty;
      };
      GapCursor2.prototype.eq = function eq(other) {
        return other instanceof GapCursor2 && other.head == this.head;
      };
      GapCursor2.prototype.toJSON = function toJSON() {
        return { type: "gapcursor", pos: this.head };
      };
      GapCursor2.fromJSON = function fromJSON(doc, json) {
        if (typeof json.pos != "number") {
          throw new RangeError("Invalid input for GapCursor.fromJSON");
        }
        return new GapCursor2(doc.resolve(json.pos));
      };
      GapCursor2.prototype.getBookmark = function getBookmark() {
        return new GapBookmark(this.anchor);
      };
      GapCursor2.valid = function valid($pos) {
        var parent = $pos.parent;
        if (parent.isTextblock || !closedBefore($pos) || !closedAfter($pos)) {
          return false;
        }
        var override = parent.type.spec.allowGapCursor;
        if (override != null) {
          return override;
        }
        var deflt = parent.contentMatchAt($pos.index()).defaultType;
        return deflt && deflt.isTextblock;
      };
      GapCursor2.findFrom = function findFrom($pos, dir, mustMove) {
        search:
          for (; ; ) {
            if (!mustMove && GapCursor2.valid($pos)) {
              return $pos;
            }
            var pos = $pos.pos, next = null;
            for (var d = $pos.depth; ; d--) {
              var parent = $pos.node(d);
              if (dir > 0 ? $pos.indexAfter(d) < parent.childCount : $pos.index(d) > 0) {
                next = parent.child(dir > 0 ? $pos.indexAfter(d) : $pos.index(d) - 1);
                break;
              } else if (d == 0) {
                return null;
              }
              pos += dir;
              var $cur = $pos.doc.resolve(pos);
              if (GapCursor2.valid($cur)) {
                return $cur;
              }
            }
            for (; ; ) {
              var inside = dir > 0 ? next.firstChild : next.lastChild;
              if (!inside) {
                if (next.isAtom && !next.isText && !prosemirrorState.NodeSelection.isSelectable(next)) {
                  $pos = $pos.doc.resolve(pos + next.nodeSize * dir);
                  mustMove = false;
                  continue search;
                }
                break;
              }
              next = inside;
              pos += dir;
              var $cur$1 = $pos.doc.resolve(pos);
              if (GapCursor2.valid($cur$1)) {
                return $cur$1;
              }
            }
            return null;
          }
      };
      return GapCursor2;
    }(prosemirrorState.Selection);
    GapCursor.prototype.visible = false;
    prosemirrorState.Selection.jsonID("gapcursor", GapCursor);
    var GapBookmark = function GapBookmark2(pos) {
      this.pos = pos;
    };
    GapBookmark.prototype.map = function map2(mapping) {
      return new GapBookmark(mapping.map(this.pos));
    };
    GapBookmark.prototype.resolve = function resolve2(doc) {
      var $pos = doc.resolve(this.pos);
      return GapCursor.valid($pos) ? new GapCursor($pos) : prosemirrorState.Selection.near($pos);
    };
    function closedBefore($pos) {
      for (var d = $pos.depth; d >= 0; d--) {
        var index2 = $pos.index(d);
        if (index2 == 0) {
          continue;
        }
        for (var before = $pos.node(d).child(index2 - 1); ; before = before.lastChild) {
          if (before.childCount == 0 && !before.inlineContent || before.isAtom || before.type.spec.isolating) {
            return true;
          }
          if (before.inlineContent) {
            return false;
          }
        }
      }
      return true;
    }
    function closedAfter($pos) {
      for (var d = $pos.depth; d >= 0; d--) {
        var index2 = $pos.indexAfter(d), parent = $pos.node(d);
        if (index2 == parent.childCount) {
          continue;
        }
        for (var after = parent.child(index2); ; after = after.firstChild) {
          if (after.childCount == 0 && !after.inlineContent || after.isAtom || after.type.spec.isolating) {
            return true;
          }
          if (after.inlineContent) {
            return false;
          }
        }
      }
      return true;
    }
    var gapCursor = function() {
      return new prosemirrorState.Plugin({
        props: {
          decorations: drawGapCursor,
          createSelectionBetween: function createSelectionBetween(_view, $anchor, $head) {
            if ($anchor.pos == $head.pos && GapCursor.valid($head)) {
              return new GapCursor($head);
            }
          },
          handleClick,
          handleKeyDown
        }
      });
    };
    var handleKeyDown = prosemirrorKeymap.keydownHandler({
      "ArrowLeft": arrow("horiz", -1),
      "ArrowRight": arrow("horiz", 1),
      "ArrowUp": arrow("vert", -1),
      "ArrowDown": arrow("vert", 1)
    });
    function arrow(axis, dir) {
      var dirStr = axis == "vert" ? dir > 0 ? "down" : "up" : dir > 0 ? "right" : "left";
      return function(state, dispatch, view) {
        var sel = state.selection;
        var $start = dir > 0 ? sel.$to : sel.$from, mustMove = sel.empty;
        if (sel instanceof prosemirrorState.TextSelection) {
          if (!view.endOfTextblock(dirStr) || $start.depth == 0) {
            return false;
          }
          mustMove = false;
          $start = state.doc.resolve(dir > 0 ? $start.after() : $start.before());
        }
        var $found = GapCursor.findFrom($start, dir, mustMove);
        if (!$found) {
          return false;
        }
        if (dispatch) {
          dispatch(state.tr.setSelection(new GapCursor($found)));
        }
        return true;
      };
    }
    function handleClick(view, pos, event) {
      if (!view.editable) {
        return false;
      }
      var $pos = view.state.doc.resolve(pos);
      if (!GapCursor.valid($pos)) {
        return false;
      }
      var ref = view.posAtCoords({ left: event.clientX, top: event.clientY });
      var inside = ref.inside;
      if (inside > -1 && prosemirrorState.NodeSelection.isSelectable(view.state.doc.nodeAt(inside))) {
        return false;
      }
      view.dispatch(view.state.tr.setSelection(new GapCursor($pos)));
      return true;
    }
    function drawGapCursor(state) {
      if (!(state.selection instanceof GapCursor)) {
        return null;
      }
      var node = document.createElement("div");
      node.className = "ProseMirror-gapcursor";
      return prosemirrorView.DecorationSet.create(state.doc, [prosemirrorView.Decoration.widget(state.selection.head, node, { key: "gapcursor" })]);
    }
    exports.GapCursor = GapCursor;
    exports.gapCursor = gapCursor;
  }
});

// node_modules/@tiptap/extension-gapcursor/dist/tiptap-extension-gapcursor.cjs.js
var require_tiptap_extension_gapcursor_cjs = __commonJS({
  "node_modules/@tiptap/extension-gapcursor/dist/tiptap-extension-gapcursor.cjs.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_tiptap_core_cjs();
    var prosemirrorGapcursor = require_dist9();
    var Gapcursor = core.Extension.create({
      name: "gapCursor",
      addProseMirrorPlugins() {
        return [
          prosemirrorGapcursor.gapCursor()
        ];
      },
      extendNodeSchema(extension) {
        var _a;
        const context = {
          name: extension.name,
          options: extension.options
        };
        return {
          allowGapCursor: (_a = core.callOrReturn(core.getExtensionField(extension, "allowGapCursor", context))) !== null && _a !== void 0 ? _a : null
        };
      }
    });
    exports.Gapcursor = Gapcursor;
    exports["default"] = Gapcursor;
  }
});

// node_modules/@tiptap/extension-hard-break/dist/tiptap-extension-hard-break.cjs.js
var require_tiptap_extension_hard_break_cjs = __commonJS({
  "node_modules/@tiptap/extension-hard-break/dist/tiptap-extension-hard-break.cjs.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_tiptap_core_cjs();
    var HardBreak = core.Node.create({
      name: "hardBreak",
      defaultOptions: {
        keepMarks: true,
        HTMLAttributes: {}
      },
      inline: true,
      group: "inline",
      selectable: false,
      parseHTML() {
        return [
          { tag: "br" }
        ];
      },
      renderHTML({ HTMLAttributes }) {
        return ["br", core.mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];
      },
      renderText() {
        return "\n";
      },
      addCommands() {
        return {
          setHardBreak: () => ({ commands, chain, state, editor }) => {
            return commands.first([
              () => commands.exitCode(),
              () => commands.command(() => {
                const { keepMarks } = this.options;
                const { splittableMarks } = editor.extensionManager;
                const marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();
                return chain().insertContent({ type: this.name }).command(({ tr, dispatch }) => {
                  if (dispatch && marks && keepMarks) {
                    const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
                    tr.ensureMarks(filteredMarks);
                  }
                  return true;
                }).run();
              })
            ]);
          }
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Enter": () => this.editor.commands.setHardBreak(),
          "Shift-Enter": () => this.editor.commands.setHardBreak()
        };
      }
    });
    exports.HardBreak = HardBreak;
    exports["default"] = HardBreak;
  }
});

// node_modules/@tiptap/extension-heading/dist/tiptap-extension-heading.cjs.js
var require_tiptap_extension_heading_cjs = __commonJS({
  "node_modules/@tiptap/extension-heading/dist/tiptap-extension-heading.cjs.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_tiptap_core_cjs();
    var Heading = core.Node.create({
      name: "heading",
      defaultOptions: {
        levels: [1, 2, 3, 4, 5, 6],
        HTMLAttributes: {}
      },
      content: "inline*",
      group: "block",
      defining: true,
      addAttributes() {
        return {
          level: {
            default: 1,
            rendered: false
          }
        };
      },
      parseHTML() {
        return this.options.levels.map((level) => ({
          tag: `h${level}`,
          attrs: { level }
        }));
      },
      renderHTML({ node, HTMLAttributes }) {
        const hasLevel = this.options.levels.includes(node.attrs.level);
        const level = hasLevel ? node.attrs.level : this.options.levels[0];
        return [`h${level}`, core.mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
      },
      addCommands() {
        return {
          setHeading: (attributes) => ({ commands }) => {
            if (!this.options.levels.includes(attributes.level)) {
              return false;
            }
            return commands.setNode("heading", attributes);
          },
          toggleHeading: (attributes) => ({ commands }) => {
            if (!this.options.levels.includes(attributes.level)) {
              return false;
            }
            return commands.toggleNode("heading", "paragraph", attributes);
          }
        };
      },
      addKeyboardShortcuts() {
        return this.options.levels.reduce((items, level) => ({
          ...items,
          ...{
            [`Mod-Alt-${level}`]: () => this.editor.commands.toggleHeading({ level })
          }
        }), {});
      },
      addInputRules() {
        return this.options.levels.map((level) => {
          return core.textblockTypeInputRule({
            find: new RegExp(`^(#{1,${level}})\\s$`),
            type: this.type,
            getAttributes: {
              level
            }
          });
        });
      }
    });
    exports.Heading = Heading;
    exports["default"] = Heading;
  }
});

// node_modules/rope-sequence/dist/index.js
var require_dist10 = __commonJS({
  "node_modules/rope-sequence/dist/index.js"(exports, module2) {
    init_shims();
    "use strict";
    var GOOD_LEAF_SIZE = 200;
    var RopeSequence = function RopeSequence2() {
    };
    RopeSequence.prototype.append = function append(other) {
      if (!other.length) {
        return this;
      }
      other = RopeSequence.from(other);
      return !this.length && other || other.length < GOOD_LEAF_SIZE && this.leafAppend(other) || this.length < GOOD_LEAF_SIZE && other.leafPrepend(this) || this.appendInner(other);
    };
    RopeSequence.prototype.prepend = function prepend(other) {
      if (!other.length) {
        return this;
      }
      return RopeSequence.from(other).append(this);
    };
    RopeSequence.prototype.appendInner = function appendInner(other) {
      return new Append(this, other);
    };
    RopeSequence.prototype.slice = function slice(from, to) {
      if (from === void 0)
        from = 0;
      if (to === void 0)
        to = this.length;
      if (from >= to) {
        return RopeSequence.empty;
      }
      return this.sliceInner(Math.max(0, from), Math.min(this.length, to));
    };
    RopeSequence.prototype.get = function get2(i) {
      if (i < 0 || i >= this.length) {
        return void 0;
      }
      return this.getInner(i);
    };
    RopeSequence.prototype.forEach = function forEach(f, from, to) {
      if (from === void 0)
        from = 0;
      if (to === void 0)
        to = this.length;
      if (from <= to) {
        this.forEachInner(f, from, to, 0);
      } else {
        this.forEachInvertedInner(f, from, to, 0);
      }
    };
    RopeSequence.prototype.map = function map2(f, from, to) {
      if (from === void 0)
        from = 0;
      if (to === void 0)
        to = this.length;
      var result = [];
      this.forEach(function(elt, i) {
        return result.push(f(elt, i));
      }, from, to);
      return result;
    };
    RopeSequence.from = function from(values) {
      if (values instanceof RopeSequence) {
        return values;
      }
      return values && values.length ? new Leaf(values) : RopeSequence.empty;
    };
    var Leaf = /* @__PURE__ */ function(RopeSequence2) {
      function Leaf2(values) {
        RopeSequence2.call(this);
        this.values = values;
      }
      if (RopeSequence2)
        Leaf2.__proto__ = RopeSequence2;
      Leaf2.prototype = Object.create(RopeSequence2 && RopeSequence2.prototype);
      Leaf2.prototype.constructor = Leaf2;
      var prototypeAccessors = { length: { configurable: true }, depth: { configurable: true } };
      Leaf2.prototype.flatten = function flatten() {
        return this.values;
      };
      Leaf2.prototype.sliceInner = function sliceInner(from, to) {
        if (from == 0 && to == this.length) {
          return this;
        }
        return new Leaf2(this.values.slice(from, to));
      };
      Leaf2.prototype.getInner = function getInner(i) {
        return this.values[i];
      };
      Leaf2.prototype.forEachInner = function forEachInner(f, from, to, start) {
        for (var i = from; i < to; i++) {
          if (f(this.values[i], start + i) === false) {
            return false;
          }
        }
      };
      Leaf2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from, to, start) {
        for (var i = from - 1; i >= to; i--) {
          if (f(this.values[i], start + i) === false) {
            return false;
          }
        }
      };
      Leaf2.prototype.leafAppend = function leafAppend(other) {
        if (this.length + other.length <= GOOD_LEAF_SIZE) {
          return new Leaf2(this.values.concat(other.flatten()));
        }
      };
      Leaf2.prototype.leafPrepend = function leafPrepend(other) {
        if (this.length + other.length <= GOOD_LEAF_SIZE) {
          return new Leaf2(other.flatten().concat(this.values));
        }
      };
      prototypeAccessors.length.get = function() {
        return this.values.length;
      };
      prototypeAccessors.depth.get = function() {
        return 0;
      };
      Object.defineProperties(Leaf2.prototype, prototypeAccessors);
      return Leaf2;
    }(RopeSequence);
    RopeSequence.empty = new Leaf([]);
    var Append = /* @__PURE__ */ function(RopeSequence2) {
      function Append2(left, right) {
        RopeSequence2.call(this);
        this.left = left;
        this.right = right;
        this.length = left.length + right.length;
        this.depth = Math.max(left.depth, right.depth) + 1;
      }
      if (RopeSequence2)
        Append2.__proto__ = RopeSequence2;
      Append2.prototype = Object.create(RopeSequence2 && RopeSequence2.prototype);
      Append2.prototype.constructor = Append2;
      Append2.prototype.flatten = function flatten() {
        return this.left.flatten().concat(this.right.flatten());
      };
      Append2.prototype.getInner = function getInner(i) {
        return i < this.left.length ? this.left.get(i) : this.right.get(i - this.left.length);
      };
      Append2.prototype.forEachInner = function forEachInner(f, from, to, start) {
        var leftLen = this.left.length;
        if (from < leftLen && this.left.forEachInner(f, from, Math.min(to, leftLen), start) === false) {
          return false;
        }
        if (to > leftLen && this.right.forEachInner(f, Math.max(from - leftLen, 0), Math.min(this.length, to) - leftLen, start + leftLen) === false) {
          return false;
        }
      };
      Append2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from, to, start) {
        var leftLen = this.left.length;
        if (from > leftLen && this.right.forEachInvertedInner(f, from - leftLen, Math.max(to, leftLen) - leftLen, start + leftLen) === false) {
          return false;
        }
        if (to < leftLen && this.left.forEachInvertedInner(f, Math.min(from, leftLen), to, start) === false) {
          return false;
        }
      };
      Append2.prototype.sliceInner = function sliceInner(from, to) {
        if (from == 0 && to == this.length) {
          return this;
        }
        var leftLen = this.left.length;
        if (to <= leftLen) {
          return this.left.slice(from, to);
        }
        if (from >= leftLen) {
          return this.right.slice(from - leftLen, to - leftLen);
        }
        return this.left.slice(from, leftLen).append(this.right.slice(0, to - leftLen));
      };
      Append2.prototype.leafAppend = function leafAppend(other) {
        var inner = this.right.leafAppend(other);
        if (inner) {
          return new Append2(this.left, inner);
        }
      };
      Append2.prototype.leafPrepend = function leafPrepend(other) {
        var inner = this.left.leafPrepend(other);
        if (inner) {
          return new Append2(inner, this.right);
        }
      };
      Append2.prototype.appendInner = function appendInner(other) {
        if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1) {
          return new Append2(this.left, new Append2(this.right, other));
        }
        return new Append2(this, other);
      };
      return Append2;
    }(RopeSequence);
    var ropeSequence = RopeSequence;
    module2.exports = ropeSequence;
  }
});

// node_modules/prosemirror-history/dist/index.js
var require_dist11 = __commonJS({
  "node_modules/prosemirror-history/dist/index.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var RopeSequence = require_dist10();
    var prosemirrorTransform = require_dist2();
    var prosemirrorState = require_dist3();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var RopeSequence__default = /* @__PURE__ */ _interopDefaultLegacy(RopeSequence);
    var max_empty_items = 500;
    var Branch = function Branch2(items, eventCount) {
      this.items = items;
      this.eventCount = eventCount;
    };
    Branch.prototype.popEvent = function popEvent(state, preserveItems) {
      var this$1 = this;
      if (this.eventCount == 0) {
        return null;
      }
      var end = this.items.length;
      for (; ; end--) {
        var next = this.items.get(end - 1);
        if (next.selection) {
          --end;
          break;
        }
      }
      var remap, mapFrom;
      if (preserveItems) {
        remap = this.remapping(end, this.items.length);
        mapFrom = remap.maps.length;
      }
      var transform = state.tr;
      var selection, remaining;
      var addAfter = [], addBefore = [];
      this.items.forEach(function(item, i) {
        if (!item.step) {
          if (!remap) {
            remap = this$1.remapping(end, i + 1);
            mapFrom = remap.maps.length;
          }
          mapFrom--;
          addBefore.push(item);
          return;
        }
        if (remap) {
          addBefore.push(new Item(item.map));
          var step = item.step.map(remap.slice(mapFrom)), map2;
          if (step && transform.maybeStep(step).doc) {
            map2 = transform.mapping.maps[transform.mapping.maps.length - 1];
            addAfter.push(new Item(map2, null, null, addAfter.length + addBefore.length));
          }
          mapFrom--;
          if (map2) {
            remap.appendMap(map2, mapFrom);
          }
        } else {
          transform.maybeStep(item.step);
        }
        if (item.selection) {
          selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;
          remaining = new Branch(this$1.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), this$1.eventCount - 1);
          return false;
        }
      }, this.items.length, 0);
      return { remaining, transform, selection };
    };
    Branch.prototype.addTransform = function addTransform(transform, selection, histOptions, preserveItems) {
      var newItems = [], eventCount = this.eventCount;
      var oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;
      for (var i = 0; i < transform.steps.length; i++) {
        var step = transform.steps[i].invert(transform.docs[i]);
        var item = new Item(transform.mapping.maps[i], step, selection), merged = void 0;
        if (merged = lastItem && lastItem.merge(item)) {
          item = merged;
          if (i) {
            newItems.pop();
          } else {
            oldItems = oldItems.slice(0, oldItems.length - 1);
          }
        }
        newItems.push(item);
        if (selection) {
          eventCount++;
          selection = null;
        }
        if (!preserveItems) {
          lastItem = item;
        }
      }
      var overflow = eventCount - histOptions.depth;
      if (overflow > DEPTH_OVERFLOW) {
        oldItems = cutOffEvents(oldItems, overflow);
        eventCount -= overflow;
      }
      return new Branch(oldItems.append(newItems), eventCount);
    };
    Branch.prototype.remapping = function remapping(from, to) {
      var maps = new prosemirrorTransform.Mapping();
      this.items.forEach(function(item, i) {
        var mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from ? maps.maps.length - item.mirrorOffset : null;
        maps.appendMap(item.map, mirrorPos);
      }, from, to);
      return maps;
    };
    Branch.prototype.addMaps = function addMaps(array) {
      if (this.eventCount == 0) {
        return this;
      }
      return new Branch(this.items.append(array.map(function(map2) {
        return new Item(map2);
      })), this.eventCount);
    };
    Branch.prototype.rebased = function rebased(rebasedTransform, rebasedCount) {
      if (!this.eventCount) {
        return this;
      }
      var rebasedItems = [], start = Math.max(0, this.items.length - rebasedCount);
      var mapping = rebasedTransform.mapping;
      var newUntil = rebasedTransform.steps.length;
      var eventCount = this.eventCount;
      this.items.forEach(function(item) {
        if (item.selection) {
          eventCount--;
        }
      }, start);
      var iRebased = rebasedCount;
      this.items.forEach(function(item) {
        var pos = mapping.getMirror(--iRebased);
        if (pos == null) {
          return;
        }
        newUntil = Math.min(newUntil, pos);
        var map2 = mapping.maps[pos];
        if (item.step) {
          var step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);
          var selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));
          if (selection) {
            eventCount++;
          }
          rebasedItems.push(new Item(map2, step, selection));
        } else {
          rebasedItems.push(new Item(map2));
        }
      }, start);
      var newMaps = [];
      for (var i = rebasedCount; i < newUntil; i++) {
        newMaps.push(new Item(mapping.maps[i]));
      }
      var items = this.items.slice(0, start).append(newMaps).append(rebasedItems);
      var branch = new Branch(items, eventCount);
      if (branch.emptyItemCount() > max_empty_items) {
        branch = branch.compress(this.items.length - rebasedItems.length);
      }
      return branch;
    };
    Branch.prototype.emptyItemCount = function emptyItemCount() {
      var count = 0;
      this.items.forEach(function(item) {
        if (!item.step) {
          count++;
        }
      });
      return count;
    };
    Branch.prototype.compress = function compress(upto) {
      if (upto === void 0)
        upto = this.items.length;
      var remap = this.remapping(0, upto), mapFrom = remap.maps.length;
      var items = [], events = 0;
      this.items.forEach(function(item, i) {
        if (i >= upto) {
          items.push(item);
          if (item.selection) {
            events++;
          }
        } else if (item.step) {
          var step = item.step.map(remap.slice(mapFrom)), map2 = step && step.getMap();
          mapFrom--;
          if (map2) {
            remap.appendMap(map2, mapFrom);
          }
          if (step) {
            var selection = item.selection && item.selection.map(remap.slice(mapFrom));
            if (selection) {
              events++;
            }
            var newItem = new Item(map2.invert(), step, selection), merged, last = items.length - 1;
            if (merged = items.length && items[last].merge(newItem)) {
              items[last] = merged;
            } else {
              items.push(newItem);
            }
          }
        } else if (item.map) {
          mapFrom--;
        }
      }, this.items.length, 0);
      return new Branch(RopeSequence__default["default"].from(items.reverse()), events);
    };
    Branch.empty = new Branch(RopeSequence__default["default"].empty, 0);
    function cutOffEvents(items, n) {
      var cutPoint;
      items.forEach(function(item, i) {
        if (item.selection && n-- == 0) {
          cutPoint = i;
          return false;
        }
      });
      return items.slice(cutPoint);
    }
    var Item = function Item2(map2, step, selection, mirrorOffset) {
      this.map = map2;
      this.step = step;
      this.selection = selection;
      this.mirrorOffset = mirrorOffset;
    };
    Item.prototype.merge = function merge(other) {
      if (this.step && other.step && !other.selection) {
        var step = other.step.merge(this.step);
        if (step) {
          return new Item(step.getMap().invert(), step, this.selection);
        }
      }
    };
    var HistoryState = function HistoryState2(done, undone, prevRanges, prevTime) {
      this.done = done;
      this.undone = undone;
      this.prevRanges = prevRanges;
      this.prevTime = prevTime;
    };
    var DEPTH_OVERFLOW = 20;
    function applyTransaction(history2, state, tr, options2) {
      var historyTr = tr.getMeta(historyKey), rebased;
      if (historyTr) {
        return historyTr.historyState;
      }
      if (tr.getMeta(closeHistoryKey)) {
        history2 = new HistoryState(history2.done, history2.undone, null, 0);
      }
      var appended = tr.getMeta("appendedTransaction");
      if (tr.steps.length == 0) {
        return history2;
      } else if (appended && appended.getMeta(historyKey)) {
        if (appended.getMeta(historyKey).redo) {
          return new HistoryState(history2.done.addTransform(tr, null, options2, mustPreserveItems(state)), history2.undone, rangesFor(tr.mapping.maps[tr.steps.length - 1]), history2.prevTime);
        } else {
          return new HistoryState(history2.done, history2.undone.addTransform(tr, null, options2, mustPreserveItems(state)), null, history2.prevTime);
        }
      } else if (tr.getMeta("addToHistory") !== false && !(appended && appended.getMeta("addToHistory") === false)) {
        var newGroup = history2.prevTime == 0 || !appended && (history2.prevTime < (tr.time || 0) - options2.newGroupDelay || !isAdjacentTo(tr, history2.prevRanges));
        var prevRanges = appended ? mapRanges(history2.prevRanges, tr.mapping) : rangesFor(tr.mapping.maps[tr.steps.length - 1]);
        return new HistoryState(history2.done.addTransform(tr, newGroup ? state.selection.getBookmark() : null, options2, mustPreserveItems(state)), Branch.empty, prevRanges, tr.time);
      } else if (rebased = tr.getMeta("rebased")) {
        return new HistoryState(history2.done.rebased(tr, rebased), history2.undone.rebased(tr, rebased), mapRanges(history2.prevRanges, tr.mapping), history2.prevTime);
      } else {
        return new HistoryState(history2.done.addMaps(tr.mapping.maps), history2.undone.addMaps(tr.mapping.maps), mapRanges(history2.prevRanges, tr.mapping), history2.prevTime);
      }
    }
    function isAdjacentTo(transform, prevRanges) {
      if (!prevRanges) {
        return false;
      }
      if (!transform.docChanged) {
        return true;
      }
      var adjacent = false;
      transform.mapping.maps[0].forEach(function(start, end) {
        for (var i = 0; i < prevRanges.length; i += 2) {
          if (start <= prevRanges[i + 1] && end >= prevRanges[i]) {
            adjacent = true;
          }
        }
      });
      return adjacent;
    }
    function rangesFor(map2) {
      var result = [];
      map2.forEach(function(_from, _to, from, to) {
        return result.push(from, to);
      });
      return result;
    }
    function mapRanges(ranges, mapping) {
      if (!ranges) {
        return null;
      }
      var result = [];
      for (var i = 0; i < ranges.length; i += 2) {
        var from = mapping.map(ranges[i], 1), to = mapping.map(ranges[i + 1], -1);
        if (from <= to) {
          result.push(from, to);
        }
      }
      return result;
    }
    function histTransaction(history2, state, dispatch, redo2) {
      var preserveItems = mustPreserveItems(state), histOptions = historyKey.get(state).spec.config;
      var pop = (redo2 ? history2.undone : history2.done).popEvent(state, preserveItems);
      if (!pop) {
        return;
      }
      var selection = pop.selection.resolve(pop.transform.doc);
      var added = (redo2 ? history2.done : history2.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);
      var newHist = new HistoryState(redo2 ? added : pop.remaining, redo2 ? pop.remaining : added, null, 0);
      dispatch(pop.transform.setSelection(selection).setMeta(historyKey, { redo: redo2, historyState: newHist }).scrollIntoView());
    }
    var cachedPreserveItems = false;
    var cachedPreserveItemsPlugins = null;
    function mustPreserveItems(state) {
      var plugins = state.plugins;
      if (cachedPreserveItemsPlugins != plugins) {
        cachedPreserveItems = false;
        cachedPreserveItemsPlugins = plugins;
        for (var i = 0; i < plugins.length; i++) {
          if (plugins[i].spec.historyPreserveItems) {
            cachedPreserveItems = true;
            break;
          }
        }
      }
      return cachedPreserveItems;
    }
    function closeHistory(tr) {
      return tr.setMeta(closeHistoryKey, true);
    }
    var historyKey = new prosemirrorState.PluginKey("history");
    var closeHistoryKey = new prosemirrorState.PluginKey("closeHistory");
    function history(config) {
      config = {
        depth: config && config.depth || 100,
        newGroupDelay: config && config.newGroupDelay || 500
      };
      return new prosemirrorState.Plugin({
        key: historyKey,
        state: {
          init: function init2() {
            return new HistoryState(Branch.empty, Branch.empty, null, 0);
          },
          apply: function apply(tr, hist, state) {
            return applyTransaction(hist, state, tr, config);
          }
        },
        config,
        props: {
          handleDOMEvents: {
            beforeinput: function beforeinput(view, e) {
              var handled = e.inputType == "historyUndo" ? undo(view.state, view.dispatch) : e.inputType == "historyRedo" ? redo(view.state, view.dispatch) : false;
              if (handled) {
                e.preventDefault();
              }
              return handled;
            }
          }
        }
      });
    }
    function undo(state, dispatch) {
      var hist = historyKey.getState(state);
      if (!hist || hist.done.eventCount == 0) {
        return false;
      }
      if (dispatch) {
        histTransaction(hist, state, dispatch, false);
      }
      return true;
    }
    function redo(state, dispatch) {
      var hist = historyKey.getState(state);
      if (!hist || hist.undone.eventCount == 0) {
        return false;
      }
      if (dispatch) {
        histTransaction(hist, state, dispatch, true);
      }
      return true;
    }
    function undoDepth(state) {
      var hist = historyKey.getState(state);
      return hist ? hist.done.eventCount : 0;
    }
    function redoDepth(state) {
      var hist = historyKey.getState(state);
      return hist ? hist.undone.eventCount : 0;
    }
    exports.HistoryState = HistoryState;
    exports.closeHistory = closeHistory;
    exports.history = history;
    exports.redo = redo;
    exports.redoDepth = redoDepth;
    exports.undo = undo;
    exports.undoDepth = undoDepth;
  }
});

// node_modules/@tiptap/extension-history/dist/tiptap-extension-history.cjs.js
var require_tiptap_extension_history_cjs = __commonJS({
  "node_modules/@tiptap/extension-history/dist/tiptap-extension-history.cjs.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_tiptap_core_cjs();
    var prosemirrorHistory = require_dist11();
    var History = core.Extension.create({
      name: "history",
      defaultOptions: {
        depth: 100,
        newGroupDelay: 500
      },
      addCommands() {
        return {
          undo: () => ({ state, dispatch }) => {
            return prosemirrorHistory.undo(state, dispatch);
          },
          redo: () => ({ state, dispatch }) => {
            return prosemirrorHistory.redo(state, dispatch);
          }
        };
      },
      addProseMirrorPlugins() {
        return [
          prosemirrorHistory.history(this.options)
        ];
      },
      addKeyboardShortcuts() {
        return {
          "Mod-z": () => this.editor.commands.undo(),
          "Mod-y": () => this.editor.commands.redo(),
          "Shift-Mod-z": () => this.editor.commands.redo(),
          "Mod-\u044F": () => this.editor.commands.undo(),
          "Shift-Mod-\u044F": () => this.editor.commands.redo()
        };
      }
    });
    exports.History = History;
    exports["default"] = History;
  }
});

// node_modules/@tiptap/extension-horizontal-rule/dist/tiptap-extension-horizontal-rule.cjs.js
var require_tiptap_extension_horizontal_rule_cjs = __commonJS({
  "node_modules/@tiptap/extension-horizontal-rule/dist/tiptap-extension-horizontal-rule.cjs.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_tiptap_core_cjs();
    var prosemirrorState = require_dist3();
    var HorizontalRule = core.Node.create({
      name: "horizontalRule",
      defaultOptions: {
        HTMLAttributes: {}
      },
      group: "block",
      parseHTML() {
        return [
          { tag: "hr" }
        ];
      },
      renderHTML({ HTMLAttributes }) {
        return ["hr", core.mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];
      },
      addCommands() {
        return {
          setHorizontalRule: () => ({ chain }) => {
            return chain().command(({ tr, dispatch }) => {
              const { selection } = tr;
              const { empty: empty2, $anchor } = selection;
              const isEmptyTextBlock = $anchor.parent.isTextblock && !$anchor.parent.type.spec.code && !$anchor.parent.textContent;
              if (!empty2 || !isEmptyTextBlock || !dispatch) {
                return true;
              }
              const from = $anchor.before();
              const to = $anchor.start();
              tr.deleteRange(from, to);
              tr.setSelection(prosemirrorState.TextSelection.create(tr.doc, from));
              return true;
            }).insertContent({ type: this.name }).command(({ tr, dispatch }) => {
              var _a;
              if (dispatch) {
                const { parent, pos } = tr.selection.$from;
                const posAfter = pos + 1;
                const nodeAfter = tr.doc.nodeAt(posAfter);
                if (!nodeAfter) {
                  const node = (_a = parent.type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.create();
                  if (node) {
                    tr.insert(posAfter, node);
                    tr.setSelection(prosemirrorState.TextSelection.create(tr.doc, posAfter));
                  }
                }
                tr.scrollIntoView();
              }
              return true;
            }).run();
          }
        };
      },
      addInputRules() {
        return [
          core.nodeInputRule({
            find: /^(?:---|-|___\s|\*\*\*\s)$/,
            type: this.type
          })
        ];
      }
    });
    exports.HorizontalRule = HorizontalRule;
    exports["default"] = HorizontalRule;
  }
});

// node_modules/@tiptap/extension-italic/dist/tiptap-extension-italic.cjs.js
var require_tiptap_extension_italic_cjs = __commonJS({
  "node_modules/@tiptap/extension-italic/dist/tiptap-extension-italic.cjs.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_tiptap_core_cjs();
    var starInputRegex = /(?:^|\s)((?:\*)((?:[^*]+))(?:\*))$/gm;
    var starPasteRegex = /(?:^|\s)((?:\*)((?:[^*]+))(?:\*))/gm;
    var underscoreInputRegex = /(?:^|\s)((?:_)((?:[^_]+))(?:_))$/gm;
    var underscorePasteRegex = /(?:^|\s)((?:_)((?:[^_]+))(?:_))/gm;
    var Italic = core.Mark.create({
      name: "italic",
      defaultOptions: {
        HTMLAttributes: {}
      },
      parseHTML() {
        return [
          {
            tag: "em"
          },
          {
            tag: "i",
            getAttrs: (node) => node.style.fontStyle !== "normal" && null
          },
          {
            style: "font-style=italic"
          }
        ];
      },
      renderHTML({ HTMLAttributes }) {
        return ["em", core.mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
      },
      addCommands() {
        return {
          setItalic: () => ({ commands }) => {
            return commands.setMark("italic");
          },
          toggleItalic: () => ({ commands }) => {
            return commands.toggleMark("italic");
          },
          unsetItalic: () => ({ commands }) => {
            return commands.unsetMark("italic");
          }
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-i": () => this.editor.commands.toggleItalic()
        };
      },
      addInputRules() {
        return [
          core.markInputRule({
            find: starInputRegex,
            type: this.type
          }),
          core.markInputRule({
            find: underscoreInputRegex,
            type: this.type
          })
        ];
      },
      addPasteRules() {
        return [
          core.markPasteRule({
            find: starPasteRegex,
            type: this.type
          }),
          core.markPasteRule({
            find: underscorePasteRegex,
            type: this.type
          })
        ];
      }
    });
    exports.Italic = Italic;
    exports["default"] = Italic;
    exports.starInputRegex = starInputRegex;
    exports.starPasteRegex = starPasteRegex;
    exports.underscoreInputRegex = underscoreInputRegex;
    exports.underscorePasteRegex = underscorePasteRegex;
  }
});

// node_modules/@tiptap/extension-list-item/dist/tiptap-extension-list-item.cjs.js
var require_tiptap_extension_list_item_cjs = __commonJS({
  "node_modules/@tiptap/extension-list-item/dist/tiptap-extension-list-item.cjs.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_tiptap_core_cjs();
    var ListItem = core.Node.create({
      name: "listItem",
      defaultOptions: {
        HTMLAttributes: {}
      },
      content: "paragraph block*",
      defining: true,
      parseHTML() {
        return [
          {
            tag: "li"
          }
        ];
      },
      renderHTML({ HTMLAttributes }) {
        return ["li", core.mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
      },
      addKeyboardShortcuts() {
        return {
          Enter: () => this.editor.commands.splitListItem("listItem"),
          Tab: () => this.editor.commands.sinkListItem("listItem"),
          "Shift-Tab": () => this.editor.commands.liftListItem("listItem")
        };
      }
    });
    exports.ListItem = ListItem;
    exports.default = ListItem;
  }
});

// node_modules/@tiptap/extension-ordered-list/dist/tiptap-extension-ordered-list.cjs.js
var require_tiptap_extension_ordered_list_cjs = __commonJS({
  "node_modules/@tiptap/extension-ordered-list/dist/tiptap-extension-ordered-list.cjs.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_tiptap_core_cjs();
    var inputRegex = /^(\d+)\.\s$/;
    var OrderedList = core.Node.create({
      name: "orderedList",
      defaultOptions: {
        HTMLAttributes: {}
      },
      group: "block list",
      content: "listItem+",
      addAttributes() {
        return {
          start: {
            default: 1,
            parseHTML: (element) => {
              return element.hasAttribute("start") ? parseInt(element.getAttribute("start") || "", 10) : 1;
            }
          }
        };
      },
      parseHTML() {
        return [
          {
            tag: "ol"
          }
        ];
      },
      renderHTML({ HTMLAttributes }) {
        const { start, ...attributesWithoutStart } = HTMLAttributes;
        return start === 1 ? ["ol", core.mergeAttributes(this.options.HTMLAttributes, attributesWithoutStart), 0] : ["ol", core.mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
      },
      addCommands() {
        return {
          toggleOrderedList: () => ({ commands }) => {
            return commands.toggleList("orderedList", "listItem");
          }
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Shift-7": () => this.editor.commands.toggleOrderedList()
        };
      },
      addInputRules() {
        return [
          core.wrappingInputRule({
            find: inputRegex,
            type: this.type,
            getAttributes: (match) => ({ start: +match[1] }),
            joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1]
          })
        ];
      }
    });
    exports.OrderedList = OrderedList;
    exports["default"] = OrderedList;
    exports.inputRegex = inputRegex;
  }
});

// node_modules/@tiptap/extension-paragraph/dist/tiptap-extension-paragraph.cjs.js
var require_tiptap_extension_paragraph_cjs = __commonJS({
  "node_modules/@tiptap/extension-paragraph/dist/tiptap-extension-paragraph.cjs.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_tiptap_core_cjs();
    var Paragraph = core.Node.create({
      name: "paragraph",
      priority: 1e3,
      defaultOptions: {
        HTMLAttributes: {}
      },
      group: "block",
      content: "inline*",
      parseHTML() {
        return [
          { tag: "p" }
        ];
      },
      renderHTML({ HTMLAttributes }) {
        return ["p", core.mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
      },
      addCommands() {
        return {
          setParagraph: () => ({ commands }) => {
            return commands.setNode("paragraph");
          }
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Alt-0": () => this.editor.commands.setParagraph()
        };
      }
    });
    exports.Paragraph = Paragraph;
    exports["default"] = Paragraph;
  }
});

// node_modules/@tiptap/extension-strike/dist/tiptap-extension-strike.cjs.js
var require_tiptap_extension_strike_cjs = __commonJS({
  "node_modules/@tiptap/extension-strike/dist/tiptap-extension-strike.cjs.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_tiptap_core_cjs();
    var inputRegex = /(?:^|\s)((?:~~)((?:[^~]+))(?:~~))$/gm;
    var pasteRegex = /(?:^|\s)((?:~~)((?:[^~]+))(?:~~))/gm;
    var Strike = core.Mark.create({
      name: "strike",
      defaultOptions: {
        HTMLAttributes: {}
      },
      parseHTML() {
        return [
          {
            tag: "s"
          },
          {
            tag: "del"
          },
          {
            tag: "strike"
          },
          {
            style: "text-decoration",
            consuming: false,
            getAttrs: (style) => style.includes("line-through") ? {} : false
          }
        ];
      },
      renderHTML({ HTMLAttributes }) {
        return ["s", core.mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
      },
      addCommands() {
        return {
          setStrike: () => ({ commands }) => {
            return commands.setMark("strike");
          },
          toggleStrike: () => ({ commands }) => {
            return commands.toggleMark("strike");
          },
          unsetStrike: () => ({ commands }) => {
            return commands.unsetMark("strike");
          }
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Shift-x": () => this.editor.commands.toggleStrike()
        };
      },
      addInputRules() {
        return [
          core.markInputRule({
            find: inputRegex,
            type: this.type
          })
        ];
      },
      addPasteRules() {
        return [
          core.markPasteRule({
            find: pasteRegex,
            type: this.type
          })
        ];
      }
    });
    exports.Strike = Strike;
    exports["default"] = Strike;
    exports.inputRegex = inputRegex;
    exports.pasteRegex = pasteRegex;
  }
});

// node_modules/@tiptap/extension-text/dist/tiptap-extension-text.cjs.js
var require_tiptap_extension_text_cjs = __commonJS({
  "node_modules/@tiptap/extension-text/dist/tiptap-extension-text.cjs.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_tiptap_core_cjs();
    var Text = core.Node.create({
      name: "text",
      group: "inline"
    });
    exports.Text = Text;
    exports.default = Text;
  }
});

// node_modules/@tiptap/starter-kit/dist/tiptap-starter-kit.cjs.js
var require_tiptap_starter_kit_cjs = __commonJS({
  "node_modules/@tiptap/starter-kit/dist/tiptap-starter-kit.cjs.js"(exports, module2) {
    init_shims();
    "use strict";
    var core = require_tiptap_core_cjs();
    var Blockquote = require_tiptap_extension_blockquote_cjs();
    var Bold = require_tiptap_extension_bold_cjs();
    var BulletList = require_tiptap_extension_bullet_list_cjs();
    var Code2 = require_tiptap_extension_code_cjs();
    var CodeBlock = require_tiptap_extension_code_block_cjs();
    var Document = require_tiptap_extension_document_cjs();
    var Dropcursor = require_tiptap_extension_dropcursor_cjs();
    var Gapcursor = require_tiptap_extension_gapcursor_cjs();
    var HardBreak = require_tiptap_extension_hard_break_cjs();
    var Heading = require_tiptap_extension_heading_cjs();
    var History = require_tiptap_extension_history_cjs();
    var HorizontalRule = require_tiptap_extension_horizontal_rule_cjs();
    var Italic = require_tiptap_extension_italic_cjs();
    var ListItem = require_tiptap_extension_list_item_cjs();
    var OrderedList = require_tiptap_extension_ordered_list_cjs();
    var Paragraph = require_tiptap_extension_paragraph_cjs();
    var Strike = require_tiptap_extension_strike_cjs();
    var Text = require_tiptap_extension_text_cjs();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var Blockquote__default = /* @__PURE__ */ _interopDefaultLegacy(Blockquote);
    var Bold__default = /* @__PURE__ */ _interopDefaultLegacy(Bold);
    var BulletList__default = /* @__PURE__ */ _interopDefaultLegacy(BulletList);
    var Code__default = /* @__PURE__ */ _interopDefaultLegacy(Code2);
    var CodeBlock__default = /* @__PURE__ */ _interopDefaultLegacy(CodeBlock);
    var Document__default = /* @__PURE__ */ _interopDefaultLegacy(Document);
    var Dropcursor__default = /* @__PURE__ */ _interopDefaultLegacy(Dropcursor);
    var Gapcursor__default = /* @__PURE__ */ _interopDefaultLegacy(Gapcursor);
    var HardBreak__default = /* @__PURE__ */ _interopDefaultLegacy(HardBreak);
    var Heading__default = /* @__PURE__ */ _interopDefaultLegacy(Heading);
    var History__default = /* @__PURE__ */ _interopDefaultLegacy(History);
    var HorizontalRule__default = /* @__PURE__ */ _interopDefaultLegacy(HorizontalRule);
    var Italic__default = /* @__PURE__ */ _interopDefaultLegacy(Italic);
    var ListItem__default = /* @__PURE__ */ _interopDefaultLegacy(ListItem);
    var OrderedList__default = /* @__PURE__ */ _interopDefaultLegacy(OrderedList);
    var Paragraph__default = /* @__PURE__ */ _interopDefaultLegacy(Paragraph);
    var Strike__default = /* @__PURE__ */ _interopDefaultLegacy(Strike);
    var Text__default = /* @__PURE__ */ _interopDefaultLegacy(Text);
    var StarterKit = core.Extension.create({
      name: "starterKit",
      addExtensions() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
        const extensions = [];
        if (this.options.blockquote !== false) {
          extensions.push(Blockquote__default["default"].configure((_a = this.options) === null || _a === void 0 ? void 0 : _a.blockquote));
        }
        if (this.options.bold !== false) {
          extensions.push(Bold__default["default"].configure((_b = this.options) === null || _b === void 0 ? void 0 : _b.bold));
        }
        if (this.options.bulletList !== false) {
          extensions.push(BulletList__default["default"].configure((_c = this.options) === null || _c === void 0 ? void 0 : _c.bulletList));
        }
        if (this.options.code !== false) {
          extensions.push(Code__default["default"].configure((_d = this.options) === null || _d === void 0 ? void 0 : _d.code));
        }
        if (this.options.codeBlock !== false) {
          extensions.push(CodeBlock__default["default"].configure((_e = this.options) === null || _e === void 0 ? void 0 : _e.codeBlock));
        }
        if (this.options.document !== false) {
          extensions.push(Document__default["default"].configure((_f = this.options) === null || _f === void 0 ? void 0 : _f.document));
        }
        if (this.options.dropcursor !== false) {
          extensions.push(Dropcursor__default["default"].configure((_g = this.options) === null || _g === void 0 ? void 0 : _g.dropcursor));
        }
        if (this.options.gapcursor !== false) {
          extensions.push(Gapcursor__default["default"].configure((_h = this.options) === null || _h === void 0 ? void 0 : _h.gapcursor));
        }
        if (this.options.hardBreak !== false) {
          extensions.push(HardBreak__default["default"].configure((_j = this.options) === null || _j === void 0 ? void 0 : _j.hardBreak));
        }
        if (this.options.heading !== false) {
          extensions.push(Heading__default["default"].configure((_k = this.options) === null || _k === void 0 ? void 0 : _k.heading));
        }
        if (this.options.history !== false) {
          extensions.push(History__default["default"].configure((_l = this.options) === null || _l === void 0 ? void 0 : _l.history));
        }
        if (this.options.horizontalRule !== false) {
          extensions.push(HorizontalRule__default["default"].configure((_m = this.options) === null || _m === void 0 ? void 0 : _m.horizontalRule));
        }
        if (this.options.italic !== false) {
          extensions.push(Italic__default["default"].configure((_o = this.options) === null || _o === void 0 ? void 0 : _o.italic));
        }
        if (this.options.listItem !== false) {
          extensions.push(ListItem__default["default"].configure((_p = this.options) === null || _p === void 0 ? void 0 : _p.listItem));
        }
        if (this.options.orderedList !== false) {
          extensions.push(OrderedList__default["default"].configure((_q = this.options) === null || _q === void 0 ? void 0 : _q.orderedList));
        }
        if (this.options.paragraph !== false) {
          extensions.push(Paragraph__default["default"].configure((_r = this.options) === null || _r === void 0 ? void 0 : _r.paragraph));
        }
        if (this.options.strike !== false) {
          extensions.push(Strike__default["default"].configure((_s = this.options) === null || _s === void 0 ? void 0 : _s.strike));
        }
        if (this.options.text !== false) {
          extensions.push(Text__default["default"].configure((_t = this.options) === null || _t === void 0 ? void 0 : _t.text));
        }
        return extensions;
      }
    });
    module2.exports = StarterKit;
  }
});

// node_modules/prismjs/prism.js
var require_prism = __commonJS({
  "node_modules/prismjs/prism.js"(exports, module2) {
    init_shims();
    var _self = typeof window !== "undefined" ? window : typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope ? self : {};
    var Prism2 = function(_self2) {
      var lang = /\blang(?:uage)?-([\w-]+)\b/i;
      var uniqueId = 0;
      var plainTextGrammar = {};
      var _ = {
        manual: _self2.Prism && _self2.Prism.manual,
        disableWorkerMessageHandler: _self2.Prism && _self2.Prism.disableWorkerMessageHandler,
        util: {
          encode: function encode(tokens) {
            if (tokens instanceof Token) {
              return new Token(tokens.type, encode(tokens.content), tokens.alias);
            } else if (Array.isArray(tokens)) {
              return tokens.map(encode);
            } else {
              return tokens.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
            }
          },
          type: function(o) {
            return Object.prototype.toString.call(o).slice(8, -1);
          },
          objId: function(obj) {
            if (!obj["__id"]) {
              Object.defineProperty(obj, "__id", { value: ++uniqueId });
            }
            return obj["__id"];
          },
          clone: function deepClone(o, visited) {
            visited = visited || {};
            var clone2;
            var id;
            switch (_.util.type(o)) {
              case "Object":
                id = _.util.objId(o);
                if (visited[id]) {
                  return visited[id];
                }
                clone2 = {};
                visited[id] = clone2;
                for (var key in o) {
                  if (o.hasOwnProperty(key)) {
                    clone2[key] = deepClone(o[key], visited);
                  }
                }
                return clone2;
              case "Array":
                id = _.util.objId(o);
                if (visited[id]) {
                  return visited[id];
                }
                clone2 = [];
                visited[id] = clone2;
                o.forEach(function(v, i) {
                  clone2[i] = deepClone(v, visited);
                });
                return clone2;
              default:
                return o;
            }
          },
          getLanguage: function(element) {
            while (element && !lang.test(element.className)) {
              element = element.parentElement;
            }
            if (element) {
              return (element.className.match(lang) || [, "none"])[1].toLowerCase();
            }
            return "none";
          },
          currentScript: function() {
            if (typeof document === "undefined") {
              return null;
            }
            if ("currentScript" in document && 1 < 2) {
              return document.currentScript;
            }
            try {
              throw new Error();
            } catch (err) {
              var src2 = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(err.stack) || [])[1];
              if (src2) {
                var scripts = document.getElementsByTagName("script");
                for (var i in scripts) {
                  if (scripts[i].src == src2) {
                    return scripts[i];
                  }
                }
              }
              return null;
            }
          },
          isActive: function(element, className, defaultActivation) {
            var no = "no-" + className;
            while (element) {
              var classList = element.classList;
              if (classList.contains(className)) {
                return true;
              }
              if (classList.contains(no)) {
                return false;
              }
              element = element.parentElement;
            }
            return !!defaultActivation;
          }
        },
        languages: {
          plain: plainTextGrammar,
          plaintext: plainTextGrammar,
          text: plainTextGrammar,
          txt: plainTextGrammar,
          extend: function(id, redef) {
            var lang2 = _.util.clone(_.languages[id]);
            for (var key in redef) {
              lang2[key] = redef[key];
            }
            return lang2;
          },
          insertBefore: function(inside, before, insert, root) {
            root = root || _.languages;
            var grammar = root[inside];
            var ret = {};
            for (var token in grammar) {
              if (grammar.hasOwnProperty(token)) {
                if (token == before) {
                  for (var newToken in insert) {
                    if (insert.hasOwnProperty(newToken)) {
                      ret[newToken] = insert[newToken];
                    }
                  }
                }
                if (!insert.hasOwnProperty(token)) {
                  ret[token] = grammar[token];
                }
              }
            }
            var old = root[inside];
            root[inside] = ret;
            _.languages.DFS(_.languages, function(key, value) {
              if (value === old && key != inside) {
                this[key] = ret;
              }
            });
            return ret;
          },
          DFS: function DFS(o, callback, type, visited) {
            visited = visited || {};
            var objId = _.util.objId;
            for (var i in o) {
              if (o.hasOwnProperty(i)) {
                callback.call(o, i, o[i], type || i);
                var property = o[i];
                var propertyType = _.util.type(property);
                if (propertyType === "Object" && !visited[objId(property)]) {
                  visited[objId(property)] = true;
                  DFS(property, callback, null, visited);
                } else if (propertyType === "Array" && !visited[objId(property)]) {
                  visited[objId(property)] = true;
                  DFS(property, callback, i, visited);
                }
              }
            }
          }
        },
        plugins: {},
        highlightAll: function(async, callback) {
          _.highlightAllUnder(document, async, callback);
        },
        highlightAllUnder: function(container, async, callback) {
          var env = {
            callback,
            container,
            selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
          };
          _.hooks.run("before-highlightall", env);
          env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));
          _.hooks.run("before-all-elements-highlight", env);
          for (var i = 0, element; element = env.elements[i++]; ) {
            _.highlightElement(element, async === true, env.callback);
          }
        },
        highlightElement: function(element, async, callback) {
          var language = _.util.getLanguage(element);
          var grammar = _.languages[language];
          element.className = element.className.replace(lang, "").replace(/\s+/g, " ") + " language-" + language;
          var parent = element.parentElement;
          if (parent && parent.nodeName.toLowerCase() === "pre") {
            parent.className = parent.className.replace(lang, "").replace(/\s+/g, " ") + " language-" + language;
          }
          var code = element.textContent;
          var env = {
            element,
            language,
            grammar,
            code
          };
          function insertHighlightedCode(highlightedCode) {
            env.highlightedCode = highlightedCode;
            _.hooks.run("before-insert", env);
            env.element.innerHTML = env.highlightedCode;
            _.hooks.run("after-highlight", env);
            _.hooks.run("complete", env);
            callback && callback.call(env.element);
          }
          _.hooks.run("before-sanity-check", env);
          parent = env.element.parentElement;
          if (parent && parent.nodeName.toLowerCase() === "pre" && !parent.hasAttribute("tabindex")) {
            parent.setAttribute("tabindex", "0");
          }
          if (!env.code) {
            _.hooks.run("complete", env);
            callback && callback.call(env.element);
            return;
          }
          _.hooks.run("before-highlight", env);
          if (!env.grammar) {
            insertHighlightedCode(_.util.encode(env.code));
            return;
          }
          if (async && _self2.Worker) {
            var worker = new Worker(_.filename);
            worker.onmessage = function(evt) {
              insertHighlightedCode(evt.data);
            };
            worker.postMessage(JSON.stringify({
              language: env.language,
              code: env.code,
              immediateClose: true
            }));
          } else {
            insertHighlightedCode(_.highlight(env.code, env.grammar, env.language));
          }
        },
        highlight: function(text, grammar, language) {
          var env = {
            code: text,
            grammar,
            language
          };
          _.hooks.run("before-tokenize", env);
          env.tokens = _.tokenize(env.code, env.grammar);
          _.hooks.run("after-tokenize", env);
          return Token.stringify(_.util.encode(env.tokens), env.language);
        },
        tokenize: function(text, grammar) {
          var rest = grammar.rest;
          if (rest) {
            for (var token in rest) {
              grammar[token] = rest[token];
            }
            delete grammar.rest;
          }
          var tokenList = new LinkedList();
          addAfter(tokenList, tokenList.head, text);
          matchGrammar(text, tokenList, grammar, tokenList.head, 0);
          return toArray(tokenList);
        },
        hooks: {
          all: {},
          add: function(name, callback) {
            var hooks = _.hooks.all;
            hooks[name] = hooks[name] || [];
            hooks[name].push(callback);
          },
          run: function(name, env) {
            var callbacks = _.hooks.all[name];
            if (!callbacks || !callbacks.length) {
              return;
            }
            for (var i = 0, callback; callback = callbacks[i++]; ) {
              callback(env);
            }
          }
        },
        Token
      };
      _self2.Prism = _;
      function Token(type, content, alias, matchedStr) {
        this.type = type;
        this.content = content;
        this.alias = alias;
        this.length = (matchedStr || "").length | 0;
      }
      Token.stringify = function stringify(o, language) {
        if (typeof o == "string") {
          return o;
        }
        if (Array.isArray(o)) {
          var s2 = "";
          o.forEach(function(e) {
            s2 += stringify(e, language);
          });
          return s2;
        }
        var env = {
          type: o.type,
          content: stringify(o.content, language),
          tag: "span",
          classes: ["token", o.type],
          attributes: {},
          language
        };
        var aliases = o.alias;
        if (aliases) {
          if (Array.isArray(aliases)) {
            Array.prototype.push.apply(env.classes, aliases);
          } else {
            env.classes.push(aliases);
          }
        }
        _.hooks.run("wrap", env);
        var attributes = "";
        for (var name in env.attributes) {
          attributes += " " + name + '="' + (env.attributes[name] || "").replace(/"/g, "&quot;") + '"';
        }
        return "<" + env.tag + ' class="' + env.classes.join(" ") + '"' + attributes + ">" + env.content + "</" + env.tag + ">";
      };
      function matchPattern(pattern, pos, text, lookbehind) {
        pattern.lastIndex = pos;
        var match = pattern.exec(text);
        if (match && lookbehind && match[1]) {
          var lookbehindLength = match[1].length;
          match.index += lookbehindLength;
          match[0] = match[0].slice(lookbehindLength);
        }
        return match;
      }
      function matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {
        for (var token in grammar) {
          if (!grammar.hasOwnProperty(token) || !grammar[token]) {
            continue;
          }
          var patterns = grammar[token];
          patterns = Array.isArray(patterns) ? patterns : [patterns];
          for (var j = 0; j < patterns.length; ++j) {
            if (rematch && rematch.cause == token + "," + j) {
              return;
            }
            var patternObj = patterns[j];
            var inside = patternObj.inside;
            var lookbehind = !!patternObj.lookbehind;
            var greedy = !!patternObj.greedy;
            var alias = patternObj.alias;
            if (greedy && !patternObj.pattern.global) {
              var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
              patternObj.pattern = RegExp(patternObj.pattern.source, flags + "g");
            }
            var pattern = patternObj.pattern || patternObj;
            for (var currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail; pos += currentNode.value.length, currentNode = currentNode.next) {
              if (rematch && pos >= rematch.reach) {
                break;
              }
              var str = currentNode.value;
              if (tokenList.length > text.length) {
                return;
              }
              if (str instanceof Token) {
                continue;
              }
              var removeCount = 1;
              var match;
              if (greedy) {
                match = matchPattern(pattern, pos, text, lookbehind);
                if (!match) {
                  break;
                }
                var from = match.index;
                var to = match.index + match[0].length;
                var p = pos;
                p += currentNode.value.length;
                while (from >= p) {
                  currentNode = currentNode.next;
                  p += currentNode.value.length;
                }
                p -= currentNode.value.length;
                pos = p;
                if (currentNode.value instanceof Token) {
                  continue;
                }
                for (var k = currentNode; k !== tokenList.tail && (p < to || typeof k.value === "string"); k = k.next) {
                  removeCount++;
                  p += k.value.length;
                }
                removeCount--;
                str = text.slice(pos, p);
                match.index -= pos;
              } else {
                match = matchPattern(pattern, 0, str, lookbehind);
                if (!match) {
                  continue;
                }
              }
              var from = match.index;
              var matchStr = match[0];
              var before = str.slice(0, from);
              var after = str.slice(from + matchStr.length);
              var reach = pos + str.length;
              if (rematch && reach > rematch.reach) {
                rematch.reach = reach;
              }
              var removeFrom = currentNode.prev;
              if (before) {
                removeFrom = addAfter(tokenList, removeFrom, before);
                pos += before.length;
              }
              removeRange(tokenList, removeFrom, removeCount);
              var wrapped = new Token(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);
              currentNode = addAfter(tokenList, removeFrom, wrapped);
              if (after) {
                addAfter(tokenList, currentNode, after);
              }
              if (removeCount > 1) {
                var nestedRematch = {
                  cause: token + "," + j,
                  reach
                };
                matchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch);
                if (rematch && nestedRematch.reach > rematch.reach) {
                  rematch.reach = nestedRematch.reach;
                }
              }
            }
          }
        }
      }
      function LinkedList() {
        var head = { value: null, prev: null, next: null };
        var tail = { value: null, prev: head, next: null };
        head.next = tail;
        this.head = head;
        this.tail = tail;
        this.length = 0;
      }
      function addAfter(list, node, value) {
        var next = node.next;
        var newNode = { value, prev: node, next };
        node.next = newNode;
        next.prev = newNode;
        list.length++;
        return newNode;
      }
      function removeRange(list, node, count) {
        var next = node.next;
        for (var i = 0; i < count && next !== list.tail; i++) {
          next = next.next;
        }
        node.next = next;
        next.prev = node;
        list.length -= i;
      }
      function toArray(list) {
        var array = [];
        var node = list.head.next;
        while (node !== list.tail) {
          array.push(node.value);
          node = node.next;
        }
        return array;
      }
      if (!_self2.document) {
        if (!_self2.addEventListener) {
          return _;
        }
        if (!_.disableWorkerMessageHandler) {
          _self2.addEventListener("message", function(evt) {
            var message = JSON.parse(evt.data);
            var lang2 = message.language;
            var code = message.code;
            var immediateClose = message.immediateClose;
            _self2.postMessage(_.highlight(code, _.languages[lang2], lang2));
            if (immediateClose) {
              _self2.close();
            }
          }, false);
        }
        return _;
      }
      var script = _.util.currentScript();
      if (script) {
        _.filename = script.src;
        if (script.hasAttribute("data-manual")) {
          _.manual = true;
        }
      }
      function highlightAutomaticallyCallback() {
        if (!_.manual) {
          _.highlightAll();
        }
      }
      if (!_.manual) {
        var readyState = document.readyState;
        if (readyState === "loading" || readyState === "interactive" && script && script.defer) {
          document.addEventListener("DOMContentLoaded", highlightAutomaticallyCallback);
        } else {
          if (window.requestAnimationFrame) {
            window.requestAnimationFrame(highlightAutomaticallyCallback);
          } else {
            window.setTimeout(highlightAutomaticallyCallback, 16);
          }
        }
      }
      return _;
    }(_self);
    if (typeof module2 !== "undefined" && module2.exports) {
      module2.exports = Prism2;
    }
    if (typeof global !== "undefined") {
      global.Prism = Prism2;
    }
    Prism2.languages.markup = {
      "comment": {
        pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
        greedy: true
      },
      "prolog": {
        pattern: /<\?[\s\S]+?\?>/,
        greedy: true
      },
      "doctype": {
        pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
        greedy: true,
        inside: {
          "internal-subset": {
            pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
            lookbehind: true,
            greedy: true,
            inside: null
          },
          "string": {
            pattern: /"[^"]*"|'[^']*'/,
            greedy: true
          },
          "punctuation": /^<!|>$|[[\]]/,
          "doctype-tag": /^DOCTYPE/i,
          "name": /[^\s<>'"]+/
        }
      },
      "cdata": {
        pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
        greedy: true
      },
      "tag": {
        pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
        greedy: true,
        inside: {
          "tag": {
            pattern: /^<\/?[^\s>\/]+/,
            inside: {
              "punctuation": /^<\/?/,
              "namespace": /^[^\s>\/:]+:/
            }
          },
          "special-attr": [],
          "attr-value": {
            pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
            inside: {
              "punctuation": [
                {
                  pattern: /^=/,
                  alias: "attr-equals"
                },
                /"|'/
              ]
            }
          },
          "punctuation": /\/?>/,
          "attr-name": {
            pattern: /[^\s>\/]+/,
            inside: {
              "namespace": /^[^\s>\/:]+:/
            }
          }
        }
      },
      "entity": [
        {
          pattern: /&[\da-z]{1,8};/i,
          alias: "named-entity"
        },
        /&#x?[\da-f]{1,8};/i
      ]
    };
    Prism2.languages.markup["tag"].inside["attr-value"].inside["entity"] = Prism2.languages.markup["entity"];
    Prism2.languages.markup["doctype"].inside["internal-subset"].inside = Prism2.languages.markup;
    Prism2.hooks.add("wrap", function(env) {
      if (env.type === "entity") {
        env.attributes["title"] = env.content.replace(/&amp;/, "&");
      }
    });
    Object.defineProperty(Prism2.languages.markup.tag, "addInlined", {
      value: function addInlined2(tagName, lang) {
        var includedCdataInside = {};
        includedCdataInside["language-" + lang] = {
          pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
          lookbehind: true,
          inside: Prism2.languages[lang]
        };
        includedCdataInside["cdata"] = /^<!\[CDATA\[|\]\]>$/i;
        var inside = {
          "included-cdata": {
            pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
            inside: includedCdataInside
          }
        };
        inside["language-" + lang] = {
          pattern: /[\s\S]+/,
          inside: Prism2.languages[lang]
        };
        var def = {};
        def[tagName] = {
          pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
            return tagName;
          }), "i"),
          lookbehind: true,
          greedy: true,
          inside
        };
        Prism2.languages.insertBefore("markup", "cdata", def);
      }
    });
    Object.defineProperty(Prism2.languages.markup.tag, "addAttribute", {
      value: function(attrName, lang) {
        Prism2.languages.markup.tag.inside["special-attr"].push({
          pattern: RegExp(/(^|["'\s])/.source + "(?:" + attrName + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source, "i"),
          lookbehind: true,
          inside: {
            "attr-name": /^[^\s=]+/,
            "attr-value": {
              pattern: /=[\s\S]+/,
              inside: {
                "value": {
                  pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                  lookbehind: true,
                  alias: [lang, "language-" + lang],
                  inside: Prism2.languages[lang]
                },
                "punctuation": [
                  {
                    pattern: /^=/,
                    alias: "attr-equals"
                  },
                  /"|'/
                ]
              }
            }
          }
        });
      }
    });
    Prism2.languages.html = Prism2.languages.markup;
    Prism2.languages.mathml = Prism2.languages.markup;
    Prism2.languages.svg = Prism2.languages.markup;
    Prism2.languages.xml = Prism2.languages.extend("markup", {});
    Prism2.languages.ssml = Prism2.languages.xml;
    Prism2.languages.atom = Prism2.languages.xml;
    Prism2.languages.rss = Prism2.languages.xml;
    (function(Prism3) {
      var string2 = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
      Prism3.languages.css = {
        "comment": /\/\*[\s\S]*?\*\//,
        "atrule": {
          pattern: /@[\w-](?:[^;{\s]|\s+(?![\s{]))*(?:;|(?=\s*\{))/,
          inside: {
            "rule": /^@[\w-]+/,
            "selector-function-argument": {
              pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
              lookbehind: true,
              alias: "selector"
            },
            "keyword": {
              pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
              lookbehind: true
            }
          }
        },
        "url": {
          pattern: RegExp("\\burl\\((?:" + string2.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
          greedy: true,
          inside: {
            "function": /^url/i,
            "punctuation": /^\(|\)$/,
            "string": {
              pattern: RegExp("^" + string2.source + "$"),
              alias: "url"
            }
          }
        },
        "selector": {
          pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + string2.source + ")*(?=\\s*\\{)"),
          lookbehind: true
        },
        "string": {
          pattern: string2,
          greedy: true
        },
        "property": {
          pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
          lookbehind: true
        },
        "important": /!important\b/i,
        "function": {
          pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
          lookbehind: true
        },
        "punctuation": /[(){};:,]/
      };
      Prism3.languages.css["atrule"].inside.rest = Prism3.languages.css;
      var markup = Prism3.languages.markup;
      if (markup) {
        markup.tag.addInlined("style", "css");
        markup.tag.addAttribute("style", "css");
      }
    })(Prism2);
    Prism2.languages.clike = {
      "comment": [
        {
          pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
          lookbehind: true,
          greedy: true
        },
        {
          pattern: /(^|[^\\:])\/\/.*/,
          lookbehind: true,
          greedy: true
        }
      ],
      "string": {
        pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
        greedy: true
      },
      "class-name": {
        pattern: /(\b(?:class|interface|extends|implements|trait|instanceof|new)\s+|\bcatch\s+\()[\w.\\]+/i,
        lookbehind: true,
        inside: {
          "punctuation": /[.\\]/
        }
      },
      "keyword": /\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,
      "boolean": /\b(?:true|false)\b/,
      "function": /\b\w+(?=\()/,
      "number": /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
      "operator": /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
      "punctuation": /[{}[\];(),.:]/
    };
    Prism2.languages.javascript = Prism2.languages.extend("clike", {
      "class-name": [
        Prism2.languages.clike["class-name"],
        {
          pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:prototype|constructor))/,
          lookbehind: true
        }
      ],
      "keyword": [
        {
          pattern: /((?:^|\})\s*)catch\b/,
          lookbehind: true
        },
        {
          pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
          lookbehind: true
        }
      ],
      "function": /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
      "number": /\b(?:(?:0[xX](?:[\dA-Fa-f](?:_[\dA-Fa-f])?)+|0[bB](?:[01](?:_[01])?)+|0[oO](?:[0-7](?:_[0-7])?)+)n?|(?:\d(?:_\d)?)+n|NaN|Infinity)\b|(?:\b(?:\d(?:_\d)?)+\.?(?:\d(?:_\d)?)*|\B\.(?:\d(?:_\d)?)+)(?:[Ee][+-]?(?:\d(?:_\d)?)+)?/,
      "operator": /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
    });
    Prism2.languages.javascript["class-name"][0].pattern = /(\b(?:class|interface|extends|implements|instanceof|new)\s+)[\w.\\]+/;
    Prism2.languages.insertBefore("javascript", "keyword", {
      "regex": {
        pattern: /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)\/(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/,
        lookbehind: true,
        greedy: true,
        inside: {
          "regex-source": {
            pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
            lookbehind: true,
            alias: "language-regex",
            inside: Prism2.languages.regex
          },
          "regex-delimiter": /^\/|\/$/,
          "regex-flags": /^[a-z]+$/
        }
      },
      "function-variable": {
        pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
        alias: "function"
      },
      "parameter": [
        {
          pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
          lookbehind: true,
          inside: Prism2.languages.javascript
        },
        {
          pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
          lookbehind: true,
          inside: Prism2.languages.javascript
        },
        {
          pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
          lookbehind: true,
          inside: Prism2.languages.javascript
        },
        {
          pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
          lookbehind: true,
          inside: Prism2.languages.javascript
        }
      ],
      "constant": /\b[A-Z](?:[A-Z_]|\dx?)*\b/
    });
    Prism2.languages.insertBefore("javascript", "string", {
      "hashbang": {
        pattern: /^#!.*/,
        greedy: true,
        alias: "comment"
      },
      "template-string": {
        pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
        greedy: true,
        inside: {
          "template-punctuation": {
            pattern: /^`|`$/,
            alias: "string"
          },
          "interpolation": {
            pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
            lookbehind: true,
            inside: {
              "interpolation-punctuation": {
                pattern: /^\$\{|\}$/,
                alias: "punctuation"
              },
              rest: Prism2.languages.javascript
            }
          },
          "string": /[\s\S]+/
        }
      }
    });
    if (Prism2.languages.markup) {
      Prism2.languages.markup.tag.addInlined("script", "javascript");
      Prism2.languages.markup.tag.addAttribute(/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source, "javascript");
    }
    Prism2.languages.js = Prism2.languages.javascript;
    (function() {
      if (typeof Prism2 === "undefined" || typeof document === "undefined") {
        return;
      }
      if (!Element.prototype.matches) {
        Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
      }
      var LOADING_MESSAGE = "Loading\u2026";
      var FAILURE_MESSAGE = function(status, message) {
        return "\u2716 Error " + status + " while fetching file: " + message;
      };
      var FAILURE_EMPTY_MESSAGE = "\u2716 Error: File does not exist or is empty";
      var EXTENSIONS = {
        "js": "javascript",
        "py": "python",
        "rb": "ruby",
        "ps1": "powershell",
        "psm1": "powershell",
        "sh": "bash",
        "bat": "batch",
        "h": "c",
        "tex": "latex"
      };
      var STATUS_ATTR = "data-src-status";
      var STATUS_LOADING = "loading";
      var STATUS_LOADED = "loaded";
      var STATUS_FAILED = "failed";
      var SELECTOR = "pre[data-src]:not([" + STATUS_ATTR + '="' + STATUS_LOADED + '"]):not([' + STATUS_ATTR + '="' + STATUS_LOADING + '"])';
      var lang = /\blang(?:uage)?-([\w-]+)\b/i;
      function setLanguageClass(element, language) {
        var className = element.className;
        className = className.replace(lang, " ") + " language-" + language;
        element.className = className.replace(/\s+/g, " ").trim();
      }
      Prism2.hooks.add("before-highlightall", function(env) {
        env.selector += ", " + SELECTOR;
      });
      Prism2.hooks.add("before-sanity-check", function(env) {
        var pre = env.element;
        if (pre.matches(SELECTOR)) {
          env.code = "";
          pre.setAttribute(STATUS_ATTR, STATUS_LOADING);
          var code = pre.appendChild(document.createElement("CODE"));
          code.textContent = LOADING_MESSAGE;
          var src2 = pre.getAttribute("data-src");
          var language = env.language;
          if (language === "none") {
            var extension = (/\.(\w+)$/.exec(src2) || [, "none"])[1];
            language = EXTENSIONS[extension] || extension;
          }
          setLanguageClass(code, language);
          setLanguageClass(pre, language);
          var autoloader = Prism2.plugins.autoloader;
          if (autoloader) {
            autoloader.loadLanguages(language);
          }
          var xhr = new XMLHttpRequest();
          xhr.open("GET", src2, true);
          xhr.onreadystatechange = function() {
            if (xhr.readyState == 4) {
              if (xhr.status < 400 && xhr.responseText) {
                pre.setAttribute(STATUS_ATTR, STATUS_LOADED);
                code.textContent = xhr.responseText;
                Prism2.highlightElement(code);
              } else {
                pre.setAttribute(STATUS_ATTR, STATUS_FAILED);
                if (xhr.status >= 400) {
                  code.textContent = FAILURE_MESSAGE(xhr.status, xhr.statusText);
                } else {
                  code.textContent = FAILURE_EMPTY_MESSAGE;
                }
              }
            }
          };
          xhr.send(null);
        }
      });
      Prism2.plugins.fileHighlight = {
        highlight: function highlight(container) {
          var elements = (container || document).querySelectorAll(SELECTOR);
          for (var i = 0, element; element = elements[i++]; ) {
            Prism2.highlightElement(element);
          }
        }
      };
      var logged = false;
      Prism2.fileHighlight = function() {
        if (!logged) {
          console.warn("Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead.");
          logged = true;
        }
        Prism2.plugins.fileHighlight.highlight.apply(this, arguments);
      };
    })();
  }
});

// node_modules/prismjs/plugins/normalize-whitespace/prism-normalize-whitespace.js
var require_prism_normalize_whitespace = __commonJS({
  "node_modules/prismjs/plugins/normalize-whitespace/prism-normalize-whitespace.js"(exports, module2) {
    init_shims();
    (function() {
      if (typeof Prism === "undefined") {
        return;
      }
      var assign = Object.assign || function(obj1, obj2) {
        for (var name in obj2) {
          if (obj2.hasOwnProperty(name)) {
            obj1[name] = obj2[name];
          }
        }
        return obj1;
      };
      function NormalizeWhitespace(defaults) {
        this.defaults = assign({}, defaults);
      }
      function toCamelCase(value) {
        return value.replace(/-(\w)/g, function(match, firstChar) {
          return firstChar.toUpperCase();
        });
      }
      function tabLen(str) {
        var res = 0;
        for (var i = 0; i < str.length; ++i) {
          if (str.charCodeAt(i) == "	".charCodeAt(0)) {
            res += 3;
          }
        }
        return str.length + res;
      }
      NormalizeWhitespace.prototype = {
        setDefaults: function(defaults) {
          this.defaults = assign(this.defaults, defaults);
        },
        normalize: function(input, settings) {
          settings = assign(this.defaults, settings);
          for (var name in settings) {
            var methodName = toCamelCase(name);
            if (name !== "normalize" && methodName !== "setDefaults" && settings[name] && this[methodName]) {
              input = this[methodName].call(this, input, settings[name]);
            }
          }
          return input;
        },
        leftTrim: function(input) {
          return input.replace(/^\s+/, "");
        },
        rightTrim: function(input) {
          return input.replace(/\s+$/, "");
        },
        tabsToSpaces: function(input, spaces) {
          spaces = spaces | 0 || 4;
          return input.replace(/\t/g, new Array(++spaces).join(" "));
        },
        spacesToTabs: function(input, spaces) {
          spaces = spaces | 0 || 4;
          return input.replace(RegExp(" {" + spaces + "}", "g"), "	");
        },
        removeTrailing: function(input) {
          return input.replace(/\s*?$/gm, "");
        },
        removeInitialLineFeed: function(input) {
          return input.replace(/^(?:\r?\n|\r)/, "");
        },
        removeIndent: function(input) {
          var indents = input.match(/^[^\S\n\r]*(?=\S)/gm);
          if (!indents || !indents[0].length) {
            return input;
          }
          indents.sort(function(a, b) {
            return a.length - b.length;
          });
          if (!indents[0].length) {
            return input;
          }
          return input.replace(RegExp("^" + indents[0], "gm"), "");
        },
        indent: function(input, tabs) {
          return input.replace(/^[^\S\n\r]*(?=\S)/gm, new Array(++tabs).join("	") + "$&");
        },
        breakLines: function(input, characters) {
          characters = characters === true ? 80 : characters | 0 || 80;
          var lines = input.split("\n");
          for (var i = 0; i < lines.length; ++i) {
            if (tabLen(lines[i]) <= characters) {
              continue;
            }
            var line = lines[i].split(/(\s+)/g);
            var len = 0;
            for (var j = 0; j < line.length; ++j) {
              var tl = tabLen(line[j]);
              len += tl;
              if (len > characters) {
                line[j] = "\n" + line[j];
                len = tl;
              }
            }
            lines[i] = line.join("");
          }
          return lines.join("\n");
        }
      };
      if (typeof module2 !== "undefined" && module2.exports) {
        module2.exports = NormalizeWhitespace;
      }
      Prism.plugins.NormalizeWhitespace = new NormalizeWhitespace({
        "remove-trailing": true,
        "remove-indent": true,
        "left-trim": true,
        "right-trim": true
      });
      Prism.hooks.add("before-sanity-check", function(env) {
        var Normalizer = Prism.plugins.NormalizeWhitespace;
        if (env.settings && env.settings["whitespace-normalization"] === false) {
          return;
        }
        if (!Prism.util.isActive(env.element, "whitespace-normalization", true)) {
          return;
        }
        if ((!env.element || !env.element.parentNode) && env.code) {
          env.code = Normalizer.normalize(env.code, env.settings);
          return;
        }
        var pre = env.element.parentNode;
        if (!env.code || !pre || pre.nodeName.toLowerCase() !== "pre") {
          return;
        }
        var children = pre.childNodes;
        var before = "";
        var after = "";
        var codeFound = false;
        for (var i = 0; i < children.length; ++i) {
          var node = children[i];
          if (node == env.element) {
            codeFound = true;
          } else if (node.nodeName === "#text") {
            if (codeFound) {
              after += node.nodeValue;
            } else {
              before += node.nodeValue;
            }
            pre.removeChild(node);
            --i;
          }
        }
        if (!env.element.children.length || !Prism.plugins.KeepMarkup) {
          env.code = before + env.code + after;
          env.code = Normalizer.normalize(env.code, env.settings);
        } else {
          var html = before + env.element.innerHTML + after;
          env.element.innerHTML = Normalizer.normalize(html, env.settings);
          env.code = env.element.textContent;
        }
      });
    })();
  }
});

// .svelte-kit/netlify/entry.js
__export(exports, {
  handler: () => handler
});
init_shims();

// .svelte-kit/output/server/app.js
init_shims();
var import_gsap = __toModule(require_gsap());
var import_MorphSVGPlugin = __toModule(require_MorphSVGPlugin());
var import_core = __toModule(require_tiptap_core_cjs());
var import_starter_kit = __toModule(require_tiptap_starter_kit_cjs());
var import_prismjs = __toModule(require_prism());

// node_modules/prismjs/plugins/line-numbers/prism-line-numbers.js
init_shims();
(function() {
  if (typeof Prism === "undefined" || typeof document === "undefined") {
    return;
  }
  var PLUGIN_NAME = "line-numbers";
  var NEW_LINE_EXP = /\n(?!$)/g;
  var config = Prism.plugins.lineNumbers = {
    getLine: function(element, number2) {
      if (element.tagName !== "PRE" || !element.classList.contains(PLUGIN_NAME)) {
        return;
      }
      var lineNumberRows = element.querySelector(".line-numbers-rows");
      if (!lineNumberRows) {
        return;
      }
      var lineNumberStart = parseInt(element.getAttribute("data-start"), 10) || 1;
      var lineNumberEnd = lineNumberStart + (lineNumberRows.children.length - 1);
      if (number2 < lineNumberStart) {
        number2 = lineNumberStart;
      }
      if (number2 > lineNumberEnd) {
        number2 = lineNumberEnd;
      }
      var lineIndex = number2 - lineNumberStart;
      return lineNumberRows.children[lineIndex];
    },
    resize: function(element) {
      resizeElements([element]);
    },
    assumeViewportIndependence: true
  };
  function resizeElements(elements) {
    elements = elements.filter(function(e) {
      var codeStyles = getStyles(e);
      var whiteSpace = codeStyles["white-space"];
      return whiteSpace === "pre-wrap" || whiteSpace === "pre-line";
    });
    if (elements.length == 0) {
      return;
    }
    var infos = elements.map(function(element) {
      var codeElement = element.querySelector("code");
      var lineNumbersWrapper = element.querySelector(".line-numbers-rows");
      if (!codeElement || !lineNumbersWrapper) {
        return void 0;
      }
      var lineNumberSizer = element.querySelector(".line-numbers-sizer");
      var codeLines = codeElement.textContent.split(NEW_LINE_EXP);
      if (!lineNumberSizer) {
        lineNumberSizer = document.createElement("span");
        lineNumberSizer.className = "line-numbers-sizer";
        codeElement.appendChild(lineNumberSizer);
      }
      lineNumberSizer.innerHTML = "0";
      lineNumberSizer.style.display = "block";
      var oneLinerHeight = lineNumberSizer.getBoundingClientRect().height;
      lineNumberSizer.innerHTML = "";
      return {
        element,
        lines: codeLines,
        lineHeights: [],
        oneLinerHeight,
        sizer: lineNumberSizer
      };
    }).filter(Boolean);
    infos.forEach(function(info) {
      var lineNumberSizer = info.sizer;
      var lines = info.lines;
      var lineHeights = info.lineHeights;
      var oneLinerHeight = info.oneLinerHeight;
      lineHeights[lines.length - 1] = void 0;
      lines.forEach(function(line, index2) {
        if (line && line.length > 1) {
          var e = lineNumberSizer.appendChild(document.createElement("span"));
          e.style.display = "block";
          e.textContent = line;
        } else {
          lineHeights[index2] = oneLinerHeight;
        }
      });
    });
    infos.forEach(function(info) {
      var lineNumberSizer = info.sizer;
      var lineHeights = info.lineHeights;
      var childIndex = 0;
      for (var i = 0; i < lineHeights.length; i++) {
        if (lineHeights[i] === void 0) {
          lineHeights[i] = lineNumberSizer.children[childIndex++].getBoundingClientRect().height;
        }
      }
    });
    infos.forEach(function(info) {
      var lineNumberSizer = info.sizer;
      var wrapper = info.element.querySelector(".line-numbers-rows");
      lineNumberSizer.style.display = "none";
      lineNumberSizer.innerHTML = "";
      info.lineHeights.forEach(function(height, lineNumber) {
        wrapper.children[lineNumber].style.height = height + "px";
      });
    });
  }
  function getStyles(element) {
    if (!element) {
      return null;
    }
    return window.getComputedStyle ? getComputedStyle(element) : element.currentStyle || null;
  }
  var lastWidth = void 0;
  window.addEventListener("resize", function() {
    if (config.assumeViewportIndependence && lastWidth === window.innerWidth) {
      return;
    }
    lastWidth = window.innerWidth;
    resizeElements(Array.prototype.slice.call(document.querySelectorAll("pre." + PLUGIN_NAME)));
  });
  Prism.hooks.add("complete", function(env) {
    if (!env.code) {
      return;
    }
    var code = env.element;
    var pre = code.parentNode;
    if (!pre || !/pre/i.test(pre.nodeName)) {
      return;
    }
    if (code.querySelector(".line-numbers-rows")) {
      return;
    }
    if (!Prism.util.isActive(code, PLUGIN_NAME)) {
      return;
    }
    code.classList.remove(PLUGIN_NAME);
    pre.classList.add(PLUGIN_NAME);
    var match = env.code.match(NEW_LINE_EXP);
    var linesNum = match ? match.length + 1 : 1;
    var lineNumbersWrapper;
    var lines = new Array(linesNum + 1).join("<span></span>");
    lineNumbersWrapper = document.createElement("span");
    lineNumbersWrapper.setAttribute("aria-hidden", "true");
    lineNumbersWrapper.className = "line-numbers-rows";
    lineNumbersWrapper.innerHTML = lines;
    if (pre.hasAttribute("data-start")) {
      pre.style.counterReset = "linenumber " + (parseInt(pre.getAttribute("data-start"), 10) - 1);
    }
    env.element.appendChild(lineNumbersWrapper);
    resizeElements([pre]);
    Prism.hooks.run("line-numbers", env);
  });
  Prism.hooks.add("line-numbers", function(env) {
    env.plugins = env.plugins || {};
    env.plugins.lineNumbers = true;
  });
})();

// .svelte-kit/output/server/app.js
var import_prism_normalize_whitespace = __toModule(require_prism_normalize_whitespace());

// node_modules/prismjs/plugins/line-highlight/prism-line-highlight.js
init_shims();
(function() {
  if (typeof Prism === "undefined" || typeof document === "undefined" || !document.querySelector) {
    return;
  }
  var LINE_NUMBERS_CLASS = "line-numbers";
  var LINKABLE_LINE_NUMBERS_CLASS = "linkable-line-numbers";
  function $$(selector, container) {
    return Array.prototype.slice.call((container || document).querySelectorAll(selector));
  }
  function hasClass(element, className) {
    return element.classList.contains(className);
  }
  function callFunction(func) {
    func();
  }
  var isLineHeightRounded = function() {
    var res;
    return function() {
      if (typeof res === "undefined") {
        var d = document.createElement("div");
        d.style.fontSize = "13px";
        d.style.lineHeight = "1.5";
        d.style.padding = "0";
        d.style.border = "0";
        d.innerHTML = "&nbsp;<br />&nbsp;";
        document.body.appendChild(d);
        res = d.offsetHeight === 38;
        document.body.removeChild(d);
      }
      return res;
    };
  }();
  function getContentBoxTopOffset(parent, child) {
    var parentStyle = getComputedStyle(parent);
    var childStyle = getComputedStyle(child);
    function pxToNumber(px) {
      return +px.substr(0, px.length - 2);
    }
    return child.offsetTop + pxToNumber(childStyle.borderTopWidth) + pxToNumber(childStyle.paddingTop) - pxToNumber(parentStyle.paddingTop);
  }
  function isActiveFor(pre) {
    if (!pre || !/pre/i.test(pre.nodeName)) {
      return false;
    }
    if (pre.hasAttribute("data-line")) {
      return true;
    }
    if (pre.id && Prism.util.isActive(pre, LINKABLE_LINE_NUMBERS_CLASS)) {
      return true;
    }
    return false;
  }
  var scrollIntoView = true;
  function highlightLines(pre, lines, classes) {
    lines = typeof lines === "string" ? lines : pre.getAttribute("data-line") || "";
    var ranges = lines.replace(/\s+/g, "").split(",").filter(Boolean);
    var offset = +pre.getAttribute("data-line-offset") || 0;
    var parseMethod = isLineHeightRounded() ? parseInt : parseFloat;
    var lineHeight = parseMethod(getComputedStyle(pre).lineHeight);
    var hasLineNumbers = Prism.util.isActive(pre, LINE_NUMBERS_CLASS);
    var codeElement = pre.querySelector("code");
    var parentElement = hasLineNumbers ? pre : codeElement || pre;
    var mutateActions = [];
    var codePreOffset = !codeElement || parentElement == codeElement ? 0 : getContentBoxTopOffset(pre, codeElement);
    ranges.forEach(function(currentRange) {
      var range = currentRange.split("-");
      var start2 = +range[0];
      var end = +range[1] || start2;
      var line = pre.querySelector('.line-highlight[data-range="' + currentRange + '"]') || document.createElement("div");
      mutateActions.push(function() {
        line.setAttribute("aria-hidden", "true");
        line.setAttribute("data-range", currentRange);
        line.className = (classes || "") + " line-highlight";
      });
      if (hasLineNumbers && Prism.plugins.lineNumbers) {
        var startNode = Prism.plugins.lineNumbers.getLine(pre, start2);
        var endNode = Prism.plugins.lineNumbers.getLine(pre, end);
        if (startNode) {
          var top = startNode.offsetTop + codePreOffset + "px";
          mutateActions.push(function() {
            line.style.top = top;
          });
        }
        if (endNode) {
          var height = endNode.offsetTop - startNode.offsetTop + endNode.offsetHeight + "px";
          mutateActions.push(function() {
            line.style.height = height;
          });
        }
      } else {
        mutateActions.push(function() {
          line.setAttribute("data-start", String(start2));
          if (end > start2) {
            line.setAttribute("data-end", String(end));
          }
          line.style.top = (start2 - offset - 1) * lineHeight + codePreOffset + "px";
          line.textContent = new Array(end - start2 + 2).join(" \n");
        });
      }
      mutateActions.push(function() {
        line.style.width = pre.scrollWidth + "px";
      });
      mutateActions.push(function() {
        parentElement.appendChild(line);
      });
    });
    var id = pre.id;
    if (hasLineNumbers && Prism.util.isActive(pre, LINKABLE_LINE_NUMBERS_CLASS) && id) {
      if (!hasClass(pre, LINKABLE_LINE_NUMBERS_CLASS)) {
        mutateActions.push(function() {
          pre.classList.add(LINKABLE_LINE_NUMBERS_CLASS);
        });
      }
      var start = parseInt(pre.getAttribute("data-start") || "1");
      $$(".line-numbers-rows > span", pre).forEach(function(lineSpan, i) {
        var lineNumber = i + start;
        lineSpan.onclick = function() {
          var hash2 = id + "." + lineNumber;
          scrollIntoView = false;
          location.hash = hash2;
          setTimeout(function() {
            scrollIntoView = true;
          }, 1);
        };
      });
    }
    return function() {
      mutateActions.forEach(callFunction);
    };
  }
  function applyHash() {
    var hash2 = location.hash.slice(1);
    $$(".temporary.line-highlight").forEach(function(line) {
      line.parentNode.removeChild(line);
    });
    var range = (hash2.match(/\.([\d,-]+)$/) || [, ""])[1];
    if (!range || document.getElementById(hash2)) {
      return;
    }
    var id = hash2.slice(0, hash2.lastIndexOf("."));
    var pre = document.getElementById(id);
    if (!pre) {
      return;
    }
    if (!pre.hasAttribute("data-line")) {
      pre.setAttribute("data-line", "");
    }
    var mutateDom = highlightLines(pre, range, "temporary ");
    mutateDom();
    if (scrollIntoView) {
      document.querySelector(".temporary.line-highlight").scrollIntoView();
    }
  }
  var fakeTimer = 0;
  Prism.hooks.add("before-sanity-check", function(env) {
    var pre = env.element.parentElement;
    if (!isActiveFor(pre)) {
      return;
    }
    var num = 0;
    $$(".line-highlight", pre).forEach(function(line) {
      num += line.textContent.length;
      line.parentNode.removeChild(line);
    });
    if (num && /^(?: \n)+$/.test(env.code.slice(-num))) {
      env.code = env.code.slice(0, -num);
    }
  });
  Prism.hooks.add("complete", function completeHook(env) {
    var pre = env.element.parentElement;
    if (!isActiveFor(pre)) {
      return;
    }
    clearTimeout(fakeTimer);
    var hasLineNumbers = Prism.plugins.lineNumbers;
    var isLineNumbersLoaded = env.plugins && env.plugins.lineNumbers;
    if (hasClass(pre, LINE_NUMBERS_CLASS) && hasLineNumbers && !isLineNumbersLoaded) {
      Prism.hooks.add("line-numbers", completeHook);
    } else {
      var mutateDom = highlightLines(pre);
      mutateDom();
      fakeTimer = setTimeout(applyHash, 1);
    }
  });
  window.addEventListener("hashchange", applyHash);
  window.addEventListener("resize", function() {
    var actions = $$("pre").filter(isActiveFor).map(function(pre) {
      return highlightLines(pre);
    });
    actions.forEach(callFunction);
  });
})();

// node_modules/prismjs/plugins/file-highlight/prism-file-highlight.js
init_shims();
(function() {
  if (typeof Prism === "undefined" || typeof document === "undefined") {
    return;
  }
  if (!Element.prototype.matches) {
    Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
  }
  var LOADING_MESSAGE = "Loading\u2026";
  var FAILURE_MESSAGE = function(status, message) {
    return "\u2716 Error " + status + " while fetching file: " + message;
  };
  var FAILURE_EMPTY_MESSAGE = "\u2716 Error: File does not exist or is empty";
  var EXTENSIONS = {
    "js": "javascript",
    "py": "python",
    "rb": "ruby",
    "ps1": "powershell",
    "psm1": "powershell",
    "sh": "bash",
    "bat": "batch",
    "h": "c",
    "tex": "latex"
  };
  var STATUS_ATTR = "data-src-status";
  var STATUS_LOADING = "loading";
  var STATUS_LOADED = "loaded";
  var STATUS_FAILED = "failed";
  var SELECTOR = "pre[data-src]:not([" + STATUS_ATTR + '="' + STATUS_LOADED + '"]):not([' + STATUS_ATTR + '="' + STATUS_LOADING + '"])';
  var lang = /\blang(?:uage)?-([\w-]+)\b/i;
  function setLanguageClass(element, language) {
    var className = element.className;
    className = className.replace(lang, " ") + " language-" + language;
    element.className = className.replace(/\s+/g, " ").trim();
  }
  Prism.hooks.add("before-highlightall", function(env) {
    env.selector += ", " + SELECTOR;
  });
  Prism.hooks.add("before-sanity-check", function(env) {
    var pre = env.element;
    if (pre.matches(SELECTOR)) {
      env.code = "";
      pre.setAttribute(STATUS_ATTR, STATUS_LOADING);
      var code = pre.appendChild(document.createElement("CODE"));
      code.textContent = LOADING_MESSAGE;
      var src2 = pre.getAttribute("data-src");
      var language = env.language;
      if (language === "none") {
        var extension = (/\.(\w+)$/.exec(src2) || [, "none"])[1];
        language = EXTENSIONS[extension] || extension;
      }
      setLanguageClass(code, language);
      setLanguageClass(pre, language);
      var autoloader = Prism.plugins.autoloader;
      if (autoloader) {
        autoloader.loadLanguages(language);
      }
      var xhr = new XMLHttpRequest();
      xhr.open("GET", src2, true);
      xhr.onreadystatechange = function() {
        if (xhr.readyState == 4) {
          if (xhr.status < 400 && xhr.responseText) {
            pre.setAttribute(STATUS_ATTR, STATUS_LOADED);
            code.textContent = xhr.responseText;
            Prism.highlightElement(code);
          } else {
            pre.setAttribute(STATUS_ATTR, STATUS_FAILED);
            if (xhr.status >= 400) {
              code.textContent = FAILURE_MESSAGE(xhr.status, xhr.statusText);
            } else {
              code.textContent = FAILURE_EMPTY_MESSAGE;
            }
          }
        }
      };
      xhr.send(null);
    }
  });
  Prism.plugins.fileHighlight = {
    highlight: function highlight(container) {
      var elements = (container || document).querySelectorAll(SELECTOR);
      for (var i = 0, element; element = elements[i++]; ) {
        Prism.highlightElement(element);
      }
    }
  };
  var logged = false;
  Prism.fileHighlight = function() {
    if (!logged) {
      console.warn("Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead.");
      logged = true;
    }
    Prism.plugins.fileHighlight.highlight.apply(this, arguments);
  };
})();

// node_modules/prismjs/components/prism-bash.js
init_shims();
(function(Prism2) {
  var envVars = "\\b(?:BASH|BASHOPTS|BASH_ALIASES|BASH_ARGC|BASH_ARGV|BASH_CMDS|BASH_COMPLETION_COMPAT_DIR|BASH_LINENO|BASH_REMATCH|BASH_SOURCE|BASH_VERSINFO|BASH_VERSION|COLORTERM|COLUMNS|COMP_WORDBREAKS|DBUS_SESSION_BUS_ADDRESS|DEFAULTS_PATH|DESKTOP_SESSION|DIRSTACK|DISPLAY|EUID|GDMSESSION|GDM_LANG|GNOME_KEYRING_CONTROL|GNOME_KEYRING_PID|GPG_AGENT_INFO|GROUPS|HISTCONTROL|HISTFILE|HISTFILESIZE|HISTSIZE|HOME|HOSTNAME|HOSTTYPE|IFS|INSTANCE|JOB|LANG|LANGUAGE|LC_ADDRESS|LC_ALL|LC_IDENTIFICATION|LC_MEASUREMENT|LC_MONETARY|LC_NAME|LC_NUMERIC|LC_PAPER|LC_TELEPHONE|LC_TIME|LESSCLOSE|LESSOPEN|LINES|LOGNAME|LS_COLORS|MACHTYPE|MAILCHECK|MANDATORY_PATH|NO_AT_BRIDGE|OLDPWD|OPTERR|OPTIND|ORBIT_SOCKETDIR|OSTYPE|PAPERSIZE|PATH|PIPESTATUS|PPID|PS1|PS2|PS3|PS4|PWD|RANDOM|REPLY|SECONDS|SELINUX_INIT|SESSION|SESSIONTYPE|SESSION_MANAGER|SHELL|SHELLOPTS|SHLVL|SSH_AUTH_SOCK|TERM|UID|UPSTART_EVENTS|UPSTART_INSTANCE|UPSTART_JOB|UPSTART_SESSION|USER|WINDOWID|XAUTHORITY|XDG_CONFIG_DIRS|XDG_CURRENT_DESKTOP|XDG_DATA_DIRS|XDG_GREETER_DATA_DIR|XDG_MENU_PREFIX|XDG_RUNTIME_DIR|XDG_SEAT|XDG_SEAT_PATH|XDG_SESSION_DESKTOP|XDG_SESSION_ID|XDG_SESSION_PATH|XDG_SESSION_TYPE|XDG_VTNR|XMODIFIERS)\\b";
  var commandAfterHeredoc = {
    pattern: /(^(["']?)\w+\2)[ \t]+\S.*/,
    lookbehind: true,
    alias: "punctuation",
    inside: null
  };
  var insideString = {
    "bash": commandAfterHeredoc,
    "environment": {
      pattern: RegExp("\\$" + envVars),
      alias: "constant"
    },
    "variable": [
      {
        pattern: /\$?\(\([\s\S]+?\)\)/,
        greedy: true,
        inside: {
          "variable": [
            {
              pattern: /(^\$\(\([\s\S]+)\)\)/,
              lookbehind: true
            },
            /^\$\(\(/
          ],
          "number": /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee]-?\d+)?/,
          "operator": /--|\+\+|\*\*=?|<<=?|>>=?|&&|\|\||[=!+\-*/%<>^&|]=?|[?~:]/,
          "punctuation": /\(\(?|\)\)?|,|;/
        }
      },
      {
        pattern: /\$\((?:\([^)]+\)|[^()])+\)|`[^`]+`/,
        greedy: true,
        inside: {
          "variable": /^\$\(|^`|\)$|`$/
        }
      },
      {
        pattern: /\$\{[^}]+\}/,
        greedy: true,
        inside: {
          "operator": /:[-=?+]?|[!\/]|##?|%%?|\^\^?|,,?/,
          "punctuation": /[\[\]]/,
          "environment": {
            pattern: RegExp("(\\{)" + envVars),
            lookbehind: true,
            alias: "constant"
          }
        }
      },
      /\$(?:\w+|[#?*!@$])/
    ],
    "entity": /\\(?:[abceEfnrtv\\"]|O?[0-7]{1,3}|x[0-9a-fA-F]{1,2}|u[0-9a-fA-F]{4}|U[0-9a-fA-F]{8})/
  };
  Prism2.languages.bash = {
    "shebang": {
      pattern: /^#!\s*\/.*/,
      alias: "important"
    },
    "comment": {
      pattern: /(^|[^"{\\$])#.*/,
      lookbehind: true
    },
    "function-name": [
      {
        pattern: /(\bfunction\s+)[\w-]+(?=(?:\s*\(?:\s*\))?\s*\{)/,
        lookbehind: true,
        alias: "function"
      },
      {
        pattern: /\b[\w-]+(?=\s*\(\s*\)\s*\{)/,
        alias: "function"
      }
    ],
    "for-or-select": {
      pattern: /(\b(?:for|select)\s+)\w+(?=\s+in\s)/,
      alias: "variable",
      lookbehind: true
    },
    "assign-left": {
      pattern: /(^|[\s;|&]|[<>]\()\w+(?=\+?=)/,
      inside: {
        "environment": {
          pattern: RegExp("(^|[\\s;|&]|[<>]\\()" + envVars),
          lookbehind: true,
          alias: "constant"
        }
      },
      alias: "variable",
      lookbehind: true
    },
    "string": [
      {
        pattern: /((?:^|[^<])<<-?\s*)(\w+)\s[\s\S]*?(?:\r?\n|\r)\2/,
        lookbehind: true,
        greedy: true,
        inside: insideString
      },
      {
        pattern: /((?:^|[^<])<<-?\s*)(["'])(\w+)\2\s[\s\S]*?(?:\r?\n|\r)\3/,
        lookbehind: true,
        greedy: true,
        inside: {
          "bash": commandAfterHeredoc
        }
      },
      {
        pattern: /(^|[^\\](?:\\\\)*)"(?:\\[\s\S]|\$\([^)]+\)|\$(?!\()|`[^`]+`|[^"\\`$])*"/,
        lookbehind: true,
        greedy: true,
        inside: insideString
      },
      {
        pattern: /(^|[^$\\])'[^']*'/,
        lookbehind: true,
        greedy: true
      },
      {
        pattern: /\$'(?:[^'\\]|\\[\s\S])*'/,
        greedy: true,
        inside: {
          "entity": insideString.entity
        }
      }
    ],
    "environment": {
      pattern: RegExp("\\$?" + envVars),
      alias: "constant"
    },
    "variable": insideString.variable,
    "function": {
      pattern: /(^|[\s;|&]|[<>]\()(?:add|apropos|apt|aptitude|apt-cache|apt-get|aspell|automysqlbackup|awk|basename|bash|bc|bconsole|bg|bzip2|cal|cat|cfdisk|chgrp|chkconfig|chmod|chown|chroot|cksum|clear|cmp|column|comm|composer|cp|cron|crontab|csplit|curl|cut|date|dc|dd|ddrescue|debootstrap|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|du|egrep|eject|env|ethtool|expand|expect|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|git|gparted|grep|groupadd|groupdel|groupmod|groups|grub-mkconfig|gzip|halt|head|hg|history|host|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|ip|jobs|join|kill|killall|less|link|ln|locate|logname|logrotate|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|lynx|make|man|mc|mdadm|mkconfig|mkdir|mke2fs|mkfifo|mkfs|mkisofs|mknod|mkswap|mmv|more|most|mount|mtools|mtr|mutt|mv|nano|nc|netstat|nice|nl|nohup|notify-send|npm|nslookup|op|open|parted|passwd|paste|pathchk|ping|pkill|pnpm|popd|pr|printcap|printenv|ps|pushd|pv|quota|quotacheck|quotactl|ram|rar|rcp|reboot|remsync|rename|renice|rev|rm|rmdir|rpm|rsync|scp|screen|sdiff|sed|sendmail|seq|service|sftp|sh|shellcheck|shuf|shutdown|sleep|slocate|sort|split|ssh|stat|strace|su|sudo|sum|suspend|swapon|sync|tac|tail|tar|tee|time|timeout|top|touch|tr|traceroute|tsort|tty|umount|uname|unexpand|uniq|units|unrar|unshar|unzip|update-grub|uptime|useradd|userdel|usermod|users|uudecode|uuencode|v|vdir|vi|vim|virsh|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yarn|yes|zenity|zip|zsh|zypper)(?=$|[)\s;|&])/,
      lookbehind: true
    },
    "keyword": {
      pattern: /(^|[\s;|&]|[<>]\()(?:if|then|else|elif|fi|for|while|in|case|esac|function|select|do|done|until)(?=$|[)\s;|&])/,
      lookbehind: true
    },
    "builtin": {
      pattern: /(^|[\s;|&]|[<>]\()(?:\.|:|break|cd|continue|eval|exec|exit|export|getopts|hash|pwd|readonly|return|shift|test|times|trap|umask|unset|alias|bind|builtin|caller|command|declare|echo|enable|help|let|local|logout|mapfile|printf|read|readarray|source|type|typeset|ulimit|unalias|set|shopt)(?=$|[)\s;|&])/,
      lookbehind: true,
      alias: "class-name"
    },
    "boolean": {
      pattern: /(^|[\s;|&]|[<>]\()(?:true|false)(?=$|[)\s;|&])/,
      lookbehind: true
    },
    "file-descriptor": {
      pattern: /\B&\d\b/,
      alias: "important"
    },
    "operator": {
      pattern: /\d?<>|>\||\+=|=[=~]?|!=?|<<[<-]?|[&\d]?>>|\d[<>]&?|[<>][&=]?|&[>&]?|\|[&|]?/,
      inside: {
        "file-descriptor": {
          pattern: /^\d/,
          alias: "important"
        }
      }
    },
    "punctuation": /\$?\(\(?|\)\)?|\.\.|[{}[\];\\]/,
    "number": {
      pattern: /(^|\s)(?:[1-9]\d*|0)(?:[.,]\d+)?\b/,
      lookbehind: true
    }
  };
  commandAfterHeredoc.inside = Prism2.languages.bash;
  var toBeCopied = [
    "comment",
    "function-name",
    "for-or-select",
    "assign-left",
    "string",
    "environment",
    "function",
    "keyword",
    "builtin",
    "boolean",
    "file-descriptor",
    "operator",
    "punctuation",
    "number"
  ];
  var inside = insideString.variable[1].inside;
  for (var i = 0; i < toBeCopied.length; i++) {
    inside[toBeCopied[i]] = Prism2.languages.bash[toBeCopied[i]];
  }
  Prism2.languages.shell = Prism2.languages.bash;
})(Prism);

// node_modules/prismjs/components/prism-css.js
init_shims();
(function(Prism2) {
  var string2 = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
  Prism2.languages.css = {
    "comment": /\/\*[\s\S]*?\*\//,
    "atrule": {
      pattern: /@[\w-](?:[^;{\s]|\s+(?![\s{]))*(?:;|(?=\s*\{))/,
      inside: {
        "rule": /^@[\w-]+/,
        "selector-function-argument": {
          pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
          lookbehind: true,
          alias: "selector"
        },
        "keyword": {
          pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
          lookbehind: true
        }
      }
    },
    "url": {
      pattern: RegExp("\\burl\\((?:" + string2.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
      greedy: true,
      inside: {
        "function": /^url/i,
        "punctuation": /^\(|\)$/,
        "string": {
          pattern: RegExp("^" + string2.source + "$"),
          alias: "url"
        }
      }
    },
    "selector": {
      pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + string2.source + ")*(?=\\s*\\{)"),
      lookbehind: true
    },
    "string": {
      pattern: string2,
      greedy: true
    },
    "property": {
      pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
      lookbehind: true
    },
    "important": /!important\b/i,
    "function": {
      pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
      lookbehind: true
    },
    "punctuation": /[(){};:,]/
  };
  Prism2.languages.css["atrule"].inside.rest = Prism2.languages.css;
  var markup = Prism2.languages.markup;
  if (markup) {
    markup.tag.addInlined("style", "css");
    markup.tag.addAttribute("style", "css");
  }
})(Prism);

// node_modules/prismjs/components/prism-r.js
init_shims();
Prism.languages.r = {
  "comment": /#.*/,
  "string": {
    pattern: /(['"])(?:\\.|(?!\1)[^\\\r\n])*\1/,
    greedy: true
  },
  "percent-operator": {
    pattern: /%[^%\s]*%/,
    alias: "operator"
  },
  "boolean": /\b(?:TRUE|FALSE)\b/,
  "ellipsis": /\.\.(?:\.|\d+)/,
  "number": [
    /\b(?:NaN|Inf)\b/,
    /(?:\b0x[\dA-Fa-f]+(?:\.\d*)?|\b\d+(?:\.\d*)?|\B\.\d+)(?:[EePp][+-]?\d+)?[iL]?/
  ],
  "keyword": /\b(?:if|else|repeat|while|function|for|in|next|break|NULL|NA|NA_integer_|NA_real_|NA_complex_|NA_character_)\b/,
  "operator": /->?>?|<(?:=|<?-)?|[>=!]=?|::?|&&?|\|\|?|[+*\/^$@~]/,
  "punctuation": /[(){}\[\],;]/
};

// node_modules/prismjs/components/prism-json.js
init_shims();
Prism.languages.json = {
  "property": {
    pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?=\s*:)/,
    lookbehind: true,
    greedy: true
  },
  "string": {
    pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?!\s*:)/,
    lookbehind: true,
    greedy: true
  },
  "comment": {
    pattern: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,
    greedy: true
  },
  "number": /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
  "punctuation": /[{}[\],]/,
  "operator": /:/,
  "boolean": /\b(?:true|false)\b/,
  "null": {
    pattern: /\bnull\b/,
    alias: "keyword"
  }
};
Prism.languages.webmanifest = Prism.languages.json;

// node_modules/prismjs/components/prism-yaml.js
init_shims();
(function(Prism2) {
  var anchorOrAlias = /[*&][^\s[\]{},]+/;
  var tag = /!(?:<[\w\-%#;/?:@&=+$,.!~*'()[\]]+>|(?:[a-zA-Z\d-]*!)?[\w\-%#;/?:@&=+$.~*'()]+)?/;
  var properties = "(?:" + tag.source + "(?:[ 	]+" + anchorOrAlias.source + ")?|" + anchorOrAlias.source + "(?:[ 	]+" + tag.source + ")?)";
  var plainKey = /(?:[^\s\x00-\x08\x0e-\x1f!"#%&'*,\-:>?@[\]`{|}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]|[?:-]<PLAIN>)(?:[ \t]*(?:(?![#:])<PLAIN>|:<PLAIN>))*/.source.replace(/<PLAIN>/g, function() {
    return /[^\s\x00-\x08\x0e-\x1f,[\]{}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]/.source;
  });
  var string2 = /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\\\r\n]|\\.)*'/.source;
  function createValuePattern(value, flags) {
    flags = (flags || "").replace(/m/g, "") + "m";
    var pattern = /([:\-,[{]\s*(?:\s<<prop>>[ \t]+)?)(?:<<value>>)(?=[ \t]*(?:$|,|\]|\}|(?:[\r\n]\s*)?#))/.source.replace(/<<prop>>/g, function() {
      return properties;
    }).replace(/<<value>>/g, function() {
      return value;
    });
    return RegExp(pattern, flags);
  }
  Prism2.languages.yaml = {
    "scalar": {
      pattern: RegExp(/([\-:]\s*(?:\s<<prop>>[ \t]+)?[|>])[ \t]*(?:((?:\r?\n|\r)[ \t]+)\S[^\r\n]*(?:\2[^\r\n]+)*)/.source.replace(/<<prop>>/g, function() {
        return properties;
      })),
      lookbehind: true,
      alias: "string"
    },
    "comment": /#.*/,
    "key": {
      pattern: RegExp(/((?:^|[:\-,[{\r\n?])[ \t]*(?:<<prop>>[ \t]+)?)<<key>>(?=\s*:\s)/.source.replace(/<<prop>>/g, function() {
        return properties;
      }).replace(/<<key>>/g, function() {
        return "(?:" + plainKey + "|" + string2 + ")";
      })),
      lookbehind: true,
      greedy: true,
      alias: "atrule"
    },
    "directive": {
      pattern: /(^[ \t]*)%.+/m,
      lookbehind: true,
      alias: "important"
    },
    "datetime": {
      pattern: createValuePattern(/\d{4}-\d\d?-\d\d?(?:[tT]|[ \t]+)\d\d?:\d{2}:\d{2}(?:\.\d*)?(?:[ \t]*(?:Z|[-+]\d\d?(?::\d{2})?))?|\d{4}-\d{2}-\d{2}|\d\d?:\d{2}(?::\d{2}(?:\.\d*)?)?/.source),
      lookbehind: true,
      alias: "number"
    },
    "boolean": {
      pattern: createValuePattern(/true|false/.source, "i"),
      lookbehind: true,
      alias: "important"
    },
    "null": {
      pattern: createValuePattern(/null|~/.source, "i"),
      lookbehind: true,
      alias: "important"
    },
    "string": {
      pattern: createValuePattern(string2),
      lookbehind: true,
      greedy: true
    },
    "number": {
      pattern: createValuePattern(/[+-]?(?:0x[\da-f]+|0o[0-7]+|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?|\.inf|\.nan)/.source, "i"),
      lookbehind: true
    },
    "tag": tag,
    "important": anchorOrAlias,
    "punctuation": /---|[:[\]{}\-,|>?]|\.\.\./
  };
  Prism2.languages.yml = Prism2.languages.yaml;
})(Prism);

// .svelte-kit/output/server/app.js
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var _map;
function get_single_valued_header(headers, key) {
  const value = headers[key];
  if (Array.isArray(value)) {
    if (value.length === 0) {
      return void 0;
    }
    if (value.length > 1) {
      throw new Error(`Multiple headers provided for ${key}. Multiple may be provided only for set-cookie`);
    }
    return value[0];
  }
  return value;
}
function coalesce_to_error(err) {
  return err instanceof Error || err && err.name && err.message ? err : new Error(JSON.stringify(err));
}
function lowercase_keys(obj) {
  const clone2 = {};
  for (const key in obj) {
    clone2[key.toLowerCase()] = obj[key];
  }
  return clone2;
}
function error(body) {
  return {
    status: 500,
    body,
    headers: {}
  };
}
function is_string(s2) {
  return typeof s2 === "string" || s2 instanceof String;
}
function is_content_type_textual(content_type) {
  if (!content_type)
    return true;
  const [type] = content_type.split(";");
  return type === "text/plain" || type === "application/json" || type === "application/x-www-form-urlencoded" || type === "multipart/form-data";
}
async function render_endpoint(request, route, match) {
  const mod = await route.load();
  const handler2 = mod[request.method.toLowerCase().replace("delete", "del")];
  if (!handler2) {
    return;
  }
  const params = route.params(match);
  const response = await handler2({ ...request, params });
  const preface = `Invalid response from route ${request.path}`;
  if (!response) {
    return;
  }
  if (typeof response !== "object") {
    return error(`${preface}: expected an object, got ${typeof response}`);
  }
  let { status = 200, body, headers = {} } = response;
  headers = lowercase_keys(headers);
  const type = get_single_valued_header(headers, "content-type");
  const is_type_textual = is_content_type_textual(type);
  if (!is_type_textual && !(body instanceof Uint8Array || is_string(body))) {
    return error(`${preface}: body must be an instance of string or Uint8Array if content-type is not a supported textual content-type`);
  }
  let normalized_body;
  if ((typeof body === "object" || typeof body === "undefined") && !(body instanceof Uint8Array) && (!type || type.startsWith("application/json"))) {
    headers = { ...headers, "content-type": "application/json; charset=utf-8" };
    normalized_body = JSON.stringify(typeof body === "undefined" ? {} : body);
  } else {
    normalized_body = body;
  }
  return { status, body: normalized_body, headers };
}
var chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$";
var unsafeChars = /[<>\b\f\n\r\t\0\u2028\u2029]/g;
var reserved = /^(?:do|if|in|for|int|let|new|try|var|byte|case|char|else|enum|goto|long|this|void|with|await|break|catch|class|const|final|float|short|super|throw|while|yield|delete|double|export|import|native|return|switch|throws|typeof|boolean|default|extends|finally|package|private|abstract|continue|debugger|function|volatile|interface|protected|transient|implements|instanceof|synchronized)$/;
var escaped$1 = {
  "<": "\\u003C",
  ">": "\\u003E",
  "/": "\\u002F",
  "\\": "\\\\",
  "\b": "\\b",
  "\f": "\\f",
  "\n": "\\n",
  "\r": "\\r",
  "	": "\\t",
  "\0": "\\0",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
};
var objectProtoOwnPropertyNames = Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
function devalue(value) {
  var counts = new Map();
  function walk(thing) {
    if (typeof thing === "function") {
      throw new Error("Cannot stringify a function");
    }
    if (counts.has(thing)) {
      counts.set(thing, counts.get(thing) + 1);
      return;
    }
    counts.set(thing, 1);
    if (!isPrimitive(thing)) {
      var type = getType(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
        case "Date":
        case "RegExp":
          return;
        case "Array":
          thing.forEach(walk);
          break;
        case "Set":
        case "Map":
          Array.from(thing).forEach(walk);
          break;
        default:
          var proto = Object.getPrototypeOf(thing);
          if (proto !== Object.prototype && proto !== null && Object.getOwnPropertyNames(proto).sort().join("\0") !== objectProtoOwnPropertyNames) {
            throw new Error("Cannot stringify arbitrary non-POJOs");
          }
          if (Object.getOwnPropertySymbols(thing).length > 0) {
            throw new Error("Cannot stringify POJOs with symbolic keys");
          }
          Object.keys(thing).forEach(function(key) {
            return walk(thing[key]);
          });
      }
    }
  }
  walk(value);
  var names = new Map();
  Array.from(counts).filter(function(entry) {
    return entry[1] > 1;
  }).sort(function(a, b) {
    return b[1] - a[1];
  }).forEach(function(entry, i) {
    names.set(entry[0], getName(i));
  });
  function stringify(thing) {
    if (names.has(thing)) {
      return names.get(thing);
    }
    if (isPrimitive(thing)) {
      return stringifyPrimitive(thing);
    }
    var type = getType(thing);
    switch (type) {
      case "Number":
      case "String":
      case "Boolean":
        return "Object(" + stringify(thing.valueOf()) + ")";
      case "RegExp":
        return "new RegExp(" + stringifyString(thing.source) + ', "' + thing.flags + '")';
      case "Date":
        return "new Date(" + thing.getTime() + ")";
      case "Array":
        var members = thing.map(function(v, i) {
          return i in thing ? stringify(v) : "";
        });
        var tail = thing.length === 0 || thing.length - 1 in thing ? "" : ",";
        return "[" + members.join(",") + tail + "]";
      case "Set":
      case "Map":
        return "new " + type + "([" + Array.from(thing).map(stringify).join(",") + "])";
      default:
        var obj = "{" + Object.keys(thing).map(function(key) {
          return safeKey(key) + ":" + stringify(thing[key]);
        }).join(",") + "}";
        var proto = Object.getPrototypeOf(thing);
        if (proto === null) {
          return Object.keys(thing).length > 0 ? "Object.assign(Object.create(null)," + obj + ")" : "Object.create(null)";
        }
        return obj;
    }
  }
  var str = stringify(value);
  if (names.size) {
    var params_1 = [];
    var statements_1 = [];
    var values_1 = [];
    names.forEach(function(name, thing) {
      params_1.push(name);
      if (isPrimitive(thing)) {
        values_1.push(stringifyPrimitive(thing));
        return;
      }
      var type = getType(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
          values_1.push("Object(" + stringify(thing.valueOf()) + ")");
          break;
        case "RegExp":
          values_1.push(thing.toString());
          break;
        case "Date":
          values_1.push("new Date(" + thing.getTime() + ")");
          break;
        case "Array":
          values_1.push("Array(" + thing.length + ")");
          thing.forEach(function(v, i) {
            statements_1.push(name + "[" + i + "]=" + stringify(v));
          });
          break;
        case "Set":
          values_1.push("new Set");
          statements_1.push(name + "." + Array.from(thing).map(function(v) {
            return "add(" + stringify(v) + ")";
          }).join("."));
          break;
        case "Map":
          values_1.push("new Map");
          statements_1.push(name + "." + Array.from(thing).map(function(_a) {
            var k = _a[0], v = _a[1];
            return "set(" + stringify(k) + ", " + stringify(v) + ")";
          }).join("."));
          break;
        default:
          values_1.push(Object.getPrototypeOf(thing) === null ? "Object.create(null)" : "{}");
          Object.keys(thing).forEach(function(key) {
            statements_1.push("" + name + safeProp(key) + "=" + stringify(thing[key]));
          });
      }
    });
    statements_1.push("return " + str);
    return "(function(" + params_1.join(",") + "){" + statements_1.join(";") + "}(" + values_1.join(",") + "))";
  } else {
    return str;
  }
}
function getName(num) {
  var name = "";
  do {
    name = chars[num % chars.length] + name;
    num = ~~(num / chars.length) - 1;
  } while (num >= 0);
  return reserved.test(name) ? name + "_" : name;
}
function isPrimitive(thing) {
  return Object(thing) !== thing;
}
function stringifyPrimitive(thing) {
  if (typeof thing === "string")
    return stringifyString(thing);
  if (thing === void 0)
    return "void 0";
  if (thing === 0 && 1 / thing < 0)
    return "-0";
  var str = String(thing);
  if (typeof thing === "number")
    return str.replace(/^(-)?0\./, "$1.");
  return str;
}
function getType(thing) {
  return Object.prototype.toString.call(thing).slice(8, -1);
}
function escapeUnsafeChar(c) {
  return escaped$1[c] || c;
}
function escapeUnsafeChars(str) {
  return str.replace(unsafeChars, escapeUnsafeChar);
}
function safeKey(key) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key) ? key : escapeUnsafeChars(JSON.stringify(key));
}
function safeProp(key) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key) ? "." + key : "[" + escapeUnsafeChars(JSON.stringify(key)) + "]";
}
function stringifyString(str) {
  var result = '"';
  for (var i = 0; i < str.length; i += 1) {
    var char = str.charAt(i);
    var code2 = char.charCodeAt(0);
    if (char === '"') {
      result += '\\"';
    } else if (char in escaped$1) {
      result += escaped$1[char];
    } else if (code2 >= 55296 && code2 <= 57343) {
      var next = str.charCodeAt(i + 1);
      if (code2 <= 56319 && (next >= 56320 && next <= 57343)) {
        result += char + str[++i];
      } else {
        result += "\\u" + code2.toString(16).toUpperCase();
      }
    } else {
      result += char;
    }
  }
  result += '"';
  return result;
}
function noop$1() {
}
function safe_not_equal$1(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
Promise.resolve();
var subscriber_queue$1 = [];
function writable$1(value, start = noop$1) {
  let stop;
  const subscribers = new Set();
  function set(new_value) {
    if (safe_not_equal$1(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue$1.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue$1.push(subscriber, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue$1.length; i += 2) {
            subscriber_queue$1[i][0](subscriber_queue$1[i + 1]);
          }
          subscriber_queue$1.length = 0;
        }
      }
    }
  }
  function update(fn) {
    set(fn(value));
  }
  function subscribe2(run2, invalidate = noop$1) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set) || noop$1;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update, subscribe: subscribe2 };
}
function hash(value) {
  let hash2 = 5381;
  let i = value.length;
  if (typeof value === "string") {
    while (i)
      hash2 = hash2 * 33 ^ value.charCodeAt(--i);
  } else {
    while (i)
      hash2 = hash2 * 33 ^ value[--i];
  }
  return (hash2 >>> 0).toString(36);
}
var s$1 = JSON.stringify;
async function render_response({
  branch,
  options: options2,
  $session,
  page_config,
  status,
  error: error2,
  page: page2
}) {
  const css2 = new Set(options2.entry.css);
  const js = new Set(options2.entry.js);
  const styles = new Set();
  const serialized_data = [];
  let rendered;
  let is_private = false;
  let maxage;
  if (error2) {
    error2.stack = options2.get_stack(error2);
  }
  if (page_config.ssr) {
    branch.forEach(({ node, loaded, fetched, uses_credentials }) => {
      if (node.css)
        node.css.forEach((url) => css2.add(url));
      if (node.js)
        node.js.forEach((url) => js.add(url));
      if (node.styles)
        node.styles.forEach((content) => styles.add(content));
      if (fetched && page_config.hydrate)
        serialized_data.push(...fetched);
      if (uses_credentials)
        is_private = true;
      maxage = loaded.maxage;
    });
    const session = writable$1($session);
    const props = {
      stores: {
        page: writable$1(null),
        navigating: writable$1(null),
        session
      },
      page: page2,
      components: branch.map(({ node }) => node.module.default)
    };
    for (let i = 0; i < branch.length; i += 1) {
      props[`props_${i}`] = await branch[i].loaded.props;
    }
    let session_tracking_active = false;
    const unsubscribe = session.subscribe(() => {
      if (session_tracking_active)
        is_private = true;
    });
    session_tracking_active = true;
    try {
      rendered = options2.root.render(props);
    } finally {
      unsubscribe();
    }
  } else {
    rendered = { head: "", html: "", css: { code: "", map: null } };
  }
  const include_js = page_config.router || page_config.hydrate;
  if (!include_js)
    js.clear();
  const links = options2.amp ? styles.size > 0 || rendered.css.code.length > 0 ? `<style amp-custom>${Array.from(styles).concat(rendered.css.code).join("\n")}</style>` : "" : [
    ...Array.from(js).map((dep) => `<link rel="modulepreload" href="${dep}">`),
    ...Array.from(css2).map((dep) => `<link rel="stylesheet" href="${dep}">`)
  ].join("\n		");
  let init2 = "";
  if (options2.amp) {
    init2 = `
		<style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style>
		<noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript>
		<script async src="https://cdn.ampproject.org/v0.js"><\/script>`;
  } else if (include_js) {
    init2 = `<script type="module">
			import { start } from ${s$1(options2.entry.file)};
			start({
				target: ${options2.target ? `document.querySelector(${s$1(options2.target)})` : "document.body"},
				paths: ${s$1(options2.paths)},
				session: ${try_serialize($session, (error3) => {
      throw new Error(`Failed to serialize session data: ${error3.message}`);
    })},
				host: ${page2 && page2.host ? s$1(page2.host) : "location.host"},
				route: ${!!page_config.router},
				spa: ${!page_config.ssr},
				trailing_slash: ${s$1(options2.trailing_slash)},
				hydrate: ${page_config.ssr && page_config.hydrate ? `{
					status: ${status},
					error: ${serialize_error(error2)},
					nodes: [
						${(branch || []).map(({ node }) => `import(${s$1(node.entry)})`).join(",\n						")}
					],
					page: {
						host: ${page2 && page2.host ? s$1(page2.host) : "location.host"}, // TODO this is redundant
						path: ${s$1(page2 && page2.path)},
						query: new URLSearchParams(${page2 ? s$1(page2.query.toString()) : ""}),
						params: ${page2 && s$1(page2.params)}
					}
				}` : "null"}
			});
		<\/script>`;
  }
  if (options2.service_worker) {
    init2 += `<script>
			if ('serviceWorker' in navigator) {
				navigator.serviceWorker.register('${options2.service_worker}');
			}
		<\/script>`;
  }
  const head = [
    rendered.head,
    styles.size && !options2.amp ? `<style data-svelte>${Array.from(styles).join("\n")}</style>` : "",
    links,
    init2
  ].join("\n\n		");
  const body = options2.amp ? rendered.html : `${rendered.html}

			${serialized_data.map(({ url, body: body2, json }) => {
    let attributes = `type="application/json" data-type="svelte-data" data-url="${url}"`;
    if (body2)
      attributes += ` data-body="${hash(body2)}"`;
    return `<script ${attributes}>${json}<\/script>`;
  }).join("\n\n	")}
		`;
  const headers = {
    "content-type": "text/html"
  };
  if (maxage) {
    headers["cache-control"] = `${is_private ? "private" : "public"}, max-age=${maxage}`;
  }
  if (!options2.floc) {
    headers["permissions-policy"] = "interest-cohort=()";
  }
  return {
    status,
    headers,
    body: options2.template({ head, body })
  };
}
function try_serialize(data, fail) {
  try {
    return devalue(data);
  } catch (err) {
    if (fail)
      fail(coalesce_to_error(err));
    return null;
  }
}
function serialize_error(error2) {
  if (!error2)
    return null;
  let serialized = try_serialize(error2);
  if (!serialized) {
    const { name, message, stack } = error2;
    serialized = try_serialize({ ...error2, name, message, stack });
  }
  if (!serialized) {
    serialized = "{}";
  }
  return serialized;
}
function normalize$1(loaded) {
  const has_error_status = loaded.status && loaded.status >= 400 && loaded.status <= 599 && !loaded.redirect;
  if (loaded.error || has_error_status) {
    const status = loaded.status;
    if (!loaded.error && has_error_status) {
      return {
        status: status || 500,
        error: new Error()
      };
    }
    const error2 = typeof loaded.error === "string" ? new Error(loaded.error) : loaded.error;
    if (!(error2 instanceof Error)) {
      return {
        status: 500,
        error: new Error(`"error" property returned from load() must be a string or instance of Error, received type "${typeof error2}"`)
      };
    }
    if (!status || status < 400 || status > 599) {
      console.warn('"error" returned from load() without a valid status code \u2014 defaulting to 500');
      return { status: 500, error: error2 };
    }
    return { status, error: error2 };
  }
  if (loaded.redirect) {
    if (!loaded.status || Math.floor(loaded.status / 100) !== 3) {
      return {
        status: 500,
        error: new Error('"redirect" property returned from load() must be accompanied by a 3xx status code')
      };
    }
    if (typeof loaded.redirect !== "string") {
      return {
        status: 500,
        error: new Error('"redirect" property returned from load() must be a string')
      };
    }
  }
  if (loaded.context) {
    throw new Error('You are returning "context" from a load function. "context" was renamed to "stuff", please adjust your code accordingly.');
  }
  return loaded;
}
var s = JSON.stringify;
async function load_node({
  request,
  options: options2,
  state,
  route,
  page: page2,
  node,
  $session,
  stuff,
  prerender_enabled,
  is_leaf,
  is_error,
  status,
  error: error2
}) {
  const { module: module2 } = node;
  let uses_credentials = false;
  const fetched = [];
  let set_cookie_headers = [];
  let loaded;
  const page_proxy = new Proxy(page2, {
    get: (target, prop, receiver) => {
      if (prop === "query" && prerender_enabled) {
        throw new Error("Cannot access query on a page with prerendering enabled");
      }
      return Reflect.get(target, prop, receiver);
    }
  });
  if (module2.load) {
    const load_input = {
      page: page_proxy,
      get session() {
        uses_credentials = true;
        return $session;
      },
      fetch: async (resource, opts = {}) => {
        let url;
        if (typeof resource === "string") {
          url = resource;
        } else {
          url = resource.url;
          opts = {
            method: resource.method,
            headers: resource.headers,
            body: resource.body,
            mode: resource.mode,
            credentials: resource.credentials,
            cache: resource.cache,
            redirect: resource.redirect,
            referrer: resource.referrer,
            integrity: resource.integrity,
            ...opts
          };
        }
        const resolved = resolve(request.path, url.split("?")[0]);
        let response;
        const filename = resolved.replace(options2.paths.assets, "").slice(1);
        const filename_html = `${filename}/index.html`;
        const asset = options2.manifest.assets.find((d) => d.file === filename || d.file === filename_html);
        if (asset) {
          response = options2.read ? new Response(options2.read(asset.file), {
            headers: asset.type ? { "content-type": asset.type } : {}
          }) : await fetch(`http://${page2.host}/${asset.file}`, opts);
        } else if (resolved.startsWith("/") && !resolved.startsWith("//")) {
          const relative = resolved;
          const headers = {
            ...opts.headers
          };
          if (opts.credentials !== "omit") {
            uses_credentials = true;
            headers.cookie = request.headers.cookie;
            if (!headers.authorization) {
              headers.authorization = request.headers.authorization;
            }
          }
          if (opts.body && typeof opts.body !== "string") {
            throw new Error("Request body must be a string");
          }
          const search = url.includes("?") ? url.slice(url.indexOf("?") + 1) : "";
          const rendered = await respond({
            host: request.host,
            method: opts.method || "GET",
            headers,
            path: relative,
            rawBody: opts.body == null ? null : new TextEncoder().encode(opts.body),
            query: new URLSearchParams(search)
          }, options2, {
            fetched: url,
            initiator: route
          });
          if (rendered) {
            if (state.prerender) {
              state.prerender.dependencies.set(relative, rendered);
            }
            response = new Response(rendered.body, {
              status: rendered.status,
              headers: rendered.headers
            });
          }
        } else {
          if (resolved.startsWith("//")) {
            throw new Error(`Cannot request protocol-relative URL (${url}) in server-side fetch`);
          }
          if (typeof request.host !== "undefined") {
            const { hostname: fetch_hostname } = new URL(url);
            const [server_hostname] = request.host.split(":");
            if (`.${fetch_hostname}`.endsWith(`.${server_hostname}`) && opts.credentials !== "omit") {
              uses_credentials = true;
              opts.headers = {
                ...opts.headers,
                cookie: request.headers.cookie
              };
            }
          }
          const external_request = new Request(url, opts);
          response = await options2.hooks.externalFetch.call(null, external_request);
        }
        if (response) {
          const proxy = new Proxy(response, {
            get(response2, key, receiver) {
              async function text() {
                const body = await response2.text();
                const headers = {};
                for (const [key2, value] of response2.headers) {
                  if (key2 === "set-cookie") {
                    set_cookie_headers = set_cookie_headers.concat(value);
                  } else if (key2 !== "etag") {
                    headers[key2] = value;
                  }
                }
                if (!opts.body || typeof opts.body === "string") {
                  fetched.push({
                    url,
                    body: opts.body,
                    json: `{"status":${response2.status},"statusText":${s(response2.statusText)},"headers":${s(headers)},"body":${escape$1(body)}}`
                  });
                }
                return body;
              }
              if (key === "text") {
                return text;
              }
              if (key === "json") {
                return async () => {
                  return JSON.parse(await text());
                };
              }
              return Reflect.get(response2, key, response2);
            }
          });
          return proxy;
        }
        return response || new Response("Not found", {
          status: 404
        });
      },
      stuff: { ...stuff }
    };
    if (is_error) {
      load_input.status = status;
      load_input.error = error2;
    }
    loaded = await module2.load.call(null, load_input);
  } else {
    loaded = {};
  }
  if (!loaded && is_leaf && !is_error)
    return;
  if (!loaded) {
    throw new Error(`${node.entry} - load must return a value except for page fall through`);
  }
  return {
    node,
    loaded: normalize$1(loaded),
    stuff: loaded.stuff || stuff,
    fetched,
    set_cookie_headers,
    uses_credentials
  };
}
var escaped$2 = {
  "<": "\\u003C",
  ">": "\\u003E",
  "/": "\\u002F",
  "\\": "\\\\",
  "\b": "\\b",
  "\f": "\\f",
  "\n": "\\n",
  "\r": "\\r",
  "	": "\\t",
  "\0": "\\0",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
};
function escape$1(str) {
  let result = '"';
  for (let i = 0; i < str.length; i += 1) {
    const char = str.charAt(i);
    const code2 = char.charCodeAt(0);
    if (char === '"') {
      result += '\\"';
    } else if (char in escaped$2) {
      result += escaped$2[char];
    } else if (code2 >= 55296 && code2 <= 57343) {
      const next = str.charCodeAt(i + 1);
      if (code2 <= 56319 && next >= 56320 && next <= 57343) {
        result += char + str[++i];
      } else {
        result += `\\u${code2.toString(16).toUpperCase()}`;
      }
    } else {
      result += char;
    }
  }
  result += '"';
  return result;
}
var absolute = /^([a-z]+:)?\/?\//;
function resolve(base2, path) {
  const base_match = absolute.exec(base2);
  const path_match = absolute.exec(path);
  if (!base_match) {
    throw new Error(`bad base path: "${base2}"`);
  }
  const baseparts = path_match ? [] : base2.slice(base_match[0].length).split("/");
  const pathparts = path_match ? path.slice(path_match[0].length).split("/") : path.split("/");
  baseparts.pop();
  for (let i = 0; i < pathparts.length; i += 1) {
    const part = pathparts[i];
    if (part === ".")
      continue;
    else if (part === "..")
      baseparts.pop();
    else
      baseparts.push(part);
  }
  const prefix = path_match && path_match[0] || base_match && base_match[0] || "";
  return `${prefix}${baseparts.join("/")}`;
}
async function respond_with_error({ request, options: options2, state, $session, status, error: error2 }) {
  const default_layout = await options2.load_component(options2.manifest.layout);
  const default_error = await options2.load_component(options2.manifest.error);
  const page2 = {
    host: request.host,
    path: request.path,
    query: request.query,
    params: {}
  };
  const loaded = await load_node({
    request,
    options: options2,
    state,
    route: null,
    page: page2,
    node: default_layout,
    $session,
    stuff: {},
    prerender_enabled: is_prerender_enabled(options2, default_error, state),
    is_leaf: false,
    is_error: false
  });
  const branch = [
    loaded,
    await load_node({
      request,
      options: options2,
      state,
      route: null,
      page: page2,
      node: default_error,
      $session,
      stuff: loaded ? loaded.stuff : {},
      prerender_enabled: is_prerender_enabled(options2, default_error, state),
      is_leaf: false,
      is_error: true,
      status,
      error: error2
    })
  ];
  try {
    return await render_response({
      options: options2,
      $session,
      page_config: {
        hydrate: options2.hydrate,
        router: options2.router,
        ssr: options2.ssr
      },
      status,
      error: error2,
      branch,
      page: page2
    });
  } catch (err) {
    const error3 = coalesce_to_error(err);
    options2.handle_error(error3, request);
    return {
      status: 500,
      headers: {},
      body: error3.stack
    };
  }
}
function is_prerender_enabled(options2, node, state) {
  return options2.prerender && (!!node.module.prerender || !!state.prerender && state.prerender.all);
}
async function respond$1(opts) {
  const { request, options: options2, state, $session, route } = opts;
  let nodes;
  try {
    nodes = await Promise.all(route.a.map((id) => id ? options2.load_component(id) : void 0));
  } catch (err) {
    const error3 = coalesce_to_error(err);
    options2.handle_error(error3, request);
    return await respond_with_error({
      request,
      options: options2,
      state,
      $session,
      status: 500,
      error: error3
    });
  }
  const leaf = nodes[nodes.length - 1].module;
  let page_config = get_page_config(leaf, options2);
  if (!leaf.prerender && state.prerender && !state.prerender.all) {
    return {
      status: 204,
      headers: {},
      body: ""
    };
  }
  let branch = [];
  let status = 200;
  let error2;
  let set_cookie_headers = [];
  ssr:
    if (page_config.ssr) {
      let stuff = {};
      for (let i = 0; i < nodes.length; i += 1) {
        const node = nodes[i];
        let loaded;
        if (node) {
          try {
            loaded = await load_node({
              ...opts,
              node,
              stuff,
              prerender_enabled: is_prerender_enabled(options2, node, state),
              is_leaf: i === nodes.length - 1,
              is_error: false
            });
            if (!loaded)
              return;
            set_cookie_headers = set_cookie_headers.concat(loaded.set_cookie_headers);
            if (loaded.loaded.redirect) {
              return with_cookies({
                status: loaded.loaded.status,
                headers: {
                  location: encodeURI(loaded.loaded.redirect)
                }
              }, set_cookie_headers);
            }
            if (loaded.loaded.error) {
              ({ status, error: error2 } = loaded.loaded);
            }
          } catch (err) {
            const e = coalesce_to_error(err);
            options2.handle_error(e, request);
            status = 500;
            error2 = e;
          }
          if (loaded && !error2) {
            branch.push(loaded);
          }
          if (error2) {
            while (i--) {
              if (route.b[i]) {
                const error_node = await options2.load_component(route.b[i]);
                let node_loaded;
                let j = i;
                while (!(node_loaded = branch[j])) {
                  j -= 1;
                }
                try {
                  const error_loaded = await load_node({
                    ...opts,
                    node: error_node,
                    stuff: node_loaded.stuff,
                    prerender_enabled: is_prerender_enabled(options2, error_node, state),
                    is_leaf: false,
                    is_error: true,
                    status,
                    error: error2
                  });
                  if (error_loaded.loaded.error) {
                    continue;
                  }
                  page_config = get_page_config(error_node.module, options2);
                  branch = branch.slice(0, j + 1).concat(error_loaded);
                  break ssr;
                } catch (err) {
                  const e = coalesce_to_error(err);
                  options2.handle_error(e, request);
                  continue;
                }
              }
            }
            return with_cookies(await respond_with_error({
              request,
              options: options2,
              state,
              $session,
              status,
              error: error2
            }), set_cookie_headers);
          }
        }
        if (loaded && loaded.loaded.stuff) {
          stuff = {
            ...stuff,
            ...loaded.loaded.stuff
          };
        }
      }
    }
  try {
    return with_cookies(await render_response({
      ...opts,
      page_config,
      status,
      error: error2,
      branch: branch.filter(Boolean)
    }), set_cookie_headers);
  } catch (err) {
    const error3 = coalesce_to_error(err);
    options2.handle_error(error3, request);
    return with_cookies(await respond_with_error({
      ...opts,
      status: 500,
      error: error3
    }), set_cookie_headers);
  }
}
function get_page_config(leaf, options2) {
  return {
    ssr: "ssr" in leaf ? !!leaf.ssr : options2.ssr,
    router: "router" in leaf ? !!leaf.router : options2.router,
    hydrate: "hydrate" in leaf ? !!leaf.hydrate : options2.hydrate
  };
}
function with_cookies(response, set_cookie_headers) {
  if (set_cookie_headers.length) {
    response.headers["set-cookie"] = set_cookie_headers;
  }
  return response;
}
async function render_page(request, route, match, options2, state) {
  if (state.initiator === route) {
    return {
      status: 404,
      headers: {},
      body: `Not found: ${request.path}`
    };
  }
  const params = route.params(match);
  const page2 = {
    host: request.host,
    path: request.path,
    query: request.query,
    params
  };
  const $session = await options2.hooks.getSession(request);
  const response = await respond$1({
    request,
    options: options2,
    state,
    $session,
    route,
    page: page2
  });
  if (response) {
    return response;
  }
  if (state.fetched) {
    return {
      status: 500,
      headers: {},
      body: `Bad request in load function: failed to fetch ${state.fetched}`
    };
  }
}
function read_only_form_data() {
  const map2 = new Map();
  return {
    append(key, value) {
      if (map2.has(key)) {
        (map2.get(key) || []).push(value);
      } else {
        map2.set(key, [value]);
      }
    },
    data: new ReadOnlyFormData(map2)
  };
}
var ReadOnlyFormData = class {
  constructor(map2) {
    __privateAdd(this, _map, void 0);
    __privateSet(this, _map, map2);
  }
  get(key) {
    const value = __privateGet(this, _map).get(key);
    return value && value[0];
  }
  getAll(key) {
    return __privateGet(this, _map).get(key);
  }
  has(key) {
    return __privateGet(this, _map).has(key);
  }
  *[Symbol.iterator]() {
    for (const [key, value] of __privateGet(this, _map)) {
      for (let i = 0; i < value.length; i += 1) {
        yield [key, value[i]];
      }
    }
  }
  *entries() {
    for (const [key, value] of __privateGet(this, _map)) {
      for (let i = 0; i < value.length; i += 1) {
        yield [key, value[i]];
      }
    }
  }
  *keys() {
    for (const [key] of __privateGet(this, _map))
      yield key;
  }
  *values() {
    for (const [, value] of __privateGet(this, _map)) {
      for (let i = 0; i < value.length; i += 1) {
        yield value[i];
      }
    }
  }
};
_map = new WeakMap();
function parse_body(raw, headers) {
  if (!raw)
    return raw;
  const content_type = headers["content-type"];
  const [type, ...directives] = content_type ? content_type.split(/;\s*/) : [];
  const text = () => new TextDecoder(headers["content-encoding"] || "utf-8").decode(raw);
  switch (type) {
    case "text/plain":
      return text();
    case "application/json":
      return JSON.parse(text());
    case "application/x-www-form-urlencoded":
      return get_urlencoded(text());
    case "multipart/form-data": {
      const boundary = directives.find((directive) => directive.startsWith("boundary="));
      if (!boundary)
        throw new Error("Missing boundary");
      return get_multipart(text(), boundary.slice("boundary=".length));
    }
    default:
      return raw;
  }
}
function get_urlencoded(text) {
  const { data, append } = read_only_form_data();
  text.replace(/\+/g, " ").split("&").forEach((str) => {
    const [key, value] = str.split("=");
    append(decodeURIComponent(key), decodeURIComponent(value));
  });
  return data;
}
function get_multipart(text, boundary) {
  const parts = text.split(`--${boundary}`);
  if (parts[0] !== "" || parts[parts.length - 1].trim() !== "--") {
    throw new Error("Malformed form data");
  }
  const { data, append } = read_only_form_data();
  parts.slice(1, -1).forEach((part) => {
    const match = /\s*([\s\S]+?)\r\n\r\n([\s\S]*)\s*/.exec(part);
    if (!match) {
      throw new Error("Malformed form data");
    }
    const raw_headers = match[1];
    const body = match[2].trim();
    let key;
    const headers = {};
    raw_headers.split("\r\n").forEach((str) => {
      const [raw_header, ...raw_directives] = str.split("; ");
      let [name, value] = raw_header.split(": ");
      name = name.toLowerCase();
      headers[name] = value;
      const directives = {};
      raw_directives.forEach((raw_directive) => {
        const [name2, value2] = raw_directive.split("=");
        directives[name2] = JSON.parse(value2);
      });
      if (name === "content-disposition") {
        if (value !== "form-data")
          throw new Error("Malformed form data");
        if (directives.filename) {
          throw new Error("File upload is not yet implemented");
        }
        if (directives.name) {
          key = directives.name;
        }
      }
    });
    if (!key)
      throw new Error("Malformed form data");
    append(key, body);
  });
  return data;
}
async function respond(incoming, options2, state = {}) {
  if (incoming.path !== "/" && options2.trailing_slash !== "ignore") {
    const has_trailing_slash = incoming.path.endsWith("/");
    if (has_trailing_slash && options2.trailing_slash === "never" || !has_trailing_slash && options2.trailing_slash === "always" && !(incoming.path.split("/").pop() || "").includes(".")) {
      const path = has_trailing_slash ? incoming.path.slice(0, -1) : incoming.path + "/";
      const q = incoming.query.toString();
      return {
        status: 301,
        headers: {
          location: options2.paths.base + path + (q ? `?${q}` : "")
        }
      };
    }
  }
  const headers = lowercase_keys(incoming.headers);
  const request = {
    ...incoming,
    headers,
    body: parse_body(incoming.rawBody, headers),
    params: {},
    locals: {}
  };
  try {
    return await options2.hooks.handle({
      request,
      resolve: async (request2) => {
        if (state.prerender && state.prerender.fallback) {
          return await render_response({
            options: options2,
            $session: await options2.hooks.getSession(request2),
            page_config: { ssr: false, router: true, hydrate: true },
            status: 200,
            branch: []
          });
        }
        const decoded = decodeURI(request2.path);
        for (const route of options2.manifest.routes) {
          const match = route.pattern.exec(decoded);
          if (!match)
            continue;
          const response = route.type === "endpoint" ? await render_endpoint(request2, route, match) : await render_page(request2, route, match, options2, state);
          if (response) {
            if (response.status === 200) {
              const cache_control = get_single_valued_header(response.headers, "cache-control");
              if (!cache_control || !/(no-store|immutable)/.test(cache_control)) {
                const etag = `"${hash(response.body || "")}"`;
                if (request2.headers["if-none-match"] === etag) {
                  return {
                    status: 304,
                    headers: {},
                    body: ""
                  };
                }
                response.headers["etag"] = etag;
              }
            }
            return response;
          }
        }
        const $session = await options2.hooks.getSession(request2);
        return await respond_with_error({
          request: request2,
          options: options2,
          state,
          $session,
          status: 404,
          error: new Error(`Not found: ${request2.path}`)
        });
      }
    });
  } catch (err) {
    const e = coalesce_to_error(err);
    options2.handle_error(e, request);
    return {
      status: 500,
      headers: {},
      body: options2.dev ? e.stack : e.message
    };
  }
}
function noop() {
}
function run(fn) {
  return fn();
}
function blank_object() {
  return Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
function subscribe(store, ...callbacks) {
  if (store == null) {
    return noop;
  }
  const unsub = store.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function compute_rest_props(props, keys) {
  const rest = {};
  keys = new Set(keys);
  for (const k in props)
    if (!keys.has(k) && k[0] !== "$")
      rest[k] = props[k];
  return rest;
}
function null_to_empty(value) {
  return value == null ? "" : value;
}
function set_store_value(store, ret, value) {
  store.set(value);
  return ret;
}
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function setContext(key, context) {
  get_current_component().$$.context.set(key, context);
}
function getContext(key) {
  return get_current_component().$$.context.get(key);
}
Promise.resolve();
var boolean_attributes = new Set([
  "allowfullscreen",
  "allowpaymentrequest",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "defer",
  "disabled",
  "formnovalidate",
  "hidden",
  "ismap",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "selected"
]);
var invalid_attribute_name_character = /[\s'">/=\u{FDD0}-\u{FDEF}\u{FFFE}\u{FFFF}\u{1FFFE}\u{1FFFF}\u{2FFFE}\u{2FFFF}\u{3FFFE}\u{3FFFF}\u{4FFFE}\u{4FFFF}\u{5FFFE}\u{5FFFF}\u{6FFFE}\u{6FFFF}\u{7FFFE}\u{7FFFF}\u{8FFFE}\u{8FFFF}\u{9FFFE}\u{9FFFF}\u{AFFFE}\u{AFFFF}\u{BFFFE}\u{BFFFF}\u{CFFFE}\u{CFFFF}\u{DFFFE}\u{DFFFF}\u{EFFFE}\u{EFFFF}\u{FFFFE}\u{FFFFF}\u{10FFFE}\u{10FFFF}]/u;
function spread(args, classes_to_add) {
  const attributes = Object.assign({}, ...args);
  if (classes_to_add) {
    if (attributes.class == null) {
      attributes.class = classes_to_add;
    } else {
      attributes.class += " " + classes_to_add;
    }
  }
  let str = "";
  Object.keys(attributes).forEach((name) => {
    if (invalid_attribute_name_character.test(name))
      return;
    const value = attributes[name];
    if (value === true)
      str += " " + name;
    else if (boolean_attributes.has(name.toLowerCase())) {
      if (value)
        str += " " + name;
    } else if (value != null) {
      str += ` ${name}="${value}"`;
    }
  });
  return str;
}
var escaped = {
  '"': "&quot;",
  "'": "&#39;",
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;"
};
function escape(html) {
  return String(html).replace(/["'&<>]/g, (match) => escaped[match]);
}
function escape_attribute_value(value) {
  return typeof value === "string" ? escape(value) : value;
}
function escape_object(obj) {
  const result = {};
  for (const key in obj) {
    result[key] = escape_attribute_value(obj[key]);
  }
  return result;
}
function each(items, fn) {
  let str = "";
  for (let i = 0; i < items.length; i += 1) {
    str += fn(items[i], i);
  }
  return str;
}
var missing_component = {
  $$render: () => ""
};
function validate_component(component, name) {
  if (!component || !component.$$render) {
    if (name === "svelte:component")
      name += " this={...}";
    throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);
  }
  return component;
}
var on_destroy;
function create_ssr_component(fn) {
  function $$render(result, props, bindings, slots, context) {
    const parent_component = current_component;
    const $$ = {
      on_destroy,
      context: new Map(context || (parent_component ? parent_component.$$.context : [])),
      on_mount: [],
      before_update: [],
      after_update: [],
      callbacks: blank_object()
    };
    set_current_component({ $$ });
    const html = fn(result, props, bindings, slots);
    set_current_component(parent_component);
    return html;
  }
  return {
    render: (props = {}, { $$slots = {}, context = new Map() } = {}) => {
      on_destroy = [];
      const result = { title: "", head: "", css: new Set() };
      const html = $$render(result, props, {}, $$slots, context);
      run_all(on_destroy);
      return {
        html,
        css: {
          code: Array.from(result.css).map((css2) => css2.code).join("\n"),
          map: null
        },
        head: result.title + result.head
      };
    },
    $$render
  };
}
function add_attribute(name, value, boolean) {
  if (value == null || boolean && !value)
    return "";
  return ` ${name}${value === true ? "" : `=${typeof value === "string" ? JSON.stringify(escape(value)) : `"${value}"`}`}`;
}
function afterUpdate() {
}
var css$p = {
  code: "#svelte-announcer.svelte-1j55zn5{position:absolute;left:0;top:0;clip:rect(0 0 0 0);clip-path:inset(50%);overflow:hidden;white-space:nowrap;width:1px;height:1px}",
  map: `{"version":3,"file":"root.svelte","sources":["root.svelte"],"sourcesContent":["<!-- This file is generated by @sveltejs/kit \u2014 do not edit it! -->\\n<script>\\n\\timport { setContext, afterUpdate, onMount } from 'svelte';\\n\\n\\t// stores\\n\\texport let stores;\\n\\texport let page;\\n\\n\\texport let components;\\n\\texport let props_0 = null;\\n\\texport let props_1 = null;\\n\\texport let props_2 = null;\\n\\n\\tsetContext('__svelte__', stores);\\n\\n\\t$: stores.page.set(page);\\n\\tafterUpdate(stores.page.notify);\\n\\n\\tlet mounted = false;\\n\\tlet navigated = false;\\n\\tlet title = null;\\n\\n\\tonMount(() => {\\n\\t\\tconst unsubscribe = stores.page.subscribe(() => {\\n\\t\\t\\tif (mounted) {\\n\\t\\t\\t\\tnavigated = true;\\n\\t\\t\\t\\ttitle = document.title || 'untitled page';\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tmounted = true;\\n\\t\\treturn unsubscribe;\\n\\t});\\n<\/script>\\n\\n<svelte:component this={components[0]} {...(props_0 || {})}>\\n\\t{#if components[1]}\\n\\t\\t<svelte:component this={components[1]} {...(props_1 || {})}>\\n\\t\\t\\t{#if components[2]}\\n\\t\\t\\t\\t<svelte:component this={components[2]} {...(props_2 || {})}/>\\n\\t\\t\\t{/if}\\n\\t\\t</svelte:component>\\n\\t{/if}\\n</svelte:component>\\n\\n{#if mounted}\\n\\t<div id=\\"svelte-announcer\\" aria-live=\\"assertive\\" aria-atomic=\\"true\\">\\n\\t\\t{#if navigated}\\n\\t\\t\\t{title}\\n\\t\\t{/if}\\n\\t</div>\\n{/if}\\n\\n<style>\\n\\t#svelte-announcer {\\n\\t\\tposition: absolute;\\n\\t\\tleft: 0;\\n\\t\\ttop: 0;\\n\\t\\tclip: rect(0 0 0 0);\\n\\t\\tclip-path: inset(50%);\\n\\t\\toverflow: hidden;\\n\\t\\twhite-space: nowrap;\\n\\t\\twidth: 1px;\\n\\t\\theight: 1px;\\n\\t}\\n</style>"],"names":[],"mappings":"AAsDC,iBAAiB,eAAC,CAAC,AAClB,QAAQ,CAAE,QAAQ,CAClB,IAAI,CAAE,CAAC,CACP,GAAG,CAAE,CAAC,CACN,IAAI,CAAE,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CACnB,SAAS,CAAE,MAAM,GAAG,CAAC,CACrB,QAAQ,CAAE,MAAM,CAChB,WAAW,CAAE,MAAM,CACnB,KAAK,CAAE,GAAG,CACV,MAAM,CAAE,GAAG,AACZ,CAAC"}`
};
var Root = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { stores } = $$props;
  let { page: page2 } = $$props;
  let { components } = $$props;
  let { props_0 = null } = $$props;
  let { props_1 = null } = $$props;
  let { props_2 = null } = $$props;
  setContext("__svelte__", stores);
  afterUpdate(stores.page.notify);
  if ($$props.stores === void 0 && $$bindings.stores && stores !== void 0)
    $$bindings.stores(stores);
  if ($$props.page === void 0 && $$bindings.page && page2 !== void 0)
    $$bindings.page(page2);
  if ($$props.components === void 0 && $$bindings.components && components !== void 0)
    $$bindings.components(components);
  if ($$props.props_0 === void 0 && $$bindings.props_0 && props_0 !== void 0)
    $$bindings.props_0(props_0);
  if ($$props.props_1 === void 0 && $$bindings.props_1 && props_1 !== void 0)
    $$bindings.props_1(props_1);
  if ($$props.props_2 === void 0 && $$bindings.props_2 && props_2 !== void 0)
    $$bindings.props_2(props_2);
  $$result.css.add(css$p);
  {
    stores.page.set(page2);
  }
  return `


${validate_component(components[0] || missing_component, "svelte:component").$$render($$result, Object.assign(props_0 || {}), {}, {
    default: () => `${components[1] ? `${validate_component(components[1] || missing_component, "svelte:component").$$render($$result, Object.assign(props_1 || {}), {}, {
      default: () => `${components[2] ? `${validate_component(components[2] || missing_component, "svelte:component").$$render($$result, Object.assign(props_2 || {}), {}, {})}` : ``}`
    })}` : ``}`
  })}

${``}`;
});
var base = "";
var assets = "";
function set_paths(paths) {
  base = paths.base;
  assets = paths.assets || base;
}
function set_prerendering(value) {
}
var user_hooks = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module"
});
var template = ({ head, body }) => '<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <link rel="icon" href="/favicon.ico" />\n    <link rel="stylesheet" href="https://use.typekit.net/mhr2lku.css">\n    <meta name="viewport" content="width=device-width, initial-scale=1" />\n    \n    ' + head + '\n  </head>\n  <body>\n    <div id="svelte">' + body + "</div>\n  </body>\n</html>\n";
var options = null;
var default_settings = { paths: { "base": "", "assets": "" } };
function init(settings = default_settings) {
  set_paths(settings.paths);
  set_prerendering(settings.prerendering || false);
  const hooks = get_hooks(user_hooks);
  options = {
    amp: false,
    dev: false,
    entry: {
      file: assets + "/_app/start-03e3549f.js",
      css: [assets + "/_app/assets/start-d977ffc4.css"],
      js: [assets + "/_app/start-03e3549f.js", assets + "/_app/chunks/vendor-81ee5109.js"]
    },
    fetched: void 0,
    floc: false,
    get_component_path: (id) => assets + "/_app/" + entry_lookup[id],
    get_stack: (error2) => String(error2),
    handle_error: (error2, request) => {
      hooks.handleError({ error: error2, request });
      error2.stack = options.get_stack(error2);
    },
    hooks,
    hydrate: true,
    initiator: void 0,
    load_component,
    manifest,
    paths: settings.paths,
    prerender: true,
    read: settings.read,
    root: Root,
    service_worker: null,
    router: true,
    ssr: true,
    target: "#svelte",
    template,
    trailing_slash: "never"
  };
}
var empty = () => ({});
var manifest = {
  assets: [{ "file": ".DS_Store", "size": 6148, "type": null }, { "file": "images/.DS_Store", "size": 10244, "type": null }, { "file": "images/icons/shuffle.svg", "size": 1574, "type": "image/svg+xml" }, { "file": "images/jobs/axios.svg", "size": 455, "type": "image/svg+xml" }, { "file": "images/jobs/moksha.svg", "size": 1261, "type": "image/svg+xml" }, { "file": "images/jobs/socom.svg", "size": 77530, "type": "image/svg+xml" }, { "file": "images/jobs/tpl.svg", "size": 709, "type": "image/svg+xml" }, { "file": "images/post/.DS_Store", "size": 16388, "type": null }, { "file": "images/post/adding-a-chart-to-your-d3-tooltip/.DS_Store", "size": 6148, "type": null }, { "file": "images/post/adding-a-chart-to-your-d3-tooltip/header.png", "size": 222355, "type": "image/png" }, { "file": "images/post/adding-a-chart-to-your-d3-tooltip/new-tooltip.gif", "size": 1394285, "type": "image/gif" }, { "file": "images/post/adding-a-chart-to-your-d3-tooltip/old-tooltip.gif", "size": 1828083, "type": "image/gif" }, { "file": "images/post/adding-a-chart-to-your-d3-tooltip/west-virginia.jpg", "size": 96852, "type": "image/jpeg" }, { "file": "images/post/animate-hugo-academic/about.png", "size": 171201, "type": "image/png" }, { "file": "images/post/animate-hugo-academic/after-demo-hero-remove.png", "size": 274988, "type": "image/png" }, { "file": "images/post/animate-hugo-academic/before-demo-hero-remove.png", "size": 996449, "type": "image/png" }, { "file": "images/post/animate-hugo-academic/bg-red.png", "size": 247553, "type": "image/png" }, { "file": "images/post/animate-hugo-academic/double-slide.gif", "size": 4049647, "type": "image/gif" }, { "file": "images/post/animate-hugo-academic/final.gif", "size": 4711318, "type": "image/gif" }, { "file": "images/post/animate-hugo-academic/font-red.png", "size": 274418, "type": "image/png" }, { "file": "images/post/animate-hugo-academic/header.jpg", "size": 272081, "type": "image/jpeg" }, { "file": "images/post/animate-hugo-academic/header.png", "size": 502097, "type": "image/png" }, { "file": "images/post/animate-hugo-academic/left-and-right.gif", "size": 7187557, "type": "image/gif" }, { "file": "images/post/animate-hugo-academic/red.gif", "size": 6389199, "type": "image/gif" }, { "file": "images/post/animate-hugo-academic/slide-from-right.gif", "size": 5650648, "type": "image/gif" }, { "file": "images/post/automation-scrollytell/header.png", "size": 347231, "type": "image/png" }, { "file": "images/post/bible-babies/boys.gif", "size": 3320504, "type": "image/gif" }, { "file": "images/post/bible-babies/combined.gif", "size": 2500209, "type": "image/gif" }, { "file": "images/post/bible-babies/girls.gif", "size": 3171023, "type": "image/gif" }, { "file": "images/post/bible-babies/header.png", "size": 207384, "type": "image/png" }, { "file": "images/post/bible-babies/line.png", "size": 88209, "type": "image/png" }, { "file": "images/post/bible-babies/male-female-line.png", "size": 103538, "type": "image/png" }, { "file": "images/post/color-in-data-vis/.DS_Store", "size": 8196, "type": null }, { "file": "images/post/color-in-data-vis/all-color.jpg", "size": 48568, "type": "image/jpeg" }, { "file": "images/post/color-in-data-vis/all-grey.jpg", "size": 25976, "type": "image/jpeg" }, { "file": "images/post/color-in-data-vis/bad-and-better.jpg", "size": 41594, "type": "image/jpeg" }, { "file": "images/post/color-in-data-vis/bad-chart.jpg", "size": 144491, "type": "image/jpeg" }, { "file": "images/post/color-in-data-vis/bad-color-use-1.jpg", "size": 25638, "type": "image/jpeg" }, { "file": "images/post/color-in-data-vis/bad-color-use-2.jpg", "size": 462044, "type": "image/jpeg" }, { "file": "images/post/color-in-data-vis/better-chart1.png", "size": 102932, "type": "image/png" }, { "file": "images/post/color-in-data-vis/betterchart-1.jpg", "size": 102932, "type": "image/jpeg" }, { "file": "images/post/color-in-data-vis/choropleth-ex.jpg", "size": 116015, "type": "image/jpeg" }, { "file": "images/post/color-in-data-vis/color-emotion-guide-lol.jpg", "size": 142938, "type": "image/jpeg" }, { "file": "images/post/color-in-data-vis/color-emphasized.png", "size": 88831, "type": "image/png" }, { "file": "images/post/color-in-data-vis/flipping-points-color-annotate1.jpg", "size": 388831, "type": "image/jpeg" }, { "file": "images/post/color-in-data-vis/flipping-points-color-annotate2.jpg", "size": 292758, "type": "image/jpeg" }, { "file": "images/post/color-in-data-vis/flipping-points-color.jpg", "size": 281680, "type": "image/jpeg" }, { "file": "images/post/color-in-data-vis/header.png", "size": 1500611, "type": "image/png" }, { "file": "images/post/color-in-data-vis/map-Texas-rainbow-1.jpg", "size": 125882, "type": "image/jpeg" }, { "file": "images/post/color-in-data-vis/popgrowth-vs-popsize-bw-1.png", "size": 102932, "type": "image/png" }, { "file": "images/post/covid-gun-spikes/featured.png", "size": 708910, "type": "image/png" }, { "file": "images/post/covid-gun-spikes/header.png", "size": 960654, "type": "image/png" }, { "file": "images/post/covid-gun-spikes/table-replacement.png", "size": 37277, "type": "image/png" }, { "file": "images/post/covid-gun-spikes/unnamed-chunk-4-1.png", "size": 157047, "type": "image/png" }, { "file": "images/post/covid-gun-spikes/unnamed-chunk-5-1.png", "size": 55822, "type": "image/png" }, { "file": "images/post/covid-gun-spikes/unnamed-chunk-6-1.png", "size": 124650, "type": "image/png" }, { "file": "images/post/covid-on-campus/featured.png", "size": 144039, "type": "image/png" }, { "file": "images/post/covid-on-campus/geofacet_processed.png", "size": 233674, "type": "image/png" }, { "file": "images/post/covid-on-campus/header.png", "size": 246566, "type": "image/png" }, { "file": "images/post/covid-on-campus/table1.png", "size": 111521, "type": "image/png" }, { "file": "images/post/covid-on-campus/table2.png", "size": 49261, "type": "image/png" }, { "file": "images/post/covid-on-campus/table3.png", "size": 46864, "type": "image/png" }, { "file": "images/post/covid-posts/authorVer2-1.png", "size": 66037, "type": "image/png" }, { "file": "images/post/covid-posts/dataTable-1.png", "size": 123935, "type": "image/png" }, { "file": "images/post/covid-posts/featured.png", "size": 142943, "type": "image/png" }, { "file": "images/post/covid-posts/header.png", "size": 142943, "type": "image/png" }, { "file": "images/post/covid-posts/prolificVer2-1.png", "size": 178507, "type": "image/png" }, { "file": "images/post/covid-posts/topicsVer2-1.png", "size": 142943, "type": "image/png" }, { "file": "images/post/covid-posts/weekly-1.png", "size": 66718, "type": "image/png" }, { "file": "images/post/do-something-else/startup-faang-satisfaction.png", "size": 128566, "type": "image/png" }, { "file": "images/post/dumbbell-plots/age-disrupt.jpg", "size": 127112, "type": "image/jpeg" }, { "file": "images/post/dumbbell-plots/age-worry.jpg", "size": 133455, "type": "image/jpeg" }, { "file": "images/post/dumbbell-plots/axios.jpg", "size": 94024, "type": "image/jpeg" }, { "file": "images/post/dumbbell-plots/featured.jpg", "size": 146966, "type": "image/jpeg" }, { "file": "images/post/dumbbell-plots/header.png", "size": 211763, "type": "image/png" }, { "file": "images/post/dumbbell-plots/partisan-disrupt.jpg", "size": 139913, "type": "image/jpeg" }, { "file": "images/post/dumbbell-plots/partisan-worry.jpg", "size": 146966, "type": "image/jpeg" }, { "file": "images/post/dumbbell-plots/pew.jpg", "size": 83415, "type": "image/jpeg" }, { "file": "images/post/dumbbell-plots/process-0.jpg", "size": 79993, "type": "image/jpeg" }, { "file": "images/post/dumbbell-plots/process-1.jpg", "size": 86350, "type": "image/jpeg" }, { "file": "images/post/dumbbell-plots/process-2.jpg", "size": 93592, "type": "image/jpeg" }, { "file": "images/post/dumbbell-plots/process-3.jpg", "size": 101971, "type": "image/jpeg" }, { "file": "images/post/dumbbell-plots/process-4.jpg", "size": 96114, "type": "image/jpeg" }, { "file": "images/post/dumbbell-plots/process-5.jpg", "size": 160258, "type": "image/jpeg" }, { "file": "images/post/dumbbell-plots/process-6.jpg", "size": 146966, "type": "image/jpeg" }, { "file": "images/post/dumbbell-plots/process-gif.gif", "size": 670401, "type": "image/gif" }, { "file": "images/post/dumbbell-plots/table.jpg", "size": 27809, "type": "image/jpeg" }, { "file": "images/post/economist-table-replication-using-reactable/featured.png", "size": 107802, "type": "image/png" }, { "file": "images/post/economist-table-replication-using-reactable/header.png", "size": 207227, "type": "image/png" }, { "file": "images/post/flat-data-r/.DS_Store", "size": 6148, "type": null }, { "file": "images/post/flat-data-r/flat-diagram.png", "size": 739814, "type": "image/png" }, { "file": "images/post/flat-data-r/header.png", "size": 1651665, "type": "image/png" }, { "file": "images/post/introducing-tpltheme/featured.png", "size": 60896, "type": "image/png" }, { "file": "images/post/introducing-tpltheme/header.png", "size": 82172, "type": "image/png" }, { "file": "images/post/introducing-tpltheme/unnamed-chunk-10-1.png", "size": 156710, "type": "image/png" }, { "file": "images/post/introducing-tpltheme/unnamed-chunk-11-1.png", "size": 69452, "type": "image/png" }, { "file": "images/post/introducing-tpltheme/unnamed-chunk-12-1.png", "size": 146481, "type": "image/png" }, { "file": "images/post/introducing-tpltheme/unnamed-chunk-13-1.png", "size": 155022, "type": "image/png" }, { "file": "images/post/introducing-tpltheme/unnamed-chunk-14-1.png", "size": 79963, "type": "image/png" }, { "file": "images/post/introducing-tpltheme/unnamed-chunk-15-1.png", "size": 76710, "type": "image/png" }, { "file": "images/post/introducing-tpltheme/unnamed-chunk-16-1.png", "size": 151633, "type": "image/png" }, { "file": "images/post/introducing-tpltheme/unnamed-chunk-17-1.png", "size": 168762, "type": "image/png" }, { "file": "images/post/introducing-tpltheme/unnamed-chunk-18-1.png", "size": 147878, "type": "image/png" }, { "file": "images/post/introducing-tpltheme/unnamed-chunk-3-1.png", "size": 44351, "type": "image/png" }, { "file": "images/post/introducing-tpltheme/unnamed-chunk-5-1.png", "size": 146995, "type": "image/png" }, { "file": "images/post/introducing-tpltheme/unnamed-chunk-6-1.png", "size": 259141, "type": "image/png" }, { "file": "images/post/introducing-tpltheme/unnamed-chunk-7-1.png", "size": 208134, "type": "image/png" }, { "file": "images/post/introducing-tpltheme/unnamed-chunk-8-1.png", "size": 262530, "type": "image/png" }, { "file": "images/post/introducing-tpltheme/unnamed-chunk-9-1.png", "size": 60075, "type": "image/png" }, { "file": "images/post/map-springfield/bw_map_springfield.png", "size": 374640, "type": "image/png" }, { "file": "images/post/map-springfield/gold_map_springfield.png", "size": 673257, "type": "image/png" }, { "file": "images/post/map-springfield/header.png", "size": 462454, "type": "image/png" }, { "file": "images/post/media-mentions/header.png", "size": 311367, "type": "image/png" }, { "file": "images/post/media-mentions/unnamed-chunk-2-1.png", "size": 80891, "type": "image/png" }, { "file": "images/post/media-mentions/unnamed-chunk-3-1.png", "size": 192170, "type": "image/png" }, { "file": "images/post/media-mentions/unnamed-chunk-4-1.png", "size": 137279, "type": "image/png" }, { "file": "images/post/media-mentions/unnamed-chunk-5-1.png", "size": 86116, "type": "image/png" }, { "file": "images/post/media-mentions/unnamed-chunk-6-1.png", "size": 503911, "type": "image/png" }, { "file": "images/post/media-mentions/unnamed-chunk-7-1.png", "size": 349985, "type": "image/png" }, { "file": "images/post/nuxt-blog-starter/blog-card.png", "size": 317721, "type": "image/png" }, { "file": "images/post/nuxt-blog-starter/dark.png", "size": 86381, "type": "image/png" }, { "file": "images/post/nuxt-blog-starter/header.png", "size": 160358, "type": "image/png" }, { "file": "images/post/nuxt-blog-starter/home-card.png", "size": 245943, "type": "image/png" }, { "file": "images/post/nuxt-blog-starter/light.png", "size": 88342, "type": "image/png" }, { "file": "images/post/nuxt-blog-starter/new-site-perf.png", "size": 729480, "type": "image/png" }, { "file": "images/post/nuxt-blog-starter/old-site-perf.png", "size": 891912, "type": "image/png" }, { "file": "images/post/nuxt-blog-starter/transitions.gif", "size": 1269461, "type": "image/gif" }, { "file": "images/post/refugee-trends/.DS_Store", "size": 6148, "type": null }, { "file": "images/post/refugee-trends/featured.png", "size": 96723, "type": "image/png" }, { "file": "images/post/refugee-trends/final.svg", "size": 339820, "type": "image/svg+xml" }, { "file": "images/post/refugee-trends/firsttry.jpg", "size": 249381, "type": "image/jpeg" }, { "file": "images/post/refugee-trends/header.png", "size": 209771, "type": "image/png" }, { "file": "images/post/refugee-trends/macro.jpg", "size": 59219, "type": "image/jpeg" }, { "file": "images/post/refugee-trends/policyviz.jpg", "size": 62077, "type": "image/jpeg" }, { "file": "images/post/refugee-trends/ref.png", "size": 77965, "type": "image/png" }, { "file": "images/post/refugee-trends/secondtry.jpg", "size": 220813, "type": "image/jpeg" }, { "file": "images/post/refugee-trends/wapo.png", "size": 254826, "type": "image/png" }, { "file": "images/post/svelte-and-d3/header.png", "size": 1916771, "type": "image/png" }, { "file": "images/post/tidy-tuesday-powerlifting/featured.png", "size": 395928, "type": "image/png" }, { "file": "images/post/tidy-tuesday-powerlifting/header.png", "size": 609028, "type": "image/png" }, { "file": "images/post/tidy-tuesday-powerlifting/table.png", "size": 39430, "type": "image/png" }, { "file": "images/post/tidy-tuesday-powerlifting/unnamed-chunk-10-1.gif", "size": 2045058, "type": "image/gif" }, { "file": "images/post/tidy-tuesday-powerlifting/unnamed-chunk-11-1.gif", "size": 3152748, "type": "image/gif" }, { "file": "images/post/tidy-tuesday-powerlifting/unnamed-chunk-8-1.png", "size": 80022, "type": "image/png" }, { "file": "images/post/tidy-tuesday-powerlifting/unnamed-chunk-9-1.gif", "size": 1471396, "type": "image/gif" }, { "file": "images/post/tidy-tuesday-replication/bloomberg.png", "size": 286679, "type": "image/png" }, { "file": "images/post/tidy-tuesday-replication/featured.png", "size": 220110, "type": "image/png" }, { "file": "images/post/tidy-tuesday-replication/header.png", "size": 391425, "type": "image/png" }, { "file": "images/post/tidy-tuesday-replication/replication.png", "size": 220110, "type": "image/png" }, { "file": "images/project/.DS_Store", "size": 14340, "type": null }, { "file": "images/project/atus/header.png", "size": 196112, "type": "image/png" }, { "file": "images/project/atus/mac-1.png", "size": 324392, "type": "image/png" }, { "file": "images/project/atus/mac-2.png", "size": 358160, "type": "image/png" }, { "file": "images/project/atus/phone-1.png", "size": 566129, "type": "image/png" }, { "file": "images/project/atus/phone-2.png", "size": 650612, "type": "image/png" }, { "file": "images/project/atus/thumbnail.png", "size": 324392, "type": "image/png" }, { "file": "images/project/bob-ross-art-gallery/header.png", "size": 522077, "type": "image/png" }, { "file": "images/project/bob-ross-art-gallery/iphone-1.png", "size": 344053, "type": "image/png" }, { "file": "images/project/bob-ross-art-gallery/iphone-2.png", "size": 351424, "type": "image/png" }, { "file": "images/project/bob-ross-art-gallery/iphone-3.png", "size": 428163, "type": "image/png" }, { "file": "images/project/bob-ross-art-gallery/iphone-4.png", "size": 717046, "type": "image/png" }, { "file": "images/project/bob-ross-art-gallery/mac-1.png", "size": 289518, "type": "image/png" }, { "file": "images/project/bob-ross-art-gallery/mac-2.png", "size": 281759, "type": "image/png" }, { "file": "images/project/bob-ross-art-gallery/mac-3.png", "size": 302161, "type": "image/png" }, { "file": "images/project/bob-ross-art-gallery/mac-4.png", "size": 490020, "type": "image/png" }, { "file": "images/project/bob-ross-art-gallery/mac-5.png", "size": 856991, "type": "image/png" }, { "file": "images/project/bob-ross-art-gallery/thumbnail.png", "size": 856991, "type": "image/png" }, { "file": "images/project/compas/header.png", "size": 142488, "type": "image/png" }, { "file": "images/project/compas/mac-1.png", "size": 472868, "type": "image/png" }, { "file": "images/project/compas/mac-2.png", "size": 280729, "type": "image/png" }, { "file": "images/project/compas/phone-1.png", "size": 920374, "type": "image/png" }, { "file": "images/project/compas/phone-2.png", "size": 426156, "type": "image/png" }, { "file": "images/project/compas/thumbnail.png", "size": 280729, "type": "image/png" }, { "file": "images/project/covid-masking/header.png", "size": 162235, "type": "image/png" }, { "file": "images/project/covid-masking/mac-1.png", "size": 309479, "type": "image/png" }, { "file": "images/project/covid-masking/mac-2.png", "size": 499158, "type": "image/png" }, { "file": "images/project/covid-masking/mac-3.png", "size": 259141, "type": "image/png" }, { "file": "images/project/covid-masking/mac-4.png", "size": 422151, "type": "image/png" }, { "file": "images/project/covid-masking/mac-5.png", "size": 889689, "type": "image/png" }, { "file": "images/project/covid-masking/phone-1.png", "size": 876488, "type": "image/png" }, { "file": "images/project/covid-masking/phone-2.png", "size": 793978, "type": "image/png" }, { "file": "images/project/covid-masking/phone-3.png", "size": 1382827, "type": "image/png" }, { "file": "images/project/covid-masking/thumbnail.png", "size": 889689, "type": "image/png" }, { "file": "images/project/cudi-hums/albums-mac.png", "size": 436737, "type": "image/png" }, { "file": "images/project/cudi-hums/albums-phone.png", "size": 434100, "type": "image/png" }, { "file": "images/project/cudi-hums/header.png", "size": 387992, "type": "image/png" }, { "file": "images/project/cudi-hums/intro-phone.png", "size": 344442, "type": "image/png" }, { "file": "images/project/cudi-hums/lyrics-mac.png", "size": 391896, "type": "image/png" }, { "file": "images/project/cudi-hums/lyrics-phone.png", "size": 391041, "type": "image/png" }, { "file": "images/project/cudi-hums/outro-phone.png", "size": 839368, "type": "image/png" }, { "file": "images/project/cudi-hums/thumbnail.png", "size": 436910, "type": "image/png" }, { "file": "images/project/cudi-hums/tracks-mac.png", "size": 409045, "type": "image/png" }, { "file": "images/project/cudi-hums/tracks-phone.png", "size": 702731, "type": "image/png" }, { "file": "images/project/how-many-people/header.png", "size": 279507, "type": "image/png" }, { "file": "images/project/how-many-people/mac-1.png", "size": 344834, "type": "image/png" }, { "file": "images/project/how-many-people/mac-2.png", "size": 419217, "type": "image/png" }, { "file": "images/project/how-many-people/phone-1.png", "size": 539341, "type": "image/png" }, { "file": "images/project/how-many-people/phone-2.png", "size": 480652, "type": "image/png" }, { "file": "images/project/how-many-people/thumbnail.png", "size": 419044, "type": "image/png" }, { "file": "images/project/map-houston-homicides/header.png", "size": 940867, "type": "image/png" }, { "file": "images/project/map-houston-homicides/mac-1.png", "size": 686069, "type": "image/png" }, { "file": "images/project/map-houston-homicides/mac-2.png", "size": 763418, "type": "image/png" }, { "file": "images/project/map-houston-homicides/mac-3.png", "size": 993711, "type": "image/png" }, { "file": "images/project/map-houston-homicides/mac-4.png", "size": 1095083, "type": "image/png" }, { "file": "images/project/map-houston-homicides/phone-1.png", "size": 1357800, "type": "image/png" }, { "file": "images/project/map-houston-homicides/phone-2.png", "size": 1322563, "type": "image/png" }, { "file": "images/project/map-houston-homicides/phone-3.png", "size": 1366588, "type": "image/png" }, { "file": "images/project/map-houston-homicides/thumbnail.png", "size": 686069, "type": "image/png" }, { "file": "images/project/map-missing-migrants/header.png", "size": 2595176, "type": "image/png" }, { "file": "images/project/map-missing-migrants/mac-1.png", "size": 1686366, "type": "image/png" }, { "file": "images/project/map-missing-migrants/mac-2.png", "size": 2525417, "type": "image/png" }, { "file": "images/project/map-missing-migrants/mac-3.png", "size": 1666740, "type": "image/png" }, { "file": "images/project/map-missing-migrants/mac-4.png", "size": 2408824, "type": "image/png" }, { "file": "images/project/map-missing-migrants/mac-5.png", "size": 2937636, "type": "image/png" }, { "file": "images/project/map-missing-migrants/phone-1.png", "size": 1593964, "type": "image/png" }, { "file": "images/project/map-missing-migrants/phone-2.png", "size": 2671671, "type": "image/png" }, { "file": "images/project/map-missing-migrants/phone-3.png", "size": 4814414, "type": "image/png" }, { "file": "images/project/map-missing-migrants/thumbnail.png", "size": 1686366, "type": "image/png" }, { "file": "images/project/media-mentions/header.png", "size": 118535, "type": "image/png" }, { "file": "images/project/media-mentions/mac.png", "size": 306203, "type": "image/png" }, { "file": "images/project/media-mentions/phone.png", "size": 582627, "type": "image/png" }, { "file": "images/project/media-mentions/thumbnail.png", "size": 306203, "type": "image/png" }, { "file": "images/project/one-line-hacks/.DS_Store", "size": 6148, "type": null }, { "file": "images/project/one-line-hacks/header-old.png", "size": 490537, "type": "image/png" }, { "file": "images/project/one-line-hacks/header.png", "size": 117340, "type": "image/png" }, { "file": "images/project/one-line-hacks/mac-1.png", "size": 383847, "type": "image/png" }, { "file": "images/project/one-line-hacks/phone-1.png", "size": 769617, "type": "image/png" }, { "file": "images/project/one-line-hacks/thumbnail.png", "size": 383847, "type": "image/png" }, { "file": "images/project/police-killings/header.png", "size": 250166, "type": "image/png" }, { "file": "images/project/police-killings/mac-1.png", "size": 279769, "type": "image/png" }, { "file": "images/project/police-killings/mac-2.png", "size": 391676, "type": "image/png" }, { "file": "images/project/police-killings/phone-1.png", "size": 381385, "type": "image/png" }, { "file": "images/project/police-killings/phone-2.png", "size": 391569, "type": "image/png" }, { "file": "images/project/police-killings/thumbnail.png", "size": 391676, "type": "image/png" }, { "file": "images/project/quarantunes/header.png", "size": 214359, "type": "image/png" }, { "file": "images/project/quarantunes/macbook.png", "size": 454223, "type": "image/png" }, { "file": "images/project/quarantunes/phone.png", "size": 779131, "type": "image/png" }, { "file": "images/project/quarantunes/side-by-side.png", "size": 667703, "type": "image/png" }, { "file": "images/project/quarantunes/tablet.png", "size": 404682, "type": "image/png" }, { "file": "images/project/quarantunes/thumbnail.png", "size": 454223, "type": "image/png" }, { "file": "images/project/state-police-spending/header.png", "size": 229693, "type": "image/png" }, { "file": "images/project/state-police-spending/mac.png", "size": 365809, "type": "image/png" }, { "file": "images/project/state-police-spending/phone.png", "size": 549873, "type": "image/png" }, { "file": "images/project/state-police-spending/thumbnail.png", "size": 365809, "type": "image/png" }, { "file": "images/project/tpl-schools-db/.DS_Store", "size": 6148, "type": null }, { "file": "images/project/tpl-schools-db/header.png", "size": 437453, "type": "image/png" }, { "file": "images/project/tpl-schools-db/iphone-1.png", "size": 603447, "type": "image/png" }, { "file": "images/project/tpl-schools-db/iphone-2.png", "size": 505851, "type": "image/png" }, { "file": "images/project/tpl-schools-db/iphone-3.png", "size": 596795, "type": "image/png" }, { "file": "images/project/tpl-schools-db/mac-1.png", "size": 562424, "type": "image/png" }, { "file": "images/project/tpl-schools-db/mac-2.png", "size": 470837, "type": "image/png" }, { "file": "images/project/tpl-schools-db/thumbnail.png", "size": 562424, "type": "image/png" }],
  layout: "src/routes/__layout.svelte",
  error: "src/routes/__error.svelte",
  routes: [
    {
      type: "page",
      pattern: /^\/$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/index.svelte"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "endpoint",
      pattern: /^\/experience\.json$/,
      params: empty,
      load: () => Promise.resolve().then(function() {
        return experience_json;
      })
    },
    {
      type: "endpoint",
      pattern: /^\/projects\.json$/,
      params: empty,
      load: () => Promise.resolve().then(function() {
        return projects_json;
      })
    },
    {
      type: "endpoint",
      pattern: /^\/awards\.json$/,
      params: empty,
      load: () => Promise.resolve().then(function() {
        return awards_json;
      })
    },
    {
      type: "page",
      pattern: /^\/experience\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/experience/index.svelte"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/experience\/layout\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/experience/layout.svelte"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/experience\/moksha\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/experience/moksha.md"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/experience\/axios\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/experience/axios.md"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/experience\/socom\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/experience/socom.md"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/experience\/tpl\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/experience/tpl.md"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "endpoint",
      pattern: /^\/posts\.json$/,
      params: empty,
      load: () => Promise.resolve().then(function() {
        return posts_json;
      })
    },
    {
      type: "page",
      pattern: /^\/project\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/project/index.svelte"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/project\/map-houston-homicides\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/project/map-houston-homicides.md"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/project\/state-police-spending\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/project/state-police-spending.md"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/project\/bob-ross-art-gallery\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/project/bob-ross-art-gallery.md"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/project\/map-missing-migrants\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/project/map-missing-migrants.md"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/project\/how-many-people\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/project/how-many-people.md"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/project\/police-killings\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/project/police-killings.md"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/project\/media-mentions\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/project/media-mentions.md"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/project\/one-line-hacks\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/project/one-line-hacks.md"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/project\/tpl-schools-db\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/project/tpl-schools-db.md"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/project\/covid-masking\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/project/covid-masking.md"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/project\/quarantunes\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/project/quarantunes.md"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/project\/cudi-hums\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/project/cudi-hums.md"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/project\/compas\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/project/compas.md"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/project\/layout\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/project/layout.svelte"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/project\/atus\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/project/atus.md"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/award\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/award/index.svelte"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/award\/rstudio-table-contest-2021\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/award/rstudio-table-contest-2021.md"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/award\/d2k-showcase-2020\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/award/d2k-showcase-2020.md"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/award\/northeastern-2020\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/award/northeastern-2020.md"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/award\/pudding-cup-2020\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/award/pudding-cup-2020.md"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/award\/nationals-2017\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/award/nationals-2017.md"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/award\/datathon-2020\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/award/datathon-2020.md"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/award\/hudspeth-2020\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/award/hudspeth-2020.md"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/award\/malofiej-2020\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/award/malofiej-2020.md"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/award\/malofiej-2021\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/award/malofiej-2021.md"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/award\/bipp-2018\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/award/bipp-2018.md"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/award\/chrp-2020\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/award/chrp-2020.md"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/award\/hpc-2018\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/award/hpc-2018.md"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/award\/hpc-2019\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/award/hpc-2019.md"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/award\/hpc-2020\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/award/hpc-2020.md"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/award\/snd-2021\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/award/snd-2021.md"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/award\/layout\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/award/layout.svelte"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/post\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/post/index.svelte"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/post\/economist-table-replication-using-reactable\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/post/economist-table-replication-using-reactable.md"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/post\/adding-a-chart-to-your-d3-tooltip\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/post/adding-a-chart-to-your-d3-tooltip.md"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/post\/tidy-tuesday-powerlifting\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/post/tidy-tuesday-powerlifting.md"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/post\/tidy-tuesday-replication\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/post/tidy-tuesday-replication.md"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/post\/automation-scrollytell\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/post/automation-scrollytell.md"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/post\/animate-hugo-academic\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/post/animate-hugo-academic.md"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/post\/introducing-tpltheme\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/post/introducing-tpltheme.md"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/post\/color-in-data-vis\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/post/color-in-data-vis.md"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/post\/do-something-else\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/post/do-something-else.md"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/post\/nuxt-blog-starter\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/post/nuxt-blog-starter.md"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/post\/covid-gun-spikes\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/post/covid-gun-spikes.md"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/post\/covid-on-campus\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/post/covid-on-campus.md"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/post\/map-springfield\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/post/map-springfield.md"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/post\/dumbbell-plots\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/post/dumbbell-plots.md"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/post\/refugee-trends\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/post/refugee-trends.md"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/post\/svelte-scatter\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/post/svelte-scatter.md"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/post\/svelte-and-d3\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/post/svelte-and-d3.md"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/post\/covid-posts\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/post/covid-posts.md"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/post\/flat-data-r\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/post/flat-data-r.md"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/post\/layout\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/post/layout.svelte"],
      b: ["src/routes/__error.svelte"]
    }
  ]
};
var get_hooks = (hooks) => ({
  getSession: hooks.getSession || (() => ({})),
  handle: hooks.handle || (({ request, resolve: resolve2 }) => resolve2(request)),
  handleError: hooks.handleError || (({ error: error2 }) => console.error(error2.stack)),
  externalFetch: hooks.externalFetch || fetch
});
var module_lookup = {
  "src/routes/__layout.svelte": () => Promise.resolve().then(function() {
    return __layout;
  }),
  "src/routes/__error.svelte": () => Promise.resolve().then(function() {
    return __error;
  }),
  "src/routes/index.svelte": () => Promise.resolve().then(function() {
    return index$4;
  }),
  "src/routes/experience/index.svelte": () => Promise.resolve().then(function() {
    return index$3;
  }),
  "src/routes/experience/layout.svelte": () => Promise.resolve().then(function() {
    return layout$3;
  }),
  "src/routes/experience/moksha.md": () => Promise.resolve().then(function() {
    return moksha;
  }),
  "src/routes/experience/axios.md": () => Promise.resolve().then(function() {
    return axios;
  }),
  "src/routes/experience/socom.md": () => Promise.resolve().then(function() {
    return socom;
  }),
  "src/routes/experience/tpl.md": () => Promise.resolve().then(function() {
    return tpl;
  }),
  "src/routes/project/index.svelte": () => Promise.resolve().then(function() {
    return index$2;
  }),
  "src/routes/project/map-houston-homicides.md": () => Promise.resolve().then(function() {
    return mapHoustonHomicides;
  }),
  "src/routes/project/state-police-spending.md": () => Promise.resolve().then(function() {
    return statePoliceSpending;
  }),
  "src/routes/project/bob-ross-art-gallery.md": () => Promise.resolve().then(function() {
    return bobRossArtGallery;
  }),
  "src/routes/project/map-missing-migrants.md": () => Promise.resolve().then(function() {
    return mapMissingMigrants;
  }),
  "src/routes/project/how-many-people.md": () => Promise.resolve().then(function() {
    return howManyPeople;
  }),
  "src/routes/project/police-killings.md": () => Promise.resolve().then(function() {
    return policeKillings;
  }),
  "src/routes/project/media-mentions.md": () => Promise.resolve().then(function() {
    return mediaMentions;
  }),
  "src/routes/project/one-line-hacks.md": () => Promise.resolve().then(function() {
    return oneLineHacks;
  }),
  "src/routes/project/tpl-schools-db.md": () => Promise.resolve().then(function() {
    return tplSchoolsDb;
  }),
  "src/routes/project/covid-masking.md": () => Promise.resolve().then(function() {
    return covidMasking;
  }),
  "src/routes/project/quarantunes.md": () => Promise.resolve().then(function() {
    return quarantunes;
  }),
  "src/routes/project/cudi-hums.md": () => Promise.resolve().then(function() {
    return cudiHums;
  }),
  "src/routes/project/compas.md": () => Promise.resolve().then(function() {
    return compas;
  }),
  "src/routes/project/layout.svelte": () => Promise.resolve().then(function() {
    return layout$2;
  }),
  "src/routes/project/atus.md": () => Promise.resolve().then(function() {
    return atus;
  }),
  "src/routes/award/index.svelte": () => Promise.resolve().then(function() {
    return index$1;
  }),
  "src/routes/award/rstudio-table-contest-2021.md": () => Promise.resolve().then(function() {
    return rstudioTableContest2021;
  }),
  "src/routes/award/d2k-showcase-2020.md": () => Promise.resolve().then(function() {
    return d2kShowcase2020;
  }),
  "src/routes/award/northeastern-2020.md": () => Promise.resolve().then(function() {
    return northeastern2020;
  }),
  "src/routes/award/pudding-cup-2020.md": () => Promise.resolve().then(function() {
    return puddingCup2020;
  }),
  "src/routes/award/nationals-2017.md": () => Promise.resolve().then(function() {
    return nationals2017;
  }),
  "src/routes/award/datathon-2020.md": () => Promise.resolve().then(function() {
    return datathon2020;
  }),
  "src/routes/award/hudspeth-2020.md": () => Promise.resolve().then(function() {
    return hudspeth2020;
  }),
  "src/routes/award/malofiej-2020.md": () => Promise.resolve().then(function() {
    return malofiej2020;
  }),
  "src/routes/award/malofiej-2021.md": () => Promise.resolve().then(function() {
    return malofiej2021;
  }),
  "src/routes/award/bipp-2018.md": () => Promise.resolve().then(function() {
    return bipp2018;
  }),
  "src/routes/award/chrp-2020.md": () => Promise.resolve().then(function() {
    return chrp2020;
  }),
  "src/routes/award/hpc-2018.md": () => Promise.resolve().then(function() {
    return hpc2018;
  }),
  "src/routes/award/hpc-2019.md": () => Promise.resolve().then(function() {
    return hpc2019;
  }),
  "src/routes/award/hpc-2020.md": () => Promise.resolve().then(function() {
    return hpc2020;
  }),
  "src/routes/award/snd-2021.md": () => Promise.resolve().then(function() {
    return snd2021;
  }),
  "src/routes/award/layout.svelte": () => Promise.resolve().then(function() {
    return layout$1;
  }),
  "src/routes/post/index.svelte": () => Promise.resolve().then(function() {
    return index;
  }),
  "src/routes/post/economist-table-replication-using-reactable.md": () => Promise.resolve().then(function() {
    return economistTableReplicationUsingReactable;
  }),
  "src/routes/post/adding-a-chart-to-your-d3-tooltip.md": () => Promise.resolve().then(function() {
    return addingAChartToYourD3Tooltip;
  }),
  "src/routes/post/tidy-tuesday-powerlifting.md": () => Promise.resolve().then(function() {
    return tidyTuesdayPowerlifting;
  }),
  "src/routes/post/tidy-tuesday-replication.md": () => Promise.resolve().then(function() {
    return tidyTuesdayReplication;
  }),
  "src/routes/post/automation-scrollytell.md": () => Promise.resolve().then(function() {
    return automationScrollytell;
  }),
  "src/routes/post/animate-hugo-academic.md": () => Promise.resolve().then(function() {
    return animateHugoAcademic;
  }),
  "src/routes/post/introducing-tpltheme.md": () => Promise.resolve().then(function() {
    return introducingTpltheme;
  }),
  "src/routes/post/color-in-data-vis.md": () => Promise.resolve().then(function() {
    return colorInDataVis;
  }),
  "src/routes/post/do-something-else.md": () => Promise.resolve().then(function() {
    return doSomethingElse;
  }),
  "src/routes/post/nuxt-blog-starter.md": () => Promise.resolve().then(function() {
    return nuxtBlogStarter;
  }),
  "src/routes/post/covid-gun-spikes.md": () => Promise.resolve().then(function() {
    return covidGunSpikes;
  }),
  "src/routes/post/covid-on-campus.md": () => Promise.resolve().then(function() {
    return covidOnCampus;
  }),
  "src/routes/post/map-springfield.md": () => Promise.resolve().then(function() {
    return mapSpringfield;
  }),
  "src/routes/post/dumbbell-plots.md": () => Promise.resolve().then(function() {
    return dumbbellPlots;
  }),
  "src/routes/post/refugee-trends.md": () => Promise.resolve().then(function() {
    return refugeeTrends;
  }),
  "src/routes/post/svelte-scatter.md": () => Promise.resolve().then(function() {
    return svelteScatter;
  }),
  "src/routes/post/svelte-and-d3.md": () => Promise.resolve().then(function() {
    return svelteAndD3;
  }),
  "src/routes/post/covid-posts.md": () => Promise.resolve().then(function() {
    return covidPosts;
  }),
  "src/routes/post/flat-data-r.md": () => Promise.resolve().then(function() {
    return flatDataR;
  }),
  "src/routes/post/layout.svelte": () => Promise.resolve().then(function() {
    return layout;
  })
};
var metadata_lookup = { "src/routes/__layout.svelte": { "entry": "pages/__layout.svelte-d60d08ee.js", "css": ["assets/pages/__layout.svelte-c8b1663c.css"], "js": ["pages/__layout.svelte-d60d08ee.js", "chunks/vendor-81ee5109.js", "chunks/store-ee9a40c3.js"], "styles": [] }, "src/routes/__error.svelte": { "entry": "pages/__error.svelte-0575c871.js", "css": [], "js": ["pages/__error.svelte-0575c871.js", "chunks/vendor-81ee5109.js"], "styles": [] }, "src/routes/index.svelte": { "entry": "pages/index.svelte-7a8f964c.js", "css": ["assets/pages/index.svelte-8c5e0038.css"], "js": ["pages/index.svelte-7a8f964c.js", "chunks/vendor-81ee5109.js"], "styles": [] }, "src/routes/experience/index.svelte": { "entry": "pages/experience/index.svelte-86685f90.js", "css": ["assets/pages/experience/index.svelte-6d9ecd69.css"], "js": ["pages/experience/index.svelte-86685f90.js", "chunks/vendor-81ee5109.js", "chunks/Main-3473b253.js", "chunks/store-ee9a40c3.js"], "styles": [] }, "src/routes/experience/layout.svelte": { "entry": "pages/experience/layout.svelte-a7e3b266.js", "css": ["assets/pages/experience/layout.svelte-7166afc4.css", "assets/BackTo-5846cd5f.css"], "js": ["pages/experience/layout.svelte-a7e3b266.js", "chunks/vendor-81ee5109.js", "chunks/Content-9a197927.js", "chunks/BackTo-b08a8f3c.js", "chunks/store-ee9a40c3.js"], "styles": [] }, "src/routes/experience/moksha.md": { "entry": "pages/experience/moksha.md-79d81230.js", "css": ["assets/pages/experience/layout.svelte-7166afc4.css", "assets/BackTo-5846cd5f.css"], "js": ["pages/experience/moksha.md-79d81230.js", "chunks/vendor-81ee5109.js", "pages/experience/layout.svelte-a7e3b266.js", "chunks/Content-9a197927.js", "chunks/BackTo-b08a8f3c.js", "chunks/store-ee9a40c3.js"], "styles": [] }, "src/routes/experience/axios.md": { "entry": "pages/experience/axios.md-3ea810de.js", "css": ["assets/pages/experience/layout.svelte-7166afc4.css", "assets/BackTo-5846cd5f.css"], "js": ["pages/experience/axios.md-3ea810de.js", "chunks/vendor-81ee5109.js", "pages/experience/layout.svelte-a7e3b266.js", "chunks/Content-9a197927.js", "chunks/BackTo-b08a8f3c.js", "chunks/store-ee9a40c3.js"], "styles": [] }, "src/routes/experience/socom.md": { "entry": "pages/experience/socom.md-b02b9d1d.js", "css": ["assets/pages/experience/layout.svelte-7166afc4.css", "assets/BackTo-5846cd5f.css"], "js": ["pages/experience/socom.md-b02b9d1d.js", "chunks/vendor-81ee5109.js", "pages/experience/layout.svelte-a7e3b266.js", "chunks/Content-9a197927.js", "chunks/BackTo-b08a8f3c.js", "chunks/store-ee9a40c3.js"], "styles": [] }, "src/routes/experience/tpl.md": { "entry": "pages/experience/tpl.md-ef383f47.js", "css": ["assets/pages/experience/layout.svelte-7166afc4.css", "assets/BackTo-5846cd5f.css"], "js": ["pages/experience/tpl.md-ef383f47.js", "chunks/vendor-81ee5109.js", "pages/experience/layout.svelte-a7e3b266.js", "chunks/Content-9a197927.js", "chunks/BackTo-b08a8f3c.js", "chunks/store-ee9a40c3.js"], "styles": [] }, "src/routes/project/index.svelte": { "entry": "pages/project/index.svelte-167f0313.js", "css": ["assets/pages/project/index.svelte-f07fac8c.css"], "js": ["pages/project/index.svelte-167f0313.js", "chunks/vendor-81ee5109.js", "chunks/Main-3473b253.js", "chunks/store-ee9a40c3.js"], "styles": [] }, "src/routes/project/map-houston-homicides.md": { "entry": "pages/project/map-houston-homicides.md-48e14ef0.js", "css": ["assets/Image.svelte_svelte&type=style&lang-8c589ec5.css", "assets/pages/project/layout.svelte-d9c068dd.css", "assets/BackTo-5846cd5f.css"], "js": ["pages/project/map-houston-homicides.md-48e14ef0.js", "chunks/vendor-81ee5109.js", "pages/project/layout.svelte-19343272.js", "chunks/BackTo-b08a8f3c.js", "chunks/Content-9a197927.js", "chunks/store-ee9a40c3.js", "chunks/Image-2267b2be.js"], "styles": [] }, "src/routes/project/state-police-spending.md": { "entry": "pages/project/state-police-spending.md-768c04c4.js", "css": ["assets/Image.svelte_svelte&type=style&lang-8c589ec5.css", "assets/pages/project/layout.svelte-d9c068dd.css", "assets/BackTo-5846cd5f.css"], "js": ["pages/project/state-police-spending.md-768c04c4.js", "chunks/vendor-81ee5109.js", "pages/project/layout.svelte-19343272.js", "chunks/BackTo-b08a8f3c.js", "chunks/Content-9a197927.js", "chunks/store-ee9a40c3.js", "chunks/Image-2267b2be.js"], "styles": [] }, "src/routes/project/bob-ross-art-gallery.md": { "entry": "pages/project/bob-ross-art-gallery.md-ca2cee27.js", "css": ["assets/Image.svelte_svelte&type=style&lang-8c589ec5.css", "assets/pages/project/layout.svelte-d9c068dd.css", "assets/BackTo-5846cd5f.css"], "js": ["pages/project/bob-ross-art-gallery.md-ca2cee27.js", "chunks/vendor-81ee5109.js", "pages/project/layout.svelte-19343272.js", "chunks/BackTo-b08a8f3c.js", "chunks/Content-9a197927.js", "chunks/store-ee9a40c3.js", "chunks/Image-2267b2be.js"], "styles": [] }, "src/routes/project/map-missing-migrants.md": { "entry": "pages/project/map-missing-migrants.md-98ecd55f.js", "css": ["assets/Image.svelte_svelte&type=style&lang-8c589ec5.css", "assets/pages/project/layout.svelte-d9c068dd.css", "assets/BackTo-5846cd5f.css"], "js": ["pages/project/map-missing-migrants.md-98ecd55f.js", "chunks/vendor-81ee5109.js", "pages/project/layout.svelte-19343272.js", "chunks/BackTo-b08a8f3c.js", "chunks/Content-9a197927.js", "chunks/store-ee9a40c3.js", "chunks/Image-2267b2be.js"], "styles": [] }, "src/routes/project/how-many-people.md": { "entry": "pages/project/how-many-people.md-2d5800f3.js", "css": ["assets/Image.svelte_svelte&type=style&lang-8c589ec5.css", "assets/pages/project/layout.svelte-d9c068dd.css", "assets/BackTo-5846cd5f.css"], "js": ["pages/project/how-many-people.md-2d5800f3.js", "chunks/vendor-81ee5109.js", "pages/project/layout.svelte-19343272.js", "chunks/BackTo-b08a8f3c.js", "chunks/Content-9a197927.js", "chunks/store-ee9a40c3.js", "chunks/Image-2267b2be.js"], "styles": [] }, "src/routes/project/police-killings.md": { "entry": "pages/project/police-killings.md-2fe3945f.js", "css": ["assets/Image.svelte_svelte&type=style&lang-8c589ec5.css", "assets/pages/project/layout.svelte-d9c068dd.css", "assets/BackTo-5846cd5f.css"], "js": ["pages/project/police-killings.md-2fe3945f.js", "chunks/vendor-81ee5109.js", "pages/project/layout.svelte-19343272.js", "chunks/BackTo-b08a8f3c.js", "chunks/Content-9a197927.js", "chunks/store-ee9a40c3.js", "chunks/Image-2267b2be.js"], "styles": [] }, "src/routes/project/media-mentions.md": { "entry": "pages/project/media-mentions.md-6f1a4df8.js", "css": ["assets/Image.svelte_svelte&type=style&lang-8c589ec5.css", "assets/pages/project/layout.svelte-d9c068dd.css", "assets/BackTo-5846cd5f.css"], "js": ["pages/project/media-mentions.md-6f1a4df8.js", "chunks/vendor-81ee5109.js", "pages/project/layout.svelte-19343272.js", "chunks/BackTo-b08a8f3c.js", "chunks/Content-9a197927.js", "chunks/store-ee9a40c3.js", "chunks/Image-2267b2be.js"], "styles": [] }, "src/routes/project/one-line-hacks.md": { "entry": "pages/project/one-line-hacks.md-18a6e850.js", "css": ["assets/Image.svelte_svelte&type=style&lang-8c589ec5.css", "assets/pages/project/layout.svelte-d9c068dd.css", "assets/BackTo-5846cd5f.css"], "js": ["pages/project/one-line-hacks.md-18a6e850.js", "chunks/vendor-81ee5109.js", "pages/project/layout.svelte-19343272.js", "chunks/BackTo-b08a8f3c.js", "chunks/Content-9a197927.js", "chunks/store-ee9a40c3.js", "chunks/Image-2267b2be.js"], "styles": [] }, "src/routes/project/tpl-schools-db.md": { "entry": "pages/project/tpl-schools-db.md-735f641b.js", "css": ["assets/Image.svelte_svelte&type=style&lang-8c589ec5.css", "assets/pages/project/layout.svelte-d9c068dd.css", "assets/BackTo-5846cd5f.css"], "js": ["pages/project/tpl-schools-db.md-735f641b.js", "chunks/vendor-81ee5109.js", "pages/project/layout.svelte-19343272.js", "chunks/BackTo-b08a8f3c.js", "chunks/Content-9a197927.js", "chunks/store-ee9a40c3.js", "chunks/Image-2267b2be.js"], "styles": [] }, "src/routes/project/covid-masking.md": { "entry": "pages/project/covid-masking.md-675cfcd8.js", "css": ["assets/Image.svelte_svelte&type=style&lang-8c589ec5.css", "assets/pages/project/layout.svelte-d9c068dd.css", "assets/BackTo-5846cd5f.css"], "js": ["pages/project/covid-masking.md-675cfcd8.js", "chunks/vendor-81ee5109.js", "pages/project/layout.svelte-19343272.js", "chunks/BackTo-b08a8f3c.js", "chunks/Content-9a197927.js", "chunks/store-ee9a40c3.js", "chunks/Image-2267b2be.js"], "styles": [] }, "src/routes/project/quarantunes.md": { "entry": "pages/project/quarantunes.md-d85cf37d.js", "css": ["assets/Image.svelte_svelte&type=style&lang-8c589ec5.css", "assets/pages/project/layout.svelte-d9c068dd.css", "assets/BackTo-5846cd5f.css"], "js": ["pages/project/quarantunes.md-d85cf37d.js", "chunks/vendor-81ee5109.js", "pages/project/layout.svelte-19343272.js", "chunks/BackTo-b08a8f3c.js", "chunks/Content-9a197927.js", "chunks/store-ee9a40c3.js", "chunks/Image-2267b2be.js"], "styles": [] }, "src/routes/project/cudi-hums.md": { "entry": "pages/project/cudi-hums.md-8000940c.js", "css": ["assets/Image.svelte_svelte&type=style&lang-8c589ec5.css", "assets/pages/project/layout.svelte-d9c068dd.css", "assets/BackTo-5846cd5f.css"], "js": ["pages/project/cudi-hums.md-8000940c.js", "chunks/vendor-81ee5109.js", "pages/project/layout.svelte-19343272.js", "chunks/BackTo-b08a8f3c.js", "chunks/Content-9a197927.js", "chunks/store-ee9a40c3.js", "chunks/Image-2267b2be.js"], "styles": [] }, "src/routes/project/compas.md": { "entry": "pages/project/compas.md-0885f7c1.js", "css": ["assets/Image.svelte_svelte&type=style&lang-8c589ec5.css", "assets/pages/project/layout.svelte-d9c068dd.css", "assets/BackTo-5846cd5f.css"], "js": ["pages/project/compas.md-0885f7c1.js", "chunks/vendor-81ee5109.js", "pages/project/layout.svelte-19343272.js", "chunks/BackTo-b08a8f3c.js", "chunks/Content-9a197927.js", "chunks/store-ee9a40c3.js", "chunks/Image-2267b2be.js"], "styles": [] }, "src/routes/project/layout.svelte": { "entry": "pages/project/layout.svelte-19343272.js", "css": ["assets/pages/project/layout.svelte-d9c068dd.css", "assets/BackTo-5846cd5f.css"], "js": ["pages/project/layout.svelte-19343272.js", "chunks/vendor-81ee5109.js", "chunks/BackTo-b08a8f3c.js", "chunks/Content-9a197927.js", "chunks/store-ee9a40c3.js"], "styles": [] }, "src/routes/project/atus.md": { "entry": "pages/project/atus.md-2904d093.js", "css": ["assets/Image.svelte_svelte&type=style&lang-8c589ec5.css", "assets/pages/project/layout.svelte-d9c068dd.css", "assets/BackTo-5846cd5f.css"], "js": ["pages/project/atus.md-2904d093.js", "chunks/vendor-81ee5109.js", "pages/project/layout.svelte-19343272.js", "chunks/BackTo-b08a8f3c.js", "chunks/Content-9a197927.js", "chunks/store-ee9a40c3.js", "chunks/Image-2267b2be.js"], "styles": [] }, "src/routes/award/index.svelte": { "entry": "pages/award/index.svelte-9631218e.js", "css": ["assets/pages/award/index.svelte-56d22de0.css", "assets/Star-4c3ba909.css"], "js": ["pages/award/index.svelte-9631218e.js", "chunks/vendor-81ee5109.js", "chunks/utils-4d01bc61.js", "chunks/Star-877e0b10.js", "chunks/Main-3473b253.js", "chunks/store-ee9a40c3.js"], "styles": [] }, "src/routes/award/rstudio-table-contest-2021.md": { "entry": "pages/award/rstudio-table-contest-2021.md-ef76bb0a.js", "css": ["assets/pages/award/layout.svelte-6c103d3e.css", "assets/BackTo-5846cd5f.css"], "js": ["pages/award/rstudio-table-contest-2021.md-ef76bb0a.js", "chunks/vendor-81ee5109.js", "pages/award/layout.svelte-f64d747c.js", "chunks/BackTo-b08a8f3c.js", "chunks/store-ee9a40c3.js"], "styles": [] }, "src/routes/award/d2k-showcase-2020.md": { "entry": "pages/award/d2k-showcase-2020.md-233cfd98.js", "css": ["assets/pages/award/layout.svelte-6c103d3e.css", "assets/BackTo-5846cd5f.css"], "js": ["pages/award/d2k-showcase-2020.md-233cfd98.js", "chunks/vendor-81ee5109.js", "pages/award/layout.svelte-f64d747c.js", "chunks/BackTo-b08a8f3c.js", "chunks/store-ee9a40c3.js"], "styles": [] }, "src/routes/award/northeastern-2020.md": { "entry": "pages/award/northeastern-2020.md-46033312.js", "css": ["assets/pages/award/layout.svelte-6c103d3e.css", "assets/BackTo-5846cd5f.css"], "js": ["pages/award/northeastern-2020.md-46033312.js", "chunks/vendor-81ee5109.js", "pages/award/layout.svelte-f64d747c.js", "chunks/BackTo-b08a8f3c.js", "chunks/store-ee9a40c3.js"], "styles": [] }, "src/routes/award/pudding-cup-2020.md": { "entry": "pages/award/pudding-cup-2020.md-d1f0dd36.js", "css": ["assets/pages/award/layout.svelte-6c103d3e.css", "assets/BackTo-5846cd5f.css"], "js": ["pages/award/pudding-cup-2020.md-d1f0dd36.js", "chunks/vendor-81ee5109.js", "pages/award/layout.svelte-f64d747c.js", "chunks/BackTo-b08a8f3c.js", "chunks/store-ee9a40c3.js"], "styles": [] }, "src/routes/award/nationals-2017.md": { "entry": "pages/award/nationals-2017.md-6e878a68.js", "css": ["assets/pages/award/layout.svelte-6c103d3e.css", "assets/BackTo-5846cd5f.css"], "js": ["pages/award/nationals-2017.md-6e878a68.js", "chunks/vendor-81ee5109.js", "pages/award/layout.svelte-f64d747c.js", "chunks/BackTo-b08a8f3c.js", "chunks/store-ee9a40c3.js"], "styles": [] }, "src/routes/award/datathon-2020.md": { "entry": "pages/award/datathon-2020.md-454615ad.js", "css": ["assets/pages/award/layout.svelte-6c103d3e.css", "assets/BackTo-5846cd5f.css"], "js": ["pages/award/datathon-2020.md-454615ad.js", "chunks/vendor-81ee5109.js", "pages/award/layout.svelte-f64d747c.js", "chunks/BackTo-b08a8f3c.js", "chunks/store-ee9a40c3.js"], "styles": [] }, "src/routes/award/hudspeth-2020.md": { "entry": "pages/award/hudspeth-2020.md-ebaa3510.js", "css": ["assets/pages/award/layout.svelte-6c103d3e.css", "assets/BackTo-5846cd5f.css"], "js": ["pages/award/hudspeth-2020.md-ebaa3510.js", "chunks/vendor-81ee5109.js", "pages/award/layout.svelte-f64d747c.js", "chunks/BackTo-b08a8f3c.js", "chunks/store-ee9a40c3.js"], "styles": [] }, "src/routes/award/malofiej-2020.md": { "entry": "pages/award/malofiej-2020.md-f8633940.js", "css": ["assets/pages/award/layout.svelte-6c103d3e.css", "assets/BackTo-5846cd5f.css"], "js": ["pages/award/malofiej-2020.md-f8633940.js", "chunks/vendor-81ee5109.js", "pages/award/layout.svelte-f64d747c.js", "chunks/BackTo-b08a8f3c.js", "chunks/store-ee9a40c3.js"], "styles": [] }, "src/routes/award/malofiej-2021.md": { "entry": "pages/award/malofiej-2021.md-038f5644.js", "css": ["assets/pages/award/layout.svelte-6c103d3e.css", "assets/BackTo-5846cd5f.css"], "js": ["pages/award/malofiej-2021.md-038f5644.js", "chunks/vendor-81ee5109.js", "pages/award/layout.svelte-f64d747c.js", "chunks/BackTo-b08a8f3c.js", "chunks/store-ee9a40c3.js"], "styles": [] }, "src/routes/award/bipp-2018.md": { "entry": "pages/award/bipp-2018.md-e6510d3d.js", "css": ["assets/pages/award/layout.svelte-6c103d3e.css", "assets/BackTo-5846cd5f.css"], "js": ["pages/award/bipp-2018.md-e6510d3d.js", "chunks/vendor-81ee5109.js", "pages/award/layout.svelte-f64d747c.js", "chunks/BackTo-b08a8f3c.js", "chunks/store-ee9a40c3.js"], "styles": [] }, "src/routes/award/chrp-2020.md": { "entry": "pages/award/chrp-2020.md-e701f3af.js", "css": ["assets/pages/award/layout.svelte-6c103d3e.css", "assets/BackTo-5846cd5f.css"], "js": ["pages/award/chrp-2020.md-e701f3af.js", "chunks/vendor-81ee5109.js", "pages/award/layout.svelte-f64d747c.js", "chunks/BackTo-b08a8f3c.js", "chunks/store-ee9a40c3.js"], "styles": [] }, "src/routes/award/hpc-2018.md": { "entry": "pages/award/hpc-2018.md-c91d779e.js", "css": ["assets/pages/award/layout.svelte-6c103d3e.css", "assets/BackTo-5846cd5f.css"], "js": ["pages/award/hpc-2018.md-c91d779e.js", "chunks/vendor-81ee5109.js", "pages/award/layout.svelte-f64d747c.js", "chunks/BackTo-b08a8f3c.js", "chunks/store-ee9a40c3.js"], "styles": [] }, "src/routes/award/hpc-2019.md": { "entry": "pages/award/hpc-2019.md-42cbb33c.js", "css": ["assets/pages/award/layout.svelte-6c103d3e.css", "assets/BackTo-5846cd5f.css"], "js": ["pages/award/hpc-2019.md-42cbb33c.js", "chunks/vendor-81ee5109.js", "pages/award/layout.svelte-f64d747c.js", "chunks/BackTo-b08a8f3c.js", "chunks/store-ee9a40c3.js"], "styles": [] }, "src/routes/award/hpc-2020.md": { "entry": "pages/award/hpc-2020.md-c908ecac.js", "css": ["assets/pages/award/layout.svelte-6c103d3e.css", "assets/BackTo-5846cd5f.css"], "js": ["pages/award/hpc-2020.md-c908ecac.js", "chunks/vendor-81ee5109.js", "pages/award/layout.svelte-f64d747c.js", "chunks/BackTo-b08a8f3c.js", "chunks/store-ee9a40c3.js"], "styles": [] }, "src/routes/award/snd-2021.md": { "entry": "pages/award/snd-2021.md-264c5d51.js", "css": ["assets/pages/award/layout.svelte-6c103d3e.css", "assets/BackTo-5846cd5f.css"], "js": ["pages/award/snd-2021.md-264c5d51.js", "chunks/vendor-81ee5109.js", "pages/award/layout.svelte-f64d747c.js", "chunks/BackTo-b08a8f3c.js", "chunks/store-ee9a40c3.js"], "styles": [] }, "src/routes/award/layout.svelte": { "entry": "pages/award/layout.svelte-f64d747c.js", "css": ["assets/pages/award/layout.svelte-6c103d3e.css", "assets/BackTo-5846cd5f.css"], "js": ["pages/award/layout.svelte-f64d747c.js", "chunks/vendor-81ee5109.js", "chunks/BackTo-b08a8f3c.js", "chunks/store-ee9a40c3.js"], "styles": [] }, "src/routes/post/index.svelte": { "entry": "pages/post/index.svelte-7cb86739.js", "css": ["assets/pages/post/index.svelte-2e807e5a.css", "assets/Star-4c3ba909.css"], "js": ["pages/post/index.svelte-7cb86739.js", "chunks/vendor-81ee5109.js", "chunks/utils-4d01bc61.js", "chunks/Star-877e0b10.js", "chunks/Main-3473b253.js", "chunks/store-ee9a40c3.js"], "styles": [] }, "src/routes/post/economist-table-replication-using-reactable.md": { "entry": "pages/post/economist-table-replication-using-reactable.md-2e25f329.js", "css": ["assets/Info.svelte_svelte&type=style&lang-2342adb2.css", "assets/Image.svelte_svelte&type=style&lang-8c589ec5.css", "assets/pages/post/layout.svelte-37d91a64.css", "assets/BackTo-5846cd5f.css"], "js": ["pages/post/economist-table-replication-using-reactable.md-2e25f329.js", "chunks/vendor-81ee5109.js", "pages/post/layout.svelte-733d38d1.js", "chunks/BackTo-b08a8f3c.js", "chunks/Content-9a197927.js", "chunks/store-ee9a40c3.js", "chunks/utils-4d01bc61.js", "chunks/Image-2267b2be.js"], "styles": [] }, "src/routes/post/adding-a-chart-to-your-d3-tooltip.md": { "entry": "pages/post/adding-a-chart-to-your-d3-tooltip.md-1b264748.js", "css": ["assets/pages/post/adding-a-chart-to-your-d3-tooltip.md-9f005a9a.css", "assets/Image.svelte_svelte&type=style&lang-8c589ec5.css", "assets/Info.svelte_svelte&type=style&lang-2342adb2.css", "assets/pages/post/layout.svelte-37d91a64.css", "assets/BackTo-5846cd5f.css", "assets/Code-456317d4.css"], "js": ["pages/post/adding-a-chart-to-your-d3-tooltip.md-1b264748.js", "chunks/vendor-81ee5109.js", "pages/post/layout.svelte-733d38d1.js", "chunks/BackTo-b08a8f3c.js", "chunks/Content-9a197927.js", "chunks/store-ee9a40c3.js", "chunks/utils-4d01bc61.js", "chunks/Image-2267b2be.js", "chunks/Code-eeafe5e5.js", "chunks/Info-1133a14c.js"], "styles": [] }, "src/routes/post/tidy-tuesday-powerlifting.md": { "entry": "pages/post/tidy-tuesday-powerlifting.md-a6a2bc6b.js", "css": ["assets/Info.svelte_svelte&type=style&lang-2342adb2.css", "assets/Image.svelte_svelte&type=style&lang-8c589ec5.css", "assets/pages/post/layout.svelte-37d91a64.css", "assets/BackTo-5846cd5f.css"], "js": ["pages/post/tidy-tuesday-powerlifting.md-a6a2bc6b.js", "chunks/vendor-81ee5109.js", "pages/post/layout.svelte-733d38d1.js", "chunks/BackTo-b08a8f3c.js", "chunks/Content-9a197927.js", "chunks/store-ee9a40c3.js", "chunks/utils-4d01bc61.js", "chunks/Image-2267b2be.js"], "styles": [] }, "src/routes/post/tidy-tuesday-replication.md": { "entry": "pages/post/tidy-tuesday-replication.md-74fee5e1.js", "css": ["assets/Info.svelte_svelte&type=style&lang-2342adb2.css", "assets/Image.svelte_svelte&type=style&lang-8c589ec5.css", "assets/pages/post/layout.svelte-37d91a64.css", "assets/BackTo-5846cd5f.css"], "js": ["pages/post/tidy-tuesday-replication.md-74fee5e1.js", "chunks/vendor-81ee5109.js", "pages/post/layout.svelte-733d38d1.js", "chunks/BackTo-b08a8f3c.js", "chunks/Content-9a197927.js", "chunks/store-ee9a40c3.js", "chunks/utils-4d01bc61.js", "chunks/Image-2267b2be.js"], "styles": [] }, "src/routes/post/automation-scrollytell.md": { "entry": "pages/post/automation-scrollytell.md-b19e9393.js", "css": ["assets/Image.svelte_svelte&type=style&lang-8c589ec5.css", "assets/Info.svelte_svelte&type=style&lang-2342adb2.css", "assets/pages/post/layout.svelte-37d91a64.css", "assets/BackTo-5846cd5f.css"], "js": ["pages/post/automation-scrollytell.md-b19e9393.js", "chunks/vendor-81ee5109.js", "pages/post/layout.svelte-733d38d1.js", "chunks/BackTo-b08a8f3c.js", "chunks/Content-9a197927.js", "chunks/store-ee9a40c3.js", "chunks/utils-4d01bc61.js"], "styles": [] }, "src/routes/post/animate-hugo-academic.md": { "entry": "pages/post/animate-hugo-academic.md-35a60547.js", "css": ["assets/Image.svelte_svelte&type=style&lang-8c589ec5.css", "assets/Info.svelte_svelte&type=style&lang-2342adb2.css", "assets/pages/post/layout.svelte-37d91a64.css", "assets/BackTo-5846cd5f.css", "assets/Code-456317d4.css"], "js": ["pages/post/animate-hugo-academic.md-35a60547.js", "chunks/vendor-81ee5109.js", "pages/post/layout.svelte-733d38d1.js", "chunks/BackTo-b08a8f3c.js", "chunks/Content-9a197927.js", "chunks/store-ee9a40c3.js", "chunks/utils-4d01bc61.js", "chunks/Image-2267b2be.js", "chunks/Code-eeafe5e5.js", "chunks/Info-1133a14c.js"], "styles": [] }, "src/routes/post/introducing-tpltheme.md": { "entry": "pages/post/introducing-tpltheme.md-84281c48.js", "css": ["assets/Info.svelte_svelte&type=style&lang-2342adb2.css", "assets/Image.svelte_svelte&type=style&lang-8c589ec5.css", "assets/pages/post/layout.svelte-37d91a64.css", "assets/BackTo-5846cd5f.css"], "js": ["pages/post/introducing-tpltheme.md-84281c48.js", "chunks/vendor-81ee5109.js", "pages/post/layout.svelte-733d38d1.js", "chunks/BackTo-b08a8f3c.js", "chunks/Content-9a197927.js", "chunks/store-ee9a40c3.js", "chunks/utils-4d01bc61.js", "chunks/Image-2267b2be.js"], "styles": [] }, "src/routes/post/color-in-data-vis.md": { "entry": "pages/post/color-in-data-vis.md-0d7c265f.js", "css": ["assets/Info.svelte_svelte&type=style&lang-2342adb2.css", "assets/Image.svelte_svelte&type=style&lang-8c589ec5.css", "assets/pages/post/layout.svelte-37d91a64.css", "assets/BackTo-5846cd5f.css"], "js": ["pages/post/color-in-data-vis.md-0d7c265f.js", "chunks/vendor-81ee5109.js", "pages/post/layout.svelte-733d38d1.js", "chunks/BackTo-b08a8f3c.js", "chunks/Content-9a197927.js", "chunks/store-ee9a40c3.js", "chunks/utils-4d01bc61.js", "chunks/Image-2267b2be.js"], "styles": [] }, "src/routes/post/do-something-else.md": { "entry": "pages/post/do-something-else.md-ebd849f0.js", "css": ["assets/Image.svelte_svelte&type=style&lang-8c589ec5.css", "assets/Info.svelte_svelte&type=style&lang-2342adb2.css", "assets/pages/post/layout.svelte-37d91a64.css", "assets/BackTo-5846cd5f.css"], "js": ["pages/post/do-something-else.md-ebd849f0.js", "chunks/vendor-81ee5109.js", "pages/post/layout.svelte-733d38d1.js", "chunks/BackTo-b08a8f3c.js", "chunks/Content-9a197927.js", "chunks/store-ee9a40c3.js", "chunks/utils-4d01bc61.js", "chunks/Image-2267b2be.js", "chunks/Info-1133a14c.js"], "styles": [] }, "src/routes/post/nuxt-blog-starter.md": { "entry": "pages/post/nuxt-blog-starter.md-5beacb28.js", "css": ["assets/Image.svelte_svelte&type=style&lang-8c589ec5.css", "assets/Info.svelte_svelte&type=style&lang-2342adb2.css", "assets/pages/post/layout.svelte-37d91a64.css", "assets/BackTo-5846cd5f.css", "assets/Code-456317d4.css"], "js": ["pages/post/nuxt-blog-starter.md-5beacb28.js", "chunks/vendor-81ee5109.js", "pages/post/layout.svelte-733d38d1.js", "chunks/BackTo-b08a8f3c.js", "chunks/Content-9a197927.js", "chunks/store-ee9a40c3.js", "chunks/utils-4d01bc61.js", "chunks/Image-2267b2be.js", "chunks/Info-1133a14c.js", "chunks/Code-eeafe5e5.js"], "styles": [] }, "src/routes/post/covid-gun-spikes.md": { "entry": "pages/post/covid-gun-spikes.md-b8c038b0.js", "css": ["assets/Info.svelte_svelte&type=style&lang-2342adb2.css", "assets/Image.svelte_svelte&type=style&lang-8c589ec5.css", "assets/pages/post/layout.svelte-37d91a64.css", "assets/BackTo-5846cd5f.css", "assets/TableHandler-cb54b39c.css", "assets/Code-456317d4.css"], "js": ["pages/post/covid-gun-spikes.md-b8c038b0.js", "chunks/vendor-81ee5109.js", "pages/post/layout.svelte-733d38d1.js", "chunks/BackTo-b08a8f3c.js", "chunks/Content-9a197927.js", "chunks/store-ee9a40c3.js", "chunks/utils-4d01bc61.js", "chunks/Image-2267b2be.js", "chunks/TableHandler-18b60a86.js", "chunks/Code-eeafe5e5.js"], "styles": [] }, "src/routes/post/covid-on-campus.md": { "entry": "pages/post/covid-on-campus.md-eaa65b35.js", "css": ["assets/Info.svelte_svelte&type=style&lang-2342adb2.css", "assets/Image.svelte_svelte&type=style&lang-8c589ec5.css", "assets/pages/post/layout.svelte-37d91a64.css", "assets/BackTo-5846cd5f.css", "assets/TableHandler-cb54b39c.css"], "js": ["pages/post/covid-on-campus.md-eaa65b35.js", "chunks/vendor-81ee5109.js", "pages/post/layout.svelte-733d38d1.js", "chunks/BackTo-b08a8f3c.js", "chunks/Content-9a197927.js", "chunks/store-ee9a40c3.js", "chunks/utils-4d01bc61.js", "chunks/Image-2267b2be.js", "chunks/TableHandler-18b60a86.js"], "styles": [] }, "src/routes/post/map-springfield.md": { "entry": "pages/post/map-springfield.md-b718f25e.js", "css": ["assets/Info.svelte_svelte&type=style&lang-2342adb2.css", "assets/Image.svelte_svelte&type=style&lang-8c589ec5.css", "assets/pages/post/layout.svelte-37d91a64.css", "assets/BackTo-5846cd5f.css"], "js": ["pages/post/map-springfield.md-b718f25e.js", "chunks/vendor-81ee5109.js", "pages/post/layout.svelte-733d38d1.js", "chunks/BackTo-b08a8f3c.js", "chunks/Content-9a197927.js", "chunks/store-ee9a40c3.js", "chunks/utils-4d01bc61.js", "chunks/Image-2267b2be.js"], "styles": [] }, "src/routes/post/dumbbell-plots.md": { "entry": "pages/post/dumbbell-plots.md-b85b2a0c.js", "css": ["assets/Info.svelte_svelte&type=style&lang-2342adb2.css", "assets/Image.svelte_svelte&type=style&lang-8c589ec5.css", "assets/pages/post/layout.svelte-37d91a64.css", "assets/BackTo-5846cd5f.css"], "js": ["pages/post/dumbbell-plots.md-b85b2a0c.js", "chunks/vendor-81ee5109.js", "pages/post/layout.svelte-733d38d1.js", "chunks/BackTo-b08a8f3c.js", "chunks/Content-9a197927.js", "chunks/store-ee9a40c3.js", "chunks/utils-4d01bc61.js", "chunks/Image-2267b2be.js"], "styles": [] }, "src/routes/post/refugee-trends.md": { "entry": "pages/post/refugee-trends.md-cb67f277.js", "css": ["assets/Info.svelte_svelte&type=style&lang-2342adb2.css", "assets/Image.svelte_svelte&type=style&lang-8c589ec5.css", "assets/pages/post/layout.svelte-37d91a64.css", "assets/BackTo-5846cd5f.css"], "js": ["pages/post/refugee-trends.md-cb67f277.js", "chunks/vendor-81ee5109.js", "pages/post/layout.svelte-733d38d1.js", "chunks/BackTo-b08a8f3c.js", "chunks/Content-9a197927.js", "chunks/store-ee9a40c3.js", "chunks/utils-4d01bc61.js", "chunks/Image-2267b2be.js"], "styles": [] }, "src/routes/post/svelte-scatter.md": { "entry": "pages/post/svelte-scatter.md-c734bdbd.js", "css": ["assets/Image.svelte_svelte&type=style&lang-8c589ec5.css", "assets/Info.svelte_svelte&type=style&lang-2342adb2.css", "assets/pages/post/layout.svelte-37d91a64.css", "assets/BackTo-5846cd5f.css"], "js": ["pages/post/svelte-scatter.md-c734bdbd.js", "chunks/vendor-81ee5109.js", "pages/post/layout.svelte-733d38d1.js", "chunks/BackTo-b08a8f3c.js", "chunks/Content-9a197927.js", "chunks/store-ee9a40c3.js", "chunks/utils-4d01bc61.js", "chunks/Info-1133a14c.js"], "styles": [] }, "src/routes/post/svelte-and-d3.md": { "entry": "pages/post/svelte-and-d3.md-d2bd4b26.js", "css": ["assets/pages/post/svelte-and-d3.md-5943aba9.css", "assets/Image.svelte_svelte&type=style&lang-8c589ec5.css", "assets/Info.svelte_svelte&type=style&lang-2342adb2.css", "assets/pages/post/layout.svelte-37d91a64.css", "assets/BackTo-5846cd5f.css", "assets/Code-456317d4.css"], "js": ["pages/post/svelte-and-d3.md-d2bd4b26.js", "chunks/vendor-81ee5109.js", "pages/post/layout.svelte-733d38d1.js", "chunks/BackTo-b08a8f3c.js", "chunks/Content-9a197927.js", "chunks/store-ee9a40c3.js", "chunks/utils-4d01bc61.js", "chunks/Code-eeafe5e5.js", "chunks/Info-1133a14c.js"], "styles": [] }, "src/routes/post/covid-posts.md": { "entry": "pages/post/covid-posts.md-35946e37.js", "css": ["assets/Info.svelte_svelte&type=style&lang-2342adb2.css", "assets/Image.svelte_svelte&type=style&lang-8c589ec5.css", "assets/pages/post/layout.svelte-37d91a64.css", "assets/BackTo-5846cd5f.css"], "js": ["pages/post/covid-posts.md-35946e37.js", "chunks/vendor-81ee5109.js", "pages/post/layout.svelte-733d38d1.js", "chunks/BackTo-b08a8f3c.js", "chunks/Content-9a197927.js", "chunks/store-ee9a40c3.js", "chunks/utils-4d01bc61.js", "chunks/Image-2267b2be.js"], "styles": [] }, "src/routes/post/flat-data-r.md": { "entry": "pages/post/flat-data-r.md-16661892.js", "css": ["assets/Image.svelte_svelte&type=style&lang-8c589ec5.css", "assets/Info.svelte_svelte&type=style&lang-2342adb2.css", "assets/pages/post/layout.svelte-37d91a64.css", "assets/BackTo-5846cd5f.css", "assets/Code-456317d4.css"], "js": ["pages/post/flat-data-r.md-16661892.js", "chunks/vendor-81ee5109.js", "pages/post/layout.svelte-733d38d1.js", "chunks/BackTo-b08a8f3c.js", "chunks/Content-9a197927.js", "chunks/store-ee9a40c3.js", "chunks/utils-4d01bc61.js", "chunks/Code-eeafe5e5.js", "chunks/Image-2267b2be.js", "chunks/Info-1133a14c.js"], "styles": [] }, "src/routes/post/layout.svelte": { "entry": "pages/post/layout.svelte-733d38d1.js", "css": ["assets/pages/post/layout.svelte-37d91a64.css", "assets/BackTo-5846cd5f.css"], "js": ["pages/post/layout.svelte-733d38d1.js", "chunks/vendor-81ee5109.js", "chunks/BackTo-b08a8f3c.js", "chunks/Content-9a197927.js", "chunks/store-ee9a40c3.js", "chunks/utils-4d01bc61.js"], "styles": [] } };
async function load_component(file) {
  const { entry, css: css2, js, styles } = metadata_lookup[file];
  return {
    module: await module_lookup[file](),
    entry: assets + "/_app/" + entry,
    css: css2.map((dep) => assets + "/_app/" + dep),
    js: js.map((dep) => assets + "/_app/" + dep),
    styles
  };
}
function render(request, {
  prerender
} = {}) {
  const host = request.headers["host"];
  return respond({ ...request, host }, options, { prerender });
}
async function get$3() {
  const imports = { "./experience/axios.md": () => Promise.resolve().then(function() {
    return axios;
  }), "./experience/moksha.md": () => Promise.resolve().then(function() {
    return moksha;
  }), "./experience/socom.md": () => Promise.resolve().then(function() {
    return socom;
  }), "./experience/tpl.md": () => Promise.resolve().then(function() {
    return tpl;
  }) };
  let body = [];
  for (const path in imports) {
    body.push(imports[path]().then(({ metadata: metadata2 }) => {
      return {
        metadata: metadata2,
        path
      };
    }));
  }
  const posts = await Promise.all(body);
  return {
    body: JSON.stringify(posts)
  };
}
var experience_json = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  get: get$3
});
async function get$2() {
  const imports = { "./project/atus.md": () => Promise.resolve().then(function() {
    return atus;
  }), "./project/bob-ross-art-gallery.md": () => Promise.resolve().then(function() {
    return bobRossArtGallery;
  }), "./project/compas.md": () => Promise.resolve().then(function() {
    return compas;
  }), "./project/covid-masking.md": () => Promise.resolve().then(function() {
    return covidMasking;
  }), "./project/cudi-hums.md": () => Promise.resolve().then(function() {
    return cudiHums;
  }), "./project/how-many-people.md": () => Promise.resolve().then(function() {
    return howManyPeople;
  }), "./project/map-houston-homicides.md": () => Promise.resolve().then(function() {
    return mapHoustonHomicides;
  }), "./project/map-missing-migrants.md": () => Promise.resolve().then(function() {
    return mapMissingMigrants;
  }), "./project/media-mentions.md": () => Promise.resolve().then(function() {
    return mediaMentions;
  }), "./project/one-line-hacks.md": () => Promise.resolve().then(function() {
    return oneLineHacks;
  }), "./project/police-killings.md": () => Promise.resolve().then(function() {
    return policeKillings;
  }), "./project/quarantunes.md": () => Promise.resolve().then(function() {
    return quarantunes;
  }), "./project/state-police-spending.md": () => Promise.resolve().then(function() {
    return statePoliceSpending;
  }), "./project/tpl-schools-db.md": () => Promise.resolve().then(function() {
    return tplSchoolsDb;
  }) };
  let body = [];
  for (const path in imports) {
    body.push(imports[path]().then(({ metadata: metadata2 }) => {
      return {
        metadata: metadata2,
        path
      };
    }));
  }
  const projects = await Promise.all(body);
  return {
    body: JSON.stringify(projects)
  };
}
var projects_json = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  get: get$2
});
async function get$1() {
  const imports = { "./award/bipp-2018.md": () => Promise.resolve().then(function() {
    return bipp2018;
  }), "./award/chrp-2020.md": () => Promise.resolve().then(function() {
    return chrp2020;
  }), "./award/d2k-showcase-2020.md": () => Promise.resolve().then(function() {
    return d2kShowcase2020;
  }), "./award/datathon-2020.md": () => Promise.resolve().then(function() {
    return datathon2020;
  }), "./award/hpc-2018.md": () => Promise.resolve().then(function() {
    return hpc2018;
  }), "./award/hpc-2019.md": () => Promise.resolve().then(function() {
    return hpc2019;
  }), "./award/hpc-2020.md": () => Promise.resolve().then(function() {
    return hpc2020;
  }), "./award/hudspeth-2020.md": () => Promise.resolve().then(function() {
    return hudspeth2020;
  }), "./award/malofiej-2020.md": () => Promise.resolve().then(function() {
    return malofiej2020;
  }), "./award/malofiej-2021.md": () => Promise.resolve().then(function() {
    return malofiej2021;
  }), "./award/nationals-2017.md": () => Promise.resolve().then(function() {
    return nationals2017;
  }), "./award/northeastern-2020.md": () => Promise.resolve().then(function() {
    return northeastern2020;
  }), "./award/pudding-cup-2020.md": () => Promise.resolve().then(function() {
    return puddingCup2020;
  }), "./award/rstudio-table-contest-2021.md": () => Promise.resolve().then(function() {
    return rstudioTableContest2021;
  }), "./award/snd-2021.md": () => Promise.resolve().then(function() {
    return snd2021;
  }) };
  let body = [];
  for (const path in imports) {
    body.push(imports[path]().then(({ metadata: metadata2 }) => {
      return {
        metadata: metadata2,
        path
      };
    }));
  }
  const awards = await Promise.all(body);
  return {
    body: JSON.stringify(awards)
  };
}
var awards_json = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  get: get$1
});
async function get() {
  const imports = { "./post/adding-a-chart-to-your-d3-tooltip.md": () => Promise.resolve().then(function() {
    return addingAChartToYourD3Tooltip;
  }), "./post/animate-hugo-academic.md": () => Promise.resolve().then(function() {
    return animateHugoAcademic;
  }), "./post/automation-scrollytell.md": () => Promise.resolve().then(function() {
    return automationScrollytell;
  }), "./post/color-in-data-vis.md": () => Promise.resolve().then(function() {
    return colorInDataVis;
  }), "./post/covid-gun-spikes.md": () => Promise.resolve().then(function() {
    return covidGunSpikes;
  }), "./post/covid-on-campus.md": () => Promise.resolve().then(function() {
    return covidOnCampus;
  }), "./post/covid-posts.md": () => Promise.resolve().then(function() {
    return covidPosts;
  }), "./post/do-something-else.md": () => Promise.resolve().then(function() {
    return doSomethingElse;
  }), "./post/dumbbell-plots.md": () => Promise.resolve().then(function() {
    return dumbbellPlots;
  }), "./post/economist-table-replication-using-reactable.md": () => Promise.resolve().then(function() {
    return economistTableReplicationUsingReactable;
  }), "./post/flat-data-r.md": () => Promise.resolve().then(function() {
    return flatDataR;
  }), "./post/introducing-tpltheme.md": () => Promise.resolve().then(function() {
    return introducingTpltheme;
  }), "./post/map-springfield.md": () => Promise.resolve().then(function() {
    return mapSpringfield;
  }), "./post/nuxt-blog-starter.md": () => Promise.resolve().then(function() {
    return nuxtBlogStarter;
  }), "./post/refugee-trends.md": () => Promise.resolve().then(function() {
    return refugeeTrends;
  }), "./post/svelte-and-d3.md": () => Promise.resolve().then(function() {
    return svelteAndD3;
  }), "./post/svelte-scatter.md": () => Promise.resolve().then(function() {
    return svelteScatter;
  }), "./post/tidy-tuesday-powerlifting.md": () => Promise.resolve().then(function() {
    return tidyTuesdayPowerlifting;
  }), "./post/tidy-tuesday-replication.md": () => Promise.resolve().then(function() {
    return tidyTuesdayReplication;
  }) };
  let body = [];
  for (const path in imports) {
    body.push(imports[path]().then(({ metadata: metadata2 }) => {
      return {
        metadata: metadata2,
        path
      };
    }));
  }
  const posts = await Promise.all(body);
  return {
    body: JSON.stringify(posts)
  };
}
var posts_json = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  get
});
var subscriber_queue = [];
function writable(value, start = noop) {
  let stop;
  const subscribers = new Set();
  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update(fn) {
    set(fn(value));
  }
  function subscribe2(run2, invalidate = noop) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set) || noop;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update, subscribe: subscribe2 };
}
var seo = writable({
  title: "Connor Rothschild",
  description: "I tell visual stories on the web."
});
var Seo = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $seo, $$unsubscribe_seo;
  $$unsubscribe_seo = subscribe(seo, (value) => $seo = value);
  $$unsubscribe_seo();
  return `${$$result.head += `${$$result.title = `<title>${escape($seo.title)}</title>`, ""}<meta name="${"description"}"${add_attribute("content", $seo.description, 0)} data-svelte="svelte-1w5w2bj">`, ""}`;
});
var getStores = () => {
  const stores = getContext("__svelte__");
  return {
    page: {
      subscribe: stores.page.subscribe
    },
    navigating: {
      subscribe: stores.navigating.subscribe
    },
    get preloading() {
      console.error("stores.preloading is deprecated; use stores.navigating instead");
      return {
        subscribe: stores.navigating.subscribe
      };
    },
    session: stores.session
  };
};
var page = {
  subscribe(fn) {
    const store = getStores().page;
    return store.subscribe(fn);
  }
};
var currentIcon = writable("");
var css$o = {
  code: "li.svelte-ayox18{display:inline-block;padding:0;margin:0}a.svelte-ayox18{color:var(--text-color);font-family:var(--font-serif);text-transform:uppercase}.current.svelte-ayox18{color:var(--accent-color);border-bottom:2px solid var(--accent-color)}.current.svelte-ayox18:hover{text-decoration:none}@media screen and (max-width: 560px){li.svelte-ayox18{font-size:2.5vw;margin-right:2vw}}@media screen and (max-width: 460px){li.svelte-ayox18{font-size:3.5vw;margin-right:3vw}}",
  map: '{"version":3,"file":"NavListItem.svelte","sources":["NavListItem.svelte"],"sourcesContent":["<script>\\n  export let code;\\n  export let title;\\n\\n  import { page } from \\"$app/stores\\";\\n  import { currentIcon } from \\"../stores/global.js\\";\\n\\n  let hoveredIcon;\\n  const setCurrent = function (icon) {\\n    hoveredIcon = icon == \\"\\" ? \\"home\\" : icon;\\n    currentIcon.set(hoveredIcon);\\n  };\\n<\/script>\\n\\n<li>\\n  <a\\n    on:mouseover={() => {\\n      setCurrent(code);\\n    }}\\n    on:focus={() => {\\n      setCurrent(code);\\n    }}\\n    on:click={() => {\\n      setCurrent(code);\\n    }}\\n    on:mouseleave={() => {\\n      setCurrent(null);\\n    }}\\n    sveltekit:prefetch\\n    href=\\"/{code}\\"\\n    class={$page.path.replace(/^\\\\/([^\\\\/]*).*$/, \\"$1\\") == `${code}`\\n      ? \\"current\\"\\n      : \\"\\"}>{title}</a\\n  >\\n</li>\\n\\n<style>\\n  li {\\n    display: inline-block;\\n    padding: 0;\\n    margin: 0;\\n  }\\n\\n  a {\\n    color: var(--text-color);\\n    font-family: var(--font-serif);\\n    text-transform: uppercase;\\n  }\\n\\n  .current {\\n    color: var(--accent-color);\\n    border-bottom: 2px solid var(--accent-color);\\n  }\\n\\n  .current:hover {\\n    text-decoration: none;\\n  }\\n\\n  @media screen and (max-width: 560px) {\\n    li {\\n      font-size: 2.5vw;\\n      margin-right: 2vw;\\n    }\\n  }\\n\\n  @media screen and (max-width: 460px) {\\n    li {\\n      font-size: 3.5vw;\\n      margin-right: 3vw;\\n    }\\n  }\\n</style>\\n"],"names":[],"mappings":"AAqCE,EAAE,cAAC,CAAC,AACF,OAAO,CAAE,YAAY,CACrB,OAAO,CAAE,CAAC,CACV,MAAM,CAAE,CAAC,AACX,CAAC,AAED,CAAC,cAAC,CAAC,AACD,KAAK,CAAE,IAAI,YAAY,CAAC,CACxB,WAAW,CAAE,IAAI,YAAY,CAAC,CAC9B,cAAc,CAAE,SAAS,AAC3B,CAAC,AAED,QAAQ,cAAC,CAAC,AACR,KAAK,CAAE,IAAI,cAAc,CAAC,CAC1B,aAAa,CAAE,GAAG,CAAC,KAAK,CAAC,IAAI,cAAc,CAAC,AAC9C,CAAC,AAED,sBAAQ,MAAM,AAAC,CAAC,AACd,eAAe,CAAE,IAAI,AACvB,CAAC,AAED,OAAO,MAAM,CAAC,GAAG,CAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AACpC,EAAE,cAAC,CAAC,AACF,SAAS,CAAE,KAAK,CAChB,YAAY,CAAE,GAAG,AACnB,CAAC,AACH,CAAC,AAED,OAAO,MAAM,CAAC,GAAG,CAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AACpC,EAAE,cAAC,CAAC,AACF,SAAS,CAAE,KAAK,CAChB,YAAY,CAAE,GAAG,AACnB,CAAC,AACH,CAAC"}'
};
var NavListItem = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $page, $$unsubscribe_page;
  $$unsubscribe_page = subscribe(page, (value) => $page = value);
  let { code: code2 } = $$props;
  let { title } = $$props;
  if ($$props.code === void 0 && $$bindings.code && code2 !== void 0)
    $$bindings.code(code2);
  if ($$props.title === void 0 && $$bindings.title && title !== void 0)
    $$bindings.title(title);
  $$result.css.add(css$o);
  $$unsubscribe_page();
  return `<li class="${"svelte-ayox18"}"><a sveltekit:prefetch href="${"/" + escape(code2)}" class="${escape(null_to_empty($page.path.replace(/^\/([^\/]*).*$/, "$1") == `${code2}` ? "current" : "")) + " svelte-ayox18"}">${escape(title)}</a>
</li>`;
});
var css$n = {
  code: "ul.svelte-gpm800{width:90%;max-width:768px;margin:0 auto;padding:1em;list-style-type:none;display:flex;justify-content:space-evenly}@media screen and (max-width: 560px){ul.svelte-gpm800{width:85%;margin:auto 0;padding:1em;list-style-type:none;display:flex;margin-right:auto}}",
  map: '{"version":3,"file":"Nav.svelte","sources":["Nav.svelte"],"sourcesContent":["<script>\\n  import NavListItem from \\"./NavListItem.svelte\\";\\n<\/script>\\n\\n<ul id=\\"nav\\">\\n  <NavListItem code={\\"\\"} title={\\"Home\\"} />\\n  <NavListItem code={\\"experience\\"} title={\\"Work\\"} />\\n  <NavListItem code={\\"project\\"} title={\\"Projects\\"} />\\n  <NavListItem code={\\"award\\"} title={\\"Awards\\"} />\\n  <NavListItem code={\\"post\\"} title={\\"Blog\\"} />\\n</ul>\\n\\n<style>\\n  ul {\\n    width: 90%;\\n    max-width: 768px;\\n    margin: 0 auto;\\n    padding: 1em;\\n    list-style-type: none;\\n    display: flex;\\n    justify-content: space-evenly;\\n  }\\n\\n  @media screen and (max-width: 560px) {\\n    ul {\\n      width: 85%;\\n      margin: auto 0;\\n      padding: 1em;\\n      list-style-type: none;\\n      display: flex;\\n      margin-right: auto;\\n    }\\n  }\\n</style>\\n"],"names":[],"mappings":"AAaE,EAAE,cAAC,CAAC,AACF,KAAK,CAAE,GAAG,CACV,SAAS,CAAE,KAAK,CAChB,MAAM,CAAE,CAAC,CAAC,IAAI,CACd,OAAO,CAAE,GAAG,CACZ,eAAe,CAAE,IAAI,CACrB,OAAO,CAAE,IAAI,CACb,eAAe,CAAE,YAAY,AAC/B,CAAC,AAED,OAAO,MAAM,CAAC,GAAG,CAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AACpC,EAAE,cAAC,CAAC,AACF,KAAK,CAAE,GAAG,CACV,MAAM,CAAE,IAAI,CAAC,CAAC,CACd,OAAO,CAAE,GAAG,CACZ,eAAe,CAAE,IAAI,CACrB,OAAO,CAAE,IAAI,CACb,YAAY,CAAE,IAAI,AACpB,CAAC,AACH,CAAC"}'
};
var Nav = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  $$result.css.add(css$n);
  return `<ul id="${"nav"}" class="${"svelte-gpm800"}">${validate_component(NavListItem, "NavListItem").$$render($$result, { code: "", title: "Home" }, {}, {})}
  ${validate_component(NavListItem, "NavListItem").$$render($$result, { code: "experience", title: "Work" }, {}, {})}
  ${validate_component(NavListItem, "NavListItem").$$render($$result, { code: "project", title: "Projects" }, {}, {})}
  ${validate_component(NavListItem, "NavListItem").$$render($$result, { code: "award", title: "Awards" }, {}, {})}
  ${validate_component(NavListItem, "NavListItem").$$render($$result, { code: "post", title: "Blog" }, {}, {})}
</ul>`;
});
var css$m = {
  code: "svg.svelte-1xqyyzc{position:fixed;top:0;right:0;height:60px;width:60px;stroke:var(--primary-color);fill:rgba(var(--accent-color-rgb), 0.9);stroke-width:1px}@media screen and (max-width: 560px){svg.svelte-1xqyyzc{height:40px;width:40px;padding-top:6px}}",
  map: '{"version":3,"file":"HoveredSvg.svelte","sources":["HoveredSvg.svelte"],"sourcesContent":["<script>\\n  import { gsap } from \\"gsap\\";\\n  import { MorphSVGPlugin } from \\"gsap/dist/MorphSVGPlugin.js\\";\\n\\n  import { onMount } from \\"svelte\\";\\n  import { currentIcon } from \\"../stores/global.js\\";\\n\\n  gsap.registerPlugin(MorphSVGPlugin);\\n\\n  import { page } from \\"$app/stores\\";\\n\\n  $: currentSlug = $page.path.replace(/^\\\\/([^\\\\/]*).*$/, \\"$1\\");\\n  $: activePage = currentSlug == \\"\\" ? \\"home\\" : currentSlug;\\n\\n  const paths = {\\n    post: \\"M71.35,28.66a9.07,9.07,0,0,0-12.83,0l-.52.51L56.85,28a6.87,6.87,0,0,0-9.7,0l-8.56,8.57A2,2,0,0,0,40,40a2,2,0,0,0,1.42-.59L50,30.85a2.88,2.88,0,0,1,4.05,0L55.17,32,44.59,42.58h0l-16,16A2,2,0,0,0,28,59.67l-2,12a2,2,0,0,0,.56,1.74A2,2,0,0,0,28,74a1.84,1.84,0,0,0,.33,0l12-2a2,2,0,0,0,1.09-.56L71.35,41.49A9.1,9.1,0,0,0,71.35,28.66ZM39,68.13l-8.6,1.44L31.87,61,46,46.83,53.17,54ZM68.52,38.66,56,51.17,48.83,44,61.35,31.49a5.18,5.18,0,0,1,7.17,0A5.09,5.09,0,0,1,68.52,38.66Z\\",\\n    project:\\n      \\"M28,72H64a2,2,0,0,0,1.9-1.37l8-24A2,2,0,0,0,72,44H66V38a4,4,0,0,0-4-4H49.14L45.8,28.9a2,2,0,0,0-1.67-.9H30a4,4,0,0,0-4,4V70A2,2,0,0,0,28,72ZM69.23,48,62.56,68H34.77l6.67-20ZM30,32h13l3.34,5.1a2,2,0,0,0,1.67.9H62v6H40a2,2,0,0,0-1.9,1.37L30.56,68H30Z\\",\\n    home: \\"M50,26A24,24,0,1,0,74,50,24,24,0,0,0,50,26ZM40,67.29V66a10,10,0,0,1,20,0v1.29a19.81,19.81,0,0,1-20,0ZM44,46a6,6,0,1,1,6,6A6,6,0,0,1,44,46ZM63.89,64.35a14,14,0,0,0-7.45-10.77A9.91,9.91,0,0,0,60,46a10,10,0,0,0-20,0,9.91,9.91,0,0,0,3.56,7.58,14,14,0,0,0-7.45,10.77,20,20,0,1,1,27.78,0Z\\",\\n    award:\\n      \\"M63.7,55.06l10-16a2,2,0,0,0,.16-1.8l-4-10A2,2,0,0,0,68.16,26c-.1,0-.2,0-.3,0l-.12,0H31.94a.34.34,0,0,0-.1,0,2,2,0,0,0-.59.14l-.11.06a2.17,2.17,0,0,0-.47.32.8.8,0,0,0-.13.13,2,2,0,0,0-.35.51.43.43,0,0,0,0,.07,0,0,0,0,1,0,0l-4,10a2,2,0,0,0,.16,1.8l10,16a2.25,2.25,0,0,0,.44.48,14,14,0,1,0,26.52,0A2.25,2.25,0,0,0,63.7,55.06ZM50,46a13.81,13.81,0,0,0-4.43.73L40.33,38H59.67l-5.24,8.73A13.81,13.81,0,0,0,50,46ZM62.06,34H37.94l-2.41-4H64.47ZM30.23,37.8l2.13-5.31,9.63,16a14.19,14.19,0,0,0-3.15,3ZM50,70A10,10,0,1,1,60,60,10,10,0,0,1,50,70Zm8-21.46,9.63-16,2.13,5.31L61.16,51.58A14.19,14.19,0,0,0,58,48.54Z\\",\\n    experience:\\n      \\"M66,36H60V32a6,6,0,0,0-6-6H46a6,6,0,0,0-6,6v4H34a8,8,0,0,0-8,8V66a8,8,0,0,0,8,8H66a8,8,0,0,0,8-8V44A8,8,0,0,0,66,36ZM44,32a2,2,0,0,1,2-2h8a2,2,0,0,1,2,2v4H44ZM34,40H66a4,4,0,0,1,4,4v8H60V50a2,2,0,0,0-4,0v2H44V50a2,2,0,0,0-4,0v2H30V44A4,4,0,0,1,34,40ZM66,70H34a4,4,0,0,1-4-4V56H40v2a2,2,0,0,0,4,0V56H56v2a2,2,0,0,0,4,0V56H70V66A4,4,0,0,1,66,70Z\\",\\n  };\\n\\n  let container;\\n\\n  onMount(() => {\\n    container = MorphSVGPlugin.convertToPath(\\"#container\\");\\n    changePath(paths[activePage]);\\n  });\\n\\n  const changePath = function (path) {\\n    gsap.to(container, {\\n      duration: 0.3,\\n      morphSVG: path,\\n      delay: 0.05,\\n    });\\n  };\\n\\n  $: changePath($currentIcon ? paths[$currentIcon] : paths[activePage]);\\n<\/script>\\n\\n<a href=\\"#nav\\" class=\\"no-underline\\">\\n  <svg xmlns=\\"http://www.w3.org/2000/svg\\" viewBox=\\"0 0 100 100\\" x=\\"0px\\" y=\\"0px\\"\\n    ><path id=\\"container\\" d={paths[activePage]} />\\n  </svg>\\n</a>\\n\\n<style>\\n  svg {\\n    position: fixed;\\n    top: 0;\\n    right: 0;\\n    height: 60px;\\n    width: 60px;\\n    stroke: var(--primary-color);\\n    fill: rgba(var(--accent-color-rgb), 0.9);\\n    stroke-width: 1px;\\n  }\\n\\n  @media screen and (max-width: 560px) {\\n    svg {\\n      height: 40px;\\n      width: 40px;\\n      padding-top: 6px;\\n    }\\n  }\\n</style>\\n"],"names":[],"mappings":"AAkDE,GAAG,eAAC,CAAC,AACH,QAAQ,CAAE,KAAK,CACf,GAAG,CAAE,CAAC,CACN,KAAK,CAAE,CAAC,CACR,MAAM,CAAE,IAAI,CACZ,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,eAAe,CAAC,CAC5B,IAAI,CAAE,KAAK,IAAI,kBAAkB,CAAC,CAAC,CAAC,GAAG,CAAC,CACxC,YAAY,CAAE,GAAG,AACnB,CAAC,AAED,OAAO,MAAM,CAAC,GAAG,CAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AACpC,GAAG,eAAC,CAAC,AACH,MAAM,CAAE,IAAI,CACZ,KAAK,CAAE,IAAI,CACX,WAAW,CAAE,GAAG,AAClB,CAAC,AACH,CAAC"}'
};
var HoveredSvg = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let currentSlug;
  let activePage;
  let $currentIcon, $$unsubscribe_currentIcon;
  let $page, $$unsubscribe_page;
  $$unsubscribe_currentIcon = subscribe(currentIcon, (value) => $currentIcon = value);
  $$unsubscribe_page = subscribe(page, (value) => $page = value);
  import_gsap.gsap.registerPlugin(import_MorphSVGPlugin.MorphSVGPlugin);
  const paths = {
    post: "M71.35,28.66a9.07,9.07,0,0,0-12.83,0l-.52.51L56.85,28a6.87,6.87,0,0,0-9.7,0l-8.56,8.57A2,2,0,0,0,40,40a2,2,0,0,0,1.42-.59L50,30.85a2.88,2.88,0,0,1,4.05,0L55.17,32,44.59,42.58h0l-16,16A2,2,0,0,0,28,59.67l-2,12a2,2,0,0,0,.56,1.74A2,2,0,0,0,28,74a1.84,1.84,0,0,0,.33,0l12-2a2,2,0,0,0,1.09-.56L71.35,41.49A9.1,9.1,0,0,0,71.35,28.66ZM39,68.13l-8.6,1.44L31.87,61,46,46.83,53.17,54ZM68.52,38.66,56,51.17,48.83,44,61.35,31.49a5.18,5.18,0,0,1,7.17,0A5.09,5.09,0,0,1,68.52,38.66Z",
    project: "M28,72H64a2,2,0,0,0,1.9-1.37l8-24A2,2,0,0,0,72,44H66V38a4,4,0,0,0-4-4H49.14L45.8,28.9a2,2,0,0,0-1.67-.9H30a4,4,0,0,0-4,4V70A2,2,0,0,0,28,72ZM69.23,48,62.56,68H34.77l6.67-20ZM30,32h13l3.34,5.1a2,2,0,0,0,1.67.9H62v6H40a2,2,0,0,0-1.9,1.37L30.56,68H30Z",
    home: "M50,26A24,24,0,1,0,74,50,24,24,0,0,0,50,26ZM40,67.29V66a10,10,0,0,1,20,0v1.29a19.81,19.81,0,0,1-20,0ZM44,46a6,6,0,1,1,6,6A6,6,0,0,1,44,46ZM63.89,64.35a14,14,0,0,0-7.45-10.77A9.91,9.91,0,0,0,60,46a10,10,0,0,0-20,0,9.91,9.91,0,0,0,3.56,7.58,14,14,0,0,0-7.45,10.77,20,20,0,1,1,27.78,0Z",
    award: "M63.7,55.06l10-16a2,2,0,0,0,.16-1.8l-4-10A2,2,0,0,0,68.16,26c-.1,0-.2,0-.3,0l-.12,0H31.94a.34.34,0,0,0-.1,0,2,2,0,0,0-.59.14l-.11.06a2.17,2.17,0,0,0-.47.32.8.8,0,0,0-.13.13,2,2,0,0,0-.35.51.43.43,0,0,0,0,.07,0,0,0,0,1,0,0l-4,10a2,2,0,0,0,.16,1.8l10,16a2.25,2.25,0,0,0,.44.48,14,14,0,1,0,26.52,0A2.25,2.25,0,0,0,63.7,55.06ZM50,46a13.81,13.81,0,0,0-4.43.73L40.33,38H59.67l-5.24,8.73A13.81,13.81,0,0,0,50,46ZM62.06,34H37.94l-2.41-4H64.47ZM30.23,37.8l2.13-5.31,9.63,16a14.19,14.19,0,0,0-3.15,3ZM50,70A10,10,0,1,1,60,60,10,10,0,0,1,50,70Zm8-21.46,9.63-16,2.13,5.31L61.16,51.58A14.19,14.19,0,0,0,58,48.54Z",
    experience: "M66,36H60V32a6,6,0,0,0-6-6H46a6,6,0,0,0-6,6v4H34a8,8,0,0,0-8,8V66a8,8,0,0,0,8,8H66a8,8,0,0,0,8-8V44A8,8,0,0,0,66,36ZM44,32a2,2,0,0,1,2-2h8a2,2,0,0,1,2,2v4H44ZM34,40H66a4,4,0,0,1,4,4v8H60V50a2,2,0,0,0-4,0v2H44V50a2,2,0,0,0-4,0v2H30V44A4,4,0,0,1,34,40ZM66,70H34a4,4,0,0,1-4-4V56H40v2a2,2,0,0,0,4,0V56H56v2a2,2,0,0,0,4,0V56H70V66A4,4,0,0,1,66,70Z"
  };
  let container;
  const changePath = function(path) {
    import_gsap.gsap.to(container, {
      duration: 0.3,
      morphSVG: path,
      delay: 0.05
    });
  };
  $$result.css.add(css$m);
  currentSlug = $page.path.replace(/^\/([^\/]*).*$/, "$1");
  activePage = currentSlug == "" ? "home" : currentSlug;
  {
    changePath($currentIcon ? paths[$currentIcon] : paths[activePage]);
  }
  $$unsubscribe_currentIcon();
  $$unsubscribe_page();
  return `<a href="${"#nav"}" class="${"no-underline"}"><svg xmlns="${"http://www.w3.org/2000/svg"}" viewBox="${"0 0 100 100"}" x="${"0px"}" y="${"0px"}" class="${"svelte-1xqyyzc"}"><path id="${"container"}"${add_attribute("d", paths[activePage], 0)}></path></svg>
</a>`;
});
var _layout = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${validate_component(Seo, "Seo").$$render($$result, {}, {}, {})}
${validate_component(Nav, "Nav").$$render($$result, {}, {}, {})}
${validate_component(HoveredSvg, "HoveredSvg").$$render($$result, {}, {}, {})}
${slots.default ? slots.default({}) : ``}`;
});
var __layout = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": _layout
});
function load$4({ error: error2, status }) {
  console.log(error2);
  return {
    props: {
      title: `${status}: ${error2.message}`,
      errorCode: `${error2.stack}`
    }
  };
}
var _error = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { title } = $$props;
  let { errorCode } = $$props;
  if ($$props.title === void 0 && $$bindings.title && title !== void 0)
    $$bindings.title(title);
  if ($$props.errorCode === void 0 && $$bindings.errorCode && errorCode !== void 0)
    $$bindings.errorCode(errorCode);
  return `<h1>${escape(title)}</h1>

<p>${escape("Show")} the technical details
</p>
${``}`;
});
var __error = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": _error,
  load: load$4
});
function cubicOut(t) {
  const f = t - 1;
  return f * f * f + 1;
}
var css$l = {
  code: "div.svelte-19au29d{display:inline;user-select:none;cursor:pointer;transition:border-bottom 300ms linear}img.svelte-19au29d{vertical-align:middle;margin-bottom:1px;width:32px;height:32px}",
  map: '{"version":3,"file":"Spinner.svelte","sources":["Spinner.svelte"],"sourcesContent":["<script>\\n  import { quintOut } from \\"svelte/easing\\";\\n  import { fade, draw, fly } from \\"svelte/transition\\";\\n  import { cubicOut } from \\"svelte/easing\\";\\n\\n  export function expand(node, params) {\\n    const { delay = 0, duration = 400, easing = cubicOut } = params;\\n\\n    const w = parseFloat(getComputedStyle(node).strokeWidth);\\n\\n    return {\\n      delay,\\n      duration,\\n      easing,\\n      css: (t) => `opacity: ${t}; stroke-width: ${t * w}`,\\n    };\\n  }\\n\\n  export let options;\\n  let index = 0;\\n\\n  function increment() {\\n    let newIndex = index + 1 > options.length - 1 ? 0 : index + 1;\\n    return newIndex;\\n  }\\n\\n  $: currJob = options[index];\\n\\n  let color = {\\n    Axios: \\"#3b6be3\\",\\n    USSOCOM: \\"#BDAE50\\",\\n    \\"Texas Policy Lab\\": \\"#e54e4d\\",\\n  };\\n\\n  let hovered = false;\\n<\/script>\\n\\n<div\\n  style=\\"border-bottom: 4px solid {color[currJob]}\\"\\n  on:click={() => (index = increment())}\\n  on:mouseover={() => (hovered = true)}\\n>\\n  {currJob}\\n  <img src=\\"/images/icons/shuffle.svg\\" alt=\\"Shuffle icon\\" />\\n</div>\\n\\n<style>\\n  div {\\n    display: inline;\\n    user-select: none;\\n    cursor: pointer;\\n    transition: border-bottom 300ms linear;\\n  }\\n\\n  img {\\n    vertical-align: middle;\\n    margin-bottom: 1px;\\n    width: 32px;\\n    height: 32px;\\n  }\\n</style>\\n"],"names":[],"mappings":"AA+CE,GAAG,eAAC,CAAC,AACH,OAAO,CAAE,MAAM,CACf,WAAW,CAAE,IAAI,CACjB,MAAM,CAAE,OAAO,CACf,UAAU,CAAE,aAAa,CAAC,KAAK,CAAC,MAAM,AACxC,CAAC,AAED,GAAG,eAAC,CAAC,AACH,cAAc,CAAE,MAAM,CACtB,aAAa,CAAE,GAAG,CAClB,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,AACd,CAAC"}'
};
var Spinner = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let currJob;
  function expand(node, params) {
    const { delay = 0, duration = 400, easing = cubicOut } = params;
    const w = parseFloat(getComputedStyle(node).strokeWidth);
    return {
      delay,
      duration,
      easing,
      css: (t) => `opacity: ${t}; stroke-width: ${t * w}`
    };
  }
  let { options: options2 } = $$props;
  let index2 = 0;
  let color2 = {
    Axios: "#3b6be3",
    USSOCOM: "#BDAE50",
    "Texas Policy Lab": "#e54e4d"
  };
  if ($$props.expand === void 0 && $$bindings.expand && expand !== void 0)
    $$bindings.expand(expand);
  if ($$props.options === void 0 && $$bindings.options && options2 !== void 0)
    $$bindings.options(options2);
  $$result.css.add(css$l);
  currJob = options2[index2];
  return `<div style="${"border-bottom: 4px solid " + escape(color2[currJob])}" class="${"svelte-19au29d"}">${escape(currJob)}
  <img src="${"/images/icons/shuffle.svg"}" alt="${"Shuffle icon"}" class="${"svelte-19au29d"}">
</div>`;
});
var Home = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return ``;
});
var css$k = {
  code: "main.svelte-pes05w{max-width:780px;margin:0 auto;padding:1em;margin-bottom:2rem}section.svelte-pes05w{display:flex;flex-direction:column;justify-content:center;align-items:flex-start;flex:1}.title.svelte-pes05w{margin:3rem 0 2rem;font-size:64px;text-align:left;letter-spacing:-1px;font-weight:200}.subtitle.svelte-pes05w{font-size:32px;line-height:1.5;margin-bottom:2rem;font-weight:300}p.svelte-pes05w{margin-bottom:1rem}@media(max-width: 768px){h1.svelte-pes05w{font-size:3.5rem}h2.svelte-pes05w{font-size:1.75rem}.block-if-mobile.svelte-pes05w{display:block}}@media(max-width: 568px){h1.svelte-pes05w{font-size:3.5rem}h2.svelte-pes05w{font-size:1.5rem;line-height:1.25}}",
  map: `{"version":3,"file":"index.svelte","sources":["index.svelte"],"sourcesContent":["<script>\\n  import Spinner from \\"$lib/Spinner.svelte\\";\\n  import Transition from \\"$lib/Transitions/Home.svelte\\";\\n  let options = [\\"Axios\\", \\"Texas Policy Lab\\", \\"USSOCOM\\"];\\n<\/script>\\n\\n<Transition />\\n<main>\\n  <section>\\n    <h1 class=\\"title\\">\\n      Hi, I'm <span\\n        class=\\"gradient-accented block-if-mobile\\"\\n        style=\\"font-weight: 600;\\">Connor Rothschild</span\\n      >\\n    </h1>\\n    <h2 class=\\"subtitle\\">\\n      I'm a data scientist who specializes in telling visual stories on the web.\\n      Right now, I'm doing that at <a\\n        href=\\"https://www.mokshadata.com/\\"\\n        target=\\"_blank\\">Moksha Data</a\\n      >. Previously, I did similar work at <Spinner {options} />\\n    </h2>\\n  </section>\\n\\n  <section class=\\"content\\">\\n    <p>\\n      During my time at Rice University, I found that nothing motivates me like <em\\n        >impact</em\\n      >. Lorem ipsum dolor sit amet consectetur, adipisicing elit. Illo,\\n      explicabo? Blanditiis, laborum aliquid odit magni possimus numquam\\n      necessitatibus cumque vel. Impedit animi possimus culpa explicabo mollitia\\n      fugit delectus dolores qui!\\n    </p>\\n    <p>\\n      Lorem ipsum dolor sit amet consectetur, adipisicing elit. Illo, explicabo?\\n      Blanditiis, laborum aliquid odit magni possimus numquam necessitatibus\\n      cumque vel. Impedit animi possimus culpa explicabo mollitia fugit delectus\\n      dolores qui!\\n    </p>\\n\\n    <a sveltekit:prefetch href=\\"/post\\" class=\\"pulled-right padding-bottom\\"\\n      >See my blog &#8594;</a\\n    >\\n  </section>\\n</main>\\n\\n<style>\\n  main {\\n    max-width: 780px;\\n    margin: 0 auto;\\n    padding: 1em;\\n    margin-bottom: 2rem;\\n  }\\n\\n  section {\\n    display: flex;\\n    flex-direction: column;\\n    justify-content: center;\\n    align-items: flex-start;\\n    flex: 1;\\n  }\\n\\n  .title {\\n    margin: 3rem 0 2rem;\\n    font-size: 64px;\\n    text-align: left;\\n    letter-spacing: -1px;\\n    font-weight: 200;\\n  }\\n\\n  .subtitle {\\n    font-size: 32px;\\n    line-height: 1.5;\\n    margin-bottom: 2rem;\\n    font-weight: 300;\\n  }\\n\\n  p {\\n    margin-bottom: 1rem;\\n  }\\n\\n  @media (max-width: 768px) {\\n    h1 {\\n      font-size: 3.5rem;\\n    }\\n    h2 {\\n      font-size: 1.75rem;\\n    }\\n    .block-if-mobile {\\n      display: block;\\n    }\\n  }\\n\\n  @media (max-width: 568px) {\\n    h1 {\\n      font-size: 3.5rem;\\n    }\\n    h2 {\\n      font-size: 1.5rem;\\n      line-height: 1.25;\\n    }\\n  }\\n</style>\\n"],"names":[],"mappings":"AA+CE,IAAI,cAAC,CAAC,AACJ,SAAS,CAAE,KAAK,CAChB,MAAM,CAAE,CAAC,CAAC,IAAI,CACd,OAAO,CAAE,GAAG,CACZ,aAAa,CAAE,IAAI,AACrB,CAAC,AAED,OAAO,cAAC,CAAC,AACP,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,CACtB,eAAe,CAAE,MAAM,CACvB,WAAW,CAAE,UAAU,CACvB,IAAI,CAAE,CAAC,AACT,CAAC,AAED,MAAM,cAAC,CAAC,AACN,MAAM,CAAE,IAAI,CAAC,CAAC,CAAC,IAAI,CACnB,SAAS,CAAE,IAAI,CACf,UAAU,CAAE,IAAI,CAChB,cAAc,CAAE,IAAI,CACpB,WAAW,CAAE,GAAG,AAClB,CAAC,AAED,SAAS,cAAC,CAAC,AACT,SAAS,CAAE,IAAI,CACf,WAAW,CAAE,GAAG,CAChB,aAAa,CAAE,IAAI,CACnB,WAAW,CAAE,GAAG,AAClB,CAAC,AAED,CAAC,cAAC,CAAC,AACD,aAAa,CAAE,IAAI,AACrB,CAAC,AAED,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AACzB,EAAE,cAAC,CAAC,AACF,SAAS,CAAE,MAAM,AACnB,CAAC,AACD,EAAE,cAAC,CAAC,AACF,SAAS,CAAE,OAAO,AACpB,CAAC,AACD,gBAAgB,cAAC,CAAC,AAChB,OAAO,CAAE,KAAK,AAChB,CAAC,AACH,CAAC,AAED,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AACzB,EAAE,cAAC,CAAC,AACF,SAAS,CAAE,MAAM,AACnB,CAAC,AACD,EAAE,cAAC,CAAC,AACF,SAAS,CAAE,MAAM,CACjB,WAAW,CAAE,IAAI,AACnB,CAAC,AACH,CAAC"}`
};
var Routes = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let options2 = ["Axios", "Texas Policy Lab", "USSOCOM"];
  $$result.css.add(css$k);
  return `${validate_component(Home, "Transition").$$render($$result, {}, {}, {})}
<main class="${"svelte-pes05w"}"><section class="${"svelte-pes05w"}"><h1 class="${"title svelte-pes05w"}">Hi, I&#39;m <span class="${"gradient-accented block-if-mobile svelte-pes05w"}" style="${"font-weight: 600;"}">Connor Rothschild</span></h1>
    <h2 class="${"subtitle svelte-pes05w"}">I&#39;m a data scientist who specializes in telling visual stories on the web.
      Right now, I&#39;m doing that at <a href="${"https://www.mokshadata.com/"}" target="${"_blank"}">Moksha Data</a>. Previously, I did similar work at ${validate_component(Spinner, "Spinner").$$render($$result, { options: options2 }, {}, {})}</h2></section>

  <section class="${"content svelte-pes05w"}"><p class="${"svelte-pes05w"}">During my time at Rice University, I found that nothing motivates me like <em>impact</em>. Lorem ipsum dolor sit amet consectetur, adipisicing elit. Illo,
      explicabo? Blanditiis, laborum aliquid odit magni possimus numquam
      necessitatibus cumque vel. Impedit animi possimus culpa explicabo mollitia
      fugit delectus dolores qui!
    </p>
    <p class="${"svelte-pes05w"}">Lorem ipsum dolor sit amet consectetur, adipisicing elit. Illo, explicabo?
      Blanditiis, laborum aliquid odit magni possimus numquam necessitatibus
      cumque vel. Impedit animi possimus culpa explicabo mollitia fugit delectus
      dolores qui!
    </p>

    <a sveltekit:prefetch href="${"/post"}" class="${"pulled-right padding-bottom"}">See my blog \u2192</a></section>
</main>`;
});
var index$4 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Routes
});
var Main = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return ``;
});
var css$j = {
  code: ".job-container.svelte-gkdjpt.svelte-gkdjpt{padding:2rem 0;border-bottom:1px dashed var(--accent-color);display:flex;align-items:center;justify-content:space-between}h2.svelte-gkdjpt.svelte-gkdjpt{font-size:44px;font-weight:200;text-transform:uppercase;letter-spacing:0.64px;transition:all 300ms linear}h3.svelte-gkdjpt.svelte-gkdjpt{font-size:34px}.job-image.svelte-gkdjpt.svelte-gkdjpt{margin-left:12px;width:40px;transition:width 300ms ease}.job-container.hovered.svelte-gkdjpt.svelte-gkdjpt{cursor:pointer;border-bottom:1px solid var(--accent-color)}.job-container.hovered.svelte-gkdjpt h2.svelte-gkdjpt{color:var(--accent-color);text-decoration:none !important;letter-spacing:1px}.job-container.hovered.svelte-gkdjpt h3.svelte-gkdjpt{color:var(--accent-color);animation:svelte-gkdjpt-right 1s ease infinite;text-decoration:none}a.svelte-gkdjpt.svelte-gkdjpt:hover{text-decoration:none}@keyframes svelte-gkdjpt-right{0%{transform:translateX(0px)}50%{transform:translateX(5px)}100%{transform:translateX(0px)}}@media(max-width: 768px){h2.svelte-gkdjpt.svelte-gkdjpt{font-size:2rem !important}.job-container.svelte-gkdjpt.svelte-gkdjpt{padding:0.5em 0;height:100px}.job-image.svelte-gkdjpt.svelte-gkdjpt{width:32.5px;margin-left:8px}}@media(max-width: 560px){.job-container.svelte-gkdjpt.svelte-gkdjpt{padding:0.5em 0;height:100px}}@media(max-width: 400px){h2.svelte-gkdjpt.svelte-gkdjpt{font-size:1.5rem !important}.job-image.svelte-gkdjpt.svelte-gkdjpt{width:25px}}",
  map: `{"version":3,"file":"JobSection.svelte","sources":["JobSection.svelte"],"sourcesContent":["<script>\\n  export let job;\\n  export let slug;\\n\\n  let hovered = false;\\n<\/script>\\n\\n<a\\n  class=\\"job-container {hovered ? 'hovered' : ''}\\"\\n  on:mouseover={() => (hovered = true)}\\n  on:focus={() => (hovered = true)}\\n  on:mouseleave={() => (hovered = false)}\\n  sveltekit:prefetch\\n  href={slug}\\n>\\n  <div style=\\"display: flex; place-items: center;\\">\\n    <h2>{job.name}</h2>\\n    <img\\n      src=\\"/images/jobs/{job.imageUrl}.svg\\"\\n      class=\\"job-image {hovered ? 'hovered' : ''}\\"\\n      alt=\\"logo\\"\\n    />\\n  </div>\\n  <h3>&#8594;</h3>\\n</a>\\n\\n<style>\\n  .job-container {\\n    padding: 2rem 0;\\n    border-bottom: 1px dashed var(--accent-color);\\n    display: flex;\\n    align-items: center;\\n    justify-content: space-between;\\n  }\\n\\n  h2 {\\n    font-size: 44px;\\n    font-weight: 200;\\n    text-transform: uppercase;\\n    letter-spacing: 0.64px;\\n    transition: all 300ms linear;\\n  }\\n\\n  h3 {\\n    font-size: 34px;\\n  }\\n\\n  .job-image {\\n    margin-left: 12px;\\n    width: 40px;\\n    transition: width 300ms ease;\\n  }\\n\\n  .job-container.hovered {\\n    cursor: pointer;\\n    border-bottom: 1px solid var(--accent-color);\\n  }\\n\\n  .job-container.hovered h2 {\\n    color: var(--accent-color);\\n    text-decoration: none !important;\\n    letter-spacing: 1px;\\n  }\\n\\n  .job-container.hovered h3 {\\n    color: var(--accent-color);\\n    animation: right 1s ease infinite;\\n    text-decoration: none;\\n  }\\n\\n  a:hover {\\n    text-decoration: none;\\n  }\\n\\n  @keyframes right {\\n    0% {\\n      transform: translateX(0px);\\n    }\\n    50% {\\n      transform: translateX(5px);\\n    }\\n    100% {\\n      transform: translateX(0px);\\n    }\\n  }\\n\\n  /* TABLET */\\n  @media (max-width: 768px) {\\n    h2 {\\n      font-size: 2rem !important;\\n    }\\n    .job-container {\\n      padding: 0.5em 0;\\n      height: 100px;\\n    }\\n    .job-image {\\n      width: 32.5px;\\n      margin-left: 8px;\\n    }\\n  }\\n\\n  /* MOBILE */\\n  @media (max-width: 560px) {\\n    .job-container {\\n      padding: 0.5em 0;\\n      height: 100px;\\n    }\\n  }\\n\\n  /* TINY */\\n  @media (max-width: 400px) {\\n    h2 {\\n      font-size: 1.5rem !important;\\n    }\\n    .job-image {\\n      width: 25px;\\n    }\\n  }\\n  /* .logos {\\n    display: flex;\\n    flex-direction: row;\\n    place-items: center;\\n  }\\n\\n  .job-image {\\n    margin-left: 1em;\\n  }\\n  .job-image {\\n    filter: blur(2px) grayscale(0.8);\\n    transition: filter 400ms ease;\\n    cursor: pointer;\\n  }\\n\\n  .job-image.hovered {\\n    filter: blur(0) grayscale(0.8);\\n  } */\\n\\n  /* .job-image {\\n    transition: transform 0.3s ease-in-out;\\n  }\\n\\n  .job-image.hovered {\\n    transform: rotate(360deg);\\n  } */\\n</style>\\n"],"names":[],"mappings":"AA2BE,cAAc,4BAAC,CAAC,AACd,OAAO,CAAE,IAAI,CAAC,CAAC,CACf,aAAa,CAAE,GAAG,CAAC,MAAM,CAAC,IAAI,cAAc,CAAC,CAC7C,OAAO,CAAE,IAAI,CACb,WAAW,CAAE,MAAM,CACnB,eAAe,CAAE,aAAa,AAChC,CAAC,AAED,EAAE,4BAAC,CAAC,AACF,SAAS,CAAE,IAAI,CACf,WAAW,CAAE,GAAG,CAChB,cAAc,CAAE,SAAS,CACzB,cAAc,CAAE,MAAM,CACtB,UAAU,CAAE,GAAG,CAAC,KAAK,CAAC,MAAM,AAC9B,CAAC,AAED,EAAE,4BAAC,CAAC,AACF,SAAS,CAAE,IAAI,AACjB,CAAC,AAED,UAAU,4BAAC,CAAC,AACV,WAAW,CAAE,IAAI,CACjB,KAAK,CAAE,IAAI,CACX,UAAU,CAAE,KAAK,CAAC,KAAK,CAAC,IAAI,AAC9B,CAAC,AAED,cAAc,QAAQ,4BAAC,CAAC,AACtB,MAAM,CAAE,OAAO,CACf,aAAa,CAAE,GAAG,CAAC,KAAK,CAAC,IAAI,cAAc,CAAC,AAC9C,CAAC,AAED,cAAc,sBAAQ,CAAC,EAAE,cAAC,CAAC,AACzB,KAAK,CAAE,IAAI,cAAc,CAAC,CAC1B,eAAe,CAAE,IAAI,CAAC,UAAU,CAChC,cAAc,CAAE,GAAG,AACrB,CAAC,AAED,cAAc,sBAAQ,CAAC,EAAE,cAAC,CAAC,AACzB,KAAK,CAAE,IAAI,cAAc,CAAC,CAC1B,SAAS,CAAE,mBAAK,CAAC,EAAE,CAAC,IAAI,CAAC,QAAQ,CACjC,eAAe,CAAE,IAAI,AACvB,CAAC,AAED,6BAAC,MAAM,AAAC,CAAC,AACP,eAAe,CAAE,IAAI,AACvB,CAAC,AAED,WAAW,mBAAM,CAAC,AAChB,EAAE,AAAC,CAAC,AACF,SAAS,CAAE,WAAW,GAAG,CAAC,AAC5B,CAAC,AACD,GAAG,AAAC,CAAC,AACH,SAAS,CAAE,WAAW,GAAG,CAAC,AAC5B,CAAC,AACD,IAAI,AAAC,CAAC,AACJ,SAAS,CAAE,WAAW,GAAG,CAAC,AAC5B,CAAC,AACH,CAAC,AAGD,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AACzB,EAAE,4BAAC,CAAC,AACF,SAAS,CAAE,IAAI,CAAC,UAAU,AAC5B,CAAC,AACD,cAAc,4BAAC,CAAC,AACd,OAAO,CAAE,KAAK,CAAC,CAAC,CAChB,MAAM,CAAE,KAAK,AACf,CAAC,AACD,UAAU,4BAAC,CAAC,AACV,KAAK,CAAE,MAAM,CACb,WAAW,CAAE,GAAG,AAClB,CAAC,AACH,CAAC,AAGD,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AACzB,cAAc,4BAAC,CAAC,AACd,OAAO,CAAE,KAAK,CAAC,CAAC,CAChB,MAAM,CAAE,KAAK,AACf,CAAC,AACH,CAAC,AAGD,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AACzB,EAAE,4BAAC,CAAC,AACF,SAAS,CAAE,MAAM,CAAC,UAAU,AAC9B,CAAC,AACD,UAAU,4BAAC,CAAC,AACV,KAAK,CAAE,IAAI,AACb,CAAC,AACH,CAAC"}`
};
var JobSection = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { job } = $$props;
  let { slug } = $$props;
  if ($$props.job === void 0 && $$bindings.job && job !== void 0)
    $$bindings.job(job);
  if ($$props.slug === void 0 && $$bindings.slug && slug !== void 0)
    $$bindings.slug(slug);
  $$result.css.add(css$j);
  return `<a class="${"job-container " + escape("") + " svelte-gkdjpt"}" sveltekit:prefetch${add_attribute("href", slug, 0)}><div style="${"display: flex; place-items: center;"}"><h2 class="${"svelte-gkdjpt"}">${escape(job.name)}</h2>
    <img src="${"/images/jobs/" + escape(job.imageUrl) + ".svg"}" class="${"job-image " + escape("") + " svelte-gkdjpt"}" alt="${"logo"}"></div>
  <h3 class="${"svelte-gkdjpt"}">\u2192</h3>
</a>`;
});
var css$i = {
  code: "main.svelte-1k3c6fk{width:90vw;max-width:860px;margin:0 auto;padding:1em}",
  map: `{"version":3,"file":"index.svelte","sources":["index.svelte"],"sourcesContent":["<script context=\\"module\\">\\n  /**\\n   * @type {import('@sveltejs/kit').Load}\\n   */\\n  export async function load({ fetch }) {\\n    const res = await fetch(\`/experience.json\`);\\n    const jobs = await res.json();\\n    return {\\n      props: {\\n        jobs,\\n      },\\n    };\\n  }\\n<\/script>\\n\\n<script>\\n  import Transition from \\"$lib/Transition.svelte\\";\\n  import JobSection from \\"$lib/JobSection.svelte\\";\\n  export let jobs;\\n\\n  const sortedJobs = jobs.sort((a, b) => a.metadata.order - b.metadata.order);\\n\\n  import { seo } from \\"$lib/store.js\\";\\n  $seo = {\\n    title: \\"Experience | Connor Rothschild\\",\\n    description: \\"Some of my work experience.\\",\\n  };\\n<\/script>\\n\\n<Transition />\\n<main>\\n  <h1 class=\\"page-overline\\">Experience</h1>\\n  <h1 class=\\"page-title\\">\\n    Where I've\\n    <span class=\\"gradient-accented bolded \\">worked</span>\\n  </h1>\\n\\n  <div class=\\"transition-content\\">\\n    {#each sortedJobs as job}\\n      <JobSection job={job.metadata} slug={job.path.replace(/\\\\.[^/.]+$/, \\"\\")} />\\n    {/each}\\n  </div>\\n</main>\\n\\n<style>\\n  main {\\n    width: 90vw;\\n    max-width: 860px;\\n    margin: 0 auto;\\n    padding: 1em;\\n  }\\n\\n  /* .page-title {\\n    font-size: 2.5rem !important;\\n  } */\\n</style>\\n"],"names":[],"mappings":"AA6CE,IAAI,eAAC,CAAC,AACJ,KAAK,CAAE,IAAI,CACX,SAAS,CAAE,KAAK,CAChB,MAAM,CAAE,CAAC,CAAC,IAAI,CACd,OAAO,CAAE,GAAG,AACd,CAAC"}`
};
async function load$3({ fetch: fetch2 }) {
  const res = await fetch2(`/experience.json`);
  const jobs = await res.json();
  return { props: { jobs } };
}
var Experience = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $seo, $$unsubscribe_seo;
  $$unsubscribe_seo = subscribe(seo, (value) => $seo = value);
  let { jobs } = $$props;
  const sortedJobs = jobs.sort((a, b) => a.metadata.order - b.metadata.order);
  set_store_value(seo, $seo = {
    title: "Experience | Connor Rothschild",
    description: "Some of my work experience."
  }, $seo);
  if ($$props.jobs === void 0 && $$bindings.jobs && jobs !== void 0)
    $$bindings.jobs(jobs);
  $$result.css.add(css$i);
  $$unsubscribe_seo();
  return `${validate_component(Main, "Transition").$$render($$result, {}, {}, {})}
<main class="${"svelte-1k3c6fk"}"><h1 class="${"page-overline"}">Experience</h1>
  <h1 class="${"page-title"}">Where I&#39;ve
    <span class="${"gradient-accented bolded "}">worked</span></h1>

  <div class="${"transition-content"}">${each(sortedJobs, (job) => `${validate_component(JobSection, "JobSection").$$render($$result, {
    job: job.metadata,
    slug: job.path.replace(/\.[^/.]+$/, "")
  }, {}, {})}`)}</div>
</main>`;
});
var index$3 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Experience,
  load: load$3
});
var Content = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return ``;
});
var css$h = {
  code: "a.svelte-1i7uvlb{font-family:var(--font-sans);font-size:1rem;text-transform:uppercase;letter-spacing:0;font-weight:300;transition:transform 300ms ease}a.svelte-1i7uvlb:hover{transform:translateX(-10px)}",
  map: '{"version":3,"file":"BackTo.svelte","sources":["BackTo.svelte"],"sourcesContent":["<script>\\n  export let href;\\n  export let text = \\"\\";\\n  export let classes = \\"\\";\\n<\/script>\\n\\n<a class=\\"block no-underline {classes}\\" {href} sveltekit:prefetch\\n  >&#8592; {@html text}\\n</a>\\n\\n<style>\\n  a {\\n    font-family: var(--font-sans);\\n    font-size: 1rem;\\n    text-transform: uppercase;\\n    letter-spacing: 0;\\n    font-weight: 300;\\n    transition: transform 300ms ease;\\n  }\\n\\n  a:hover {\\n    transform: translateX(-10px);\\n  }\\n</style>\\n"],"names":[],"mappings":"AAWE,CAAC,eAAC,CAAC,AACD,WAAW,CAAE,IAAI,WAAW,CAAC,CAC7B,SAAS,CAAE,IAAI,CACf,cAAc,CAAE,SAAS,CACzB,cAAc,CAAE,CAAC,CACjB,WAAW,CAAE,GAAG,CAChB,UAAU,CAAE,SAAS,CAAC,KAAK,CAAC,IAAI,AAClC,CAAC,AAED,gBAAC,MAAM,AAAC,CAAC,AACP,SAAS,CAAE,WAAW,KAAK,CAAC,AAC9B,CAAC"}'
};
var BackTo = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { href } = $$props;
  let { text = "" } = $$props;
  let { classes = "" } = $$props;
  if ($$props.href === void 0 && $$bindings.href && href !== void 0)
    $$bindings.href(href);
  if ($$props.text === void 0 && $$bindings.text && text !== void 0)
    $$bindings.text(text);
  if ($$props.classes === void 0 && $$bindings.classes && classes !== void 0)
    $$bindings.classes(classes);
  $$result.css.add(css$h);
  return `<a class="${"block no-underline " + escape(classes) + " svelte-1i7uvlb"}"${add_attribute("href", href, 0)} sveltekit:prefetch>\u2190 <!-- HTML_TAG_START -->${text}<!-- HTML_TAG_END -->
</a>`;
});
var css$g = {
  code: "main.svelte-7btaq2{max-width:768px;margin:0 auto;padding:1em;width:90vw}.content.svelte-7btaq2{margin-bottom:4rem}.logo.svelte-7btaq2{height:0.75em;transition:transform 500ms ease}.logo.svelte-7btaq2:hover{transform:rotate(360deg)}",
  map: '{"version":3,"file":"layout.svelte","sources":["layout.svelte"],"sourcesContent":["<script>\\n  import Transition from \\"$lib/Transitions/Content.svelte\\";\\n  import BackTo from \\"$lib/Text/BackTo.svelte\\";\\n\\n  import { seo } from \\"$lib/store\\";\\n\\n  export let name;\\n  export let description;\\n  export let imageUrl;\\n\\n  $seo = {\\n    title: name,\\n    description: description,\\n  };\\n<\/script>\\n\\n<Transition />\\n<main>\\n  <BackTo href=\\"/experience\\" text=\\"Experience\\" classes=\\"page-overline\\" />\\n\\n  <h1 class=\\"page-title\\">\\n    {name}\\n    <img\\n      src={`/images/jobs/${imageUrl}.svg`}\\n      alt=\\"Logo for {name}\\"\\n      class=\\"logo\\"\\n    />\\n  </h1>\\n  <div class=\\"transition-content\\">\\n    <div class=\\"content\\">\\n      <slot />\\n      <BackTo href=\\"/experience\\" text=\\"Back to all jobs\\" classes=\\"border-top\\" />\\n    </div>\\n  </div>\\n</main>\\n\\n<style>\\n  main {\\n    max-width: 768px;\\n    margin: 0 auto;\\n    padding: 1em;\\n    width: 90vw;\\n  }\\n\\n  .content {\\n    margin-bottom: 4rem;\\n  }\\n\\n  .logo {\\n    height: 0.75em;\\n    transition: transform 500ms ease;\\n  }\\n\\n  .logo:hover {\\n    transform: rotate(360deg);\\n  }\\n</style>\\n"],"names":[],"mappings":"AAqCE,IAAI,cAAC,CAAC,AACJ,SAAS,CAAE,KAAK,CAChB,MAAM,CAAE,CAAC,CAAC,IAAI,CACd,OAAO,CAAE,GAAG,CACZ,KAAK,CAAE,IAAI,AACb,CAAC,AAED,QAAQ,cAAC,CAAC,AACR,aAAa,CAAE,IAAI,AACrB,CAAC,AAED,KAAK,cAAC,CAAC,AACL,MAAM,CAAE,MAAM,CACd,UAAU,CAAE,SAAS,CAAC,KAAK,CAAC,IAAI,AAClC,CAAC,AAED,mBAAK,MAAM,AAAC,CAAC,AACX,SAAS,CAAE,OAAO,MAAM,CAAC,AAC3B,CAAC"}'
};
var Layout$3 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $seo, $$unsubscribe_seo;
  $$unsubscribe_seo = subscribe(seo, (value) => $seo = value);
  let { name } = $$props;
  let { description } = $$props;
  let { imageUrl } = $$props;
  set_store_value(seo, $seo = { title: name, description }, $seo);
  if ($$props.name === void 0 && $$bindings.name && name !== void 0)
    $$bindings.name(name);
  if ($$props.description === void 0 && $$bindings.description && description !== void 0)
    $$bindings.description(description);
  if ($$props.imageUrl === void 0 && $$bindings.imageUrl && imageUrl !== void 0)
    $$bindings.imageUrl(imageUrl);
  $$result.css.add(css$g);
  $$unsubscribe_seo();
  return `${validate_component(Content, "Transition").$$render($$result, {}, {}, {})}
<main class="${"svelte-7btaq2"}">${validate_component(BackTo, "BackTo").$$render($$result, {
    href: "/experience",
    text: "Experience",
    classes: "page-overline"
  }, {}, {})}

  <h1 class="${"page-title"}">${escape(name)}
    <img${add_attribute("src", `/images/jobs/${imageUrl}.svg`, 0)} alt="${"Logo for " + escape(name)}" class="${"logo svelte-7btaq2"}"></h1>
  <div class="${"transition-content"}"><div class="${"content svelte-7btaq2"}">${slots.default ? slots.default({}) : ``}
      ${validate_component(BackTo, "BackTo").$$render($$result, {
    href: "/experience",
    text: "Back to all jobs",
    classes: "border-top"
  }, {}, {})}</div></div>
</main>`;
});
var layout$3 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Layout$3
});
var metadata$P = {
  "layout": "experience",
  "name": "Moksha Data",
  "imageUrl": "moksha",
  "description": "Lorem",
  "order": 1
};
var Moksha = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${validate_component(Layout$3, "Layout_MDSVEX_DEFAULT").$$render($$result, Object.assign($$props, metadata$P), {}, { default: () => `<p>Yo</p>` })}`;
});
var moksha = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Moksha,
  metadata: metadata$P
});
var metadata$O = {
  "layout": "experience",
  "name": "Axios",
  "imageUrl": "axios",
  "description": "Lorem",
  "order": 2
};
var Axios = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${validate_component(Layout$3, "Layout_MDSVEX_DEFAULT").$$render($$result, Object.assign($$props, metadata$O), {}, {
    default: () => `<p>I worked as a visual journalist at Axios in the summer after graduating. While there, I created a variety of visualizations for journalists and even had the opportunity to write a few of my own stories!</p>
<p>Here are some of my favorite visuals I created in my tenure there:</p>
<ul><li><a href="${"https://www.axios.com/olympics-medal-count-usa-tokyo-762804df-d836-4fb2-8407-9a9c5b273643.html"}" rel="${"nofollow"}">The Olympic medals tracker</a></li>
<li><a href="${"https://www.axios.com/olympic-winners-a1912446-22ef-4c2a-9fda-85bfe8dedb08.html"}" rel="${"nofollow"}">Olympic winners, over time</a></li>
<li><a href="${"https://www.axios.com/diversity-majority-minority-white-american-census-bd181b53-f170-40b2-9913-dd43363e1aaf.html"}" rel="${"nofollow"}">More than 400 U.S. counties are now minority white</a></li>
<li><a href="${"https://www.axios.com/coronavirus-vaccines-vulnerability-states-outbreaks-variants-b418fe6d-31f6-4790-9d79-bd7c4d747dd3.html?utm_source=twitter&utm_medium=social&utm_campaign=editorial&utm_content=health-statesvaccines"}" rel="${"nofollow"}">States most vulnerable to COVID are also some of the least vaccinated</a></li>
<li><a href="${"https://www.axios.com/partisan-media-biden-trump-26f54a8b-d4e2-4319-a185-bd5f55ac661f.html"}" rel="${"nofollow"}">Boring news cycle deals blow to partisan media</a></li></ul>`
  })}`;
});
var axios = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Axios,
  metadata: metadata$O
});
var metadata$N = {
  "layout": "experience",
  "name": "USSOCOM",
  "imageUrl": "socom",
  "description": "Lorem",
  "order": 3
};
var Socom = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${validate_component(Layout$3, "Layout_MDSVEX_DEFAULT").$$render($$result, Object.assign($$props, metadata$N), {}, { default: () => `<p>Yo</p>` })}`;
});
var socom = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Socom,
  metadata: metadata$N
});
var metadata$M = {
  "layout": "experience",
  "name": "Texas Policy Lab",
  "imageUrl": "tpl",
  "description": "Lorem",
  "order": 4
};
var Tpl = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${validate_component(Layout$3, "Layout_MDSVEX_DEFAULT").$$render($$result, Object.assign($$props, metadata$M), {}, { default: () => `<p>Yo</p>` })}`;
});
var tpl = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Tpl,
  metadata: metadata$M
});
var css$f = {
  code: ".project-card.svelte-sy0qx9{position:relative;border-radius:5px;box-shadow:1px 1px 4px #b2b2b2;height:100%}.project-image.svelte-sy0qx9{width:100%;height:100%;object-fit:cover;border-radius:5px;filter:blur(0);z-index:0}.hovered-gradient.svelte-sy0qx9{position:absolute;background-image:linear-gradient(\n      to bottom,\n      rgba(255, 255, 255, 0),\n      rgba(0, 0, 0, 0.75)\n    );width:100%;height:100%;background-size:cover;pointer-events:none;z-index:1}.hovered.svelte-sy0qx9{filter:blur(1px)}.project-text.svelte-sy0qx9{position:absolute;bottom:0;left:0;pointer-events:none;padding:1.5rem;z-index:3}h1.svelte-sy0qx9,h2.svelte-sy0qx9{color:white}h1.svelte-sy0qx9{font-size:1.5rem;line-height:1.15;text-shadow:1px 1px 6px black}.description.svelte-sy0qx9{font-family:var(--font-sans);font-size:1rem;line-height:1.2;font-weight:300;margin-top:12px;letter-spacing:0.64px;text-shadow:1px 1px 6px black}",
  map: '{"version":3,"file":"ProjectSection.svelte","sources":["ProjectSection.svelte"],"sourcesContent":["<script>\\n  export let project;\\n  export let slug;\\n\\n  import { fly, fade } from \\"svelte/transition\\";\\n\\n  let hovered = false;\\n<\/script>\\n\\n<a class=\\"project-card no-underline\\" href={slug} sveltekit:prefetch>\\n  {#if hovered}\\n    <div transition:fade={{ duration: 200 }} class=\\"hovered-gradient\\" />\\n  {/if}\\n  <img\\n    src=\\"/images/project/{project.image}\\"\\n    alt=\\"Project image for {project.title}\\"\\n    class=\\"project-image\\"\\n    on:mouseover={() => {\\n      hovered = true;\\n    }}\\n    on:focus={() => {\\n      hovered = true;\\n    }}\\n    on:mouseleave={() => {\\n      hovered = false;\\n    }}\\n    class:hovered\\n  />\\n  {#if hovered}\\n    <div\\n      in:fly={{ y: 50, duration: 200 }}\\n      out:fade={{ duration: 200 }}\\n      class=\\"project-text\\"\\n    >\\n      <h1>{project.title}</h1>\\n      <h2 class=\\"description\\">{project.description}</h2>\\n    </div>\\n  {/if}\\n</a>\\n\\n<style>\\n  .project-card {\\n    position: relative;\\n    border-radius: 5px;\\n    box-shadow: 1px 1px 4px #b2b2b2;\\n    height: 100%;\\n  }\\n\\n  .project-image {\\n    width: 100%;\\n    height: 100%;\\n    object-fit: cover;\\n    border-radius: 5px;\\n    filter: blur(0);\\n    z-index: 0;\\n    /* transition: filter 1000ms linear; */\\n  }\\n\\n  .hovered-gradient {\\n    position: absolute;\\n    background-image: linear-gradient(\\n      to bottom,\\n      rgba(255, 255, 255, 0),\\n      rgba(0, 0, 0, 0.75)\\n    );\\n    width: 100%;\\n    height: 100%;\\n    background-size: cover;\\n    pointer-events: none;\\n    z-index: 1; /* Above image */\\n  }\\n\\n  .hovered {\\n    filter: blur(1px);\\n  }\\n\\n  .project-text {\\n    position: absolute;\\n    bottom: 0;\\n    left: 0;\\n    pointer-events: none;\\n    padding: 1.5rem;\\n    z-index: 3;\\n  }\\n\\n  h1,\\n  h2 {\\n    color: white;\\n  }\\n\\n  h1 {\\n    font-size: 1.5rem;\\n    line-height: 1.15;\\n    text-shadow: 1px 1px 6px black;\\n  }\\n\\n  .description {\\n    font-family: var(--font-sans);\\n    font-size: 1rem;\\n    line-height: 1.2;\\n    font-weight: 300;\\n    margin-top: 12px;\\n    letter-spacing: 0.64px;\\n    text-shadow: 1px 1px 6px black;\\n  }\\n</style>\\n"],"names":[],"mappings":"AAyCE,aAAa,cAAC,CAAC,AACb,QAAQ,CAAE,QAAQ,CAClB,aAAa,CAAE,GAAG,CAClB,UAAU,CAAE,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,OAAO,CAC/B,MAAM,CAAE,IAAI,AACd,CAAC,AAED,cAAc,cAAC,CAAC,AACd,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,UAAU,CAAE,KAAK,CACjB,aAAa,CAAE,GAAG,CAClB,MAAM,CAAE,KAAK,CAAC,CAAC,CACf,OAAO,CAAE,CAAC,AAEZ,CAAC,AAED,iBAAiB,cAAC,CAAC,AACjB,QAAQ,CAAE,QAAQ,CAClB,gBAAgB,CAAE;MAChB,EAAE,CAAC,MAAM,CAAC;MACV,KAAK,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;MACvB,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;KACpB,CACD,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,eAAe,CAAE,KAAK,CACtB,cAAc,CAAE,IAAI,CACpB,OAAO,CAAE,CAAC,AACZ,CAAC,AAED,QAAQ,cAAC,CAAC,AACR,MAAM,CAAE,KAAK,GAAG,CAAC,AACnB,CAAC,AAED,aAAa,cAAC,CAAC,AACb,QAAQ,CAAE,QAAQ,CAClB,MAAM,CAAE,CAAC,CACT,IAAI,CAAE,CAAC,CACP,cAAc,CAAE,IAAI,CACpB,OAAO,CAAE,MAAM,CACf,OAAO,CAAE,CAAC,AACZ,CAAC,AAED,gBAAE,CACF,EAAE,cAAC,CAAC,AACF,KAAK,CAAE,KAAK,AACd,CAAC,AAED,EAAE,cAAC,CAAC,AACF,SAAS,CAAE,MAAM,CACjB,WAAW,CAAE,IAAI,CACjB,WAAW,CAAE,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,KAAK,AAChC,CAAC,AAED,YAAY,cAAC,CAAC,AACZ,WAAW,CAAE,IAAI,WAAW,CAAC,CAC7B,SAAS,CAAE,IAAI,CACf,WAAW,CAAE,GAAG,CAChB,WAAW,CAAE,GAAG,CAChB,UAAU,CAAE,IAAI,CAChB,cAAc,CAAE,MAAM,CACtB,WAAW,CAAE,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,KAAK,AAChC,CAAC"}'
};
var ProjectSection = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { project: project2 } = $$props;
  let { slug } = $$props;
  if ($$props.project === void 0 && $$bindings.project && project2 !== void 0)
    $$bindings.project(project2);
  if ($$props.slug === void 0 && $$bindings.slug && slug !== void 0)
    $$bindings.slug(slug);
  $$result.css.add(css$f);
  return `<a class="${"project-card no-underline svelte-sy0qx9"}"${add_attribute("href", slug, 0)} sveltekit:prefetch>${``}
  <img src="${"/images/project/" + escape(project2.image)}" alt="${"Project image for " + escape(project2.title)}" class="${["project-image svelte-sy0qx9", ""].join(" ").trim()}">
  ${``}
</a>`;
});
var css$e = {
  code: "main.svelte-1wf2rgn{width:90vw;max-width:860px;margin:0 auto;padding:1em}.projects-container.svelte-1wf2rgn{display:grid;grid-template-columns:repeat(2, 1fr);grid-gap:10px;margin-bottom:10px}.button.svelte-1wf2rgn{margin:12px 0 12px auto}@media screen and (max-width: 660px){.projects-container.svelte-1wf2rgn{grid-template-columns:auto;grid-template-rows:repeat(1, 1fr)}}",
  map: `{"version":3,"file":"index.svelte","sources":["index.svelte"],"sourcesContent":["<script context=\\"module\\">\\n  /**\\n   * @type {import('@sveltejs/kit').Load}\\n   */\\n  export async function load({ fetch }) {\\n    const res = await fetch(\`/projects.json\`);\\n    const projects = await res.json();\\n    return {\\n      props: {\\n        projects,\\n      },\\n    };\\n  }\\n<\/script>\\n\\n<script>\\n  import Transition from \\"$lib/Transition.svelte\\";\\n  import ProjectSection from \\"$lib/ProjectSection.svelte\\";\\n\\n  import { linear } from \\"svelte/easing\\";\\n  import { slide } from \\"svelte/transition\\";\\n\\n  export let projects;\\n\\n  let filteredProjects = projects\\n    .filter((d) => d.metadata.archived != true)\\n    .sort((a, b) => Date.parse(b.metadata.date) - Date.parse(a.metadata.date));\\n\\n  let featuredProjects = filteredProjects.filter(\\n    (d) => d.metadata.featured == true\\n  );\\n  let otherProjects = filteredProjects.filter(\\n    (d) => !d.metadata.featured == true\\n  );\\n\\n  let showAll = false;\\n\\n  import { seo } from \\"$lib/store.js\\";\\n  $seo = {\\n    title: \\"Projects | Connor Rothschild\\",\\n    description: \\"Some of my projects.\\",\\n  };\\n<\/script>\\n\\n<Transition />\\n<main>\\n  <h1 class=\\"page-overline\\">Projects</h1>\\n  <h1 class=\\"page-title\\">\\n    What I've <span class=\\"gradient-accented bolded\\">built</span>\\n  </h1>\\n\\n  <div class=\\"transition-content\\">\\n    <div class=\\"projects-container\\">\\n      {#each featuredProjects as project}\\n        <ProjectSection\\n          project={project.metadata}\\n          slug={project.path.replace(/\\\\.[^/.]+$/, \\"\\")}\\n        />\\n      {/each}\\n    </div>\\n    {#if showAll}\\n      <div\\n        transition:slide={{ duration: 300, easing: linear }}\\n        class=\\"projects-container\\"\\n      >\\n        {#each otherProjects as project}\\n          <ProjectSection\\n            project={project.metadata}\\n            slug={project.path.replace(/\\\\.[^/.]+$/, \\"\\")}\\n          />\\n        {/each}\\n      </div>\\n    {/if}\\n    <button\\n      class=\\"button pulled-right block\\"\\n      on:click={() => {\\n        showAll = !showAll;\\n      }}\\n    >\\n      {showAll ? \\"Hide others \u2191\\" : \\"Show all \u2193\\"}\\n    </button>\\n  </div>\\n</main>\\n\\n<style>\\n  main {\\n    width: 90vw;\\n    max-width: 860px;\\n    margin: 0 auto;\\n    padding: 1em;\\n  }\\n\\n  .projects-container {\\n    display: grid;\\n    grid-template-columns: repeat(2, 1fr);\\n    grid-gap: 10px;\\n    margin-bottom: 10px;\\n  }\\n\\n  .button {\\n    margin: 12px 0 12px auto;\\n  }\\n\\n  @media screen and (max-width: 660px) {\\n    .projects-container {\\n      grid-template-columns: auto;\\n      grid-template-rows: repeat(1, 1fr);\\n    }\\n  }\\n</style>\\n"],"names":[],"mappings":"AAqFE,IAAI,eAAC,CAAC,AACJ,KAAK,CAAE,IAAI,CACX,SAAS,CAAE,KAAK,CAChB,MAAM,CAAE,CAAC,CAAC,IAAI,CACd,OAAO,CAAE,GAAG,AACd,CAAC,AAED,mBAAmB,eAAC,CAAC,AACnB,OAAO,CAAE,IAAI,CACb,qBAAqB,CAAE,OAAO,CAAC,CAAC,CAAC,GAAG,CAAC,CACrC,QAAQ,CAAE,IAAI,CACd,aAAa,CAAE,IAAI,AACrB,CAAC,AAED,OAAO,eAAC,CAAC,AACP,MAAM,CAAE,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,AAC1B,CAAC,AAED,OAAO,MAAM,CAAC,GAAG,CAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AACpC,mBAAmB,eAAC,CAAC,AACnB,qBAAqB,CAAE,IAAI,CAC3B,kBAAkB,CAAE,OAAO,CAAC,CAAC,CAAC,GAAG,CAAC,AACpC,CAAC,AACH,CAAC"}`
};
async function load$2({ fetch: fetch2 }) {
  const res = await fetch2(`/projects.json`);
  const projects = await res.json();
  return { props: { projects } };
}
var Project = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $seo, $$unsubscribe_seo;
  $$unsubscribe_seo = subscribe(seo, (value) => $seo = value);
  let { projects } = $$props;
  let filteredProjects = projects.filter((d) => d.metadata.archived != true).sort((a, b) => Date.parse(b.metadata.date) - Date.parse(a.metadata.date));
  let featuredProjects = filteredProjects.filter((d) => d.metadata.featured == true);
  filteredProjects.filter((d) => !d.metadata.featured == true);
  set_store_value(seo, $seo = {
    title: "Projects | Connor Rothschild",
    description: "Some of my projects."
  }, $seo);
  if ($$props.projects === void 0 && $$bindings.projects && projects !== void 0)
    $$bindings.projects(projects);
  $$result.css.add(css$e);
  $$unsubscribe_seo();
  return `${validate_component(Main, "Transition").$$render($$result, {}, {}, {})}
<main class="${"svelte-1wf2rgn"}"><h1 class="${"page-overline"}">Projects</h1>
  <h1 class="${"page-title"}">What I&#39;ve <span class="${"gradient-accented bolded"}">built</span></h1>

  <div class="${"transition-content"}"><div class="${"projects-container svelte-1wf2rgn"}">${each(featuredProjects, (project2) => `${validate_component(ProjectSection, "ProjectSection").$$render($$result, {
    project: project2.metadata,
    slug: project2.path.replace(/\.[^/.]+$/, "")
  }, {}, {})}`)}</div>
    ${``}
    <button class="${"button pulled-right block svelte-1wf2rgn"}">${escape("Show all \u2193")}</button></div>
</main>`;
});
var index$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Project,
  load: load$2
});
var css$d = {
  code: "main.svelte-3tm1lf{max-width:768px;margin:0 auto;padding:1em;width:90vw}.project.svelte-3tm1lf{margin-bottom:4rem}",
  map: '{"version":3,"file":"layout.svelte","sources":["layout.svelte"],"sourcesContent":["<script>\\n  import BackTo from \\"$lib/Text/BackTo.svelte\\";\\n  import Transition from \\"$lib/Transitions/Content.svelte\\";\\n  import { seo } from \\"$lib/store\\";\\n\\n  export let title;\\n  export let description;\\n\\n  $seo = {\\n    title: title,\\n    description: description,\\n  };\\n<\/script>\\n\\n<Transition />\\n<main>\\n  <BackTo href=\\"/project\\" text=\\"Projects\\" classes=\\"page-overline\\" />\\n  <h1 class=\\"page-title\\">{title}</h1>\\n  <div class=\\"project transition-content\\">\\n    <slot />\\n    <BackTo href=\\"/project\\" text=\\"Back to all projects\\" classes=\\"border-top\\" />\\n  </div>\\n</main>\\n\\n<style>\\n  main {\\n    max-width: 768px;\\n    margin: 0 auto;\\n    padding: 1em;\\n    width: 90vw;\\n  }\\n\\n  .project {\\n    margin-bottom: 4rem;\\n  }\\n\\n  /* .date {\\n    font-weight: 300;\\n    margin-top: -1rem;\\n    font-size: 1.5rem;\\n    margin-bottom: 2rem;\\n    border-bottom: 1px solid var(--accent-color);\\n    padding-bottom: 1rem;\\n  } */\\n</style>\\n"],"names":[],"mappings":"AAyBE,IAAI,cAAC,CAAC,AACJ,SAAS,CAAE,KAAK,CAChB,MAAM,CAAE,CAAC,CAAC,IAAI,CACd,OAAO,CAAE,GAAG,CACZ,KAAK,CAAE,IAAI,AACb,CAAC,AAED,QAAQ,cAAC,CAAC,AACR,aAAa,CAAE,IAAI,AACrB,CAAC"}'
};
var Layout$2 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $seo, $$unsubscribe_seo;
  $$unsubscribe_seo = subscribe(seo, (value) => $seo = value);
  let { title } = $$props;
  let { description } = $$props;
  set_store_value(seo, $seo = { title, description }, $seo);
  if ($$props.title === void 0 && $$bindings.title && title !== void 0)
    $$bindings.title(title);
  if ($$props.description === void 0 && $$bindings.description && description !== void 0)
    $$bindings.description(description);
  $$result.css.add(css$d);
  $$unsubscribe_seo();
  return `${validate_component(Content, "Transition").$$render($$result, {}, {}, {})}
<main class="${"svelte-3tm1lf"}">${validate_component(BackTo, "BackTo").$$render($$result, {
    href: "/project",
    text: "Projects",
    classes: "page-overline"
  }, {}, {})}
  <h1 class="${"page-title"}">${escape(title)}</h1>
  <div class="${"project transition-content svelte-3tm1lf"}">${slots.default ? slots.default({}) : ``}
    ${validate_component(BackTo, "BackTo").$$render($$result, {
    href: "/project",
    text: "Back to all projects",
    classes: "border-top"
  }, {}, {})}</div>
</main>`;
});
var layout$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Layout$2
});
var css$c = {
  code: ".centered.svelte-1s66x9g{display:block;margin:1rem auto}.fullscreen-unscrollable.svelte-1s66x9g{width:100vw;height:100vh;background:rgba(0, 0, 0, 0.7);position:fixed;top:0;left:0;z-index:5;display:flex;place-items:center;justify-content:center}img.svelte-1s66x9g:not(.expanded){cursor:zoom-in}img.href.svelte-1s66x9g{cursor:pointer}.expanded.svelte-1s66x9g{z-index:100;max-height:95%;max-width:95%;left:50%;top:50%;position:fixed;transform:translate(-50%, -50%);border-radius:5px;cursor:zoom-out}@media screen and (max-width: 768px){img.svelte-1s66x9g{width:100% !important}}",
  map: '{"version":3,"file":"Image.svelte","sources":["Image.svelte"],"sourcesContent":["<script>\\n  export let src;\\n  export let alt;\\n  export let width = \\"100%\\";\\n  export let centered = false;\\n  export let style = \\"\\";\\n  export let href = null;\\n\\n  import { fade } from \\"svelte/transition\\";\\n\\n  let expanded = false;\\n\\n  const toggleExpand = function () {\\n    if (href) {\\n      return;\\n    }\\n    expanded = !expanded;\\n  };\\n<\/script>\\n\\n<svelte:window\\n  on:scroll={() => {\\n    expanded ? (expanded = false) : null;\\n  }}\\n  on:keydown={(e) => {\\n    e.key == \\"Escape\\" ? (expanded = false) : null;\\n  }}\\n/>\\n\\n{#if expanded}\\n  <div\\n    transition:fade\\n    class=\\"fullscreen-unscrollable\\"\\n    on:click={() => {\\n      expanded = false;\\n    }}\\n  />\\n  <img transition:fade class=\\"expanded\\" {src} {alt} on:click={toggleExpand} />\\n{/if}\\n<a {href} target=\\"_blank\\" class=\\"no-underline\\">\\n  <img\\n    {src}\\n    {alt}\\n    {width}\\n    {style}\\n    on:click={toggleExpand}\\n    class:centered\\n    class:href\\n  />\\n</a>\\n\\n<style>\\n  .centered {\\n    display: block;\\n    margin: 1rem auto;\\n  }\\n\\n  .fullscreen-unscrollable {\\n    width: 100vw;\\n    height: 100vh;\\n    background: rgba(0, 0, 0, 0.7);\\n    position: fixed;\\n    top: 0;\\n    left: 0;\\n    z-index: 5;\\n    display: flex;\\n    place-items: center;\\n    justify-content: center;\\n  }\\n\\n  img:not(.expanded) {\\n    cursor: zoom-in;\\n  }\\n\\n  img.href {\\n    cursor: pointer;\\n  }\\n\\n  .expanded {\\n    z-index: 100;\\n    max-height: 95%;\\n    max-width: 95%;\\n    left: 50%;\\n    top: 50%;\\n    position: fixed;\\n    transform: translate(-50%, -50%);\\n    border-radius: 5px;\\n    cursor: zoom-out;\\n  }\\n\\n  @media screen and (max-width: 768px) {\\n    img {\\n      width: 100% !important;\\n    }\\n  }\\n</style>\\n"],"names":[],"mappings":"AAoDE,SAAS,eAAC,CAAC,AACT,OAAO,CAAE,KAAK,CACd,MAAM,CAAE,IAAI,CAAC,IAAI,AACnB,CAAC,AAED,wBAAwB,eAAC,CAAC,AACxB,KAAK,CAAE,KAAK,CACZ,MAAM,CAAE,KAAK,CACb,UAAU,CAAE,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAC9B,QAAQ,CAAE,KAAK,CACf,GAAG,CAAE,CAAC,CACN,IAAI,CAAE,CAAC,CACP,OAAO,CAAE,CAAC,CACV,OAAO,CAAE,IAAI,CACb,WAAW,CAAE,MAAM,CACnB,eAAe,CAAE,MAAM,AACzB,CAAC,AAED,kBAAG,KAAK,SAAS,CAAC,AAAC,CAAC,AAClB,MAAM,CAAE,OAAO,AACjB,CAAC,AAED,GAAG,KAAK,eAAC,CAAC,AACR,MAAM,CAAE,OAAO,AACjB,CAAC,AAED,SAAS,eAAC,CAAC,AACT,OAAO,CAAE,GAAG,CACZ,UAAU,CAAE,GAAG,CACf,SAAS,CAAE,GAAG,CACd,IAAI,CAAE,GAAG,CACT,GAAG,CAAE,GAAG,CACR,QAAQ,CAAE,KAAK,CACf,SAAS,CAAE,UAAU,IAAI,CAAC,CAAC,IAAI,CAAC,CAChC,aAAa,CAAE,GAAG,CAClB,MAAM,CAAE,QAAQ,AAClB,CAAC,AAED,OAAO,MAAM,CAAC,GAAG,CAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AACpC,GAAG,eAAC,CAAC,AACH,KAAK,CAAE,IAAI,CAAC,UAAU,AACxB,CAAC,AACH,CAAC"}'
};
var Image = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { src: src2 } = $$props;
  let { alt } = $$props;
  let { width = "100%" } = $$props;
  let { centered = false } = $$props;
  let { style: style2 = "" } = $$props;
  let { href = null } = $$props;
  if ($$props.src === void 0 && $$bindings.src && src2 !== void 0)
    $$bindings.src(src2);
  if ($$props.alt === void 0 && $$bindings.alt && alt !== void 0)
    $$bindings.alt(alt);
  if ($$props.width === void 0 && $$bindings.width && width !== void 0)
    $$bindings.width(width);
  if ($$props.centered === void 0 && $$bindings.centered && centered !== void 0)
    $$bindings.centered(centered);
  if ($$props.style === void 0 && $$bindings.style && style2 !== void 0)
    $$bindings.style(style2);
  if ($$props.href === void 0 && $$bindings.href && href !== void 0)
    $$bindings.href(href);
  $$result.css.add(css$c);
  return `

${``}
<a${add_attribute("href", href, 0)} target="${"_blank"}" class="${"no-underline"}"><img${add_attribute("src", src2, 0)}${add_attribute("alt", alt, 0)}${add_attribute("width", width, 0)}${add_attribute("style", style2, 0)} class="${["svelte-1s66x9g", (centered ? "centered" : "") + " " + (href ? "href" : "")].join(" ").trim()}">
</a>`;
});
var metadata$L = {
  "layout": "project",
  "title": "Mapping Houston Homicides",
  "description": "An exploration of homicides in Houston.",
  "date": "2020-02-04",
  "audience": "Rice Datathon",
  "featured": false,
  "image": "map-houston-homicides/header.png",
  "img_alt": "An example screen of the 'Mapping Houston Homicides' article",
  "techstack": "Mapbox, R",
  "github": "https://github.com/connorrothschild/datathon-2020/",
  "url": "https://connorrothschild.github.io/datathon-2020/source"
};
var Map_houston_homicides = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${validate_component(Layout$2, "Layout_MDSVEX_DEFAULT").$$render($$result, Object.assign($$props, metadata$L), {}, {
    default: () => `${validate_component(Image, "Image").$$render($$result, {
      href: "https://connorrothschild.github.io/datathon-2020/source/",
      src: "/images/project/map-houston-homicides/header.png",
      alt: "Header"
    }, {}, {})}
<h1 id="${"what-it-is"}"><a href="${"#what-it-is"}">What it is</a></h1>
<p><a href="${"https://connorrothschild.github.io/datathon-2020/source/"}" rel="${"nofollow"}"><strong>Mapping Houston Homicides</strong></a> is a visual storytelling piece focused on homicides in Houston. It was recognized as the winner of the Houston/Trends track at the <a href="${"http://news.rice.edu/2020/02/10/rice-students-sweep-second-datathon/"}" rel="${"nofollow"}">2020 Rice Datathon</a>.</p>
<h1 id="${"tools-used"}"><a href="${"#tools-used"}">Tools used</a></h1>
<p>This project was an example of a low-code but high-impact story. Rather than reinventing the wheel and implementing my own scrollytelling capabilities, my team used two tools from Mapbox: their <a href="${"https://www.mapbox.com/solutions/interactive-storytelling"}" rel="${"nofollow"}">interactive storytelling template</a> and <a href="${"https://www.mapbox.com/mapbox-studio"}" rel="${"nofollow"}">Mapbox Studio</a>. In combination, we were able to write very little code but provide a highly tailored, powerful user experience for the reader.</p>
<p>We used Mapbox Studio to create each of the bubbles that is present on the map. As a corollary, we used Studio to define the size, fill, and location of each bubble. we created many different layers that toggled visibility on scroll.</p>
<p>To trigger scroll events, We used the Mapbox storytelling template. This was a simple JSON where, for each \u2018view\u2019, I defined three elements: the <em>text</em>, the <em>layer</em>, and the <em>location</em>.</p>
<h1 id="${"project-images"}"><a href="${"#project-images"}">Project images</a></h1>
${validate_component(Image, "Image").$$render($$result, {
      style: "box-shadow: none;",
      src: "/images/project/map-houston-homicides/mac-1.png",
      alt: "Project image for 'Mapping Houston Homicides'",
      width: "48%"
    }, {}, {})}
${validate_component(Image, "Image").$$render($$result, {
      style: "box-shadow: none;",
      src: "/images/project/map-houston-homicides/mac-2.png",
      alt: "Project image for 'Mapping Houston Homicides'",
      width: "48%"
    }, {}, {})}
${validate_component(Image, "Image").$$render($$result, {
      style: "box-shadow: none;",
      src: "/images/project/map-houston-homicides/mac-3.png",
      alt: "Project image for 'Mapping Houston Homicides'",
      width: "48%"
    }, {}, {})}
${validate_component(Image, "Image").$$render($$result, {
      style: "box-shadow: none;",
      src: "/images/project/map-houston-homicides/mac-4.png",
      alt: "Project image for 'Mapping Houston Homicides'",
      width: "48%"
    }, {}, {})}
${validate_component(Image, "Image").$$render($$result, {
      style: "box-shadow: none;",
      src: "/images/project/map-houston-homicides/phone-1.png",
      alt: "Project image for 'Mapping Houston Homicides'",
      width: "32%"
    }, {}, {})}
${validate_component(Image, "Image").$$render($$result, {
      style: "box-shadow: none;",
      src: "/images/project/map-houston-homicides/phone-2.png",
      alt: "Project image for 'Mapping Houston Homicides'",
      width: "32%"
    }, {}, {})}
${validate_component(Image, "Image").$$render($$result, {
      style: "box-shadow: none;",
      src: "/images/project/map-houston-homicides/phone-3.png",
      alt: "Project image for 'Mapping Houston Homicides'",
      width: "32%"
    }, {}, {})}`
  })}`;
});
var mapHoustonHomicides = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Map_houston_homicides,
  metadata: metadata$L
});
var metadata$K = {
  "layout": "project",
  "title": "How Much Does Your State Spend on Police?",
  "description": "Contextualizing police spending in your state.",
  "date": "2020-06-02",
  "audience": "The world!",
  "featured": false,
  "image": "state-police-spending/header.png",
  "img_alt": "State police spending header, includes an image of a MacBook with the application open.",
  "techstack": "D3.js",
  "github": "https://github.com/connorrothschild/state-police-spending",
  "url": "https://connorrothschild.github.io/state-police-spending/"
};
var State_police_spending = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${validate_component(Layout$2, "Layout_MDSVEX_DEFAULT").$$render($$result, Object.assign($$props, metadata$K), {}, {
    default: () => `${validate_component(Image, "Image").$$render($$result, {
      href: "https://connorrothschild.github.io/state-police-spending/",
      src: "/images/project/state-police-spending/header.png",
      alt: "Header"
    }, {}, {})}
<h1 id="${"what-it-is"}"><a href="${"#what-it-is"}">What it is</a></h1>
<p><a href="${"https://connorrothschild.github.io/state-police-spending/"}" rel="${"nofollow"}"><strong>How Much Does Your State Spend on Police?</strong></a> allows users to compare their state\u2019s police spending to a variety of equivalent costing programs, such as residential drug treatment programs or additional SNAP recipients. The goal is to contextualize police spending in numbers that everyone can understand, in particular by comparing it to other known programs.</p>
<h1 id="${"tools-used"}"><a href="${"#tools-used"}">Tools used</a></h1>
<p>I used <a href="${"https://d3js.org/"}" rel="${"nofollow"}">D3.js</a> for the minor visualization that accompanies these numbers. The rest of the computation is done by simply dividing the state\u2019s police spending by a specified denominator, one for each metric. This was a technically simple project. The goal is not to amaze, but to provide simple, easy comparisons that better inform the user about their state\u2019s police spending.</p>
<h1 id="${"project-images"}"><a href="${"#project-images"}">Project images</a></h1>
${validate_component(Image, "Image").$$render($$result, {
      style: "box-shadow: none;",
      src: "/images/project/state-police-spending/mac.png",
      alt: "Project image for 'How Much Does Your State Spend on Police?'",
      width: "74%"
    }, {}, {})}
${validate_component(Image, "Image").$$render($$result, {
      style: "box-shadow: none;",
      src: "/images/project/state-police-spending/phone.png",
      alt: "Project image for 'How Much Does Your State Spend on Police?'",
      width: "22%"
    }, {}, {})}`
  })}`;
});
var statePoliceSpending = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": State_police_spending,
  metadata: metadata$K
});
var metadata$J = {
  "layout": "project",
  "title": "The Bob Ross Virtual Art Gallery",
  "description": "A visual, virtual tour of every piece in The Joy of Painting.",
  "date": "2021-03-22",
  "audience": "The world!",
  "featured": true,
  "image": "bob-ross-art-gallery/header.png",
  "img_alt": 'A header image that says "The Bob Ross (virtual) Art Gallery"',
  "techstack": "D3.js, Svelte, R, Scrollama",
  "github": "https://github.com/connorrothschild/bob-ross-art-gallery/",
  "url": "https://connorrothschild.github.io/bob-ross-art-gallery/"
};
var Bob_ross_art_gallery = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${validate_component(Layout$2, "Layout_MDSVEX_DEFAULT").$$render($$result, Object.assign($$props, metadata$J), {}, {
    default: () => `${validate_component(Image, "Image").$$render($$result, {
      href: "https://connorrothschild.github.io/bob-ross-art-gallery/",
      src: "/images/project/bob-ross-art-gallery/header.png",
      alt: "Header"
    }, {}, {})}
<h1 id="${"what-it-is"}"><a href="${"#what-it-is"}">What it is</a></h1>
<p><a href="${"https://connorrothschild.github.io/bob-ross-art-gallery/"}" rel="${"nofollow"}"><strong>The Bob Ross Virtual Art Gallery</strong></a> is a visual storytelling piece analyzing Bob Ross\u2019 series <em>The Joy of Painting</em>. </p>

<p>It has since been retired due to a cease and desist from Bob Ross, Inc. Before that, it attracted media attention from <a href="${"https://www.yahoo.com/now/bob-ross-virtual-gallery-offers-195835693.html"}" rel="${"nofollow"}">Yahoo</a>, <a href="${"https://nerdist.com/article/bob-ross-virtual-gallery-art/"}" rel="${"nofollow"}">Nerdist</a>, <a href="${"https://www.openculture.com/2021/06/the-bob-ross-virtual-art-gallery.html"}" rel="${"nofollow"}">OpenCulture</a>, <a href="${"https://www.fatherly.com/play/bob-ross-virtual-art-gallery-perfect-relax/"}" rel="${"nofollow"}">Fatherly</a>, <a href="${"https://designtaxi.com/news/414284/Bob-Ross-Virtual-Art-Gallery-Lets-You-Take-A-Happy-Little-Break-To-See-His-Art/"}" rel="${"nofollow"}">DesignTaxi</a>, <a href="${"https://flowingdata.com/2021/06/01/colors-of-bob-ross-explored/"}" rel="${"nofollow"}">FlowingData</a> and others. It also won first place in the Standalone Multimedia category at the Society for News Design\u2019s <a href="${"https://msusnd.org/2021-college-design-contest/"}" rel="${"nofollow"}">2021 Student Design Contest</a>.</p>
<h1 id="${"tools-used"}"><a href="${"#tools-used"}">Tools used</a></h1>
<p>I used <a href="${"https://svelte.dev/"}" rel="${"nofollow"}">Svelte</a> and <a href="${"https://d3js.org/"}" rel="${"nofollow"}">D3.js</a> for all things visual and front-end. I used The Pudding\u2019s <a href="${"https://github.com/the-pudding/svelte-starter"}" rel="${"nofollow"}">Svelte Starter template</a> which made configuration much easier, and made a lot of the visual aspects of the project less difficult to create (e.g. their <code>Window</code> component simplified resize events a ton).</p>
<p>For the scroll-based interactions, I used Russell Goldenberg\u2019s <a href="${"https://github.com/russellgoldenberg/scrollama"}" rel="${"nofollow"}">Scrollama</a>. As of the creation of this project, there is no formal or official Svelte-based scrollytelling library. I therefore used Scrollama in its vanilla form, and plugged it into the Svelte component as if I were writing normal JavaScript.</p>
<h1 id="${"project-images"}"><a href="${"#project-images"}">Project images</a></h1>
${validate_component(Image, "Image").$$render($$result, {
      style: "box-shadow: none;",
      src: "/images/project/bob-ross-art-gallery/mac-1.png",
      alt: "Project image for 'The Bob Ross Virtual Art Gallery'",
      width: "74%"
    }, {}, {})}
${validate_component(Image, "Image").$$render($$result, {
      style: "box-shadow: none;",
      src: "/images/project/bob-ross-art-gallery/iphone-1.png",
      alt: "Project image for 'The Bob Ross Virtual Art Gallery'",
      width: "22%"
    }, {}, {})}
${validate_component(Image, "Image").$$render($$result, {
      style: "box-shadow: none;",
      src: "/images/project/bob-ross-art-gallery/iphone-2.png",
      alt: "Project image for 'The Bob Ross Virtual Art Gallery'",
      width: "22%"
    }, {}, {})}
${validate_component(Image, "Image").$$render($$result, {
      style: "box-shadow: none;",
      src: "/images/project/bob-ross-art-gallery/mac-2.png",
      alt: "Project image for 'The Bob Ross Virtual Art Gallery'",
      width: "74%"
    }, {}, {})}
${validate_component(Image, "Image").$$render($$result, {
      style: "box-shadow: none;",
      src: "/images/project/bob-ross-art-gallery/iphone-3.png",
      alt: "Project image for 'The Bob Ross Virtual Art Gallery'",
      width: "18%"
    }, {}, {})}
${validate_component(Image, "Image").$$render($$result, {
      style: "box-shadow: none;",
      src: "/images/project/bob-ross-art-gallery/mac-3.png",
      alt: "Project image for 'The Bob Ross Virtual Art Gallery'",
      width: "58%"
    }, {}, {})}
${validate_component(Image, "Image").$$render($$result, {
      style: "box-shadow: none;",
      src: "/images/project/bob-ross-art-gallery/iphone-4.png",
      alt: "Project image for 'The Bob Ross Virtual Art Gallery'",
      width: "18%"
    }, {}, {})}
${validate_component(Image, "Image").$$render($$result, {
      style: "box-shadow: none;",
      src: "/images/project/bob-ross-art-gallery/mac-4.png",
      alt: "Project image for 'The Bob Ross Virtual Art Gallery'",
      width: "48%"
    }, {}, {})}
${validate_component(Image, "Image").$$render($$result, {
      style: "box-shadow: none;",
      src: "/images/project/bob-ross-art-gallery/mac-5.png",
      alt: "Project image for 'The Bob Ross Virtual Art Gallery'",
      width: "48%"
    }, {}, {})}
`
  })}`;
});
var bobRossArtGallery = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Bob_ross_art_gallery,
  metadata: metadata$J
});
var metadata$I = {
  "layout": "project",
  "title": "Mapping Missing Migrants",
  "description": "Documenting migrants who have lost their lives while seeking refuge.",
  "date": "2019-10-22",
  "audience": "The world!",
  "featured": true,
  "image": "map-missing-migrants/header.png",
  "img_alt": "An example screen of the 'Mapping Missing Migrants' article",
  "techstack": "Mapbox, R",
  "github": "https://github.com/connorrothschild/map-missing-migrants/",
  "url": "https://connorrothschild.github.io/map-missing-migrants"
};
var Map_missing_migrants = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${validate_component(Layout$2, "Layout_MDSVEX_DEFAULT").$$render($$result, Object.assign($$props, metadata$I), {}, {
    default: () => `${validate_component(Image, "Image").$$render($$result, {
      href: "https://connorrothschild.github.io/map-missing-migrants",
      src: "/images/project/map-missing-migrants/header.png",
      alt: "Header"
    }, {}, {})}
<h1 id="${"what-it-is"}"><a href="${"#what-it-is"}">What it is</a></h1>
<p><a href="${"https://connorrothschild.github.io/map-missing-migrants/"}" rel="${"nofollow"}"><strong>Mapping Missing Migrants</strong></a> is a visual storytelling piece focused on migrants and refugees who have lost their lives while traveling to another country. It was awarded the Student Bronze in the <a href="${"https://www.malofiejgraphics.com/general/students-have-won-awards-too/2020/08"}" rel="${"nofollow"}">28th Malofiej Awards</a>.</p>
<h1 id="${"tools-used"}"><a href="${"#tools-used"}">Tools used</a></h1>
<p>This project was an example of a low-code but high-impact story. Rather than reinventing the wheel and implementing my own scrollytelling capabilities, I used two tools from Mapbox: their <a href="${"https://www.mapbox.com/solutions/interactive-storytelling"}" rel="${"nofollow"}">interactive storytelling template</a> and <a href="${"https://www.mapbox.com/mapbox-studio"}" rel="${"nofollow"}">Mapbox Studio</a>. In combination, I was able to write very little code but provide a highly tailored, powerful user experience for the reader.</p>
<p>I used Mapbox Studio to create each of the bubbles that is present on the map. As a corollary, I used Studio to define the size, fill, and location of each bubble. I created many different layers that toggled visibility on scroll.</p>
<p>To trigger scroll events, I used the Mapbox storytelling template. This was a simple JSON where, for each \u2018view\u2019, I defined three elements: the <em>text</em>, the <em>layer</em>, and the <em>location</em>.</p>
<h1 id="${"project-images"}"><a href="${"#project-images"}">Project images</a></h1>
${validate_component(Image, "Image").$$render($$result, {
      style: "box-shadow: none;",
      src: "/images/project/map-missing-migrants/mac-1.png",
      alt: "Project image for 'Mapping Missing Migrants'",
      width: "100%"
    }, {}, {})}
${validate_component(Image, "Image").$$render($$result, {
      style: "box-shadow: none;",
      src: "/images/project/map-missing-migrants/mac-2.png",
      alt: "Project image for 'Mapping Missing Migrants'",
      width: "48%"
    }, {}, {})}
${validate_component(Image, "Image").$$render($$result, {
      style: "box-shadow: none;",
      src: "/images/project/map-missing-migrants/mac-3.png",
      alt: "Project image for 'Mapping Missing Migrants'",
      width: "48%"
    }, {}, {})}
${validate_component(Image, "Image").$$render($$result, {
      style: "box-shadow: none;",
      src: "/images/project/map-missing-migrants/mac-4.png",
      alt: "Project image for 'Mapping Missing Migrants'",
      width: "48%"
    }, {}, {})}
${validate_component(Image, "Image").$$render($$result, {
      style: "box-shadow: none;",
      src: "/images/project/map-missing-migrants/mac-5.png",
      alt: "Project image for 'Mapping Missing Migrants'",
      width: "48%"
    }, {}, {})}
${validate_component(Image, "Image").$$render($$result, {
      style: "box-shadow: none;",
      src: "/images/project/map-missing-migrants/phone-1.png",
      alt: "Project image for 'Mapping Missing Migrants'",
      width: "32%"
    }, {}, {})}
${validate_component(Image, "Image").$$render($$result, {
      style: "box-shadow: none;",
      src: "/images/project/map-missing-migrants/phone-2.png",
      alt: "Project image for 'Mapping Missing Migrants'",
      width: "32%"
    }, {}, {})}
${validate_component(Image, "Image").$$render($$result, {
      style: "box-shadow: none;",
      src: "/images/project/map-missing-migrants/phone-3.png",
      alt: "Project image for 'Mapping Missing Migrants'",
      width: "32%"
    }, {}, {})}`
  })}`;
});
var mapMissingMigrants = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Map_missing_migrants,
  metadata: metadata$I
});
var metadata$H = {
  "layout": "project",
  "title": "How Many People Have Had COVID-19?",
  "description": "A novel way to visualize COVID-19 case counts.",
  "date": "2020-11-06",
  "audience": "The world!",
  "featured": false,
  "image": "how-many-people/header.png",
  "img_alt": "An example screen of the 'How Many People' application",
  "techstack": "D3.js, Vue.js, Bulma",
  "github": "https://github.com/connorrothschild/how-many-people",
  "url": "https://connorrothschild.github.io/how-many-people"
};
var How_many_people = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${validate_component(Layout$2, "Layout_MDSVEX_DEFAULT").$$render($$result, Object.assign($$props, metadata$H), {}, {
    default: () => `${validate_component(Image, "Image").$$render($$result, {
      href: "https://connorrothschild.github.io/how-many-people",
      src: "/images/project/how-many-people/header.png",
      alt: "Header"
    }, {}, {})}
<h1 id="${"what-it-is"}"><a href="${"#what-it-is"}">What it is</a></h1>
<p><a href="${"https://connorrothschild.github.io/how-many-people"}" rel="${"nofollow"}">How Many People Have Had COVID-19?</a> is a small web application that visualizes COVID-19 case counts in a novel way: via state populations. The application\u2019s user can see cases either in the US or globally. The goal is to capture case counts with some comparison that everyone can understand.</p>
<h1 id="${"tools-used"}"><a href="${"#tools-used"}">Tools used</a></h1>
<p>This application was built with <a href="${"https://vuejs.org/"}" rel="${"nofollow"}">Vue</a>. The minimal styling was thanks to <a href="${"https://bulma.io/"}" rel="${"nofollow"}">Bulma</a>, my framework of choice recently. The application was simpler than some others I have built (there were only <a href="${"https://github.com/connorrothschild/how-many-people/tree/master/src/components"}" rel="${"nofollow"}">three components</a>). It was mostly a fun exercise to play around with SVGs and Vue, and also an exercise to better handle user interactions. The tool needed to be robust to many changes, including 1) the adding of state populations together, 2) a \u2018ceiling\u2019 (the case counts) that state populations could not exceed, 3) resets on toggle of US/global views.</p>
<h1 id="${"project-images"}"><a href="${"#project-images"}">Project images</a></h1>
${validate_component(Image, "Image").$$render($$result, {
      style: "box-shadow: none;",
      src: "/images/project/how-many-people/mac-1.png",
      alt: "Project image for 'How Many People Have COVID-19??'"
    }, {}, {})}
${validate_component(Image, "Image").$$render($$result, {
      style: "box-shadow: none;",
      src: "/images/project/how-many-people/mac-2.png",
      alt: "Project image for 'How Many People Have COVID-19??'"
    }, {}, {})}
${validate_component(Image, "Image").$$render($$result, {
      style: "box-shadow: none;",
      src: "/images/project/how-many-people/phone-1.png",
      alt: "Project image for 'How Many People Have COVID-19??'",
      width: "48%"
    }, {}, {})}
${validate_component(Image, "Image").$$render($$result, {
      style: "box-shadow: none;",
      src: "/images/project/how-many-people/phone-2.png",
      alt: "Project image for 'How Many People Have COVID-19??'",
      width: "48%"
    }, {}, {})}`
  })}`;
});
var howManyPeople = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": How_many_people,
  metadata: metadata$H
});
var metadata$G = {
  "layout": "project",
  "title": "Mapping Police Killings",
  "description": "Visualizing officer-involved deaths since 2013.",
  "date": "2020-12-22",
  "audience": "Mapping Police Violence",
  "featured": false,
  "image": "police-killings/header.png",
  "img_alt": "Police killings header, includes an image of a MacBook with the application open.",
  "techstack": "D3.js, Vue.js, Bulma, R",
  "github": "https://github.com/connorrothschild/police-killings",
  "url": "https://mappingpoliceviolence.org/"
};
var Police_killings = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${validate_component(Layout$2, "Layout_MDSVEX_DEFAULT").$$render($$result, Object.assign($$props, metadata$G), {}, {
    default: () => `${validate_component(Image, "Image").$$render($$result, {
      href: "https://connorrothschild.github.io/police-killings/",
      src: "/images/project/police-killings/header.png",
      alt: "Header"
    }, {}, {})}
<h1 id="${"what-it-is"}"><a href="${"#what-it-is"}">What it is</a></h1>
<p><a href="${"https://connorrothschild.github.io/police-killings/"}" rel="${"nofollow"}"><strong>Mapping Police Killings</strong></a> is an application that allows for user exploration of officer-involved deaths across any US city or state. It leverages data from <a href="${"https://mappingpoliceviolence.org/"}" rel="${"nofollow"}">Mapping Police Violence</a> and visualizes shootings in a geographic area using a <a href="${"https://observablehq.com/@d3/force-directed-graph"}" rel="${"nofollow"}">force-directed graph</a> built in D3. Users are able to filter by city or state, and upon initail selection, they are able to group by a variety of victim characteristics, such as age, race, armed status, or cause of death.</p>
<p>The application is featured on the <a href="${"https://mappingpoliceviolence.org/"}" rel="${"nofollow"}">Mapping Police Violence homepage</a>. It is seen by thousands of visitors on a daily basis.</p>
<h1 id="${"tools-used"}"><a href="${"#tools-used"}">Tools used</a></h1>
<p>I used <a href="${"https://vuejs.org/"}" rel="${"nofollow"}">Vue</a> to design the application and handle user interaction. I used <a href="${"https://d3js.org/"}" rel="${"nofollow"}">D3.js</a> for visualization and for its force-directed diagram capabilities. Additional styling was done with <a href="${"https://bulma.io/"}" rel="${"nofollow"}">Bulma</a>.</p>
<p>This was actually the second iteration of this visualization. <a href="${"https://connorrothschild.github.io/police-killings-v1/"}" rel="${"nofollow"}">Version 1 can be found here</a>. Although that version was <a href="${"https://github.com/connorrothschild/police-killings-v1"}" rel="${"nofollow"}">built</a> with vanilla JavaScript and no CSS library (everything was built from scratch!). Upon deploying this to a more serious and more visited site (Mapping Police Violence\u2019s homepage), I decided an upgrade would be worth the investment.</p>
<h1 id="${"project-images"}"><a href="${"#project-images"}">Project images</a></h1>
${validate_component(Image, "Image").$$render($$result, {
      style: "box-shadow: none;",
      src: "/images/project/police-killings/mac-1.png",
      alt: "Project image for 'Mapping Police Killings'",
      width: "74%"
    }, {}, {})}
${validate_component(Image, "Image").$$render($$result, {
      style: "box-shadow: none;",
      src: "/images/project/police-killings/phone-1.png",
      alt: "Project image for 'Mapping Police Killings'",
      width: "22%"
    }, {}, {})}
${validate_component(Image, "Image").$$render($$result, {
      style: "box-shadow: none;",
      src: "/images/project/police-killings/phone-2.png",
      alt: "Project image for 'Mapping Police Killings'",
      width: "22%"
    }, {}, {})}
${validate_component(Image, "Image").$$render($$result, {
      style: "box-shadow: none;",
      src: "/images/project/police-killings/mac-2.png",
      alt: "Project image for 'Mapping Police Killings'",
      width: "74%"
    }, {}, {})}`
  })}`;
});
var policeKillings = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Police_killings,
  metadata: metadata$G
});
var metadata$F = {
  "layout": "project",
  "title": "The Race for Media Attention",
  "description": "Visualizing media coverage of 2020 presidential candidates over time.",
  "date": "2019-11-12",
  "audience": "The world!",
  "featured": false,
  "image": "media-mentions/header.png",
  "img_alt": "Media mentions header image, includes an image of a MacBook with the application open.",
  "techstack": "Observable",
  "github": "https://observablehq.com/@connorrothschild/bar-chart-race",
  "url": "https://observablehq.com/@connorrothschild/bar-chart-race"
};
var Media_mentions = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${validate_component(Layout$2, "Layout_MDSVEX_DEFAULT").$$render($$result, Object.assign($$props, metadata$F), {}, {
    default: () => `${validate_component(Image, "Image").$$render($$result, {
      href: "https://observablehq.com/@connorrothschild/bar-chart-race/",
      src: "/images/project/media-mentions/header.png",
      alt: "Header"
    }, {}, {})}
<h1 id="${"what-it-is"}"><a href="${"#what-it-is"}">What it is</a></h1>
<p><a href="${"https://observablehq.com/@connorrothschild/bar-chart-race"}" rel="${"nofollow"}"><strong>The Race for Media Attention?</strong></a> is an animated bar chart race depicting media mentions of Democratic presidential candidates during the 2020 presidential election. I made it before animated bar chart races were cool (and then <a href="${"https://www.newsbreak.com/news/1465770194170/reddits-dataisbeautiful-is-sick-of-bar-chart-races-so-its-banning-them"}" rel="${"nofollow"}">uncool</a>).</p>
<h1 id="${"tools-used"}"><a href="${"#tools-used"}">Tools used</a></h1>
<p>This project was built with <a href="${"https://observablehq.com/"}" rel="${"nofollow"}">Observable</a>. It was my first Observable notebook, and mostly an attempt to learn. (It was a fork of Mike Bostock\u2019s existing bar chart race.)</p>
<h1 id="${"project-images"}"><a href="${"#project-images"}">Project images</a></h1>
${validate_component(Image, "Image").$$render($$result, {
      style: "box-shadow: none;",
      src: "/images/project/media-mentions/mac.png",
      alt: "Project image for 'The Race for Media Attention'",
      width: "74%"
    }, {}, {})}
${validate_component(Image, "Image").$$render($$result, {
      style: "box-shadow: none;",
      src: "/images/project/media-mentions/phone.png",
      alt: "Project image for 'The Race for Media Attention'",
      width: "22%"
    }, {}, {})}`
  })}`;
});
var mediaMentions = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Media_mentions,
  metadata: metadata$F
});
var metadata$E = {
  "layout": "project",
  "title": "One Line Hacks",
  "description": "A collection of random utilities that I find myself Googling too often.",
  "date": "2021-05-01",
  "audience": "The world!",
  "featured": false,
  "image": "one-line-hacks/header.png",
  "img_alt": "One line hacks header image, includes an image of a MacBook with the application open.",
  "techstack": "JavaScript, Vue, Tailwind",
  "github": "https://connorrothschild.github.io/one-line-hacks/",
  "url": "https://connorrothschild.github.io/one-line-hacks/"
};
var One_line_hacks = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${validate_component(Layout$2, "Layout_MDSVEX_DEFAULT").$$render($$result, Object.assign($$props, metadata$E), {}, {
    default: () => `${validate_component(Image, "Image").$$render($$result, {
      href: "https://connorrothschild.github.io/one-line-hacks/",
      src: "/images/project/one-line-hacks/header.png",
      alt: "Header"
    }, {}, {})}
<h1 id="${"what-it-is"}"><a href="${"#what-it-is"}">What it is</a></h1>
<p><a href="${"https://connorrothschild.github.io/one-line-hacks/"}" rel="${"nofollow"}"><strong>One Line Hacks</strong></a> is a collection of random utilities and functions that I find myself Googling too often.</p>
<h1 id="${"tools-used"}"><a href="${"#tools-used"}">Tools used</a></h1>
<p>This small site was built with Vue and Tailwind. I use Nuxt and Nuxt Content for Markdown-based content creation.</p>
<h1 id="${"project-images"}"><a href="${"#project-images"}">Project images</a></h1>
${validate_component(Image, "Image").$$render($$result, {
      style: "box-shadow: none;",
      src: "/images/project/one-line-hacks/mac-1.png",
      alt: "Project image for the project 'One Line Hacks'",
      width: "74%"
    }, {}, {})}
${validate_component(Image, "Image").$$render($$result, {
      style: "box-shadow: none;",
      src: "/images/project/one-line-hacks/phone-1.png",
      alt: "Project image for the project 'One Line Hacks'",
      width: "22%"
    }, {}, {})}`
  })}`;
});
var oneLineHacks = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": One_line_hacks,
  metadata: metadata$E
});
var metadata$D = {
  "layout": "project",
  "title": "Texas School District COVID-19 Monitoring Dashboard",
  "description": "Informing data-driven decisions about school reopenings.",
  "date": "2021-05-05",
  "audience": "Texas policymakers, parents",
  "featured": false,
  "archived": true,
  "image": "tpl-schools-db/header.png",
  "img_alt": "TPL header image, includes an image of a MacBook with the application open.",
  "techstack": "R, Shiny",
  "url": "http://news.rice.edu/2021/05/05/dashboard-developed-at-rice-will-help-texas-schools-open-safely-amid-pandemic/"
};
var Tpl_schools_db = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${validate_component(Layout$2, "Layout_MDSVEX_DEFAULT").$$render($$result, Object.assign($$props, metadata$D), {}, {
    default: () => `${validate_component(Image, "Image").$$render($$result, {
      href: "http://news.rice.edu/2021/05/05/dashboard-developed-at-rice-will-help-texas-schools-open-safely-amid-pandemic/",
      src: "/images/project/tpl-schools-db/header.png",
      alt: "Header"
    }, {}, {})}
<h1 id="${"what-it-is"}"><a href="${"#what-it-is"}">What it is</a></h1>
<p><a href="${"http://news.rice.edu/2021/05/05/dashboard-developed-at-rice-will-help-texas-schools-open-safely-amid-pandemic/"}" rel="${"nofollow"}"><strong>The Texas School District COVID-19 Monitoring Dashboard</strong></a> was a dashboard built by my team at the Texas Policy Lab for Texas policymakers (and any other interested parties) to survey the landscape of COVID-19 in their school districts.</p>
<h1 id="${"tools-used"}"><a href="${"#tools-used"}">Tools used</a></h1>
<p>The app is built with R and is a Shiny web application. I was mostly responsible for the frontend development and some design. I helped less with the backend data retrieval, wrangling, and testing.</p>
<h1 id="${"project-images"}"><a href="${"#project-images"}">Project images</a></h1>
${validate_component(Image, "Image").$$render($$result, {
      style: "box-shadow: none;",
      src: "/images/project/tpl-schools-db/mac-1.png",
      alt: "Project image for the project 'I Can Guess What You're Doing Right Now'",
      width: "49%"
    }, {}, {})}
${validate_component(Image, "Image").$$render($$result, {
      style: "box-shadow: none;",
      src: "/images/project/tpl-schools-db/mac-2.png",
      alt: "Project image for the project 'I Can Guess What You're Doing Right Now'",
      width: "49%"
    }, {}, {})}
${validate_component(Image, "Image").$$render($$result, {
      style: "box-shadow: none;",
      src: "/images/project/tpl-schools-db/iphone-1.png",
      alt: "Project image for the project 'I Can Guess What You're Doing Right Now'",
      width: "31%"
    }, {}, {})}
${validate_component(Image, "Image").$$render($$result, {
      style: "box-shadow: none;",
      src: "/images/project/tpl-schools-db/iphone-2.png",
      alt: "Project image for the project 'I Can Guess What You're Doing Right Now'",
      width: "31%"
    }, {}, {})}
${validate_component(Image, "Image").$$render($$result, {
      style: "box-shadow: none;",
      src: "/images/project/tpl-schools-db/iphone-3.png",
      alt: "Project image for the project 'I Can Guess What You're Doing Right Now'",
      width: "31%"
    }, {}, {})}`
  })}`;
});
var tplSchoolsDb = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Tpl_schools_db,
  metadata: metadata$D
});
var metadata$C = {
  "layout": "project",
  "title": "Mask Wearing in Your County",
  "description": "Visualizing COVID-19 mask usage in your county.",
  "date": "2020-08-01",
  "audience": "The world!",
  "featured": false,
  "image": "covid-masking/header.png",
  "img_alt": "COVID masking header image, includes an image of a MacBook with the application open.",
  "techstack": "Observable",
  "github": "https://observablehq.com/@connorrothschild/mask-wearing-in-your-county",
  "url": "https://observablehq.com/@connorrothschild/mask-wearing-in-your-county"
};
var Covid_masking = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${validate_component(Layout$2, "Layout_MDSVEX_DEFAULT").$$render($$result, Object.assign($$props, metadata$C), {}, {
    default: () => `${validate_component(Image, "Image").$$render($$result, {
      href: "https://observablehq.com/@connorrothschild/mask-wearing-in-your-county",
      src: "/images/project/covid-masking/header.png",
      alt: "Header"
    }, {}, {})}
<h1 id="${"what-it-is"}"><a href="${"#what-it-is"}">What it is</a></h1>
<p><a href="${"https://observablehq.com/@connorrothschild/mask-wearing-in-your-county"}" rel="${"nofollow"}"><strong>Mask Wearing in Your County</strong></a> is an Observable notebook that allows users to explore mask wearing in their county, compared to COVID-19 case counts and mask wearing in other counties.</p>
<h1 id="${"tools-used"}"><a href="${"#tools-used"}">Tools used</a></h1>
<p>This project was exclusively built with <a href="${"https://observablehq.com/"}" rel="${"nofollow"}">Observable</a>. The notebook contains a series of visualizations, each of which build upon the prior. Altogether, the intention is to tell a <em>story</em> about masking, not just create a series of visuals.</p>
<h1 id="${"project-images"}"><a href="${"#project-images"}">Project images</a></h1>
${validate_component(Image, "Image").$$render($$result, {
      style: "box-shadow: none;",
      src: "/images/project/covid-masking/mac-1.png",
      alt: "Project image for 'Mask Wearing in Your County'",
      width: "100%"
    }, {}, {})}
${validate_component(Image, "Image").$$render($$result, {
      style: "box-shadow: none;",
      src: "/images/project/covid-masking/mac-2.png",
      alt: "Project image for 'Mask Wearing in Your County'",
      width: "32%"
    }, {}, {})}
${validate_component(Image, "Image").$$render($$result, {
      style: "box-shadow: none;",
      src: "/images/project/covid-masking/mac-3.png",
      alt: "Project image for 'Mask Wearing in Your County'",
      width: "32%"
    }, {}, {})}
${validate_component(Image, "Image").$$render($$result, {
      style: "box-shadow: none;",
      src: "/images/project/covid-masking/mac-4.png",
      alt: "Project image for 'Mask Wearing in Your County'",
      width: "32%"
    }, {}, {})}
${validate_component(Image, "Image").$$render($$result, {
      style: "box-shadow: none;",
      src: "/images/project/covid-masking/phone-1.png",
      alt: "Project image for 'Mask Wearing in Your County'",
      width: "48%"
    }, {}, {})}
${validate_component(Image, "Image").$$render($$result, {
      style: "box-shadow: none;",
      src: "/images/project/covid-masking/phone-2.png",
      alt: "Project image for 'Mask Wearing in Your County'",
      width: "48%"
    }, {}, {})}
${validate_component(Image, "Image").$$render($$result, {
      style: "box-shadow: none;",
      src: "/images/project/covid-masking/mac-5.png",
      alt: "Project image for 'Mask Wearing in Your County'",
      width: "74%"
    }, {}, {})}
${validate_component(Image, "Image").$$render($$result, {
      style: "box-shadow: none;",
      src: "/images/project/covid-masking/phone-3.png",
      alt: "Project image for 'Mask Wearing in Your County'",
      width: "24%"
    }, {}, {})}`
  })}`;
});
var covidMasking = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Covid_masking,
  metadata: metadata$C
});
var metadata$B = {
  "layout": "project",
  "title": "Quarantunes",
  "description": "Explore your listening history during COVID-19.",
  "date": "2020-10-22",
  "audience": "The world (2000 users)",
  "featured": true,
  "image": "quarantunes/header.png",
  "img_alt": "Quarantunes header, includes an image of a MacBook with the application open.",
  "techstack": "D3.js, Vue.js, Bulma, R, Spotify API",
  "github": "https://github.com/connorrothschild/quarantunes",
  "url": "https://quarantune.netlify.app"
};
var Quarantunes = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${validate_component(Layout$2, "Layout_MDSVEX_DEFAULT").$$render($$result, Object.assign($$props, metadata$B), {}, {
    default: () => `${validate_component(Image, "Image").$$render($$result, {
      href: "https://quarantune.netlify.app",
      src: "/images/project/quarantunes/header.png",
      alt: "Header"
    }, {}, {})}
<h1 id="${"what-it-is"}"><a href="${"#what-it-is"}">What it is</a></h1>
<p><a href="${"https://quarantune.netlify.app"}" rel="${"nofollow"}"><strong>Quarantunes</strong></a> is an application for Spotify users to explore their listening history during the COVID-19 pandemic. It has been used by over 4,000 visitors.
There are three tabs within the application.
The first showcases \u2018top artists\u2019 and \u2018top tracks\u2019 throughout the pandemic.
The second shows some statistics about tracks according to Spotify\u2019s <a href="${"https://developer.spotify.com/documentation/web-api/reference/#endpoint-get-audio-features"}" rel="${"nofollow"}">audio features</a> (e.g. which of your top songs is most danceable?).
The last tab creates two playlists for the user: one with their top tracks and another with recommendations for future listening.</p>
<h1 id="${"tools-used"}"><a href="${"#tools-used"}">Tools used</a></h1>
<p>I used <a href="${"https://vuejs.org/"}" rel="${"nofollow"}">Vue</a> to design the majority of this application. Charts were built using <a href="${"https://www.chartjs.org/"}" rel="${"nofollow"}">Chart.js</a>. This was my first serious project working with the <a href="${"https://developer.spotify.com/documentation/web-api/"}" rel="${"nofollow"}">Spotify API</a>. Perhaps the greatest lessons I learned throughout this process were related to API calls, asynchronous code, and race conditions. I also learned a bit about cookies; because the application creates a \u2018recommended\u2019 playlist for users, I had to store whether they had visited the site before to prevent creating multiple playlists on app reloads.</p>
<p>I also had some fun developing the more novel contributions of this project, such as a \u2018recommended\u2019 artist and a whole playlist of recommended songs. For recommended artists, I scraped a users\u2019 top 50 artists, and for each of those artists, pulled 20 <a href="${"https://developer.spotify.com/documentation/web-api/reference/#endpoint-get-an-artists-related-artists"}" rel="${"nofollow"}">\u2018related\u2019 artists</a> according to Spotify. Then, I appended all 1000 (50 x 20) of those artists into one array, and presented the one that appeared most frequently to the user. As for the playlist, I took the users\u2019 top 5 tracks and gathered 4 <a href="${"https://developer.spotify.com/console/get-recommendations/"}" rel="${"nofollow"}">\u2018seed\u2019 recommendations</a> based on those tracks. Voila! A playlist of 20 recommendations.</p>
<h1 id="${"project-images"}"><a href="${"#project-images"}">Project images</a></h1>
${validate_component(Image, "Image").$$render($$result, {
      style: "box-shadow: none;",
      src: "/images/project/quarantunes/macbook.png",
      alt: "Project image for 'Quarantunes'"
    }, {}, {})}
${validate_component(Image, "Image").$$render($$result, {
      style: "box-shadow: none;",
      src: "/images/project/quarantunes/side-by-side.png",
      alt: "Project image for 'Quarantunes'"
    }, {}, {})}`
  })}`;
});
var quarantunes = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Quarantunes,
  metadata: metadata$B
});
var metadata$A = {
  "layout": "project",
  "title": "How Much Does Kid Cudi Hum?",
  "description": "An extensive analysis of music's most famous hum.",
  "date": "2020-12-31",
  "audience": "The world!",
  "featured": true,
  "image": "cudi-hums/header.png",
  "img_alt": 'A header image that says "how much does Kid Cudi hum?"',
  "techstack": "D3.js, Vue.js, Bulma, R, Scrollama, Genius API",
  "github": "https://github.com/connorrothschild/cudi-hums",
  "url": "https://connorrothschild.github.io/cudi-hums/"
};
var Cudi_hums = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${validate_component(Layout$2, "Layout_MDSVEX_DEFAULT").$$render($$result, Object.assign($$props, metadata$A), {}, {
    default: () => `${validate_component(Image, "Image").$$render($$result, {
      href: "https://connorrothschild.github.io/cudi-hums/",
      src: "/images/project/cudi-hums/header.png",
      alt: "Header"
    }, {}, {})}
<h1 id="${"what-it-is"}"><a href="${"#what-it-is"}">What it is</a></h1>
<p><a href="${"https://connorrothschild.github.io/cudi-hums/"}" rel="${"nofollow"}"><strong>How Much Does Kid Cudi Hum?</strong></a> is a visual storytelling piece centered around analyzing music\u2019s most famous hum. It was recognized as a winner of the <a href="${"https://pudding.cool/process/pudding-cup-2020/"}" rel="${"nofollow"}">2020 Pudding Cup</a> out of 130+ entries.</p>
<h1 id="${"tools-used"}"><a href="${"#tools-used"}">Tools used</a></h1>
<p>I used <a href="${"https://vuejs.org/"}" rel="${"nofollow"}">Vue</a> and <a href="${"https://d3js.org/"}" rel="${"nofollow"}">D3.js</a> for all things visual and front-end. This was the first <a href="${"https://medium.com/nightingale/from-storytelling-to-scrollytelling-a-short-introduction-and-beyond-fbda32066964"}" rel="${"nofollow"}">scrollytelling</a> project I built, and I wanted an accessible way to approach scrollytelling so that it wouldn\u2019t get in the way of other stuff (such as making cool visuals and telling an actually interesting story). I had heard good things about Russell Goldenberg\u2019s <a href="${"https://github.com/russellgoldenberg/scrollama"}" rel="${"nofollow"}"><code>Scrollama</code></a> and wanted to find an easy way to incorporate that library with Vue. I was able to do so with Vignesh Shenoy\u2019s <a href="${"https://github.com/vgshenoy/vue-scrollama"}" rel="${"nofollow"}"><code>vue-scrollama</code></a>. It had a few quirks, but allowed me to quickly hit the ground running with scrollytelling capabilities.</p>
<h1 id="${"project-images"}"><a href="${"#project-images"}">Project images</a></h1>
${validate_component(Image, "Image").$$render($$result, {
      style: "box-shadow: none;",
      src: "/images/project/cudi-hums/albums-mac.png",
      alt: "Project image for 'How Much Does Kid Cudi Hum?'",
      width: "48%"
    }, {}, {})}
${validate_component(Image, "Image").$$render($$result, {
      style: "box-shadow: none;",
      src: "/images/project/cudi-hums/tracks-mac.png",
      alt: "Project image for 'How Much Does Kid Cudi Hum?'",
      width: "48%"
    }, {}, {})}
${validate_component(Image, "Image").$$render($$result, {
      style: "box-shadow: none;",
      src: "/images/project/cudi-hums/lyrics-mac.png",
      alt: "Project image for 'How Much Does Kid Cudi Hum?'"
    }, {}, {})}
${validate_component(Image, "Image").$$render($$result, {
      style: "box-shadow: none;",
      src: "/images/project/cudi-hums/albums-phone.png",
      alt: "Project image for 'How Much Does Kid Cudi Hum?'",
      width: "32%"
    }, {}, {})}
${validate_component(Image, "Image").$$render($$result, {
      style: "box-shadow: none;",
      src: "/images/project/cudi-hums/tracks-phone.png",
      alt: "Project image for 'How Much Does Kid Cudi Hum?'",
      width: "32%"
    }, {}, {})}
${validate_component(Image, "Image").$$render($$result, {
      style: "box-shadow: none;",
      src: "/images/project/cudi-hums/lyrics-phone.png",
      alt: "Project image for 'How Much Does Kid Cudi Hum?'",
      width: "32%"
    }, {}, {})}
${validate_component(Image, "Image").$$render($$result, {
      style: "box-shadow: none;",
      src: "/images/project/cudi-hums/intro-phone.png",
      alt: "Project image for 'How Much Does Kid Cudi Hum?'",
      width: "48%"
    }, {}, {})}
${validate_component(Image, "Image").$$render($$result, {
      style: "box-shadow: none;",
      src: "/images/project/cudi-hums/outro-phone.png",
      alt: "Project image for 'How Much Does Kid Cudi Hum?'",
      width: "48%"
    }, {}, {})}
`
  })}`;
});
var cudiHums = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Cudi_hums,
  metadata: metadata$A
});
var metadata$z = {
  "layout": "project",
  "title": "Are You Smarter Than COMPAS?",
  "description": "A quick game to see if you are more intelligent than an algorithm used to sentence millions of Americans.",
  "date": "2020-02-23",
  "audience": "The world!",
  "featured": false,
  "archived": true,
  "image": "compas/header.png",
  "img_alt": "COMPAS header image, includes an image of a MacBook with the application open.",
  "techstack": "D3.js, Bulma, R",
  "github": "https://github.com/connorrothschild/compas",
  "url": "https://connorrothschild.github.io/compas/"
};
var Compas = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${validate_component(Layout$2, "Layout_MDSVEX_DEFAULT").$$render($$result, Object.assign($$props, metadata$z), {}, {
    default: () => `${validate_component(Image, "Image").$$render($$result, {
      href: "https://connorrothschild.github.io/compas/",
      style: "box-shadow: none;",
      src: "/images/project/compas/header.png",
      alt: "Header"
    }, {}, {})}
<h1 id="${"what-it-is"}"><a href="${"#what-it-is"}">What it is</a></h1>
<p><a href="${"https://connorrothschild.github.io/compas/"}" rel="${"nofollow"}"><strong>Are You Smarter Than COMPAS?</strong></a> is an application that allows users to explore how accurately they can predict recidivism, compared to a popular criminal justice sentencing algorithm known as COMPAS.</p>
<p>The application is meant to showcase how inaccurate COMPAS is, and illustrate that human judgment can more accurately assess risk than an algorithm that has sentenced millions behind bars.</p>
<h1 id="${"tools-used"}"><a href="${"#tools-used"}">Tools used</a></h1>
<p>This project was built using vanilla JavaScript, and styling was done with assistance from <a href="${"https://bulma.io/"}" rel="${"nofollow"}">Bulma</a>. It was rather easy to build; it was mostly an exercise to 1) inform users about how inaccurate sentencing algorithms are, and 2) learn JavaScript \u{1F642}.</p>
<h1 id="${"project-images"}"><a href="${"#project-images"}">Project images</a></h1>
${validate_component(Image, "Image").$$render($$result, {
      style: "box-shadow: none;",
      src: "/images/project/compas/mac-1.png",
      alt: "Project image for the project 'Are You Smarter Than COMPAS?'",
      width: "74%"
    }, {}, {})}
${validate_component(Image, "Image").$$render($$result, {
      style: "box-shadow: none;",
      src: "/images/project/compas/phone-1.png",
      alt: "Project image for the project 'Are You Smarter Than COMPAS?'",
      width: "22%"
    }, {}, {})}
${validate_component(Image, "Image").$$render($$result, {
      style: "box-shadow: none;",
      src: "/images/project/compas/phone-2.png",
      alt: "Project image for the project 'Are You Smarter Than COMPAS?'",
      width: "22%"
    }, {}, {})}
${validate_component(Image, "Image").$$render($$result, {
      style: "box-shadow: none;",
      src: "/images/project/compas/mac-2.png",
      alt: "Project image for the project 'Are You Smarter Than COMPAS?'",
      width: "74%"
    }, {}, {})}`
  })}`;
});
var compas = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Compas,
  metadata: metadata$z
});
var metadata$y = {
  "layout": "project",
  "title": "I Can Guess What You're Doing Right Now",
  "description": "Using the American Time Use Survey to predict your daily activities.",
  "date": "2020-02-23",
  "audience": "The world!",
  "featured": false,
  "archived": true,
  "image": "atus/header.png",
  "img_alt": "ATUS header image, includes an image of a MacBook with the application open.",
  "techstack": "JavaScript, Bulma, R",
  "github": "https://github.com/connorrothschild/what-are-you-doing",
  "url": "https://connorrothschild.github.io/what-are-you-doing/"
};
var Atus = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${validate_component(Layout$2, "Layout_MDSVEX_DEFAULT").$$render($$result, Object.assign($$props, metadata$y), {}, {
    default: () => `${validate_component(Image, "Image").$$render($$result, {
      href: "https://connorrothschild.github.io/what-are-you-doing/",
      src: "/images/project/atus/header.png",
      alt: "Header"
    }, {}, {})}
<h1 id="${"what-it-is"}"><a href="${"#what-it-is"}">What it is</a></h1>
<p><a href="${"https://connorrothschild.github.io/what-are-you-doing/"}" rel="${"nofollow"}"><strong>What Are You Doing Right Now?</strong></a> is an application that leverages data from the American Time Use Survey to guess your current activities.</p>
<h1 id="${"tools-used"}"><a href="${"#tools-used"}">Tools used</a></h1>
<p>This project was built using vanilla JavaScript, and styling was done with assistance from <a href="${"https://bulma.io/"}" rel="${"nofollow"}">Bulma</a>. It was rather easy to build. It was one of my first JS projects and so it was mostly an attempt to learn \u{1F642}.</p>
<p>Methodologically, for each demographic profile (a combination of race, age, marital status), I found the most common activities at every given time. (Technically, I grouped per hour to prevent issues with low N\u2019s). I would then display that activity to the user, given their parameters. If that didn\u2019t fit (according to the user), I would show the second most common activity, and so on!</p>
<h1 id="${"project-images"}"><a href="${"#project-images"}">Project images</a></h1>
${validate_component(Image, "Image").$$render($$result, {
      style: "box-shadow: none;",
      src: "/images/project/atus/mac-1.png",
      alt: "Project image for the project 'I Can Guess What You're Doing Right Now'",
      width: "74%"
    }, {}, {})}
${validate_component(Image, "Image").$$render($$result, {
      style: "box-shadow: none;",
      src: "/images/project/atus/phone-1.png",
      alt: "Project image for the project 'I Can Guess What You're Doing Right Now'",
      width: "22%"
    }, {}, {})}
${validate_component(Image, "Image").$$render($$result, {
      style: "box-shadow: none;",
      src: "/images/project/atus/phone-2.png",
      alt: "Project image for the project 'I Can Guess What You're Doing Right Now'",
      width: "22%"
    }, {}, {})}
${validate_component(Image, "Image").$$render($$result, {
      style: "box-shadow: none;",
      src: "/images/project/atus/mac-2.png",
      alt: "Project image for the project 'I Can Guess What You're Doing Right Now'",
      width: "74%"
    }, {}, {})}`
  })}`;
});
var atus = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Atus,
  metadata: metadata$y
});
function dateFormat(date2) {
  const parsed = new Date(date2);
  const month = parsed.toLocaleString("default", { month: "long" });
  const year = parsed.getUTCFullYear();
  return `${month} ${year}`;
}
var css$b = {
  code: "svg.svelte-1exk3bt{pointer-events:none}",
  map: '{"version":3,"file":"Star.svelte","sources":["Star.svelte"],"sourcesContent":["<script>\\n  export let width = 24;\\n  export let height = 24;\\n  export let fill = \\"black\\";\\n  export let stroke = \\"transparent\\";\\n  export let hovered;\\n  export let index;\\n\\n  import { gsap } from \\"gsap\\";\\n  import { MorphSVGPlugin } from \\"gsap/dist/MorphSVGPlugin.js\\";\\n  import { onMount } from \\"svelte\\";\\n\\n  gsap.registerPlugin(MorphSVGPlugin);\\n\\n  let star;\\n  onMount(() => {\\n    star = MorphSVGPlugin.convertToPath(`#star-${index}`);\\n  });\\n\\n  const changePath = function () {\\n    if (hovered == true) {\\n      gsap.to(star, {\\n        duration: 0.3,\\n        morphSVG: arrowPath,\\n      });\\n    } else {\\n      gsap.to(star, {\\n        duration: 0.3,\\n        morphSVG: starPath,\\n      });\\n    }\\n  };\\n  const arrowPath =\\n    \\"M 2.398438 1.414062 L 2.398438 4.320312 C 2.398438 4.441406 2.496094 4.535156 2.617188 4.535156 L 17.015625 4.535156 L 1.152344 20.425781 C 1.054688 20.519531 1.054688 20.664062 1.152344 20.734375 L 3.191406 22.777344 C 3.289062 22.871094 3.433594 22.871094 3.503906 22.777344 L 19.488281 6.792969 L 19.488281 21.433594 C 19.488281 21.550781 19.585938 21.648438 19.703125 21.648438 L 22.609375 21.648438 C 22.726562 21.648438 22.824219 21.550781 22.824219 21.433594 L 22.824219 1.414062 C 22.824219 1.296875 22.726562 1.199219 22.609375 1.199219 L 2.617188 1.199219 C 2.496094 1.199219 2.398438 1.296875 2.398438 1.414062 Z M 2.398438 1.414062\\";\\n\\n  const starPath =\\n    \\"M 18.523438 12.539062 C 18.523438 12.539062 18.347656 14.273438 17.601562 13.503906 C 16.855469 12.738281 18.613281 9.703125 17.796875 7.945312 C 16.984375 6.1875 14.085938 4.914062 14.085938 4.914062 C 14.085938 4.914062 15.929688 6.671875 15.402344 7.175781 C 14.875 7.683594 12.875 7 11.910156 5.375 C 10.941406 3.75 12.105469 1.199219 12.105469 1.199219 C 12.105469 1.199219 10.171875 2.210938 9.933594 4.058594 C 9.691406 5.902344 10.128906 7.175781 10.347656 9.066406 C 10.570312 10.957031 9.933594 13.503906 8.238281 13.265625 C 6.546875 13.023438 7.535156 10.210938 7.535156 10.210938 C 7.535156 10.210938 2.371094 15.285156 5.558594 19.417969 C 8.746094 23.546875 12.546875 22.734375 12.546875 22.734375 C 13.878906 22.761719 15.265625 22.34375 16.332031 21.535156 C 16.347656 21.523438 16.363281 21.511719 16.378906 21.5 C 21.738281 17.679688 18.523438 12.539062 18.523438 12.539062 Z M 18.523438 12.539062 \\";\\n  // /* OTHER FIRE */ \\"M 19.609375 14.28125 C 19.609375 11.863281 18.460938 9.460938 16.53125 7.851562 L 16.277344 7.648438 C 15.984375 7.410156 15.535156 7.5 15.371094 7.84375 C 15.292969 8.011719 15.238281 9.699219 15.238281 9.980469 C 15.238281 10.039062 15.226562 10.132812 15.226562 10.144531 C 15.226562 10.382812 15.011719 10.574219 14.765625 10.53125 C 14.570312 10.5 14.4375 10.316406 14.4375 10.117188 C 14.425781 7.234375 13.542969 5.222656 11.925781 3.722656 C 10.9375 2.804688 9.765625 1.992188 9.410156 2.625 C 9.316406 2.785156 9.46875 3.148438 9.621094 3.613281 C 9.957031 4.648438 8.925781 6.300781 7.46875 7.953125 C 6.097656 9.503906 4.390625 11.433594 4.390625 14.28125 C 4.390625 18.113281 8.015625 21.601562 12 21.601562 C 15.984375 21.601562 19.609375 18.113281 19.609375 14.28125 Z M 19.609375 14.28125 \\";\\n  // /* STAR */ \\"M12 .587l3.668 7.568 8.332 1.151-6.064 5.828 1.48 8.279-7.416-3.967-7.417 3.967 1.481-8.279-6.064-5.828 8.332-1.151z\\";\\n\\n  $: hovered, changePath(hovered);\\n<\/script>\\n\\n<svg\\n  xmlns=\\"http://www.w3.org/2000/svg\\"\\n  {width}\\n  {height}\\n  viewBox=\\"0 0 24 24\\"\\n  {fill}\\n  {stroke}><path id=\\"star-{index}\\" d={starPath} /></svg\\n>\\n\\n<style>\\n  svg {\\n    pointer-events: none;\\n  }\\n</style>\\n"],"names":[],"mappings":"AAqDE,GAAG,eAAC,CAAC,AACH,cAAc,CAAE,IAAI,AACtB,CAAC"}'
};
var arrowPath = "M 2.398438 1.414062 L 2.398438 4.320312 C 2.398438 4.441406 2.496094 4.535156 2.617188 4.535156 L 17.015625 4.535156 L 1.152344 20.425781 C 1.054688 20.519531 1.054688 20.664062 1.152344 20.734375 L 3.191406 22.777344 C 3.289062 22.871094 3.433594 22.871094 3.503906 22.777344 L 19.488281 6.792969 L 19.488281 21.433594 C 19.488281 21.550781 19.585938 21.648438 19.703125 21.648438 L 22.609375 21.648438 C 22.726562 21.648438 22.824219 21.550781 22.824219 21.433594 L 22.824219 1.414062 C 22.824219 1.296875 22.726562 1.199219 22.609375 1.199219 L 2.617188 1.199219 C 2.496094 1.199219 2.398438 1.296875 2.398438 1.414062 Z M 2.398438 1.414062";
var starPath = "M 18.523438 12.539062 C 18.523438 12.539062 18.347656 14.273438 17.601562 13.503906 C 16.855469 12.738281 18.613281 9.703125 17.796875 7.945312 C 16.984375 6.1875 14.085938 4.914062 14.085938 4.914062 C 14.085938 4.914062 15.929688 6.671875 15.402344 7.175781 C 14.875 7.683594 12.875 7 11.910156 5.375 C 10.941406 3.75 12.105469 1.199219 12.105469 1.199219 C 12.105469 1.199219 10.171875 2.210938 9.933594 4.058594 C 9.691406 5.902344 10.128906 7.175781 10.347656 9.066406 C 10.570312 10.957031 9.933594 13.503906 8.238281 13.265625 C 6.546875 13.023438 7.535156 10.210938 7.535156 10.210938 C 7.535156 10.210938 2.371094 15.285156 5.558594 19.417969 C 8.746094 23.546875 12.546875 22.734375 12.546875 22.734375 C 13.878906 22.761719 15.265625 22.34375 16.332031 21.535156 C 16.347656 21.523438 16.363281 21.511719 16.378906 21.5 C 21.738281 17.679688 18.523438 12.539062 18.523438 12.539062 Z M 18.523438 12.539062 ";
var Star = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { width = 24 } = $$props;
  let { height = 24 } = $$props;
  let { fill = "black" } = $$props;
  let { stroke = "transparent" } = $$props;
  let { hovered } = $$props;
  let { index: index2 } = $$props;
  import_gsap.gsap.registerPlugin(import_MorphSVGPlugin.MorphSVGPlugin);
  let star;
  const changePath = function() {
    if (hovered == true) {
      import_gsap.gsap.to(star, { duration: 0.3, morphSVG: arrowPath });
    } else {
      import_gsap.gsap.to(star, { duration: 0.3, morphSVG: starPath });
    }
  };
  if ($$props.width === void 0 && $$bindings.width && width !== void 0)
    $$bindings.width(width);
  if ($$props.height === void 0 && $$bindings.height && height !== void 0)
    $$bindings.height(height);
  if ($$props.fill === void 0 && $$bindings.fill && fill !== void 0)
    $$bindings.fill(fill);
  if ($$props.stroke === void 0 && $$bindings.stroke && stroke !== void 0)
    $$bindings.stroke(stroke);
  if ($$props.hovered === void 0 && $$bindings.hovered && hovered !== void 0)
    $$bindings.hovered(hovered);
  if ($$props.index === void 0 && $$bindings.index && index2 !== void 0)
    $$bindings.index(index2);
  $$result.css.add(css$b);
  {
    changePath();
  }
  return `<svg xmlns="${"http://www.w3.org/2000/svg"}"${add_attribute("width", width, 0)}${add_attribute("height", height, 0)} viewBox="${"0 0 24 24"}"${add_attribute("fill", fill, 0)}${add_attribute("stroke", stroke, 0)} class="${"svelte-1exk3bt"}"><path id="${"star-" + escape(index2)}"${add_attribute("d", starPath, 0)}></path></svg>`;
});
var css$a = {
  code: '.award-container.svelte-1sc6m05{display:block;position:relative;padding:1.5rem 1rem;margin:0.75rem 0;background:white;border-radius:5px;border-width:1px;border-style:solid;border-color:white;border-image-slice:1;box-shadow:10px -10px 10px rgba(0, 0, 0, 0.1);transition:all 500ms ease;position:relative;z-index:0}.award-container.svelte-1sc6m05:before{width:100%;height:100%;z-index:-1;position:absolute;background-image:linear-gradient(\n      to bottom right,\n      rgba(255, 255, 255, 0) 0%,\n      rgba(255, 255, 255, 1) 30%,\n      rgba(var(--accent-color-rgb), 0.45) 100%\n    );content:"";top:0;right:0;bottom:0;left:0;opacity:0;transition:opacity 500ms linear}.award-title.svelte-1sc6m05{font-size:1.5rem;margin-bottom:0.75rem}.award-description.svelte-1sc6m05{font-size:1rem;font-weight:200;letter-spacing:0.64px;text-transform:uppercase;font-family:var(--font-sans);color:rgb(55, 55, 55)}.award-container.svelte-1sc6m05:hover{border-color:rgba(var(--accent-color-rgb), 0.45);box-shadow:5px -5px 5px rgba(0, 0, 0, 0.1)}.award-container.svelte-1sc6m05:hover::before{opacity:1}.star-container.svelte-1sc6m05{position:absolute;top:0;right:0;padding:6px}',
  map: '{"version":3,"file":"AwardSection.svelte","sources":["AwardSection.svelte"],"sourcesContent":["<script>\\n  export let award;\\n  export let index;\\n  //   export let slug;\\n\\n  import { dateFormat } from \\"../scripts/utils.js\\";\\n  import Star from \\"$lib/Icons/Star.svelte\\";\\n\\n  let hovered = false;\\n<\/script>\\n\\n<a\\n  class=\\"award-container no-underline\\"\\n  href={award.media_url}\\n  target=\\"_blank\\"\\n  on:mouseover={() => {\\n    hovered = true;\\n  }}\\n  on:focus={() => {\\n    hovered = true;\\n  }}\\n  on:mouseleave={() => {\\n    hovered = false;\\n  }}\\n>\\n  {#if award.featured == true}\\n    <div class=\\"star-container\\">\\n      <Star\\n        {hovered}\\n        {index}\\n        fill={\\"var(--accent-color)\\"}\\n        width=\\"18\\"\\n        height=\\"18\\"\\n      />\\n    </div>\\n  {/if}\\n  <h1 class=\\"award-title\\">\\n    {award.title}\\n  </h1>\\n  <h2 class=\\"award-description\\">\\n    {award.organization} | {dateFormat(award.date)}\\n  </h2>\\n</a>\\n\\n<style>\\n  .award-container {\\n    display: block;\\n    position: relative;\\n    padding: 1.5rem 1rem;\\n    margin: 0.75rem 0;\\n    background: white;\\n    /* background-image: linear-gradient(\\n      to right,\\n      white 0%,\\n      white 100%\\n    ); */\\n    border-radius: 5px;\\n    border-width: 1px;\\n    border-style: solid;\\n    border-color: white;\\n    border-image-slice: 1;\\n    box-shadow: 10px -10px 10px rgba(0, 0, 0, 0.1);\\n    transition: all 500ms ease;\\n    position: relative;\\n    z-index: 0;\\n  }\\n\\n  .award-container:before {\\n    width: 100%;\\n    height: 100%;\\n    z-index: -1;\\n    position: absolute;\\n    background-image: linear-gradient(\\n      to bottom right,\\n      rgba(255, 255, 255, 0) 0%,\\n      rgba(255, 255, 255, 1) 30%,\\n      rgba(var(--accent-color-rgb), 0.45) 100%\\n    );\\n    content: \\"\\";\\n    top: 0;\\n    right: 0;\\n    bottom: 0;\\n    left: 0;\\n    opacity: 0;\\n    transition: opacity 500ms linear;\\n  }\\n\\n  .award-title {\\n    font-size: 1.5rem;\\n    margin-bottom: 0.75rem;\\n  }\\n\\n  .award-description {\\n    font-size: 1rem;\\n    font-weight: 200;\\n    letter-spacing: 0.64px;\\n    text-transform: uppercase;\\n    font-family: var(--font-sans);\\n    color: rgb(55, 55, 55);\\n  }\\n\\n  .award-container:hover {\\n    border-color: rgba(var(--accent-color-rgb), 0.45);\\n    box-shadow: 5px -5px 5px rgba(0, 0, 0, 0.1); /* none */\\n  }\\n\\n  .award-container:hover::before {\\n    opacity: 1;\\n  }\\n\\n  .star-container {\\n    position: absolute;\\n    top: 0;\\n    right: 0;\\n    padding: 6px;\\n  }\\n</style>\\n"],"names":[],"mappings":"AA6CE,gBAAgB,eAAC,CAAC,AAChB,OAAO,CAAE,KAAK,CACd,QAAQ,CAAE,QAAQ,CAClB,OAAO,CAAE,MAAM,CAAC,IAAI,CACpB,MAAM,CAAE,OAAO,CAAC,CAAC,CACjB,UAAU,CAAE,KAAK,CAMjB,aAAa,CAAE,GAAG,CAClB,YAAY,CAAE,GAAG,CACjB,YAAY,CAAE,KAAK,CACnB,YAAY,CAAE,KAAK,CACnB,kBAAkB,CAAE,CAAC,CACrB,UAAU,CAAE,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAC9C,UAAU,CAAE,GAAG,CAAC,KAAK,CAAC,IAAI,CAC1B,QAAQ,CAAE,QAAQ,CAClB,OAAO,CAAE,CAAC,AACZ,CAAC,AAED,+BAAgB,OAAO,AAAC,CAAC,AACvB,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,OAAO,CAAE,EAAE,CACX,QAAQ,CAAE,QAAQ,CAClB,gBAAgB,CAAE;MAChB,EAAE,CAAC,MAAM,CAAC,KAAK,CAAC;MAChB,KAAK,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;MAC1B,KAAK,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC;MAC3B,KAAK,IAAI,kBAAkB,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,IAAI;KACzC,CACD,OAAO,CAAE,EAAE,CACX,GAAG,CAAE,CAAC,CACN,KAAK,CAAE,CAAC,CACR,MAAM,CAAE,CAAC,CACT,IAAI,CAAE,CAAC,CACP,OAAO,CAAE,CAAC,CACV,UAAU,CAAE,OAAO,CAAC,KAAK,CAAC,MAAM,AAClC,CAAC,AAED,YAAY,eAAC,CAAC,AACZ,SAAS,CAAE,MAAM,CACjB,aAAa,CAAE,OAAO,AACxB,CAAC,AAED,kBAAkB,eAAC,CAAC,AAClB,SAAS,CAAE,IAAI,CACf,WAAW,CAAE,GAAG,CAChB,cAAc,CAAE,MAAM,CACtB,cAAc,CAAE,SAAS,CACzB,WAAW,CAAE,IAAI,WAAW,CAAC,CAC7B,KAAK,CAAE,IAAI,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,AACxB,CAAC,AAED,+BAAgB,MAAM,AAAC,CAAC,AACtB,YAAY,CAAE,KAAK,IAAI,kBAAkB,CAAC,CAAC,CAAC,IAAI,CAAC,CACjD,UAAU,CAAE,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,AAC7C,CAAC,AAED,+BAAgB,MAAM,QAAQ,AAAC,CAAC,AAC9B,OAAO,CAAE,CAAC,AACZ,CAAC,AAED,eAAe,eAAC,CAAC,AACf,QAAQ,CAAE,QAAQ,CAClB,GAAG,CAAE,CAAC,CACN,KAAK,CAAE,CAAC,CACR,OAAO,CAAE,GAAG,AACd,CAAC"}'
};
var AwardSection = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { award } = $$props;
  let { index: index2 } = $$props;
  let hovered = false;
  if ($$props.award === void 0 && $$bindings.award && award !== void 0)
    $$bindings.award(award);
  if ($$props.index === void 0 && $$bindings.index && index2 !== void 0)
    $$bindings.index(index2);
  $$result.css.add(css$a);
  return `<a class="${"award-container no-underline svelte-1sc6m05"}"${add_attribute("href", award.media_url, 0)} target="${"_blank"}">${award.featured == true ? `<div class="${"star-container svelte-1sc6m05"}">${validate_component(Star, "Star").$$render($$result, {
    hovered,
    index: index2,
    fill: "var(--accent-color)",
    width: "18",
    height: "18"
  }, {}, {})}</div>` : ``}
  <h1 class="${"award-title svelte-1sc6m05"}">${escape(award.title)}</h1>
  <h2 class="${"award-description svelte-1sc6m05"}">${escape(award.organization)} | ${escape(dateFormat(award.date))}</h2>
</a>`;
});
var css$9 = {
  code: "main.svelte-1as9kej{width:90vw;max-width:760px;margin:0 auto;padding:1em}",
  map: `{"version":3,"file":"index.svelte","sources":["index.svelte"],"sourcesContent":["<script context=\\"module\\">\\n  /**\\n   * @type {import('@sveltejs/kit').Load}\\n   */\\n  export async function load({ fetch }) {\\n    const res = await fetch(\`/awards.json\`);\\n    const awards = await res.json();\\n    return {\\n      props: {\\n        awards,\\n      },\\n    };\\n  }\\n<\/script>\\n\\n<script>\\n  import AwardSection from \\"$lib/AwardSection.svelte\\";\\n  import Transition from \\"$lib/Transition.svelte\\";\\n\\n  export let awards;\\n\\n  awards\\n    .sort((a, b) => Date.parse(b.metadata.date) - Date.parse(a.metadata.date))\\n    .sort((a, b) => b.metadata.featured);\\n\\n  import { seo } from \\"$lib/store.js\\";\\n  $seo = {\\n    title: \\"Awards | Connor Rothschild\\",\\n    description: \\"Some of my awards.\\",\\n  };\\n<\/script>\\n\\n<Transition />\\n<main>\\n  <h1 class=\\"page-overline\\">Awards</h1>\\n  <h1 class=\\"page-title\\">\\n    What I've\\n    <span class=\\"gradient-accented bolded \\">won</span>\\n  </h1>\\n\\n  <div class=\\"awards-grid transition-content\\">\\n    {#each awards as award, index}\\n      <AwardSection\\n        award={award.metadata}\\n        slug={award.path.replace(/\\\\.[^/.]+$/, \\"\\")}\\n        {index}\\n      />\\n    {/each}\\n  </div>\\n</main>\\n\\n<style>\\n  main {\\n    width: 90vw;\\n    max-width: 760px;\\n    margin: 0 auto;\\n    padding: 1em;\\n  }\\n</style>\\n"],"names":[],"mappings":"AAoDE,IAAI,eAAC,CAAC,AACJ,KAAK,CAAE,IAAI,CACX,SAAS,CAAE,KAAK,CAChB,MAAM,CAAE,CAAC,CAAC,IAAI,CACd,OAAO,CAAE,GAAG,AACd,CAAC"}`
};
async function load$1({ fetch: fetch2 }) {
  const res = await fetch2(`/awards.json`);
  const awards = await res.json();
  return { props: { awards } };
}
var Award = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $seo, $$unsubscribe_seo;
  $$unsubscribe_seo = subscribe(seo, (value) => $seo = value);
  let { awards } = $$props;
  awards.sort((a, b) => Date.parse(b.metadata.date) - Date.parse(a.metadata.date)).sort((a, b) => b.metadata.featured);
  set_store_value(seo, $seo = {
    title: "Awards | Connor Rothschild",
    description: "Some of my awards."
  }, $seo);
  if ($$props.awards === void 0 && $$bindings.awards && awards !== void 0)
    $$bindings.awards(awards);
  $$result.css.add(css$9);
  $$unsubscribe_seo();
  return `${validate_component(Main, "Transition").$$render($$result, {}, {}, {})}
<main class="${"svelte-1as9kej"}"><h1 class="${"page-overline"}">Awards</h1>
  <h1 class="${"page-title"}">What I&#39;ve
    <span class="${"gradient-accented bolded "}">won</span></h1>

  <div class="${"awards-grid transition-content"}">${each(awards, (award, index2) => `${validate_component(AwardSection, "AwardSection").$$render($$result, {
    award: award.metadata,
    slug: award.path.replace(/\.[^/.]+$/, ""),
    index: index2
  }, {}, {})}`)}</div>
</main>`;
});
var index$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Award,
  load: load$1
});
var css$8 = {
  code: "main.svelte-1f06rlp{max-width:768px;margin:0 auto;padding:1em;width:90vw}.content.svelte-1f06rlp{margin-bottom:4rem}",
  map: '{"version":3,"file":"layout.svelte","sources":["layout.svelte"],"sourcesContent":["<script>\\n  import BackTo from \\"$lib/Text/BackTo.svelte\\";\\n  import { seo } from \\"$lib/store\\";\\n\\n  export let title;\\n  export let description;\\n\\n  $seo = {\\n    title: title,\\n    description: description,\\n  };\\n<\/script>\\n\\n<main>\\n  <BackTo href=\\"/award\\" text=\\"Awards\\" classes=\\"page-overline\\" />\\n\\n  <h1 class=\\"page-title\\">{title}</h1>\\n  <div class=\\"content\\">\\n    <slot />\\n    <BackTo href=\\"/award\\" text=\\"Back to all awards\\" classes=\\"border-top\\" />\\n  </div>\\n</main>\\n\\n<style>\\n  main {\\n    max-width: 768px;\\n    margin: 0 auto;\\n    padding: 1em;\\n    width: 90vw;\\n  }\\n\\n  .content {\\n    margin-bottom: 4rem;\\n  }\\n</style>\\n"],"names":[],"mappings":"AAwBE,IAAI,eAAC,CAAC,AACJ,SAAS,CAAE,KAAK,CAChB,MAAM,CAAE,CAAC,CAAC,IAAI,CACd,OAAO,CAAE,GAAG,CACZ,KAAK,CAAE,IAAI,AACb,CAAC,AAED,QAAQ,eAAC,CAAC,AACR,aAAa,CAAE,IAAI,AACrB,CAAC"}'
};
var Layout$1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $seo, $$unsubscribe_seo;
  $$unsubscribe_seo = subscribe(seo, (value) => $seo = value);
  let { title } = $$props;
  let { description } = $$props;
  set_store_value(seo, $seo = { title, description }, $seo);
  if ($$props.title === void 0 && $$bindings.title && title !== void 0)
    $$bindings.title(title);
  if ($$props.description === void 0 && $$bindings.description && description !== void 0)
    $$bindings.description(description);
  $$result.css.add(css$8);
  $$unsubscribe_seo();
  return `<main class="${"svelte-1f06rlp"}">${validate_component(BackTo, "BackTo").$$render($$result, {
    href: "/award",
    text: "Awards",
    classes: "page-overline"
  }, {}, {})}

  <h1 class="${"page-title"}">${escape(title)}</h1>
  <div class="${"content svelte-1f06rlp"}">${slots.default ? slots.default({}) : ``}
    ${validate_component(BackTo, "BackTo").$$render($$result, {
    href: "/award",
    text: "Back to all awards",
    classes: "border-top"
  }, {}, {})}</div>
</main>`;
});
var layout$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Layout$1
});
var metadata$x = {
  "title": "Honorable Mention, RStudio Table Contest",
  "organization": "RStudio, Inc.",
  "date": "2021-01-06",
  "featured": false,
  "media_url": "https://blog.rstudio.com/2020/12/23/winners-of-the-2020-rstudio-table-contest/",
  "project_url": "https://connorrothschild.github.io/v2/post/economist-table-replication-using-reactable"
};
var Rstudio_table_contest_2021 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${validate_component(Layout$1, "Layout_MDSVEX_DEFAULT").$$render($$result, Object.assign($$props, metadata$x), {}, {
    default: () => `<p>Received an honorable mention in the 2020 RStudio Table Contest out of 80+ entries. My entry was a tutorial regarding the replication of a table by the Economist, using an R package called <code>reactable</code>.</p>`
  })}`;
});
var rstudioTableContest2021 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Rstudio_table_contest_2021,
  metadata: metadata$x
});
var metadata$w = {
  "title": "2nd Place, 2020 D2K Showcase",
  "organization": "Data to Knowledge Lab",
  "date": "2020-12-09",
  "featured": false,
  "media_url": "https://d2k.rice.edu/news/closing-gap-data-science-approach-reducing-academic-achievement-gaps",
  "project_url": "https://www.youtube.com/watch?v=6T5C4omYexs"
};
var D2k_showcase_2020 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${validate_component(Layout$1, "Layout_MDSVEX_DEFAULT").$$render($$result, Object.assign($$props, metadata$w), {}, {
    default: () => `<p>Awarded second place out of 10+ teams in the 2020 Data to Knowledge Lab\u2019s showcase. My team provided a data science approach to predicting student engagement and success, allowing teachers to preemptively intervene in students academic careers and prevent failure.</p>`
  })}`;
});
var d2kShowcase2020 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": D2k_showcase_2020,
  metadata: metadata$w
});
var metadata$v = {
  "title": "Student Winner, Computation + Journalism 2020 Conference",
  "organization": "Northeastern University",
  "date": "2020-01-07",
  "featured": true,
  "media_url": "https://cj2020.northeastern.edu/student-contest/",
  "project_url": "https://connorrothschild.shinyapps.io/automation/"
};
var Northeastern_2020 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${validate_component(Layout$1, "Layout_MDSVEX_DEFAULT").$$render($$result, Object.assign($$props, metadata$v), {}, {
    default: () => `<p>Honored with the student award for best visualization at the 2020 Computation + Journalism Conference (2020) at Northeastern University. The winning visualization was \u2018<a href="${"https://connorrothschild.shinyapps.io/automation/"}" rel="${"nofollow"}">Automation and Its Impact on Jobs</a>.\u2019</p>`
  })}`;
});
var northeastern2020 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Northeastern_2020,
  metadata: metadata$v
});
var metadata$u = {
  "title": "Winner, The 2020 Pudding Cup",
  "organization": "The Pudding",
  "featured": true,
  "date": "2021-01-07",
  "media_url": "https://pudding.cool/process/pudding-cup-2020/",
  "project_url": "https://connorrothschild.github.io/cudi-hums/"
};
var Pudding_cup_2020 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${validate_component(Layout$1, "Layout_MDSVEX_DEFAULT").$$render($$result, Object.assign($$props, metadata$u), {}, {
    default: () => `<p>Awarded winner (top 3) out of 130+ entries to the 2020 Pudding Cup, which is a contest for visual storytelling pieces. My piece, \u2019<a href="${"https://connorrothschild.github.io/cudi-hums/"}" rel="${"nofollow"}">How Much Does Kid Cudi Hum?</a>\u2019 explored the prevalence of hums in Kid Cudi\u2019s discography.</p>`
  })}`;
});
var puddingCup2020 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Pudding_cup_2020,
  metadata: metadata$u
});
var metadata$t = {
  "title": "National Champion, IX Speaking",
  "organization": "National Speech and Debate Association",
  "date": "2017-07-15",
  "featured": false,
  "media_url": "https://www.news-leader.com/story/news/business/2017/06/28/kickapoo-high-school-senior-earns-accolades-national-speech-and-debate-tournament/435570001/",
  "project_url": "https://www.youtube.com/watch?v=lzoUu1fDmWE"
};
var Nationals_2017 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${validate_component(Layout$1, "Layout_MDSVEX_DEFAULT").$$render($$result, Object.assign($$props, metadata$t), {}, {
    default: () => `<p>Awarded National Champion in International Extemporaneous Speaking. Sponsored by the Council on Foreign Relations and EF Hutton. Competed against hundreds of high schoolers throughout 13 rounds.</p>
<p>(Yes, this was when I peaked, way back in high school.)</p>`
  })}`;
});
var nationals2017 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Nationals_2017,
  metadata: metadata$t
});
var metadata$s = {
  "title": "1st Place (Houston Track), 2020 Rice Datathon",
  "organization": "Rice DataSci Club",
  "date": "2020-01-09",
  "featured": false,
  "media_url": "https://connorrothschild.github.io/datathon-2020/source/",
  "project_url": "https://connorrothschild.github.io/datathon-2020/source/"
};
var Datathon_2020 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${validate_component(Layout$1, "Layout_MDSVEX_DEFAULT").$$render($$result, Object.assign($$props, metadata$s), {}, {
    default: () => `<p>Awarded first place in the \u2018Houston/Texas trends\u2019 track at the 2020 Rice Datathon. The winning project, \u2019<a href="${"https://connorrothschild.github.io/datathon-2020/source/"}" rel="${"nofollow"}">Mapping Houston Homicides</a>,\u2019 created in 16 hours, maps Houston homicides across time and demographics.</p>`
  })}`;
});
var datathon2020 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Datathon_2020,
  metadata: metadata$s
});
var metadata$r = {
  "title": "Hudspeth Award",
  "organization": "Rice Political Science Department",
  "date": "2020-05-19",
  "featured": false,
  "media_url": "https://politicalscience.rice.edu/undergraduate-awards",
  "project_url": "https://www.researchgate.net/publication/332470540_Vota_Testing_the_Impact_of_Spanish-Language_Ballots_on_Election_Results_and_Preferences"
};
var Hudspeth_2020 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${validate_component(Layout$1, "Layout_MDSVEX_DEFAULT").$$render($$result, Object.assign($$props, metadata$r), {}, {
    default: () => `<p>Recipient of the Hudspeth Award in recognition of my seminar paper \u201C<a href="${"https://www.researchgate.net/publication/332470540_Vota_Testing_the_Impact_of_Spanish-Language_Ballots_on_Election_Results_and_Preferences"}" rel="${"nofollow"}">\xA1Vota! Testing the Impact of Spanish-Language Ballots on Election Results and Preferences</a>.\u201D The paper described an online experiment testing the impact of Spanish-language ballots on the policy preferences of white, monolingual English-speaking voters.</p>`
  })}`;
});
var hudspeth2020 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Hudspeth_2020,
  metadata: metadata$r
});
var metadata$q = {
  "title": "Bronze, 2020 Malofiej Awards",
  "organization": "Malofiej",
  "date": "2020-08-07",
  "featured": true,
  "media_url": "https://www.malofiejgraphics.com/general/students-have-won-awards-too/2020/08",
  "project_url": "https://connorrothschild.github.io/map-missing-migrants/"
};
var Malofiej_2020 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${validate_component(Layout$1, "Layout_MDSVEX_DEFAULT").$$render($$result, Object.assign($$props, metadata$q), {}, {
    default: () => `<p>Awarded the Bronze in the Student Category at the 28th Annual Malofiej Awards (the self-described \u201CPulitzer for Infographics\u201D). The award was in recognition of my visualization <a href="${"https://connorrothschild.github.io/map-missing-migrants/"}" rel="${"nofollow"}">Mapping Missing Migrants</a>.</p>`
  })}`;
});
var malofiej2020 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Malofiej_2020,
  metadata: metadata$q
});
var metadata$p = {
  "title": "Bronze, 2021 Malofiej Awards",
  "organization": "Malofiej",
  "date": "2021-06-18",
  "featured": false,
  "media_url": "https://www.malofiejgraphics.com/awards/students-have-won-awards-too-2/2021/06",
  "project_url": "https://www.connorrothschild.com/project/bob-ross-art-gallery"
};
var Malofiej_2021 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${validate_component(Layout$1, "Layout_MDSVEX_DEFAULT").$$render($$result, Object.assign($$props, metadata$p), {}, {
    default: () => `<p>Awarded the Bronze in the Student Category at the 28th Annual Malofiej Awards (the self-described \u201CPulitzer for Infographics\u201D). The award was in recognition of my visualization <a href="${"https://connorrothschild.github.io/map-missing-migrants/"}" rel="${"nofollow"}">Mapping Missing Migrants</a>.</p>
<p>Awarded the Bronze in the Student Category at the 29th Annual Malofiej Awards (the self-described \u201CPulitzer for Infographics\u201D). The award was in recognition of my project, <a href="${"https://www.connorrothschild.com/project/bob-ross-art-gallery"}" rel="${"nofollow"}">The Bob Ross Virtual Art Gallery</a>.</p>`
  })}`;
});
var malofiej2021 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Malofiej_2021,
  metadata: metadata$p
});
var metadata$o = {
  "title": "1st Place, BIPP Competition",
  "organization": "The Baker Institute for Public Policy",
  "date": "2018-04-15",
  "featured": false,
  "media_url": "https://mailchi.mp/rice.edu/gala-547673?e=a93e1ef59d#AnnualReport",
  "project_url": "https://issuu.com/ricejpp/docs/rjppfinalsingle/20"
};
var Bipp_2018 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${validate_component(Layout$1, "Layout_MDSVEX_DEFAULT").$$render($$result, Object.assign($$props, metadata$o), {}, {
    default: () => `<p>Awarded first place in the Baker Institute Student Forum\u2019s fifth annual undergraduate public policy competition. Judged by Dr. Luis Duno-Gottberg, Dr. Francisco J. Monaldi, H. Richard Sindelar, and Oscar Arredondo.</p>
<p>The award was in recognition of a 6000-word research paper and a 20 minute presentation on U.S. foreign policy toward the Western Hemisphere; my partner and I\u2019s paper critiqued current mechanisms for distributing food aid to Haiti. Awarded prize money and publication in the Rice Journal of Public Policy (Spring 2019 issue).</p>`
  })}`;
});
var bipp2018 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Bipp_2018,
  metadata: metadata$o
});
var metadata$n = {
  "title": "1st Place, Coronavirus Houston Response Projects",
  "organization": "Data To Knowledge Lab",
  "date": "2020-04-15",
  "featured": false,
  "media_url": "https://news.rice.edu/2020/04/27/d2k-lab-awards-top-teams-at-virtual-showcase/",
  "project_url": "https://github.com/connorrothschild/covid-mobility"
};
var Chrp_2020 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${validate_component(Layout$1, "Layout_MDSVEX_DEFAULT").$$render($$result, Object.assign($$props, metadata$n), {}, {
    default: () => `<p>Awarded first place in the Rice Data to Knowledge Lab\u2019s \u2018COVID19 Houston Response Projects\u2019 competition. My team\u2019s project, \u201CMobility and Predictors of Movement During COVID-19,\u201D was a rigorous statistical analysis of how COVID19 impacted community movement, mobility, and social distancing. It took the form of a Shiny Web Application, where users could explore the effects of stay-at-home orders at reducing commnunity movement and COVID-19 transmission.</p>`
  })}`;
});
var chrp2020 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Chrp_2020,
  metadata: metadata$n
});
var metadata$m = {
  "title": "1st Place, 2020 Houston Policy Challenge",
  "organization": "Rice University",
  "date": "2019-02-04",
  "featured": false,
  "media_url": "https://www.houstonpublicmedia.org/articles/news/2018/02/27/270232/rice-students-win-flood-policy-contest-for-multi-home-buyout-idea/",
  "project_url": "http://news.rice.edu/2018/02/23/martel-college-students-win-rices-inaugural-houston-centered-policy-challenge/"
};
var Hpc_2018 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${validate_component(Layout$1, "Layout_MDSVEX_DEFAULT").$$render($$result, Object.assign($$props, metadata$m), {}, {
    default: () => `<p>Awarded first place at Rice University\u2019s inaugural Houston Centered Policy Design Competition. Judged by Houston Mayor Pro Tem Ellen Cohen; former president and CEO of the Jewish Federation of Greater Houston, Lee Wunsch; City Council at-large 2 representative, David Robinson; director of Rice\u2019s Kinder Institute for Urban Research, Bill Fulton; and \u201Cflood czar\u201D Stephen Costello.</p>
<p>My partner and I proposed an innovative, multi-home buyout system for the Meyerland community in the wake of Hurricane Harvey. We recommended multi-home buyouts in order to address the \u201Ccheckerboard effect\u201D of home buyouts and also increase community solidarity. Awarded prize money and seed money for implementation.</p>`
  })}`;
});
var hpc2018 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Hpc_2018,
  metadata: metadata$m
});
var metadata$l = {
  "title": "2nd Place, 2019 Houston Policy Challenge",
  "organization": "Rice University",
  "date": "2019-02-04",
  "featured": false,
  "media_url": "https://kinder.rice.edu/urbanedge/2019/02/26/affordable-housing-houston-rice-university"
};
var Hpc_2019 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${validate_component(Layout$1, "Layout_MDSVEX_DEFAULT").$$render($$result, Object.assign($$props, metadata$l), {}, {
    default: () => `<p>Awarded second place in the 2019 Houston Policy Challenge. Judged by Dwight Boykins, Houston city council member; Tory Gunsolley, president and CEO of the Houston Housing Authority; Amanda Timm, executive director of Local Initiatives Support Corporation; Tom McCasland, director of the City of Houston\u2019s Housing and Community Development department and Stephan Fairfield, founder and CEO of Covenant Community Capital.</p>
<p>My team and I proposed a program which incentivizes homeowners in high-opportunity neighborhoods to construct ADUs &amp; house voucher recipients. Our proposal prevents \u201CNIMBYism\u201D and community backlash to high-concentration public housing projects, and decentralizes low-income voucher recipients to high-opportunity neighborhoods.</p>`
  })}`;
});
var hpc2019 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Hpc_2019,
  metadata: metadata$l
});
var metadata$k = {
  "title": "1st Place, 2020 Houston Policy Challenge",
  "organization": "Rice University",
  "date": "2020-03-09",
  "featured": false,
  "media_url": "https://news.rice.edu/2020/03/02/rice-students-tackle-criminal-justice-reform-at-houston-policy-challenge/"
};
var Hpc_2020 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${validate_component(Layout$1, "Layout_MDSVEX_DEFAULT").$$render($$result, Object.assign($$props, metadata$k), {}, {
    default: () => `<p>Awarded first place (out of 13 teams) at Rice University\u2019s 2020 Houston Policy Challenge. Judged by Harris County Sheriff Ed Gonzalez, Harris County District Attorney Kim Ogg, U.S. Magistrate Judge Andrew Edison, Southern District of Texas, and Judge Franklin Bynum, Harris County Criminal Court at Law No. 8.</p>
<p>My partner and I proposed a pre-trial diversion program, \u2018New Path,\u2019 for pregnant women and mothers of young children.</p>`
  })}`;
});
var hpc2020 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Hpc_2020,
  metadata: metadata$k
});
var metadata$j = {
  "title": "1st Place, 2021 Student Design Contest",
  "organization": "Society for News Design",
  "date": "2021-05-10",
  "featured": true,
  "media_url": "https://msusnd.org/2021-college-design-contest/",
  "project_url": "https://connorrothschild.github.io/bob-ross-art-gallery/"
};
var Snd_2021 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${validate_component(Layout$1, "Layout_MDSVEX_DEFAULT").$$render($$result, Object.assign($$props, metadata$j), {}, {
    default: () => `<p>Awarded first place in the Standalone Multimedia category at the Society for News Design\u2019s 2021 Student Design Contest. </p>
<p>The award was in recognition of my project, <a href="${"https://connorrothschild.com/project/bob-ross-art-gallery/"}" rel="${"nofollow"}">The Bob Ross Virtual Art Gallery</a>. The project is a visual essay documenting the legacy of Bob Ross.</p>`
  })}`;
});
var snd2021 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Snd_2021,
  metadata: metadata$j
});
function ascending(a, b) {
  return a == null || b == null ? NaN : a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}
function bisector(f) {
  let delta = f;
  let compare1 = f;
  let compare2 = f;
  if (f.length === 1) {
    delta = (d, x) => f(d) - x;
    compare1 = ascending;
    compare2 = (d, x) => ascending(f(d), x);
  }
  function left(a, x, lo = 0, hi = a.length) {
    if (lo < hi) {
      if (compare1(x, x) !== 0)
        return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare2(a[mid], x) < 0)
          lo = mid + 1;
        else
          hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function right(a, x, lo = 0, hi = a.length) {
    if (lo < hi) {
      if (compare1(x, x) !== 0)
        return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare2(a[mid], x) <= 0)
          lo = mid + 1;
        else
          hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function center(a, x, lo = 0, hi = a.length) {
    const i = left(a, x, lo, hi - 1);
    return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;
  }
  return { left, center, right };
}
function number$1(x) {
  return x === null ? NaN : +x;
}
var ascendingBisect = bisector(ascending);
var bisectRight = ascendingBisect.right;
bisector(number$1).center;
var bisect = bisectRight;
var e10 = Math.sqrt(50);
var e5 = Math.sqrt(10);
var e2 = Math.sqrt(2);
function ticks(start, stop, count) {
  var reverse, i = -1, n, ticks2, step;
  stop = +stop, start = +start, count = +count;
  if (start === stop && count > 0)
    return [start];
  if (reverse = stop < start)
    n = start, start = stop, stop = n;
  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step))
    return [];
  if (step > 0) {
    let r0 = Math.round(start / step), r1 = Math.round(stop / step);
    if (r0 * step < start)
      ++r0;
    if (r1 * step > stop)
      --r1;
    ticks2 = new Array(n = r1 - r0 + 1);
    while (++i < n)
      ticks2[i] = (r0 + i) * step;
  } else {
    step = -step;
    let r0 = Math.round(start * step), r1 = Math.round(stop * step);
    if (r0 / step < start)
      ++r0;
    if (r1 / step > stop)
      --r1;
    ticks2 = new Array(n = r1 - r0 + 1);
    while (++i < n)
      ticks2[i] = (r0 + i) / step;
  }
  if (reverse)
    ticks2.reverse();
  return ticks2;
}
function tickIncrement(start, stop, count) {
  var step = (stop - start) / Math.max(0, count), power = Math.floor(Math.log(step) / Math.LN10), error2 = step / Math.pow(10, power);
  return power >= 0 ? (error2 >= e10 ? 10 : error2 >= e5 ? 5 : error2 >= e2 ? 2 : 1) * Math.pow(10, power) : -Math.pow(10, -power) / (error2 >= e10 ? 10 : error2 >= e5 ? 5 : error2 >= e2 ? 2 : 1);
}
function tickStep(start, stop, count) {
  var step0 = Math.abs(stop - start) / Math.max(0, count), step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)), error2 = step0 / step1;
  if (error2 >= e10)
    step1 *= 10;
  else if (error2 >= e5)
    step1 *= 5;
  else if (error2 >= e2)
    step1 *= 2;
  return stop < start ? -step1 : step1;
}
function initRange(domain, range) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(domain);
      break;
    default:
      this.range(range).domain(domain);
      break;
  }
  return this;
}
function define2(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}
function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition)
    prototype[key] = definition[key];
  return prototype;
}
function Color() {
}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*";
var reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*";
var reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
var reHex = /^#([0-9a-f]{3,8})$/;
var reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$");
var reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$");
var reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$");
var reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$");
var reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$");
var reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");
var named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define2(Color, color, {
  copy: function(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable: function() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  formatHex: color_formatHex,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format22) {
  var m, l;
  format22 = (format22 + "").trim().toLowerCase();
  return (m = reHex.exec(format22)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) : l === 3 ? new Rgb(m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, (m & 15) << 4 | m & 15, 1) : l === 8 ? rgba(m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, (m & 255) / 255) : l === 4 ? rgba(m >> 12 & 15 | m >> 8 & 240, m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, ((m & 15) << 4 | m & 15) / 255) : null) : (m = reRgbInteger.exec(format22)) ? new Rgb(m[1], m[2], m[3], 1) : (m = reRgbPercent.exec(format22)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) : (m = reRgbaInteger.exec(format22)) ? rgba(m[1], m[2], m[3], m[4]) : (m = reRgbaPercent.exec(format22)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) : (m = reHslPercent.exec(format22)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) : (m = reHslaPercent.exec(format22)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) : named.hasOwnProperty(format22) ? rgbn(named[format22]) : format22 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n) {
  return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function rgba(r, g, b, a) {
  if (a <= 0)
    r = g = b = NaN;
  return new Rgb(r, g, b, a);
}
function rgbConvert(o) {
  if (!(o instanceof Color))
    o = color(o);
  if (!o)
    return new Rgb();
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}
function rgb$1(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}
function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}
define2(Rgb, rgb$1, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb: function() {
    return this;
  },
  displayable: function() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex,
  formatHex: rgb_formatHex,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return "#" + hex(this.r) + hex(this.g) + hex(this.b);
}
function rgb_formatRgb() {
  var a = this.opacity;
  a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
  return (a === 1 ? "rgb(" : "rgba(") + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.b) || 0)) + (a === 1 ? ")" : ", " + a + ")");
}
function hex(value) {
  value = Math.max(0, Math.min(255, Math.round(value) || 0));
  return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla(h, s2, l, a) {
  if (a <= 0)
    h = s2 = l = NaN;
  else if (l <= 0 || l >= 1)
    h = s2 = NaN;
  else if (s2 <= 0)
    h = NaN;
  return new Hsl(h, s2, l, a);
}
function hslConvert(o) {
  if (o instanceof Hsl)
    return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color))
    o = color(o);
  if (!o)
    return new Hsl();
  if (o instanceof Hsl)
    return o;
  o = o.rgb();
  var r = o.r / 255, g = o.g / 255, b = o.b / 255, min = Math.min(r, g, b), max = Math.max(r, g, b), h = NaN, s2 = max - min, l = (max + min) / 2;
  if (s2) {
    if (r === max)
      h = (g - b) / s2 + (g < b) * 6;
    else if (g === max)
      h = (b - r) / s2 + 2;
    else
      h = (r - g) / s2 + 4;
    s2 /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s2 = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s2, l, o.opacity);
}
function hsl(h, s2, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s2, l, opacity == null ? 1 : opacity);
}
function Hsl(h, s2, l, opacity) {
  this.h = +h;
  this.s = +s2;
  this.l = +l;
  this.opacity = +opacity;
}
define2(Hsl, hsl, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = this.h % 360 + (this.h < 0) * 360, s2 = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s2, m1 = 2 * l - m2;
    return new Rgb(hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2), hsl2rgb(h, m1, m2), hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2), this.opacity);
  },
  displayable: function() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl: function() {
    var a = this.opacity;
    a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
    return (a === 1 ? "hsl(" : "hsla(") + (this.h || 0) + ", " + (this.s || 0) * 100 + "%, " + (this.l || 0) * 100 + "%" + (a === 1 ? ")" : ", " + a + ")");
  }
}));
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
}
var constant = (x) => () => x;
function linear$1(a, d) {
  return function(t) {
    return a + t * d;
  };
}
function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}
function gamma(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y) : constant(isNaN(a) ? b : a);
  };
}
function nogamma(a, b) {
  var d = b - a;
  return d ? linear$1(a, d) : constant(isNaN(a) ? b : a);
}
var rgb = function rgbGamma(y) {
  var color2 = gamma(y);
  function rgb2(start, end) {
    var r = color2((start = rgb$1(start)).r, (end = rgb$1(end)).r), g = color2(start.g, end.g), b = color2(start.b, end.b), opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
  rgb2.gamma = rgbGamma;
  return rgb2;
}(1);
function numberArray(a, b) {
  if (!b)
    b = [];
  var n = a ? Math.min(b.length, a.length) : 0, c = b.slice(), i;
  return function(t) {
    for (i = 0; i < n; ++i)
      c[i] = a[i] * (1 - t) + b[i] * t;
    return c;
  };
}
function isNumberArray(x) {
  return ArrayBuffer.isView(x) && !(x instanceof DataView);
}
function genericArray(a, b) {
  var nb = b ? b.length : 0, na = a ? Math.min(nb, a.length) : 0, x = new Array(na), c = new Array(nb), i;
  for (i = 0; i < na; ++i)
    x[i] = interpolate(a[i], b[i]);
  for (; i < nb; ++i)
    c[i] = b[i];
  return function(t) {
    for (i = 0; i < na; ++i)
      c[i] = x[i](t);
    return c;
  };
}
function date(a, b) {
  var d = new Date();
  return a = +a, b = +b, function(t) {
    return d.setTime(a * (1 - t) + b * t), d;
  };
}
function interpolateNumber(a, b) {
  return a = +a, b = +b, function(t) {
    return a * (1 - t) + b * t;
  };
}
function object(a, b) {
  var i = {}, c = {}, k;
  if (a === null || typeof a !== "object")
    a = {};
  if (b === null || typeof b !== "object")
    b = {};
  for (k in b) {
    if (k in a) {
      i[k] = interpolate(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }
  return function(t) {
    for (k in i)
      c[k] = i[k](t);
    return c;
  };
}
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
var reB = new RegExp(reA.source, "g");
function zero(b) {
  return function() {
    return b;
  };
}
function one(b) {
  return function(t) {
    return b(t) + "";
  };
}
function string(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s2 = [], q = [];
  a = a + "", b = b + "";
  while ((am = reA.exec(a)) && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) {
      bs = b.slice(bi, bs);
      if (s2[i])
        s2[i] += bs;
      else
        s2[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s2[i])
        s2[i] += bm;
      else
        s2[++i] = bm;
    } else {
      s2[++i] = null;
      q.push({ i, x: interpolateNumber(am, bm) });
    }
    bi = reB.lastIndex;
  }
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s2[i])
      s2[i] += bs;
    else
      s2[++i] = bs;
  }
  return s2.length < 2 ? q[0] ? one(q[0].x) : zero(b) : (b = q.length, function(t) {
    for (var i2 = 0, o; i2 < b; ++i2)
      s2[(o = q[i2]).i] = o.x(t);
    return s2.join("");
  });
}
function interpolate(a, b) {
  var t = typeof b, c;
  return b == null || t === "boolean" ? constant(b) : (t === "number" ? interpolateNumber : t === "string" ? (c = color(b)) ? (b = c, rgb) : string : b instanceof color ? rgb : b instanceof Date ? date : isNumberArray(b) ? numberArray : Array.isArray(b) ? genericArray : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object : interpolateNumber)(a, b);
}
function interpolateRound(a, b) {
  return a = +a, b = +b, function(t) {
    return Math.round(a * (1 - t) + b * t);
  };
}
function constants(x) {
  return function() {
    return x;
  };
}
function number(x) {
  return +x;
}
var unit = [0, 1];
function identity$1(x) {
  return x;
}
function normalize(a, b) {
  return (b -= a = +a) ? function(x) {
    return (x - a) / b;
  } : constants(isNaN(b) ? NaN : 0.5);
}
function clamper(a, b) {
  var t;
  if (a > b)
    t = a, a = b, b = t;
  return function(x) {
    return Math.max(a, Math.min(b, x));
  };
}
function bimap(domain, range, interpolate2) {
  var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
  if (d1 < d0)
    d0 = normalize(d1, d0), r0 = interpolate2(r1, r0);
  else
    d0 = normalize(d0, d1), r0 = interpolate2(r0, r1);
  return function(x) {
    return r0(d0(x));
  };
}
function polymap(domain, range, interpolate2) {
  var j = Math.min(domain.length, range.length) - 1, d = new Array(j), r = new Array(j), i = -1;
  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range = range.slice().reverse();
  }
  while (++i < j) {
    d[i] = normalize(domain[i], domain[i + 1]);
    r[i] = interpolate2(range[i], range[i + 1]);
  }
  return function(x) {
    var i2 = bisect(domain, x, 1, j) - 1;
    return r[i2](d[i2](x));
  };
}
function copy(source, target) {
  return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
}
function transformer() {
  var domain = unit, range = unit, interpolate$1 = interpolate, transform, untransform, unknown, clamp = identity$1, piecewise, output, input;
  function rescale() {
    var n = Math.min(domain.length, range.length);
    if (clamp !== identity$1)
      clamp = clamper(domain[0], domain[n - 1]);
    piecewise = n > 2 ? polymap : bimap;
    output = input = null;
    return scale;
  }
  function scale(x) {
    return x == null || isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate$1)))(transform(clamp(x)));
  }
  scale.invert = function(y) {
    return clamp(untransform((input || (input = piecewise(range, domain.map(transform), interpolateNumber)))(y)));
  };
  scale.domain = function(_) {
    return arguments.length ? (domain = Array.from(_, number), rescale()) : domain.slice();
  };
  scale.range = function(_) {
    return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
  };
  scale.rangeRound = function(_) {
    return range = Array.from(_), interpolate$1 = interpolateRound, rescale();
  };
  scale.clamp = function(_) {
    return arguments.length ? (clamp = _ ? true : identity$1, rescale()) : clamp !== identity$1;
  };
  scale.interpolate = function(_) {
    return arguments.length ? (interpolate$1 = _, rescale()) : interpolate$1;
  };
  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };
  return function(t, u) {
    transform = t, untransform = u;
    return rescale();
  };
}
function continuous() {
  return transformer()(identity$1, identity$1);
}
function formatDecimal(x) {
  return Math.abs(x = Math.round(x)) >= 1e21 ? x.toLocaleString("en").replace(/,/g, "") : x.toString(10);
}
function formatDecimalParts(x, p) {
  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0)
    return null;
  var i, coefficient = x.slice(0, i);
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x.slice(i + 1)
  ];
}
function exponent(x) {
  return x = formatDecimalParts(Math.abs(x)), x ? x[1] : NaN;
}
function formatGroup(grouping, thousands) {
  return function(value, width) {
    var i = value.length, t = [], j = 0, g = grouping[0], length = 0;
    while (i > 0 && g > 0) {
      if (length + g + 1 > width)
        g = Math.max(1, width - length);
      t.push(value.substring(i -= g, i + g));
      if ((length += g + 1) > width)
        break;
      g = grouping[j = (j + 1) % grouping.length];
    }
    return t.reverse().join(thousands);
  };
}
function formatNumerals(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function formatSpecifier(specifier) {
  if (!(match = re.exec(specifier)))
    throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}
formatSpecifier.prototype = FormatSpecifier.prototype;
function FormatSpecifier(specifier) {
  this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
  this.align = specifier.align === void 0 ? ">" : specifier.align + "";
  this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === void 0 ? void 0 : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === void 0 ? "" : specifier.type + "";
}
FormatSpecifier.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};
function formatTrim(s2) {
  out:
    for (var n = s2.length, i = 1, i0 = -1, i1; i < n; ++i) {
      switch (s2[i]) {
        case ".":
          i0 = i1 = i;
          break;
        case "0":
          if (i0 === 0)
            i0 = i;
          i1 = i;
          break;
        default:
          if (!+s2[i])
            break out;
          if (i0 > 0)
            i0 = 0;
          break;
      }
    }
  return i0 > 0 ? s2.slice(0, i0) + s2.slice(i1 + 1) : s2;
}
var prefixExponent;
function formatPrefixAuto(x, p) {
  var d = formatDecimalParts(x, p);
  if (!d)
    return x + "";
  var coefficient = d[0], exponent2 = d[1], i = exponent2 - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent2 / 3))) * 3) + 1, n = coefficient.length;
  return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts(x, Math.max(0, p + i - 1))[0];
}
function formatRounded(x, p) {
  var d = formatDecimalParts(x, p);
  if (!d)
    return x + "";
  var coefficient = d[0], exponent2 = d[1];
  return exponent2 < 0 ? "0." + new Array(-exponent2).join("0") + coefficient : coefficient.length > exponent2 + 1 ? coefficient.slice(0, exponent2 + 1) + "." + coefficient.slice(exponent2 + 1) : coefficient + new Array(exponent2 - coefficient.length + 2).join("0");
}
var formatTypes = {
  "%": (x, p) => (x * 100).toFixed(p),
  "b": (x) => Math.round(x).toString(2),
  "c": (x) => x + "",
  "d": formatDecimal,
  "e": (x, p) => x.toExponential(p),
  "f": (x, p) => x.toFixed(p),
  "g": (x, p) => x.toPrecision(p),
  "o": (x) => Math.round(x).toString(8),
  "p": (x, p) => formatRounded(x * 100, p),
  "r": formatRounded,
  "s": formatPrefixAuto,
  "X": (x) => Math.round(x).toString(16).toUpperCase(),
  "x": (x) => Math.round(x).toString(16)
};
function identity(x) {
  return x;
}
var map = Array.prototype.map;
var prefixes = ["y", "z", "a", "f", "p", "n", "\xB5", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function formatLocale(locale2) {
  var group = locale2.grouping === void 0 || locale2.thousands === void 0 ? identity : formatGroup(map.call(locale2.grouping, Number), locale2.thousands + ""), currencyPrefix = locale2.currency === void 0 ? "" : locale2.currency[0] + "", currencySuffix = locale2.currency === void 0 ? "" : locale2.currency[1] + "", decimal = locale2.decimal === void 0 ? "." : locale2.decimal + "", numerals = locale2.numerals === void 0 ? identity : formatNumerals(map.call(locale2.numerals, String)), percent = locale2.percent === void 0 ? "%" : locale2.percent + "", minus = locale2.minus === void 0 ? "\u2212" : locale2.minus + "", nan = locale2.nan === void 0 ? "NaN" : locale2.nan + "";
  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);
    var fill = specifier.fill, align = specifier.align, sign = specifier.sign, symbol = specifier.symbol, zero2 = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type = specifier.type;
    if (type === "n")
      comma = true, type = "g";
    else if (!formatTypes[type])
      precision === void 0 && (precision = 12), trim = true, type = "g";
    if (zero2 || fill === "0" && align === "=")
      zero2 = true, fill = "0", align = "=";
    var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "", suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";
    var formatType = formatTypes[type], maybeSuffix = /[defgprs%]/.test(type);
    precision = precision === void 0 ? 6 : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
    function format22(value) {
      var valuePrefix = prefix, valueSuffix = suffix, i, n, c;
      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;
        var valueNegative = value < 0 || 1 / value < 0;
        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
        if (trim)
          value = formatTrim(value);
        if (valueNegative && +value === 0 && sign !== "+")
          valueNegative = false;
        valuePrefix = (valueNegative ? sign === "(" ? sign : minus : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
        valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c = value.charCodeAt(i), 48 > c || c > 57) {
              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }
      if (comma && !zero2)
        value = group(value, Infinity);
      var length = valuePrefix.length + value.length + valueSuffix.length, padding = length < width ? new Array(width - length + 1).join(fill) : "";
      if (comma && zero2)
        value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
      switch (align) {
        case "<":
          value = valuePrefix + value + valueSuffix + padding;
          break;
        case "=":
          value = valuePrefix + padding + value + valueSuffix;
          break;
        case "^":
          value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);
          break;
        default:
          value = padding + valuePrefix + value + valueSuffix;
          break;
      }
      return numerals(value);
    }
    format22.toString = function() {
      return specifier + "";
    };
    return format22;
  }
  function formatPrefix2(specifier, value) {
    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3, k = Math.pow(10, -e), prefix = prefixes[8 + e / 3];
    return function(value2) {
      return f(k * value2) + prefix;
    };
  }
  return {
    format: newFormat,
    formatPrefix: formatPrefix2
  };
}
var locale;
var format2;
var formatPrefix;
defaultLocale({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function defaultLocale(definition) {
  locale = formatLocale(definition);
  format2 = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}
function precisionFixed(step) {
  return Math.max(0, -exponent(Math.abs(step)));
}
function precisionPrefix(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
}
function precisionRound(step, max) {
  step = Math.abs(step), max = Math.abs(max) - step;
  return Math.max(0, exponent(max) - exponent(step)) + 1;
}
function tickFormat(start, stop, count, specifier) {
  var step = tickStep(start, stop, count), precision;
  specifier = formatSpecifier(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value)))
        specifier.precision = precision;
      return formatPrefix(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start), Math.abs(stop)))))
        specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = precisionFixed(step)))
        specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return format2(specifier);
}
function linearish(scale) {
  var domain = scale.domain;
  scale.ticks = function(count) {
    var d = domain();
    return ticks(d[0], d[d.length - 1], count == null ? 10 : count);
  };
  scale.tickFormat = function(count, specifier) {
    var d = domain();
    return tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
  };
  scale.nice = function(count) {
    if (count == null)
      count = 10;
    var d = domain();
    var i0 = 0;
    var i1 = d.length - 1;
    var start = d[i0];
    var stop = d[i1];
    var prestep;
    var step;
    var maxIter = 10;
    if (stop < start) {
      step = start, start = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }
    while (maxIter-- > 0) {
      step = tickIncrement(start, stop, count);
      if (step === prestep) {
        d[i0] = start;
        d[i1] = stop;
        return domain(d);
      } else if (step > 0) {
        start = Math.floor(start / step) * step;
        stop = Math.ceil(stop / step) * step;
      } else if (step < 0) {
        start = Math.ceil(start * step) / step;
        stop = Math.floor(stop * step) / step;
      } else {
        break;
      }
      prestep = step;
    }
    return scale;
  };
  return scale;
}
function linear() {
  var scale = continuous();
  scale.copy = function() {
    return copy(scale, linear());
  };
  initRange.apply(scale, arguments);
  return linearish(scale);
}
var css$7 = {
  code: ".post-container.svelte-1ktwubj{width:100%;border-radius:10px;background:white;padding:30px;margin:12px;overflow:hidden;border:1px solid white;transition:all 100ms linear, border 300ms ease}.perspective-container.svelte-1ktwubj{display:flex;position:relative;margin:-4px}.card-highlight.svelte-1ktwubj{position:absolute;width:100%;height:100%;border-radius:50%;background:rgba(0, 0, 0, 0.01);filter:blur(20px);z-index:1;pointer-events:none}.post-card.svelte-1ktwubj{display:flex;flex-direction:column;place-content:center;height:100%;pointer-events:none}.post-title.svelte-1ktwubj{font-size:1.8rem;line-height:1.2;padding-bottom:1rem;max-width:17ch}.post-description-container.svelte-1ktwubj{display:flex;justify-content:space-between}.post-description.svelte-1ktwubj,.post-tag.svelte-1ktwubj{font-size:1.1rem;line-height:1.25;text-transform:uppercase;font-family:var(--font-sans);color:rgb(55, 55, 55);font-weight:200;letter-spacing:0.64px}.post-description.svelte-1ktwubj,.post-tags-container.svelte-1ktwubj{display:inline-block}.post-tag.svelte-1ktwubj{padding:2px 6px;background:rgba(var(--accent-color-rgb), 0.1);margin:1px 3px;border-radius:3px;color:rgba(var(--accent-color-rgb), 1);font-size:0.85rem;font-weight:100;float:right}.hovered.svelte-1ktwubj{border:1px solid var(--accent-color)}.featured-star.svelte-1ktwubj{position:absolute;top:0;right:0;padding:6px}.unhovered.svelte-1ktwubj{filter:grayscale(1)}@media screen and (max-width: 768px){.post-title.svelte-1ktwubj{font-size:1.5rem;max-width:100%}}@media screen and (max-width: 460px){.post-container.svelte-1ktwubj{padding:15px 20px}.post-title.svelte-1ktwubj{font-size:1.2rem}.post-description.svelte-1ktwubj{font-size:0.9rem}.post-tag.svelte-1ktwubj{font-size:0.8rem}}",
  map: `{"version":3,"file":"BlogSection.svelte","sources":["BlogSection.svelte"],"sourcesContent":["<script>\\n  export let post;\\n  export let slug;\\n  export let anyHovered;\\n  export let index;\\n\\n  import { scaleLinear } from \\"d3-scale\\";\\n  import { onMount } from \\"svelte\\";\\n\\n  import { dateFormat } from \\"../scripts/utils.js\\";\\n  import Star from \\"$lib/Icons/Star.svelte\\";\\n\\n  /* Initialize variables which will bind to our DOM elements */\\n  let card,\\n    cardWidth,\\n    cardHeight,\\n    cardLeft,\\n    cardTop,\\n    xPos,\\n    yPos,\\n    scrollXPosition,\\n    scrollYPosition,\\n    pageWidth,\\n    readyToHover = false;\\n\\n  /* Once we have our \`card\` element, get the leftmost position and top position\\n\\t\\t This will later enable the x- and y-position of our mouse relative to the card dimensions */\\n  $: getCardDimensions = function (card) {\\n    cardLeft = card ? card.getBoundingClientRect().left : 0;\\n    cardTop = card ? card.getBoundingClientRect().top + scrollYPosition : 0;\\n  };\\n\\n  // On page resize, rerun get card dimensions\\n  $: pageWidth, getCardDimensions(card);\\n  $: scrollYPosition, getCardDimensions(card);\\n\\n  /* ! IMPORTANT !\\n    Wait for some time (at least duration of page transition) to get bounding client rect \\n    There is currently a conflict with reading getBoudingClientRect().top when page transitions \\n  */\\n  onMount(() => {\\n    setTimeout(() => {\\n      getCardDimensions(card);\\n      readyToHover = true;\\n    }, 1000);\\n  });\\n\\n  /* Called on hover, this sets our x- and y-position to equal the cursor position *within* the card */\\n  const setCoords = function (event) {\\n    xPos = event.clientX - cardLeft;\\n    yPos = event.pageY - cardTop;\\n  };\\n\\n  /* Resets */\\n  const resetCoords = function () {\\n    xPos = null;\\n    yPos = null;\\n\\n    anyHovered = false;\\n    hovered = false;\\n  };\\n\\n  /* Rotation amount */\\n  $: xScale = scaleLinear().domain([0, cardWidth]).range([-4, 4]);\\n  $: yScale = scaleLinear().domain([cardHeight, 0]).range([-4, 4]);\\n\\n  $: rotationX = xPos ? xScale(xPos) : 0;\\n  $: rotationY = yPos ? yScale(yPos) : 0;\\n\\n  /* Highlighted circle */\\n  $: circleXScale = scaleLinear().domain([0, cardWidth]).range([-50, 50]);\\n  $: circleYScale = scaleLinear().domain([0, cardHeight]).range([-50, 50]);\\n\\n  $: circleXPosition = xPos ? circleXScale(xPos) : 0;\\n  $: circleYPosition = yPos ? circleYScale(yPos) : 0;\\n\\n  /* Box shadow */\\n  $: shadowX = xPos ? circleXScale(xPos) / 5 : 0;\\n  $: shadowY = yPos ? circleYScale(yPos) / 5 : 0;\\n\\n  /* 3d scaling */\\n  $: scale3dVal = xPos && yPos ? 1.02 : 1;\\n\\n  let hovered = false;\\n<\/script>\\n\\n<svelte:window\\n  bind:scrollY={scrollYPosition}\\n  bind:scrollX={scrollXPosition}\\n  bind:innerWidth={pageWidth}\\n/>\\n<div\\n  class=\\"perspective-container\\"\\n  style=\\"perspective: {cardWidth}px\\"\\n  on:mouseover={() => {\\n    anyHovered = true;\\n    hovered = true;\\n  }}\\n  on:focus={null}\\n  on:mousemove={readyToHover ? setCoords : null}\\n  on:mouseleave={resetCoords}\\n  bind:this={card}\\n  bind:offsetWidth={cardWidth}\\n  bind:offsetHeight={cardHeight}\\n>\\n  <a\\n    style=\\"transform: rotateY({rotationX}deg) rotateX({rotationY}deg) \\n\\t\\t\\t\\t\\t scale3d({scale3dVal}, {scale3dVal}, {scale3dVal});\\n\\t\\t\\t\\t\\t box-shadow: {shadowX}px {shadowY}px 15px rgba(0, 0, 0, 0.1);\\"\\n    class=\\"post-container no-underline {post.featured ? 'featured' : ''} \\n           {anyHovered ? (hovered ? 'hovered' : 'unhovered') : ''}\\"\\n    sveltekit:prefetch\\n    href={slug}\\n  >\\n    {#if post.featured}\\n      <div class=\\"featured-star\\">\\n        <Star\\n          width=\\"20\\"\\n          height=\\"20\\"\\n          fill=\\"var(--accent-color)\\"\\n          stroke=\\"none\\"\\n          {hovered}\\n          {index}\\n        />\\n      </div>\\n    {/if}\\n    <div\\n      class=\\"card-highlight\\"\\n      style=\\"left: {circleXPosition}%; top: {circleYPosition}%\\"\\n    />\\n    <div class=\\"post-card\\">\\n      <h1 class=\\"post-title\\">{post.title}</h1>\\n      <div class=\\"post-description-container\\">\\n        <p class=\\"post-description\\">{dateFormat(post.date)}</p>\\n        <div class=\\"post-tags-container\\">\\n          {#each post.tags as tag}\\n            <span class=\\"post-tag\\">{tag}</span>\\n          {/each}\\n        </div>\\n      </div>\\n    </div>\\n  </a>\\n</div>\\n\\n<style>\\n  .post-container {\\n    width: 100%;\\n    border-radius: 10px;\\n    background: white;\\n    padding: 30px;\\n    margin: 12px; /* Need this for perspective container overflow */\\n    overflow: hidden;\\n    border: 1px solid white;\\n    transition: all 100ms linear, border 300ms ease;\\n  }\\n\\n  .perspective-container {\\n    display: flex;\\n    position: relative;\\n    margin: -4px; /* Undoes some of the margin above while still allowing for hover events */\\n  }\\n\\n  .card-highlight {\\n    position: absolute;\\n    width: 100%;\\n    height: 100%;\\n    border-radius: 50%;\\n    background: rgba(0, 0, 0, 0.01);\\n    filter: blur(20px);\\n    z-index: 1;\\n    pointer-events: none;\\n  }\\n\\n  .post-card {\\n    display: flex;\\n    flex-direction: column;\\n    place-content: center;\\n    height: 100%;\\n    pointer-events: none;\\n  }\\n\\n  .post-title {\\n    font-size: 1.8rem;\\n    line-height: 1.2;\\n    padding-bottom: 1rem;\\n    max-width: 17ch;\\n  }\\n\\n  .post-description-container {\\n    display: flex;\\n    justify-content: space-between;\\n  }\\n\\n  .post-description,\\n  .post-tag {\\n    font-size: 1.1rem;\\n    line-height: 1.25;\\n    text-transform: uppercase;\\n    font-family: var(--font-sans);\\n    color: rgb(55, 55, 55);\\n    font-weight: 200;\\n    letter-spacing: 0.64px;\\n  }\\n\\n  .post-description,\\n  .post-tags-container {\\n    display: inline-block;\\n  }\\n\\n  .post-tag {\\n    padding: 2px 6px;\\n    background: rgba(var(--accent-color-rgb), 0.1);\\n    margin: 1px 3px;\\n    border-radius: 3px;\\n    color: rgba(var(--accent-color-rgb), 1);\\n    font-size: 0.85rem;\\n    font-weight: 100;\\n    /* letter-spacing: 1px; */\\n    float: right;\\n  }\\n\\n  .hovered {\\n    border: 1px solid var(--accent-color);\\n  }\\n\\n  .featured-star {\\n    position: absolute;\\n    top: 0;\\n    right: 0;\\n    padding: 6px;\\n  }\\n\\n  .unhovered {\\n    filter: grayscale(1);\\n  }\\n\\n  /* TABLET BREAKPOINT */\\n  @media screen and (max-width: 768px) {\\n    .post-title {\\n      font-size: 1.5rem;\\n      max-width: 100%;\\n    }\\n  }\\n\\n  /* MOBILE */\\n  @media screen and (max-width: 460px) {\\n    .post-container {\\n      padding: 15px 20px;\\n    }\\n    .post-title {\\n      font-size: 1.2rem;\\n    }\\n\\n    .post-description {\\n      font-size: 0.9rem;\\n    }\\n\\n    .post-tag {\\n      font-size: 0.8rem;\\n    }\\n  }\\n</style>\\n"],"names":[],"mappings":"AAiJE,eAAe,eAAC,CAAC,AACf,KAAK,CAAE,IAAI,CACX,aAAa,CAAE,IAAI,CACnB,UAAU,CAAE,KAAK,CACjB,OAAO,CAAE,IAAI,CACb,MAAM,CAAE,IAAI,CACZ,QAAQ,CAAE,MAAM,CAChB,MAAM,CAAE,GAAG,CAAC,KAAK,CAAC,KAAK,CACvB,UAAU,CAAE,GAAG,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,AACjD,CAAC,AAED,sBAAsB,eAAC,CAAC,AACtB,OAAO,CAAE,IAAI,CACb,QAAQ,CAAE,QAAQ,CAClB,MAAM,CAAE,IAAI,AACd,CAAC,AAED,eAAe,eAAC,CAAC,AACf,QAAQ,CAAE,QAAQ,CAClB,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,aAAa,CAAE,GAAG,CAClB,UAAU,CAAE,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAC/B,MAAM,CAAE,KAAK,IAAI,CAAC,CAClB,OAAO,CAAE,CAAC,CACV,cAAc,CAAE,IAAI,AACtB,CAAC,AAED,UAAU,eAAC,CAAC,AACV,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,CACtB,aAAa,CAAE,MAAM,CACrB,MAAM,CAAE,IAAI,CACZ,cAAc,CAAE,IAAI,AACtB,CAAC,AAED,WAAW,eAAC,CAAC,AACX,SAAS,CAAE,MAAM,CACjB,WAAW,CAAE,GAAG,CAChB,cAAc,CAAE,IAAI,CACpB,SAAS,CAAE,IAAI,AACjB,CAAC,AAED,2BAA2B,eAAC,CAAC,AAC3B,OAAO,CAAE,IAAI,CACb,eAAe,CAAE,aAAa,AAChC,CAAC,AAED,gCAAiB,CACjB,SAAS,eAAC,CAAC,AACT,SAAS,CAAE,MAAM,CACjB,WAAW,CAAE,IAAI,CACjB,cAAc,CAAE,SAAS,CACzB,WAAW,CAAE,IAAI,WAAW,CAAC,CAC7B,KAAK,CAAE,IAAI,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CACtB,WAAW,CAAE,GAAG,CAChB,cAAc,CAAE,MAAM,AACxB,CAAC,AAED,gCAAiB,CACjB,oBAAoB,eAAC,CAAC,AACpB,OAAO,CAAE,YAAY,AACvB,CAAC,AAED,SAAS,eAAC,CAAC,AACT,OAAO,CAAE,GAAG,CAAC,GAAG,CAChB,UAAU,CAAE,KAAK,IAAI,kBAAkB,CAAC,CAAC,CAAC,GAAG,CAAC,CAC9C,MAAM,CAAE,GAAG,CAAC,GAAG,CACf,aAAa,CAAE,GAAG,CAClB,KAAK,CAAE,KAAK,IAAI,kBAAkB,CAAC,CAAC,CAAC,CAAC,CAAC,CACvC,SAAS,CAAE,OAAO,CAClB,WAAW,CAAE,GAAG,CAEhB,KAAK,CAAE,KAAK,AACd,CAAC,AAED,QAAQ,eAAC,CAAC,AACR,MAAM,CAAE,GAAG,CAAC,KAAK,CAAC,IAAI,cAAc,CAAC,AACvC,CAAC,AAED,cAAc,eAAC,CAAC,AACd,QAAQ,CAAE,QAAQ,CAClB,GAAG,CAAE,CAAC,CACN,KAAK,CAAE,CAAC,CACR,OAAO,CAAE,GAAG,AACd,CAAC,AAED,UAAU,eAAC,CAAC,AACV,MAAM,CAAE,UAAU,CAAC,CAAC,AACtB,CAAC,AAGD,OAAO,MAAM,CAAC,GAAG,CAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AACpC,WAAW,eAAC,CAAC,AACX,SAAS,CAAE,MAAM,CACjB,SAAS,CAAE,IAAI,AACjB,CAAC,AACH,CAAC,AAGD,OAAO,MAAM,CAAC,GAAG,CAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AACpC,eAAe,eAAC,CAAC,AACf,OAAO,CAAE,IAAI,CAAC,IAAI,AACpB,CAAC,AACD,WAAW,eAAC,CAAC,AACX,SAAS,CAAE,MAAM,AACnB,CAAC,AAED,iBAAiB,eAAC,CAAC,AACjB,SAAS,CAAE,MAAM,AACnB,CAAC,AAED,SAAS,eAAC,CAAC,AACT,SAAS,CAAE,MAAM,AACnB,CAAC,AACH,CAAC"}`
};
var BlogSection = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let getCardDimensions;
  let rotationX;
  let rotationY;
  let circleXPosition;
  let circleYPosition;
  let shadowX;
  let shadowY;
  let scale3dVal;
  let { post } = $$props;
  let { slug } = $$props;
  let { anyHovered } = $$props;
  let { index: index2 } = $$props;
  let card, cardWidth, cardHeight, scrollYPosition;
  let hovered = false;
  if ($$props.post === void 0 && $$bindings.post && post !== void 0)
    $$bindings.post(post);
  if ($$props.slug === void 0 && $$bindings.slug && slug !== void 0)
    $$bindings.slug(slug);
  if ($$props.anyHovered === void 0 && $$bindings.anyHovered && anyHovered !== void 0)
    $$bindings.anyHovered(anyHovered);
  if ($$props.index === void 0 && $$bindings.index && index2 !== void 0)
    $$bindings.index(index2);
  $$result.css.add(css$7);
  getCardDimensions = function(card2) {
    card2 ? card2.getBoundingClientRect().left : 0;
    card2 ? card2.getBoundingClientRect().top + scrollYPosition : 0;
  };
  {
    getCardDimensions(card);
  }
  {
    getCardDimensions(card);
  }
  linear().domain([0, cardWidth]).range([-4, 4]);
  linear().domain([cardHeight, 0]).range([-4, 4]);
  rotationX = 0;
  rotationY = 0;
  linear().domain([0, cardWidth]).range([-50, 50]);
  linear().domain([0, cardHeight]).range([-50, 50]);
  circleXPosition = 0;
  circleYPosition = 0;
  shadowX = 0;
  shadowY = 0;
  scale3dVal = 1;
  return `
<div class="${"perspective-container svelte-1ktwubj"}" style="${"perspective: " + escape(cardWidth) + "px"}"${add_attribute("this", card, 0)}><a style="${"transform: rotateY(" + escape(rotationX) + "deg) rotateX(" + escape(rotationY) + "deg) scale3d(" + escape(scale3dVal) + ", " + escape(scale3dVal) + ", " + escape(scale3dVal) + "); box-shadow: " + escape(shadowX) + "px " + escape(shadowY) + "px 15px rgba(0, 0, 0, 0.1);"}" class="${"post-container no-underline " + escape(post.featured ? "featured" : "") + " " + escape(anyHovered ? "unhovered" : "") + " svelte-1ktwubj"}" sveltekit:prefetch${add_attribute("href", slug, 0)}>${post.featured ? `<div class="${"featured-star svelte-1ktwubj"}">${validate_component(Star, "Star").$$render($$result, {
    width: "20",
    height: "20",
    fill: "var(--accent-color)",
    stroke: "none",
    hovered,
    index: index2
  }, {}, {})}</div>` : ``}
    <div class="${"card-highlight svelte-1ktwubj"}" style="${"left: " + escape(circleXPosition) + "%; top: " + escape(circleYPosition) + "%"}"></div>
    <div class="${"post-card svelte-1ktwubj"}"><h1 class="${"post-title svelte-1ktwubj"}">${escape(post.title)}</h1>
      <div class="${"post-description-container svelte-1ktwubj"}"><p class="${"post-description svelte-1ktwubj"}">${escape(dateFormat(post.date))}</p>
        <div class="${"post-tags-container svelte-1ktwubj"}">${each(post.tags, (tag) => `<span class="${"post-tag svelte-1ktwubj"}">${escape(tag)}</span>`)}</div></div></div></a>
</div>`;
});
var css$6 = {
  code: "main.svelte-1ajc2xg{max-width:860px;margin:0 auto;padding:1em}.post-grid.svelte-1ajc2xg{display:grid;grid-template-columns:repeat(2, 1fr)}@media screen and (max-width: 668px){.post-grid.svelte-1ajc2xg{grid-template-columns:1fr}}.archives-title.svelte-1ajc2xg{font-size:3rem;margin:1.5rem 1rem 1rem 1rem;border-top:1px solid rgba(var(--accent-color-rgb), 0.5);padding:2rem 0 0.5rem 0;font-weight:100;color:black;text-transform:uppercase;text-align:center}",
  map: `{"version":3,"file":"index.svelte","sources":["index.svelte"],"sourcesContent":["<script context=\\"module\\">\\n  /**\\n   * @type {import('@sveltejs/kit').Load}\\n   */\\n  export async function load({ fetch }) {\\n    const res = await fetch(\`/posts.json\`);\\n    const posts = await res.json();\\n\\n    return {\\n      props: {\\n        posts,\\n      },\\n    };\\n  }\\n<\/script>\\n\\n<script>\\n  import { slide } from \\"svelte/transition\\";\\n  import { linear } from \\"svelte/easing\\";\\n\\n  import BlogSection from \\"$lib/BlogSection.svelte\\";\\n  import Transition from \\"$lib/Transition.svelte\\";\\n\\n  export let posts;\\n\\n  let filteredPosts = posts\\n    .filter((d) => d.metadata.draft != true && d.metadata.archived != true)\\n    .sort((a, b) => Date.parse(b.metadata.date) - Date.parse(a.metadata.date))\\n    .sort((a, b) => b.metadata.featured);\\n\\n  let otherPosts = posts\\n    .filter((d) => d.metadata.archived == true)\\n    .sort((a, b) => Date.parse(b.metadata.date) - Date.parse(a.metadata.date));\\n\\n  import { seo } from \\"$lib/store.js\\";\\n  $seo = {\\n    title: \\"Blog | Connor Rothschild\\",\\n    description: \\"Some of my writing.\\",\\n  };\\n\\n  let anyHovered = false;\\n  let showAll = false;\\n<\/script>\\n\\n<Transition />\\n<main>\\n  <h1 class=\\"page-overline\\">Blog</h1>\\n  <h1 class=\\"page-title\\">\\n    What I've\\n    <span class=\\"gradient-accented bolded\\">written</span>\u200B\\n  </h1>\\n  <div class=\\"transition-content post-grid\\">\\n    {#each filteredPosts as post, index}\\n      <BlogSection\\n        post={post.metadata}\\n        slug={post.path.replace(/\\\\.[^/.]+$/, \\"\\")}\\n        {index}\\n        bind:anyHovered\\n      />\\n    {/each}\\n  </div>\\n  {#if showAll}\\n    <div transition:slide={{ duration: 300, easing: linear }}>\\n      <h1 class=\\"archives-title\\">\u{1F62C} The archives \u{1F62C}</h1>\\n      <div class=\\"transition-content post-grid\\">\\n        {#each otherPosts as post, index}\\n          <BlogSection\\n            post={post.metadata}\\n            slug={post.path.replace(/\\\\.[^/.]+$/, \\"\\")}\\n            {index}\\n            bind:anyHovered\\n          />\\n        {/each}\\n      </div>\\n    </div>\\n  {/if}\\n  <button\\n    class=\\"button pulled-right block\\"\\n    on:click={() => {\\n      showAll = !showAll;\\n    }}\\n  >\\n    {showAll ? \\"Hide the archives \u{1F44D}\\" : \\"Show the archives \u{1F62C}\\"}\\n  </button>\\n</main>\\n\\n<style>\\n  main {\\n    /* width: 100%; */\\n    max-width: 860px;\\n    margin: 0 auto;\\n    padding: 1em;\\n  }\\n\\n  .post-grid {\\n    display: grid;\\n    grid-template-columns: repeat(2, 1fr);\\n    /* grid-gap: 15px; */\\n  }\\n\\n  @media screen and (max-width: 668px) {\\n    .post-grid {\\n      grid-template-columns: 1fr;\\n    }\\n  }\\n\\n  .archives-title {\\n    font-size: 3rem;\\n    margin: 1.5rem 1rem 1rem 1rem;\\n    border-top: 1px solid rgba(var(--accent-color-rgb), 0.5);\\n    padding: 2rem 0 0.5rem 0;\\n    font-weight: 100;\\n    color: black;\\n    text-transform: uppercase;\\n    text-align: center;\\n  }\\n</style>\\n"],"names":[],"mappings":"AAuFE,IAAI,eAAC,CAAC,AAEJ,SAAS,CAAE,KAAK,CAChB,MAAM,CAAE,CAAC,CAAC,IAAI,CACd,OAAO,CAAE,GAAG,AACd,CAAC,AAED,UAAU,eAAC,CAAC,AACV,OAAO,CAAE,IAAI,CACb,qBAAqB,CAAE,OAAO,CAAC,CAAC,CAAC,GAAG,CAAC,AAEvC,CAAC,AAED,OAAO,MAAM,CAAC,GAAG,CAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AACpC,UAAU,eAAC,CAAC,AACV,qBAAqB,CAAE,GAAG,AAC5B,CAAC,AACH,CAAC,AAED,eAAe,eAAC,CAAC,AACf,SAAS,CAAE,IAAI,CACf,MAAM,CAAE,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAC7B,UAAU,CAAE,GAAG,CAAC,KAAK,CAAC,KAAK,IAAI,kBAAkB,CAAC,CAAC,CAAC,GAAG,CAAC,CACxD,OAAO,CAAE,IAAI,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CACxB,WAAW,CAAE,GAAG,CAChB,KAAK,CAAE,KAAK,CACZ,cAAc,CAAE,SAAS,CACzB,UAAU,CAAE,MAAM,AACpB,CAAC"}`
};
async function load({ fetch: fetch2 }) {
  const res = await fetch2(`/posts.json`);
  const posts = await res.json();
  return { props: { posts } };
}
var Post = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $seo, $$unsubscribe_seo;
  $$unsubscribe_seo = subscribe(seo, (value) => $seo = value);
  let { posts } = $$props;
  let filteredPosts = posts.filter((d) => d.metadata.draft != true && d.metadata.archived != true).sort((a, b) => Date.parse(b.metadata.date) - Date.parse(a.metadata.date)).sort((a, b) => b.metadata.featured);
  posts.filter((d) => d.metadata.archived == true).sort((a, b) => Date.parse(b.metadata.date) - Date.parse(a.metadata.date));
  set_store_value(seo, $seo = {
    title: "Blog | Connor Rothschild",
    description: "Some of my writing."
  }, $seo);
  let anyHovered = false;
  if ($$props.posts === void 0 && $$bindings.posts && posts !== void 0)
    $$bindings.posts(posts);
  $$result.css.add(css$6);
  let $$settled;
  let $$rendered;
  do {
    $$settled = true;
    $$rendered = `${validate_component(Main, "Transition").$$render($$result, {}, {}, {})}
<main class="${"svelte-1ajc2xg"}"><h1 class="${"page-overline"}">Blog</h1>
  <h1 class="${"page-title"}">What I&#39;ve
    <span class="${"gradient-accented bolded"}">written</span>\u200B
  </h1>
  <div class="${"transition-content post-grid svelte-1ajc2xg"}">${each(filteredPosts, (post, index2) => `${validate_component(BlogSection, "BlogSection").$$render($$result, {
      post: post.metadata,
      slug: post.path.replace(/\.[^/.]+$/, ""),
      index: index2,
      anyHovered
    }, {
      anyHovered: ($$value) => {
        anyHovered = $$value;
        $$settled = false;
      }
    }, {})}`)}</div>
  ${``}
  <button class="${"button pulled-right block"}">${escape("Show the archives \u{1F62C}")}</button>
</main>`;
  } while (!$$settled);
  $$unsubscribe_seo();
  return $$rendered;
});
var index = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Post,
  load
});
var css$5 = {
  code: "main.svelte-1ygtcpf{max-width:768px;margin:0 auto;padding:1em}.content.svelte-1ygtcpf{margin-bottom:4rem}.date.svelte-1ygtcpf{font-weight:200;margin-top:-2rem;font-size:1.5rem;margin-bottom:2rem;letter-spacing:0.64px}",
  map: `{"version":3,"file":"layout.svelte","sources":["layout.svelte"],"sourcesContent":["<script>\\n  import BackTo from \\"$lib/Text/BackTo.svelte\\";\\n  import Transition from \\"$lib/Transitions/Content.svelte\\";\\n\\n  import { seo } from \\"$lib/store\\";\\n  import { dateFormat } from \\"../../scripts/utils.js\\";\\n\\n  export let title;\\n  export let description;\\n  export let date;\\n\\n  $seo = {\\n    title: title,\\n    description: description,\\n  };\\n<\/script>\\n\\n<svelte:head>\\n  <title>{title}</title>\\n  <meta name=\\"description\\" content={description} />\\n</svelte:head>\\n\\n<Transition />\\n<main>\\n  <BackTo href=\\"/post\\" text=\\"Blog\\" classes=\\"page-overline\\" />\\n  <h1 class=\\"page-title no-border\\">{title}</h1>\\n  <div class=\\"date border-bottom transition-content\\">\\n    {dateFormat(date)} | 1 minute read (if you're fast)\\n  </div>\\n  <div class=\\"transition-content\\">\\n    <div class=\\"content\\">\\n      <slot />\\n      <BackTo href=\\"/post\\" text=\\"Back to all posts\\" classes=\\"border-top\\" />\\n    </div>\\n  </div>\\n</main>\\n\\n<style>\\n  main {\\n    /* background: var(--secondary-color); */\\n    max-width: 768px;\\n    margin: 0 auto;\\n    padding: 1em;\\n    /* width: 90vw; */\\n  }\\n\\n  .content {\\n    margin-bottom: 4rem;\\n  }\\n\\n  .date {\\n    font-weight: 200;\\n    margin-top: -2rem;\\n    font-size: 1.5rem;\\n    margin-bottom: 2rem;\\n    letter-spacing: 0.64px;\\n  }\\n</style>\\n"],"names":[],"mappings":"AAsCE,IAAI,eAAC,CAAC,AAEJ,SAAS,CAAE,KAAK,CAChB,MAAM,CAAE,CAAC,CAAC,IAAI,CACd,OAAO,CAAE,GAAG,AAEd,CAAC,AAED,QAAQ,eAAC,CAAC,AACR,aAAa,CAAE,IAAI,AACrB,CAAC,AAED,KAAK,eAAC,CAAC,AACL,WAAW,CAAE,GAAG,CAChB,UAAU,CAAE,KAAK,CACjB,SAAS,CAAE,MAAM,CACjB,aAAa,CAAE,IAAI,CACnB,cAAc,CAAE,MAAM,AACxB,CAAC"}`
};
var Layout = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $seo, $$unsubscribe_seo;
  $$unsubscribe_seo = subscribe(seo, (value) => $seo = value);
  let { title } = $$props;
  let { description } = $$props;
  let { date: date2 } = $$props;
  set_store_value(seo, $seo = { title, description }, $seo);
  if ($$props.title === void 0 && $$bindings.title && title !== void 0)
    $$bindings.title(title);
  if ($$props.description === void 0 && $$bindings.description && description !== void 0)
    $$bindings.description(description);
  if ($$props.date === void 0 && $$bindings.date && date2 !== void 0)
    $$bindings.date(date2);
  $$result.css.add(css$5);
  $$unsubscribe_seo();
  return `${$$result.head += `${$$result.title = `<title>${escape(title)}</title>`, ""}<meta name="${"description"}"${add_attribute("content", description, 0)} data-svelte="svelte-1law5hj">`, ""}

${validate_component(Content, "Transition").$$render($$result, {}, {}, {})}
<main class="${"svelte-1ygtcpf"}">${validate_component(BackTo, "BackTo").$$render($$result, {
    href: "/post",
    text: "Blog",
    classes: "page-overline"
  }, {}, {})}
  <h1 class="${"page-title no-border"}">${escape(title)}</h1>
  <div class="${"date border-bottom transition-content svelte-1ygtcpf"}">${escape(dateFormat(date2))} | 1 minute read (if you&#39;re fast)
  </div>
  <div class="${"transition-content"}"><div class="${"content svelte-1ygtcpf"}">${slots.default ? slots.default({}) : ``}
      ${validate_component(BackTo, "BackTo").$$render($$result, {
    href: "/post",
    text: "Back to all posts",
    classes: "border-top"
  }, {}, {})}</div></div>
</main>`;
});
var layout = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Layout
});
var css$4 = {
  code: '.info.svelte-1kch8kc::before{content:"\u2757\uFE0F";font-size:1.5rem;margin-right:1rem}.info.svelte-1kch8kc{display:flex;place-items:center;border-radius:10px;font-weight:normal;background:white;box-shadow:2px 2px 5px 1px #cecece80;padding:1rem;margin:1.75rem 0}.info .text p:not(:last-child){margin-bottom:1rem}.info .text p:last-child{margin-bottom:0}',
  map: '{"version":3,"file":"Info.svelte","sources":["Info.svelte"],"sourcesContent":["<script>\\n  // import SvelteMarkdown from \\"svelte-markdown\\";\\n<\/script>\\n\\n<div class=\\"info\\">\\n  <div class=\\"text\\">\\n    <p>\\n      <slot />\\n      <!-- <SvelteMarkdown source={$$slots.content} /> -->\\n    </p>\\n  </div>\\n</div>\\n\\n<style>\\n  .info::before {\\n    content: \\"\u2757\uFE0F\\";\\n    font-size: 1.5rem;\\n    margin-right: 1rem;\\n  }\\n\\n  .info {\\n    display: flex;\\n    place-items: center;\\n    border-radius: 10px;\\n    font-weight: normal;\\n    background: white;\\n    box-shadow: 2px 2px 5px 1px #cecece80;\\n    padding: 1rem;\\n    margin: 1.75rem 0;\\n  }\\n\\n  :global(.info .text p:not(:last-child)) {\\n    margin-bottom: 1rem;\\n  }\\n\\n  :global(.info .text p:last-child) {\\n    margin-bottom: 0;\\n  }\\n</style>\\n"],"names":[],"mappings":"AAcE,oBAAK,QAAQ,AAAC,CAAC,AACb,OAAO,CAAE,IAAI,CACb,SAAS,CAAE,MAAM,CACjB,YAAY,CAAE,IAAI,AACpB,CAAC,AAED,KAAK,eAAC,CAAC,AACL,OAAO,CAAE,IAAI,CACb,WAAW,CAAE,MAAM,CACnB,aAAa,CAAE,IAAI,CACnB,WAAW,CAAE,MAAM,CACnB,UAAU,CAAE,KAAK,CACjB,UAAU,CAAE,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,SAAS,CACrC,OAAO,CAAE,IAAI,CACb,MAAM,CAAE,OAAO,CAAC,CAAC,AACnB,CAAC,AAEO,8BAA8B,AAAE,CAAC,AACvC,aAAa,CAAE,IAAI,AACrB,CAAC,AAEO,wBAAwB,AAAE,CAAC,AACjC,aAAa,CAAE,CAAC,AAClB,CAAC"}'
};
var Info = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  $$result.css.add(css$4);
  return `<div class="${"info svelte-1kch8kc"}"><div class="${"text"}"><p>${slots.default ? slots.default({}) : ``}
      </p></div>
</div>`;
});
var metadata$i = {
  "layout": "blog",
  "title": "Recreating a Table by The Economist Using Reactable",
  "description": "Recreating a table by The Economist entirely in R, using {reactable}",
  "date": "2020-05-02",
  "image": "economist-table-replication-using-reactable/header.png",
  "archived": true,
  "tags": ["r", "tutorial"]
};
var Economist_table_replication_using_reactable = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${validate_component(Layout, "Layout_MDSVEX_DEFAULT").$$render($$result, Object.assign($$props, metadata$i), {}, {
    default: () => `<p>Thanks for visiting this blog post, but it has moved! It can be found in its fully interactive form <a href="${"https://connorrothschild.github.io/v2/post/economist-table-replication-using-reactable/"}" rel="${"nofollow"}">here</a>.</p>
<p><a href="${"https://connorrothschild.github.io/v2/post/economist-table-replication-using-reactable/"}" rel="${"nofollow"}">${validate_component(Image, "Image").$$render($$result, {
      alt: "A table depicting excess deaths by country during 2020.",
      src: "../images/post/economist-table-replication-using-reactable/featured.png"
    }, {}, {})}</a></p>`
  })}`;
});
var economistTableReplicationUsingReactable = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Economist_table_replication_using_reactable,
  metadata: metadata$i
});
var blocks = "(if|else if|await|then|catch|each|html|debug)";
Prism.languages.svelte = Prism.languages.extend("markup", {
  each: {
    pattern: new RegExp("{[#/]each(?:(?:\\{(?:(?:\\{(?:[^{}])*\\})|(?:[^{}]))*\\})|(?:[^{}]))*}"),
    inside: {
      "language-javascript": [
        {
          pattern: /(as[\s\S]*)\([\s\S]*\)(?=\s*\})/,
          lookbehind: true,
          inside: Prism.languages["javascript"]
        },
        {
          pattern: /(as[\s]*)[\s\S]*(?=\s*)/,
          lookbehind: true,
          inside: Prism.languages["javascript"]
        },
        {
          pattern: /(#each[\s]*)[\s\S]*(?=as)/,
          lookbehind: true,
          inside: Prism.languages["javascript"]
        }
      ],
      keyword: /[#/]each|as/,
      punctuation: /{|}/
    }
  },
  block: {
    pattern: new RegExp("{[#:/@]/s" + blocks + "(?:(?:\\{(?:(?:\\{(?:[^{}])*\\})|(?:[^{}]))*\\})|(?:[^{}]))*}"),
    inside: {
      punctuation: /^{|}$/,
      keyword: [new RegExp("[#:/@]" + blocks + "( )*"), /as/, /then/],
      "language-javascript": {
        pattern: /[\s\S]*/,
        inside: Prism.languages["javascript"]
      }
    }
  },
  tag: {
    pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?:"[^"]*"|'[^']*'|{[\s\S]+?}(?=[\s/>])))|(?=[\s/>])))+)?\s*\/?>/i,
    greedy: true,
    inside: {
      tag: {
        pattern: /^<\/?[^\s>\/]+/i,
        inside: {
          punctuation: /^<\/?/,
          namespace: /^[^\s>\/:]+:/
        }
      },
      "language-javascript": {
        pattern: /\{(?:(?:\{(?:(?:\{(?:[^{}])*\})|(?:[^{}]))*\})|(?:[^{}]))*\}/,
        inside: Prism.languages["javascript"]
      },
      "attr-value": {
        pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/i,
        inside: {
          punctuation: [
            /^=/,
            {
              pattern: /^(\s*)["']|["']$/,
              lookbehind: true
            }
          ],
          "language-javascript": {
            pattern: /{[\s\S]+}/,
            inside: Prism.languages["javascript"]
          }
        }
      },
      punctuation: /\/?>/,
      "attr-name": {
        pattern: /[^\s>\/]+/,
        inside: {
          namespace: /^[^\s>\/:]+:/
        }
      }
    }
  },
  "language-javascript": {
    pattern: /\{(?:(?:\{(?:(?:\{(?:[^{}])*\})|(?:[^{}]))*\})|(?:[^{}]))*\}/,
    lookbehind: true,
    inside: Prism.languages["javascript"]
  }
});
Prism.languages.svelte["tag"].inside["attr-value"].inside["entity"] = Prism.languages.svelte["entity"];
Prism.hooks.add("wrap", (env) => {
  if (env.type === "entity") {
    env.attributes["title"] = env.content.replace(/&amp;/, "&");
  }
});
Object.defineProperty(Prism.languages.svelte.tag, "addInlined", {
  value: function addInlined(tagName, lang) {
    const includedCdataInside = {};
    includedCdataInside["language-" + lang] = {
      pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
      lookbehind: true,
      inside: Prism.languages[lang]
    };
    includedCdataInside["cdata"] = /^<!\[CDATA\[|\]\]>$/i;
    const inside = {
      "included-cdata": {
        pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
        inside: includedCdataInside
      }
    };
    inside["language-" + lang] = {
      pattern: /[\s\S]+/,
      inside: Prism.languages[lang]
    };
    const def = {};
    def[tagName] = {
      pattern: RegExp(/(<__[\s\S]*?>)(?:<!\[CDATA\[[\s\S]*?\]\]>\s*|[\s\S])*?(?=<\/__>)/.source.replace(/__/g, tagName), "i"),
      lookbehind: true,
      greedy: true,
      inside
    };
    Prism.languages.insertBefore("svelte", "cdata", def);
  }
});
Prism.languages.svelte.tag.addInlined("style", "css");
Prism.languages.svelte.tag.addInlined("script", "javascript");
var css$3 = {
  code: ".filename-container.svelte-kztd4h{text-align:right;width:100%;height:30px;margin-bottom:-0.55em;border-radius:5px 5px 0 0;background:rgba(var(--accent-color-rgb), 0.9);display:flex;justify-content:flex-end;place-items:center}.filename.svelte-kztd4h{color:white;padding:0.4rem;letter-spacing:1.4px;font-weight:100}.language.svelte-kztd4h{position:absolute;top:0;right:0;color:#cecece;font-size:0.7rem;text-transform:uppercase;padding:3px 4px;background:rgba(1, 22, 39, 0.79);user-select:none}",
  map: '{"version":3,"file":"Code.svelte","sources":["Code.svelte"],"sourcesContent":["<script>\\n  // Svelte Imports\\n  import { afterUpdate, tick, onMount } from \\"svelte\\";\\n\\n  // Prism Imports\\n  import \\"prismjs\\";\\n  import \\"prismjs/plugins/line-numbers/prism-line-numbers.js\\";\\n  import \\"prismjs/plugins/normalize-whitespace/prism-normalize-whitespace.js\\";\\n  import \\"prismjs/plugins/line-numbers/prism-line-numbers.css\\";\\n  import \\"prismjs/plugins/command-line/prism-command-line.css\\";\\n  import \\"prismjs/plugins/line-highlight/prism-line-highlight.css\\";\\n\\n  import \\"prismjs/plugins/line-highlight/prism-line-highlight.js\\";\\n  import \\"prismjs/plugins/file-highlight/prism-file-highlight.js\\";\\n\\n  import \\"prism-svelte\\";\\n  import \\"prismjs/components/prism-bash.js\\";\\n  import \\"prismjs/components/prism-css.js\\";\\n  import \\"prismjs/components/prism-r.js\\";\\n  import \\"prismjs/components/prism-json.js\\";\\n  import \\"prismjs/components/prism-yaml.js\\";\\n\\n  // The code being used\\n  export let code = \\"\\";\\n\\n  export let filename = \\"\\";\\n  export let highlightedLines = \\"\\";\\n  // link https://prismjs.com/#supported-languages\\n  // import from \'prismjs/components/prism-{lanugage-name}.js\'\\n  // The language being rendered\\n  export let language = \\"javascript\\";\\n  export let showLanguage = true;\\n\\n  // link https://prismjs.com/plugins/line-numbers/\\n  // Turns on and off line numbers\\n  export let showLineNumbers = false;\\n\\n  // Link https://prismjs.com/plugins/normalize-whitespace/\\n  // Turns on and off cleanup plugin\\n  export let normalizeWhiteSpace = true;\\n  //\\n  // The defualt config for cleanup white space\\n  export let normalizeWhiteSpaceConfig = {\\n    \\"remove-trailing\\": true,\\n    \\"remove-indent\\": false,\\n    // \\"left-trim\\": true,\\n    // \\"right-trim\\": true,\\n    // \\"break-lines\\": 80,\\n    // indent: 2,\\n    // \\"remove-initial-line-feed\\": false,\\n    // \\"tabs-to-spaces\\": 4,\\n    // \\"spaces-to-tabs\\": 4,\\n  };\\n\\n  // CSS Classes specified by the user of the component\\n  export let classes = \\"\\";\\n\\n  // This is the fake coding element\\n  let fakeCodeEl;\\n\\n  // This is pre Element\\n  let preEl;\\n\\n  // This stored the formatted HTML to display\\n  let formattedCode = \\"\\";\\n\\n  // creates the prism classes\\n  $: prismClasses = `language-${language} ${\\n    showLineNumbers || highlightedLines.length > 0 ? \\"line-numbers\\" : \\"\\"\\n  } ${normalizeWhiteSpace === true ? \\"\\" : \\"no-whitespace-normalization\\"}`;\\n\\n  onMount(() => {\\n    if (normalizeWhiteSpace) {\\n      Prism.plugins.NormalizeWhitespace.setDefaults(normalizeWhiteSpaceConfig);\\n    }\\n  });\\n\\n  afterUpdate(async (node) => {\\n    // code variable if they are using a prop\\n    // Have to use innerText because innerHTML will create weird escape characaters\\n    if (fakeCodeEl && fakeCodeEl.innerText !== \\"\\") {\\n      code = fakeCodeEl.innerText;\\n    }\\n    // We need to wait till everything been rendered before we can\\n    // call highlightAll and load all the plugins\\n    await tick();\\n    // This will make sure all the plugins are loaded\\n    // Prism.highlight will not do that\\n    Prism.highlightAllUnder(preEl);\\n  });\\n\\n  $: console.log(Prism.languages);\\n\\n  // Only run if Prism is defined and we provide code\\n  $: if (typeof Prism !== \\"undefined\\" && code) {\\n    formattedCode = Prism.highlight(code, Prism.languages[\\"r\\"], language);\\n  }\\n<\/script>\\n\\n{#if filename.length > 0}\\n  <div class=\\"filename-container\\"><span class=\\"filename\\">{filename}</span></div>\\n{/if}\\n<code style=\\"display: none;\\" bind:this={fakeCodeEl}>\\n  <slot />\\n</code>\\n<pre\\n  class=\\"{prismClasses} {classes}\\"\\n  data-line={highlightedLines}\\n  bind:this={preEl}\\n  {...$$restProps}>\\n  {#if showLanguage && filename.length == 0}\\n    <span class=\\"language\\">{language}</span>\\n  {/if}\\n  <code class=\\"language-{language}\\">\\n    {@html formattedCode}\\n  </code>\\n</pre>\\n\\n<style>\\n  .filename-container {\\n    text-align: right;\\n    width: 100%;\\n    height: 30px;\\n    margin-bottom: -0.55em;\\n    border-radius: 5px 5px 0 0;\\n    background: rgba(var(--accent-color-rgb), 0.9);\\n    display: flex;\\n    justify-content: flex-end;\\n    place-items: center;\\n  }\\n\\n  .filename {\\n    color: white;\\n    padding: 0.4rem;\\n    letter-spacing: 1.4px;\\n    font-weight: 100;\\n  }\\n\\n  .language {\\n    position: absolute;\\n    top: 0;\\n    right: 0;\\n    color: #cecece;\\n    font-size: 0.7rem;\\n    text-transform: uppercase;\\n    padding: 3px 4px;\\n    background: rgba(1, 22, 39, 0.79);\\n    user-select: none;\\n  }\\n</style>\\n"],"names":[],"mappings":"AAuHE,mBAAmB,cAAC,CAAC,AACnB,UAAU,CAAE,KAAK,CACjB,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,aAAa,CAAE,OAAO,CACtB,aAAa,CAAE,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAC1B,UAAU,CAAE,KAAK,IAAI,kBAAkB,CAAC,CAAC,CAAC,GAAG,CAAC,CAC9C,OAAO,CAAE,IAAI,CACb,eAAe,CAAE,QAAQ,CACzB,WAAW,CAAE,MAAM,AACrB,CAAC,AAED,SAAS,cAAC,CAAC,AACT,KAAK,CAAE,KAAK,CACZ,OAAO,CAAE,MAAM,CACf,cAAc,CAAE,KAAK,CACrB,WAAW,CAAE,GAAG,AAClB,CAAC,AAED,SAAS,cAAC,CAAC,AACT,QAAQ,CAAE,QAAQ,CAClB,GAAG,CAAE,CAAC,CACN,KAAK,CAAE,CAAC,CACR,KAAK,CAAE,OAAO,CACd,SAAS,CAAE,MAAM,CACjB,cAAc,CAAE,SAAS,CACzB,OAAO,CAAE,GAAG,CAAC,GAAG,CAChB,UAAU,CAAE,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,CACjC,WAAW,CAAE,IAAI,AACnB,CAAC"}'
};
var Code = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let prismClasses;
  let $$restProps = compute_rest_props($$props, [
    "code",
    "filename",
    "highlightedLines",
    "language",
    "showLanguage",
    "showLineNumbers",
    "normalizeWhiteSpace",
    "normalizeWhiteSpaceConfig",
    "classes"
  ]);
  let { code: code2 = "" } = $$props;
  let { filename = "" } = $$props;
  let { highlightedLines = "" } = $$props;
  let { language = "javascript" } = $$props;
  let { showLanguage = true } = $$props;
  let { showLineNumbers = false } = $$props;
  let { normalizeWhiteSpace = true } = $$props;
  let { normalizeWhiteSpaceConfig = {
    "remove-trailing": true,
    "remove-indent": false
  } } = $$props;
  let { classes = "" } = $$props;
  let fakeCodeEl;
  let preEl;
  let formattedCode = "";
  if ($$props.code === void 0 && $$bindings.code && code2 !== void 0)
    $$bindings.code(code2);
  if ($$props.filename === void 0 && $$bindings.filename && filename !== void 0)
    $$bindings.filename(filename);
  if ($$props.highlightedLines === void 0 && $$bindings.highlightedLines && highlightedLines !== void 0)
    $$bindings.highlightedLines(highlightedLines);
  if ($$props.language === void 0 && $$bindings.language && language !== void 0)
    $$bindings.language(language);
  if ($$props.showLanguage === void 0 && $$bindings.showLanguage && showLanguage !== void 0)
    $$bindings.showLanguage(showLanguage);
  if ($$props.showLineNumbers === void 0 && $$bindings.showLineNumbers && showLineNumbers !== void 0)
    $$bindings.showLineNumbers(showLineNumbers);
  if ($$props.normalizeWhiteSpace === void 0 && $$bindings.normalizeWhiteSpace && normalizeWhiteSpace !== void 0)
    $$bindings.normalizeWhiteSpace(normalizeWhiteSpace);
  if ($$props.normalizeWhiteSpaceConfig === void 0 && $$bindings.normalizeWhiteSpaceConfig && normalizeWhiteSpaceConfig !== void 0)
    $$bindings.normalizeWhiteSpaceConfig(normalizeWhiteSpaceConfig);
  if ($$props.classes === void 0 && $$bindings.classes && classes !== void 0)
    $$bindings.classes(classes);
  $$result.css.add(css$3);
  prismClasses = `language-${language} ${showLineNumbers || highlightedLines.length > 0 ? "line-numbers" : ""} ${normalizeWhiteSpace === true ? "" : "no-whitespace-normalization"}`;
  {
    console.log(Prism.languages);
  }
  {
    if (typeof Prism !== "undefined" && code2) {
      formattedCode = Prism.highlight(code2, Prism.languages["r"], language);
    }
  }
  return `${filename.length > 0 ? `<div class="${"filename-container svelte-kztd4h"}"><span class="${"filename svelte-kztd4h"}">${escape(filename)}</span></div>` : ``}
<code style="${"display: none;"}"${add_attribute("this", fakeCodeEl, 0)}>${slots.default ? slots.default({}) : ``}</code>
<pre${spread([
    {
      class: escape(prismClasses) + " " + escape(classes)
    },
    {
      "data-line": escape_attribute_value(highlightedLines)
    },
    escape_object($$restProps)
  ], "svelte-kztd4h")}${add_attribute("this", preEl, 0)}>${showLanguage && filename.length == 0 ? `<span class="${"language svelte-kztd4h"}">${escape(language)}</span>` : ``}
  <code class="${"language-" + escape(language) + " svelte-kztd4h"}"><!-- HTML_TAG_START -->${formattedCode}<!-- HTML_TAG_END --></code>
</pre>`;
});
var css$2 = {
  code: "span.svelte-p78l24{background:rgba(var(--accent-color-rgb), 0.2);padding:1px 4px}",
  map: '{"version":3,"file":"HighlightFromProp.svelte","sources":["HighlightFromProp.svelte"],"sourcesContent":["<script>\\n  // FROM PARENT\\n  export let hoveredIdProp;\\n  export let highlightedLinesProp;\\n\\n  //   BACK TO PARENT\\n  export let hoveredId;\\n  export let highlightedLines;\\n<\/script>\\n\\n<span\\n  on:mouseover={() => {\\n    hoveredId = hoveredIdProp;\\n    highlightedLines = highlightedLinesProp;\\n  }}\\n  on:focus={() => {\\n    hoveredId = hoveredIdProp;\\n    highlightedLines = highlightedLinesProp;\\n  }}\\n  on:mouseleave={() => {\\n    hoveredId = null;\\n    highlightedLines = null;\\n  }}><slot /></span\\n>\\n\\n<style>\\n  span {\\n    background: rgba(var(--accent-color-rgb), 0.2);\\n    padding: 1px 4px;\\n    /* font-style: italic; */\\n  }\\n</style>\\n"],"names":[],"mappings":"AA0BE,IAAI,cAAC,CAAC,AACJ,UAAU,CAAE,KAAK,IAAI,kBAAkB,CAAC,CAAC,CAAC,GAAG,CAAC,CAC9C,OAAO,CAAE,GAAG,CAAC,GAAG,AAElB,CAAC"}'
};
var HighlightFromProp = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { hoveredIdProp } = $$props;
  let { highlightedLinesProp } = $$props;
  let { hoveredId } = $$props;
  let { highlightedLines } = $$props;
  if ($$props.hoveredIdProp === void 0 && $$bindings.hoveredIdProp && hoveredIdProp !== void 0)
    $$bindings.hoveredIdProp(hoveredIdProp);
  if ($$props.highlightedLinesProp === void 0 && $$bindings.highlightedLinesProp && highlightedLinesProp !== void 0)
    $$bindings.highlightedLinesProp(highlightedLinesProp);
  if ($$props.hoveredId === void 0 && $$bindings.hoveredId && hoveredId !== void 0)
    $$bindings.hoveredId(hoveredId);
  if ($$props.highlightedLines === void 0 && $$bindings.highlightedLines && highlightedLines !== void 0)
    $$bindings.highlightedLines(highlightedLines);
  $$result.css.add(css$2);
  return `<span class="${"svelte-p78l24"}">${slots.default ? slots.default({}) : ``}</span>`;
});
var metadata$h = {
  "layout": "blog",
  "title": "How to Add a Chart to Your D3 Tooltip",
  "description": "A few lines of code can make your D3 tooltips significantly more informative",
  "date": "2020-06-02",
  "image": "adding-a-chart-to-your-d3-tooltip/header.png",
  "tags": ["d3", "html", "tutorial"]
};
var Adding_a_chart_to_your_d3_tooltip = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let hoveredId;
  let highlightedLines;
  let $$settled;
  let $$rendered;
  do {
    $$settled = true;
    $$rendered = `${validate_component(Layout, "Layout_MDSVEX_DEFAULT").$$render($$result, Object.assign($$props, metadata$h), {}, {
      default: () => `<p>I think tooltips are one of the most underrated parts of a visualization. When users are initially confused by a visualization, they often hover over a data point of interest to get more information.</p>
<p>Unfortunately, many tooltips fail to really illuminate much about our data. They often recapitulate what is already being presented without clarifying any of the confusing parts of the data. Most frequently, I see (and even create \u{1F626}) tooltips which present the most basic information (in a map, a tooltip would present the state name and the value of interest), and nothing else!</p>
<p>Of course, there\u2019s nothing <em>wrong</em> with these kinds of tooltips. But they are truly doing the bare minimum, and, as a result, they\u2019re missing out on the full potential of tooltips. <strong>If users are actively seeking more information by hovering over data, we ought to reward them with the most helpful and interesting information we can.</strong></p>
<p>That\u2019s why I recently updated one of my tooltips from a static presentation of textual information to a line chart depicting change over time. In other words, I went from this:</p>
${validate_component(Image, "Image").$$render($$result, {
        src: "../images/post/adding-a-chart-to-your-d3-tooltip/old-tooltip.gif",
        alt: "A GIF depicting the old tooltip, which contained static values in textual form"
      }, {}, {})}
<p>to this:</p>
${validate_component(Image, "Image").$$render($$result, {
        src: "../images/post/adding-a-chart-to-your-d3-tooltip/new-tooltip.gif",
        alt: "A GIF depicting the old tooltip, which contained dynamic, temporal data over time for a given state upon hover"
      }, {}, {})}
<h2 id="${"why-did-i-make-that-change"}"><a href="${"#why-did-i-make-that-change"}">Why did I make that change?</a></h2>
<p>The former tooltip provided information which was rather uninteresting. Although it clarified the exact <em>rate</em> of overdose deaths in a given state at a given time, it didn\u2019t do much else. It did provide the year currently in view, but this was also visible in the bottom right corner of the visualization! It also provided the state name, but most of my viewers have likely taken US geography in middle school.</p>
<p>Thus, this tooltip was rather redundant. At best, it provided the <em>exact</em> rate, so that a viewer could compare two states, or learn more information about a given state without solely relying on color encoding (<a href="${"https://courses.cs.washington.edu/courses/cse442/17au/lectures/CSE442-VisualEncoding.pdf"}" rel="${"nofollow"}">which can be somewhat unreliable when it comes to quantitative encoding</a>, as is the case in a choropleth map).</p>
<p>The new tooltip shows a trend over time. It also shows the state name (just in case you skipped that day in US geography!), and also the most recent data on overdose deaths. Because this map is meant to show how the opioid crisis <em>has evolved</em>, showing a line chart for each state in my tooltip allows the user to explore state-by-state trends on hover! This is much easier than hovering on each state during each year and trying to keep track of the trends.</p>
<p>For example, hovering on West Virginia, which in 2017 seemed to have the highest opioid-involved overdose death rate (as indicated by it having the darkest shade of red), reveals that its also experienced one of the largest over-time increase in this rate since 1999:</p>
${validate_component(Image, "Image").$$render($$result, {
        src: "../images/post/adding-a-chart-to-your-d3-tooltip/west-virginia.jpg",
        alt: "A static image focusing on West Virginia, showcasing the tooltip which shows a line chart increasing over time."
      }, {}, {})}
<h2 id="${"so-how-do-you-do-it"}"><a href="${"#so-how-do-you-do-it"}">So, how do you do it?</a></h2>
<p>Great question! It\u2019s thankfully not that hard, but the payoff is huge. The shift from my old, boring tooltip to my new, sexy one took only a couple of hours, thanks to a few <a href="${"https://stackoverflow.com/questions/43904643/add-chart-to-tooltip-in-d3"}" rel="${"nofollow"}">Stack Overflow answers</a> and <a href="${"https://bl.ocks.org/maelafifi/ee7fecf90bb5060d5f9a7551271f4397"}" rel="${"nofollow"}">online examples</a>.</p>
<h3 id="${"step-1-load-d3-tip"}"><a href="${"#step-1-load-d3-tip"}">Step 1: Load <code>d3-tip</code></a></h3>
<p>The process mostly relies on <code>d3-tip</code>, which you can learn more about <a href="${"http://labratrevenge.com/d3-tip/"}" rel="${"nofollow"}">here</a>.</p>
<p>You can load <code>d3-tip</code> with the following code:</p>
${validate_component(Code, "Code").$$render($$result, { language: "js" }, {}, {
        default: () => `<pre class="${"language-undefined"}"><!-- HTML_TAG_START -->${`<code class="language-undefined">&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/d3-tip/0.7.1/d3-tip.min.js&quot;&gt;&lt;/script&gt;</code>`}<!-- HTML_TAG_END --></pre>`
      })}
<h3 id="${"step-2-create-a-tooltip-object"}"><a href="${"#step-2-create-a-tooltip-object"}">Step 2: Create a tooltip object</a></h3>
<p>Next, we initialize our tooltip.</p>
${validate_component(Code, "Code").$$render($$result, {
        language: "js",
        showLineNumbers: true,
        highlightedLines: hoveredId == "init-tooltip" ? highlightedLines : null
      }, {}, {
        default: () => `<pre class="${"language-undefined"}"><!-- HTML_TAG_START -->${`<code class="language-undefined">// Define the tooltip
var tool_tip = d3.tip()
  .attr(&quot;class&quot;, &quot;d3-tip&quot;)
  // If the mouse position is greater beyond ~ Kentucky/Missouri,
  // Offset tooltip left instead of right
  .offset(current_position[0] &gt; 650 ? [-20, -120] : [20, 120])
  // Input the title, and include the div with an id of #tipDiv
  .html(
    &quot;&lt;p&gt;Opioid-involved deaths over time in&lt;/p&gt;
    &lt;div id=&#39;tipDiv&#39;&gt;&lt;/div&gt;&quot;
    );

// Call it as a function to our app-wide SVG
svg.call(tool_tip);</code>`}<!-- HTML_TAG_END --></pre>`
      })}
<p>${validate_component(HighlightFromProp, "HighlightFromProp").$$render($$result, {
        hoveredIdProp: "init-tooltip",
        highlightedLinesProp: "2-3",
        hoveredId,
        highlightedLines
      }, {
        hoveredId: ($$value) => {
          hoveredId = $$value;
          $$settled = false;
        },
        highlightedLines: ($$value) => {
          highlightedLines = $$value;
          $$settled = false;
        }
      }, {
        default: () => `Lines 2 and 3
`
      })} 
  simply create our tooltip and give it a class (for CSS styling). 
</p>
<p>Then, on 
${validate_component(HighlightFromProp, "HighlightFromProp").$$render($$result, {
        hoveredIdProp: "init-tooltip",
        highlightedLinesProp: "6",
        hoveredId,
        highlightedLines
      }, {
        hoveredId: ($$value) => {
          hoveredId = $$value;
          $$settled = false;
        },
        highlightedLines: ($$value) => {
          highlightedLines = $$value;
          $$settled = false;
        }
      }, { default: () => `line 6` })}, we provide the specified <code>offset</code>. In my example, I define my offset according to the <a href="${"https://stackoverflow.com/questions/28536367/in-d3-js-how-to-adjust-tooltip-up-and-down-based-on-the-screen-position"}" target="${"_blank"}">user&#39;s mouse position</a>. That way, if a user hovers over an eastern state, the tooltip doesn&#39;t disappear off the screen! (<code>current_position</code> is defined down below.)
</p>
<p>In   
${validate_component(HighlightFromProp, "HighlightFromProp").$$render($$result, {
        hoveredIdProp: "init-tooltip",
        highlightedLinesProp: "8-11",
        hoveredId,
        highlightedLines
      }, {
        hoveredId: ($$value) => {
          hoveredId = $$value;
          $$settled = false;
        },
        highlightedLines: ($$value) => {
          highlightedLines = $$value;
          $$settled = false;
        }
      }, { default: () => `lines 8-11` })}, we define the append content to our tooltip. In our case, we 1. provide a title, &quot;Opioid-involved deaths over time&quot;, and 2. specify the div that the tooltip should include. Right now, <code>tipDiv</code> is undefined, which is what we&#39;ll cover next.
</p>
<h3 id="${"step-3-create-the-tipdiv-object"}"><a href="${"#step-3-create-the-tipdiv-object"}">Step 3: Create the <code>tipDiv</code> object</a></h3>
<p>Finally, we can create the <code>tipDiv</code> object we referenced in the above code. The object will be created on mouseover of the group of interest (in my case, states). Our code will look something like this (don\u2019t worry too much about it, I\u2019ll explain step by step below):</p>
${validate_component(Code, "Code").$$render($$result, { language: "js" }, {}, {
        default: () => `<pre class="${"language-undefined"}"><!-- HTML_TAG_START -->${`<code class="language-undefined">states = svg.append(&quot;g&quot;)
  .attr(&quot;class&quot;, &quot;states&quot;)
  .selectAll(&quot;path&quot;)
  .data(topojson.feature(us, us.objects.states).features)
  .enter()
  .append(&quot;path&quot;)
  .attr(&quot;d&quot;, path)
  .on(&#39;mouseout&#39;, tool_tip.hide) // On mouseout, hide the tooltip
  .on(&#39;mouseover&#39;, function(d) &#123;
    // Define and store the mouse position;
    // This is used to define tooltip offset, seen above
    current_position = d3.mouse(this);

    // Record current state
    current_state = nameById[d.id]

    // Show the tooltip
    tool_tip.show();

    // ... Continued below</code>`}<!-- HTML_TAG_END --></pre>`
      })}
<p>After that initialization and <code>show</code> function, we can define the <code>tipDiv</code> object:</p>
${validate_component(Code, "Code").$$render($$result, { language: "js" }, {}, {
        default: () => `<pre class="${"language-undefined"}"><!-- HTML_TAG_START -->${`<code class="language-undefined">/* ... Continued from above 
       Select the #tipDiv element, and append an SVG (this is the tooltip) */
var tipSVG = d3.select(&quot;#tipDiv&quot;)
     .append(&quot;svg&quot;)
     .attr(&quot;width&quot;, 220)
     .attr(&quot;height&quot;, 55);

/* Apply the same logic you would to a regular chart, 
   but append it to our tipSVG */
tipSVG.append(&quot;path&quot;)
     .datum(overdoses.filter((d) =&gt; &#123; nameById[d.id] == current_state &#125;))
     .style(&quot;stroke&quot;, rateById[d.id] &lt; 10 ? &quot;grey&quot; : color(rateById[d.id]))
     .style(&quot;stroke-width&quot;, 1.5)
     .style(&quot;fill&quot;, &quot;none&quot;)
     .attr(&quot;d&quot;, line)

// Same as above (this is the circle at the end of the line)
tipSVG.append(&quot;circle&quot;)
    .attr(&quot;fill&quot;, rateById[d.id] &lt; 10 ? &quot;grey&quot; : color(rateById[d.id]))
    .attr(&quot;stroke&quot;, &quot;black&quot;)
    .attr(&quot;cx&quot;, 130)
    .attr(&quot;cy&quot;, y_tooltip(rateById[d.id]))
    .attr(&quot;r&quot;, 3)

// Tooltip labelling on last value
tipSVG.append(&quot;text&quot;)
     .text(rateById[d.id] + &quot; deaths&quot;)
     .attr(&quot;x&quot;, 140)
     .attr(&quot;y&quot;, y_tooltip(rateById[d.id]) &lt; 15 ? 10 
              : y_tooltip(rateById[d.id]) - 7)

// Same as above
tipSVG.append(&quot;text&quot;)
     .text(&quot;per 100,000&quot;)
     .attr(&quot;x&quot;, 140)
     .attr(&quot;y&quot;, y_tooltip(rateById[d.id]) &lt; 15 ? 24
     		      : y_tooltip(rateById[d.id]) + 7)

// State name
tipSVG.append(&quot;text&quot;)
     .text(current_state)
     .attr(&quot;x&quot;, 0)
     .attr(&quot;y&quot;, 15)
     .style(&quot;font-size&quot;, 18)
     .style(&quot;font-weight&quot;, 400)
 &#125;) // &lt;- This is the end of the whole .on(&#39;mouseover&#39;) function</code>`}<!-- HTML_TAG_END --></pre>`
      })}
<p>What\u2019s happening here? Let\u2019s look at one piece of our mouseover function at a time.</p>
<p><strong>First</strong>, we define the object and name it <code>tipSVG</code>. <code>tipSVG</code> selects <code>#tipDiv</code> (defined in our d3-tip) and appends an SVG. We also define the width and height of the tooltip.</p>
${validate_component(Code, "Code").$$render($$result, { language: "js" }, {}, {
        default: () => `<pre class="${"language-undefined"}"><!-- HTML_TAG_START -->${`<code class="language-undefined">var tipSVG = d3
  .select(&quot;#tipDiv&quot;)
  .append(&quot;svg&quot;)
  .attr(&quot;width&quot;, 220)
  .attr(&quot;height&quot;, 55);</code>`}<!-- HTML_TAG_END --></pre>`
      })}
<p><strong>Next</strong>, we append a path to that SVG. This could be a circle, or a rectangle, or any other appendable shape. Because I am drawing a simple line, we use <code>path</code>.</p>
${validate_component(Code, "Code").$$render($$result, { language: "js" }, {}, {
        default: () => `<pre class="${"language-undefined"}"><!-- HTML_TAG_START -->${`<code class="language-undefined">tipSVG
  .append(&quot;path&quot;)
  .datum(overdoses.filter((d) =&gt; &#123; nameById[d.id] == current_state &#125;))
  .style(&quot;stroke&quot;, rateById[d.id] &lt; 10 ? &quot;grey&quot; : color(rateById[d.id]))
  .style(&quot;stroke-width&quot;, 1.5)
  .style(&quot;fill&quot;, &quot;none&quot;)
  .attr(&quot;d&quot;, line);</code>`}<!-- HTML_TAG_END --></pre>`
      })}
<p>In defining the <code>d</code> attribute, you see I reference <code>line</code>. This is a function defined earlier in my code to return the <code>x</code> and <code>y</code> position of each data point, to create the path itself, as you can see below:</p>
${validate_component(Code, "Code").$$render($$result, { language: "js" }, {}, {
        default: () => `<pre class="${"language-undefined"}"><!-- HTML_TAG_START -->${`<code class="language-undefined">var x_tooltip = d3
  .scaleLinear()
  .domain(d3.extent(overdoses, (d) =&gt; &#123; d.year &#125;))
  .range([0, 130]);

var y_tooltip = d3.scaleLinear().domain([0, 60]).range([50, 0]);

var line = d3
  .line()
  .x((d) =&gt; &#123; x_tooltip(d.year) &#125;)
  .y((d) =&gt; &#123; y_tooltip(+d.rate) &#125;)</code>`}<!-- HTML_TAG_END --></pre>`
      })}
${validate_component(Info, "Info").$$render($$result, {}, {}, {
        default: () => `<p>Because the tooltip contains its own chart with a predefined with and height, we need to provide scale functions as we would in a normal chart. We name this <code>x_tooltip</code> and <code>y_tooltip</code> so as to avoid confusion with our main scaling functions.</p>`
      })}
<p><strong>Lastly</strong>, we add a circle at the end of the line to signify the final data point. We also add the text label for the year 2017.</p>
${validate_component(Code, "Code").$$render($$result, { language: "js" }, {}, {
        default: () => `<pre class="${"language-undefined"}"><!-- HTML_TAG_START -->${`<code class="language-undefined">// Final point
tipSVG.append(&quot;circle&quot;)
    .attr(&quot;fill&quot;, rateById[d.id] &lt; 10 ? &quot;grey&quot; : color(rateById[d.id]))
    .attr(&quot;stroke&quot;, &quot;black&quot;)
    .attr(&quot;cx&quot;, 130)
    .attr(&quot;cy&quot;, y_tooltip(rateById[d.id]))
    .attr(&quot;r&quot;, 3)

// Text label (##### deaths)
tipSVG.append(&quot;text&quot;)
     .text(rateById[d.id] + &quot; deaths&quot;)
     .attr(&quot;x&quot;, 140)
     .attr(&quot;y&quot;, y_tooltip(rateById[d.id]) &lt; 15 ? 10 
              : y_tooltip(rateById[d.id]) - 7)

// Per 100,00
tipSVG.append(&quot;text&quot;)
     .text(&quot;per 100,000&quot;)
     .attr(&quot;x&quot;, 140)
     .attr(&quot;y&quot;, y_tooltip(rateById[d.id]) &lt; 15 ? 24
     		      : y_tooltip(rateById[d.id]) + 7)

// State name
tipSVG.append(&quot;text&quot;)
     .text(current_state)
     .attr(&quot;x&quot;, 0)
     .attr(&quot;y&quot;, 15)
     .style(&quot;font-size&quot;, 18)
     .style(&quot;font-weight&quot;, 400)
 &#125;) // End mouseover function</code>`}<!-- HTML_TAG_END --></pre>`
      })}
<h2 id="${"in-sum"}"><a href="${"#in-sum"}">In sum</a></h2>
<p>The process of appending a chart to your tooltip in a D3.js visualization is as simple as:</p>
<ol><li>Load <code>d3-tip</code> via a <code>&lt;script&gt;</code> tag</li>
<li>Create a tooltip object using <code>d3-tip</code>, which can be done easily upon consulting their documentation</li>
<li>Add an SVG element to the tooltip we created, as we would create a chart normally using D3 syntax</li></ol>
<p>Voila! You can find the code all in one place <a href="${"https://github.com/connorrothschild/D3.js/blob/master/map-overdoses/index.html"}" rel="${"nofollow"}">here</a>. Please note that I made this visualization early in my career, so I\u2019m not particularly proud of the code \u{1F605}</p>
<p>You can play around with the visualization and checkout the tooltip for yourself below (find the fullscreen version <a href="${"https://connorrothschild.github.io/D3.js/map-overdoses/"}" rel="${"nofollow"}">here</a>):</p>
<iframe title="${"Map of opioid-related overdoses, by state, between 1999 and 2017."}" src="${"https://connorrothschild.github.io/D3.js/map-overdoses/"}" width="${"100%"}" height="${"768px"}" style="${"background: white;"}"></iframe>`
    })}`;
  } while (!$$settled);
  return $$rendered;
});
var addingAChartToYourD3Tooltip = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Adding_a_chart_to_your_d3_tooltip,
  metadata: metadata$h
});
var metadata$g = {
  "layout": "blog",
  "title": "How to Combine Animated Plots in R",
  "description": "Leveraging the power of {gganimate} and {magick} to combine animated plots for your viewers.",
  "date": "2019-10-09",
  "image": "tidy-tuesday-powerlifting/header.png",
  "archived": true,
  "tags": ["r", "tutorial"]
};
var Tidy_tuesday_powerlifting = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${validate_component(Layout, "Layout_MDSVEX_DEFAULT").$$render($$result, Object.assign($$props, metadata$g), {}, {
    default: () => `<p>In this tutorial, I\u2019m going to outline the steps necessary to create an animated, faceted plot in R. Although rare, combining animated plots can be a powerful way to showcase different elements of the same data (as you\u2019ll see below).</p>
<p>In this example, I\u2019m using weightlifting data from the International Powerlifting Federation. For the purposes of this tutorial, we\u2019ll look at <em>differences in top lifts by sex</em>. A faceted, animated plot is a great option because we\u2019d like to observe <strong>the magnitude of these differences</strong> and <strong>how these differences have evolved over time</strong>.</p>
<p>We\u2019ll be creating this GIF:</p>
${validate_component(Image, "Image").$$render($$result, {
      src: "../images/post/tidy-tuesday-powerlifting/unnamed-chunk-11-1.gif",
      alt: "A combination of the two aforementioned plots. The top plot is the animated dumbbell plot, and the bottom is a line chart. In combination, they allow the user to see the magnitude of differences between men and women, as well as how these differences have evolved over time."
    }, {}, {})}
<h2 id="${"environment-setup"}"><a href="${"#environment-setup"}">Environment setup</a></h2>
<p>These are the packages we\u2019ll need to get started. In my case, I use a <a href="${"https://github.com/connorrothschild/cr"}" rel="${"nofollow"}">custom theme</a> I\u2019ve developed for stylistic purposes. Feel free to instead run <code>theme_set(theme_minimal())</code> rather than use my theme!</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">library<span class="token punctuation">(</span>ggplot2<span class="token punctuation">)</span>
library<span class="token punctuation">(</span>tidyverse<span class="token punctuation">)</span>
library<span class="token punctuation">(</span>ggtext<span class="token punctuation">)</span>
library<span class="token punctuation">(</span>gifski<span class="token punctuation">)</span>
library<span class="token punctuation">(</span>gganimate<span class="token punctuation">)</span>
library<span class="token punctuation">(</span>cr<span class="token punctuation">)</span>

set_cr_theme<span class="token punctuation">(</span>font <span class="token operator">=</span> <span class="token string">"Proxima Nova"</span><span class="token punctuation">)</span>
<span class="token comment"># theme_set(theme_minimal())</span></code>`}<!-- HTML_TAG_END --></pre>
<h2 id="${"load-and-clean-data"}"><a href="${"#load-and-clean-data"}">Load and clean data</a></h2>
<p>I\u2019ve already done a lot of the data cleaning for you. If you\u2019d like to follow along, here\u2019s the process (or, skip ahead!).</p>
<p>Here, we\u2019ll do some minor cleaning and then reshape the three lifts into one column:</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">ipf_lifts <span class="token operator">&lt;-</span> readr<span class="token operator">::</span>read_csv<span class="token punctuation">(</span><span class="token string">"data/ipf_lifts.csv"</span><span class="token punctuation">)</span> <span class="token percent-operator operator">%>%</span>
  mutate<span class="token punctuation">(</span>year <span class="token operator">=</span> lubridate<span class="token operator">::</span>year<span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">)</span>

ipf_lifts_reshape <span class="token operator">&lt;-</span> ipf_lifts <span class="token percent-operator operator">%>%</span>
  tidyr<span class="token operator">::</span>pivot_longer<span class="token punctuation">(</span>cols <span class="token operator">=</span> c<span class="token punctuation">(</span><span class="token string">"best3squat_kg"</span><span class="token punctuation">,</span> <span class="token string">"best3bench_kg"</span><span class="token punctuation">,</span> <span class="token string">"best3deadlift_kg"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> names_to <span class="token operator">=</span> <span class="token string">"lift"</span><span class="token punctuation">)</span> <span class="token percent-operator operator">%>%</span>
  select<span class="token punctuation">(</span>name<span class="token punctuation">,</span> sex<span class="token punctuation">,</span> year<span class="token punctuation">,</span> lift<span class="token punctuation">,</span> value<span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>
<p>For my visualization, I\u2019m only concerned with the <em>heaviest</em> lifts from
each year:</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">ipf_lifts_maxes <span class="token operator">&lt;-</span> ipf_lifts_reshape <span class="token percent-operator operator">%>%</span>
  group_by<span class="token punctuation">(</span>year<span class="token punctuation">,</span> sex<span class="token punctuation">,</span> lift<span class="token punctuation">)</span> <span class="token percent-operator operator">%>%</span>
  top_n<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token percent-operator operator">%>%</span>
  ungroup <span class="token percent-operator operator">%>%</span>
  distinct<span class="token punctuation">(</span>year<span class="token punctuation">,</span> lift<span class="token punctuation">,</span> value<span class="token punctuation">,</span> .keep_all <span class="token operator">=</span> <span class="token boolean">TRUE</span><span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>
<p>The first visualization we\u2019ll create for the final output is a <strong>dumbbell plot</strong>. Curious what that is, or how to make it in R? <a href="${"https://www.connorrothschild.com/post/dumbbell-plots/"}" rel="${"nofollow"}">Check out my other post on the topic</a>.</p>
<p>In order to construct a dumbbell plot, we need both male and female
observations in the same row. For this, we use the <code>spread</code> function.</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">max_pivot <span class="token operator">&lt;-</span> ipf_lifts_maxes <span class="token percent-operator operator">%>%</span>
  spread<span class="token punctuation">(</span>sex<span class="token punctuation">,</span> value<span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>
<p>Now, let\u2019s construct a dataframe for each sex:</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">male_lifts <span class="token operator">&lt;-</span> max_pivot <span class="token percent-operator operator">%>%</span>
  select<span class="token punctuation">(</span><span class="token operator">-</span>name<span class="token punctuation">)</span> <span class="token percent-operator operator">%>%</span>
  filter<span class="token punctuation">(</span><span class="token operator">!</span>is.na<span class="token punctuation">(</span>M<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token percent-operator operator">%>%</span>
  group_by<span class="token punctuation">(</span>year<span class="token punctuation">,</span> lift<span class="token punctuation">)</span> <span class="token percent-operator operator">%>%</span>
  summarise<span class="token punctuation">(</span>male <span class="token operator">=</span> mean<span class="token punctuation">(</span>M<span class="token punctuation">)</span><span class="token punctuation">)</span>

female_lifts <span class="token operator">&lt;-</span> max_pivot <span class="token percent-operator operator">%>%</span>
  select<span class="token punctuation">(</span><span class="token operator">-</span>name<span class="token punctuation">)</span> <span class="token percent-operator operator">%>%</span>
  filter<span class="token punctuation">(</span><span class="token operator">!</span>is.na<span class="token punctuation">(</span>F<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token percent-operator operator">%>%</span>
  group_by<span class="token punctuation">(</span>year<span class="token punctuation">,</span> lift<span class="token punctuation">)</span> <span class="token percent-operator operator">%>%</span>
  summarise<span class="token punctuation">(</span>female <span class="token operator">=</span> mean<span class="token punctuation">(</span>F<span class="token punctuation">)</span><span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>
<p>And join them:</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">max_lifts <span class="token operator">&lt;-</span> merge<span class="token punctuation">(</span>male_lifts<span class="token punctuation">,</span> female_lifts<span class="token punctuation">)</span>

max_lifts_final <span class="token operator">&lt;-</span> max_lifts <span class="token percent-operator operator">%>%</span>
  group_by<span class="token punctuation">(</span>year<span class="token punctuation">,</span> lift<span class="token punctuation">)</span> <span class="token percent-operator operator">%>%</span>
  mutate<span class="token punctuation">(</span>diff <span class="token operator">=</span> male <span class="token operator">-</span> female<span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>
<p>Not following along, or want to check your progress? Here\u2019s what our data looks like in its final form:</p>
<div class="${"table-container"}"><table><thead><tr><th align="${"left"}">year</th>
<th align="${"left"}">lift</th>
<th align="${"left"}">male</th>
<th align="${"left"}">female</th>
<th align="${"left"}">diff</th></tr></thead>
<tbody><tr><td align="${"left"}">1980</td>
<td align="${"left"}">best3bench_kg</td>
<td align="${"left"}">262.5</td>
<td align="${"left"}">120</td>
<td align="${"left"}">142.5</td></tr>
<tr><td align="${"left"}">1980</td>
<td align="${"left"}">best3deadlift_kg</td>
<td align="${"left"}">395</td>
<td align="${"left"}">205</td>
<td align="${"left"}">190</td></tr>
<tr><td align="${"left"}">1980</td>
<td align="${"left"}">best3squat_kg</td>
<td align="${"left"}">417.5</td>
<td align="${"left"}">230</td>
<td align="${"left"}">187.5</td></tr>
<tr><td align="${"left"}">1981</td>
<td align="${"left"}">best3bench_kg</td>
<td align="${"left"}">245</td>
<td align="${"left"}">150</td>
<td align="${"left"}">95</td></tr>
<tr><td align="${"left"}">1981</td>
<td align="${"left"}">best3deadlift_kg</td>
<td align="${"left"}">367.5</td>
<td align="${"left"}">230</td>
<td align="${"left"}">137.5</td></tr>
<tr><td align="${"left"}">1981</td>
<td align="${"left"}">best3squat_kg</td>
<td align="${"left"}">427.5</td>
<td align="${"left"}">215</td>
<td align="${"left"}">212.5</td></tr></tbody></table></div>
<h2 id="${"visualize"}"><a href="${"#visualize"}">Visualize!</a></h2>
<p>Finally, we can construct the visualization.</p>
<p>First, we can create a static visualization using <code>ggalt</code> (again, my <a href="${"https://www.connorrothschild.com/post/dumbbell-plots/"}" rel="${"nofollow"}">blog post</a> covers the details of this step).</p>
<p>You can fast forward the creation of individual plots if you\u2019re only interested in the <strong>combination</strong> of the two. You\u2019ll find that at the end of this post!</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">max_lifts_final <span class="token percent-operator operator">%>%</span>
  filter<span class="token punctuation">(</span>year <span class="token operator">==</span> <span class="token number">2019</span><span class="token punctuation">)</span> <span class="token percent-operator operator">%>%</span>
  ggplot<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  ggalt<span class="token operator">::</span>geom_dumbbell<span class="token punctuation">(</span>aes<span class="token punctuation">(</span>y <span class="token operator">=</span> lift<span class="token punctuation">,</span>
                    x <span class="token operator">=</span> female<span class="token punctuation">,</span> xend <span class="token operator">=</span> male<span class="token punctuation">)</span><span class="token punctuation">,</span>
                colour <span class="token operator">=</span> <span class="token string">"grey"</span><span class="token punctuation">,</span> size <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">,</span>
                colour_x <span class="token operator">=</span> <span class="token string">"#D6604C"</span><span class="token punctuation">,</span> colour_xend <span class="token operator">=</span> <span class="token string">"#395B74"</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  labs<span class="token punctuation">(</span>y <span class="token operator">=</span> element_blank<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
       x <span class="token operator">=</span> <span class="token string">"Top Lift Recorded (kg)"</span><span class="token punctuation">,</span>
       title <span class="token operator">=</span>  <span class="token string">"How &lt;span style='color:#D6604C'>Women&lt;/span> and &lt;span style='color:#395B74'>Men&lt;/span> Differ in Top Lifts"</span><span class="token punctuation">,</span>
                       subtitle <span class="token operator">=</span> <span class="token string">"In 2019"</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  theme<span class="token punctuation">(</span>plot.title <span class="token operator">=</span> element_markdown<span class="token punctuation">(</span>lineheight <span class="token operator">=</span> <span class="token number">1.1</span><span class="token punctuation">,</span> size <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        plot.subtitle <span class="token operator">=</span> element_text<span class="token punctuation">(</span>size <span class="token operator">=</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  scale_y_discrete<span class="token punctuation">(</span>labels <span class="token operator">=</span> c<span class="token punctuation">(</span><span class="token string">"Bench"</span><span class="token punctuation">,</span> <span class="token string">"Deadlift"</span><span class="token punctuation">,</span> <span class="token string">"Squat"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  drop_axis<span class="token punctuation">(</span>axis <span class="token operator">=</span> <span class="token string">"y"</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  geom_text<span class="token punctuation">(</span>aes<span class="token punctuation">(</span>x <span class="token operator">=</span> female<span class="token punctuation">,</span> y <span class="token operator">=</span> lift<span class="token punctuation">,</span> label <span class="token operator">=</span> paste<span class="token punctuation">(</span>female<span class="token punctuation">,</span> <span class="token string">"kg"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            color <span class="token operator">=</span> <span class="token string">"#D6604C"</span><span class="token punctuation">,</span> size <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">,</span> vjust <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  geom_text<span class="token punctuation">(</span>aes<span class="token punctuation">(</span>x <span class="token operator">=</span> male<span class="token punctuation">,</span> y <span class="token operator">=</span> lift<span class="token punctuation">,</span> label <span class="token operator">=</span> paste<span class="token punctuation">(</span>male<span class="token punctuation">,</span> <span class="token string">"kg"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            color <span class="token operator">=</span> <span class="token string">"#395B74"</span><span class="token punctuation">,</span> size <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">,</span> vjust <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  geom_rect<span class="token punctuation">(</span>aes<span class="token punctuation">(</span>xmin<span class="token operator">=</span><span class="token number">430</span><span class="token punctuation">,</span> xmax<span class="token operator">=</span><span class="token number">470</span><span class="token punctuation">,</span> ymin<span class="token operator">=</span><span class="token operator">-</span><span class="token number">Inf</span><span class="token punctuation">,</span> ymax<span class="token operator">=</span><span class="token number">Inf</span><span class="token punctuation">)</span><span class="token punctuation">,</span> fill<span class="token operator">=</span><span class="token string">"grey80"</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  geom_text<span class="token punctuation">(</span>aes<span class="token punctuation">(</span>label<span class="token operator">=</span>diff<span class="token punctuation">,</span> y<span class="token operator">=</span>lift<span class="token punctuation">,</span> x<span class="token operator">=</span><span class="token number">450</span><span class="token punctuation">)</span><span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  geom_text<span class="token punctuation">(</span>aes<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token number">450</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> label<span class="token operator">=</span><span class="token string">"Difference"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            color<span class="token operator">=</span><span class="token string">"grey20"</span><span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span> vjust<span class="token operator">=</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>
${validate_component(Image, "Image").$$render($$result, {
      src: "../images/post/tidy-tuesday-powerlifting/unnamed-chunk-8-1.png",
      alt: "A static dumbbell plot which represents male and female \u2018top lifts' in 2019."
    }, {}, {})}
<p>Finally, we animate, using Thomas Pedersen\u2019s wonderful <a href="${"https://github.com/thomasp85/gganimate"}" rel="${"nofollow"}">gganimate
package</a>. This is a relatively easy step, because <code>gganimate</code> only requires two extra lines of code: <code>transition_states</code> and <code>ease_aes</code>. Then, we pass it into the <code>animate</code> function!</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">animation <span class="token operator">&lt;-</span> max_lifts_final <span class="token percent-operator operator">%>%</span>
  ggplot<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  ggalt<span class="token operator">::</span>geom_dumbbell<span class="token punctuation">(</span>aes<span class="token punctuation">(</span>y <span class="token operator">=</span> lift<span class="token punctuation">,</span>
                    x <span class="token operator">=</span> female<span class="token punctuation">,</span> xend <span class="token operator">=</span> male<span class="token punctuation">)</span><span class="token punctuation">,</span>
                colour <span class="token operator">=</span> <span class="token string">"grey"</span><span class="token punctuation">,</span> size <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">,</span>
                colour_x <span class="token operator">=</span> <span class="token string">"#D6604C"</span><span class="token punctuation">,</span> colour_xend <span class="token operator">=</span> <span class="token string">"#395B74"</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  labs<span class="token punctuation">(</span>y <span class="token operator">=</span> element_blank<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
       x <span class="token operator">=</span> <span class="token string">"Top Lift Recorded (kg)"</span><span class="token punctuation">,</span>
       title <span class="token operator">=</span>  <span class="token string">"How &lt;span style='color:#D6604C'>Women&lt;/span> and &lt;span style='color:#395B74'>Men&lt;/span> Differ in Top Lifts"</span><span class="token punctuation">,</span>
  subtitle<span class="token operator">=</span><span class="token string">'&#92;nThis plot depicts the difference between the heaviest lifts for each sex at International Powerlifting Federation&#92;nevents over time. &#92;n &#92;n&#123;closest_state&#125;'</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  theme<span class="token punctuation">(</span>plot.title <span class="token operator">=</span> element_markdown<span class="token punctuation">(</span>lineheight <span class="token operator">=</span> <span class="token number">1.1</span><span class="token punctuation">,</span> size <span class="token operator">=</span> <span class="token number">25</span><span class="token punctuation">,</span> margin<span class="token operator">=</span>margin<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        plot.subtitle <span class="token operator">=</span> element_text<span class="token punctuation">(</span>size <span class="token operator">=</span> <span class="token number">15</span><span class="token punctuation">,</span> margin<span class="token operator">=</span>margin<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">30</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  scale_y_discrete<span class="token punctuation">(</span>labels <span class="token operator">=</span> c<span class="token punctuation">(</span><span class="token string">"Bench"</span><span class="token punctuation">,</span> <span class="token string">"Deadlift"</span><span class="token punctuation">,</span> <span class="token string">"Squat"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  drop_axis<span class="token punctuation">(</span>axis <span class="token operator">=</span> <span class="token string">"y"</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  geom_text<span class="token punctuation">(</span>aes<span class="token punctuation">(</span>x <span class="token operator">=</span> female<span class="token punctuation">,</span> y <span class="token operator">=</span> lift<span class="token punctuation">,</span> label <span class="token operator">=</span> paste<span class="token punctuation">(</span>female<span class="token punctuation">,</span> <span class="token string">"kg"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            color <span class="token operator">=</span> <span class="token string">"#D6604C"</span><span class="token punctuation">,</span> size <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">,</span> vjust <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  geom_text<span class="token punctuation">(</span>aes<span class="token punctuation">(</span>x <span class="token operator">=</span> male<span class="token punctuation">,</span> y <span class="token operator">=</span> lift<span class="token punctuation">,</span> label <span class="token operator">=</span> paste<span class="token punctuation">(</span>male<span class="token punctuation">,</span> <span class="token string">"kg"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            color <span class="token operator">=</span> <span class="token string">"#395B74"</span><span class="token punctuation">,</span> size <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">,</span> vjust <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  transition_states<span class="token punctuation">(</span>year<span class="token punctuation">,</span> transition_length <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">,</span> state_length <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  ease_aes<span class="token punctuation">(</span><span class="token string">'cubic-in-out'</span><span class="token punctuation">)</span>

a_gif <span class="token operator">&lt;-</span> animate<span class="token punctuation">(</span>animation<span class="token punctuation">,</span>
                 fps <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span>
                 duration <span class="token operator">=</span> <span class="token number">25</span><span class="token punctuation">,</span>
                 width <span class="token operator">=</span> <span class="token number">800</span><span class="token punctuation">,</span> height <span class="token operator">=</span> <span class="token number">400</span><span class="token punctuation">,</span>
                 renderer <span class="token operator">=</span> gifski_renderer<span class="token punctuation">(</span><span class="token string">"outputs/animation.gif"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

a_gif</code>`}<!-- HTML_TAG_END --></pre>
${validate_component(Image, "Image").$$render($$result, {
      src: "../images/post/tidy-tuesday-powerlifting/unnamed-chunk-9-1.gif",
      alt: "An animated dumbbell plot which represents male and female \u2018top lifts' over time. Each tick of the animation represents a new year."
    }, {}, {})}
<p>But in our case, we\u2019d like to include another GIF: a line chart of differences over time.</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">animation2 <span class="token operator">&lt;-</span> max_lifts_final <span class="token percent-operator operator">%>%</span>
  ungroup <span class="token percent-operator operator">%>%</span>
  mutate<span class="token punctuation">(</span>lift <span class="token operator">=</span> case_when<span class="token punctuation">(</span>lift <span class="token operator">==</span> <span class="token string">"best3bench_kg"</span> <span class="token operator">~</span> <span class="token string">"Bench"</span><span class="token punctuation">,</span>
                          lift <span class="token operator">==</span> <span class="token string">"best3squat_kg"</span> <span class="token operator">~</span> <span class="token string">"Squat"</span><span class="token punctuation">,</span>
                          lift <span class="token operator">==</span> <span class="token string">"best3deadlift_kg"</span> <span class="token operator">~</span> <span class="token string">"Deadlift"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token percent-operator operator">%>%</span>
  ggplot<span class="token punctuation">(</span>aes<span class="token punctuation">(</span>year<span class="token punctuation">,</span> diff<span class="token punctuation">,</span> group <span class="token operator">=</span> lift<span class="token punctuation">,</span> color <span class="token operator">=</span> lift<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  geom_line<span class="token punctuation">(</span>show.legend <span class="token operator">=</span> <span class="token boolean">FALSE</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  geom_segment<span class="token punctuation">(</span>aes<span class="token punctuation">(</span>xend <span class="token operator">=</span> <span class="token number">2019.1</span><span class="token punctuation">,</span> yend <span class="token operator">=</span> diff<span class="token punctuation">)</span><span class="token punctuation">,</span> linetype <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> colour <span class="token operator">=</span> <span class="token string">'grey'</span><span class="token punctuation">,</span> show.legend <span class="token operator">=</span> <span class="token boolean">FALSE</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  geom_point<span class="token punctuation">(</span>size <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> show.legend <span class="token operator">=</span> <span class="token boolean">FALSE</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  geom_text<span class="token punctuation">(</span>aes<span class="token punctuation">(</span>x <span class="token operator">=</span> <span class="token number">2019.1</span><span class="token punctuation">,</span> label <span class="token operator">=</span> lift<span class="token punctuation">,</span> color <span class="token operator">=</span> <span class="token string">"#000000"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hjust <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> show.legend <span class="token operator">=</span> <span class="token boolean">FALSE</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  drop_axis<span class="token punctuation">(</span>axis <span class="token operator">=</span> <span class="token string">"y"</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  transition_reveal<span class="token punctuation">(</span>year<span class="token punctuation">)</span> <span class="token operator">+</span>
  coord_cartesian<span class="token punctuation">(</span>clip <span class="token operator">=</span> <span class="token string">'off'</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  theme<span class="token punctuation">(</span>plot.title <span class="token operator">=</span> element_text<span class="token punctuation">(</span>size <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  labs<span class="token punctuation">(</span>title <span class="token operator">=</span> <span class="token string">'Difference over time'</span><span class="token punctuation">,</span>
       y <span class="token operator">=</span> <span class="token string">'Difference (kg)'</span><span class="token punctuation">,</span>
       x <span class="token operator">=</span> element_blank<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  theme<span class="token punctuation">(</span>plot.margin <span class="token operator">=</span> margin<span class="token punctuation">(</span><span class="token number">5.5</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">5.5</span><span class="token punctuation">,</span> <span class="token number">5.5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

b_gif <span class="token operator">&lt;-</span> animate<span class="token punctuation">(</span>animation2<span class="token punctuation">,</span>
                 fps <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span>
                 duration <span class="token operator">=</span> <span class="token number">25</span><span class="token punctuation">,</span>
        width <span class="token operator">=</span> <span class="token number">800</span><span class="token punctuation">,</span> height <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">,</span>
        renderer <span class="token operator">=</span> gifski_renderer<span class="token punctuation">(</span><span class="token string">"outputs/animation2.gif"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

b_gif</code>`}<!-- HTML_TAG_END --></pre>
${validate_component(Image, "Image").$$render($$result, {
      src: "../images/post/tidy-tuesday-powerlifting/unnamed-chunk-10-1.gif",
      alt: "An animated line chart that shows, year by year, the difference in male and female top lifts on the Y axis. Each tick of the chart shows a new year."
    }, {}, {})}
<p>Finally, we\u2019ll combine them using <code>magick</code> (thanks to <a href="${"https://github.com/thomasp85/gganimate/wiki/Animation-Composition"}" rel="${"nofollow"}">this
post</a>):</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">library<span class="token punctuation">(</span>magick<span class="token punctuation">)</span>
a_mgif <span class="token operator">&lt;-</span> image_read<span class="token punctuation">(</span>a_gif<span class="token punctuation">)</span>
b_mgif <span class="token operator">&lt;-</span> image_read<span class="token punctuation">(</span>b_gif<span class="token punctuation">)</span>

new_gif <span class="token operator">&lt;-</span> image_append<span class="token punctuation">(</span>c<span class="token punctuation">(</span>a_mgif<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> b_mgif<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> stack <span class="token operator">=</span> <span class="token boolean">TRUE</span><span class="token punctuation">)</span>
<span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token keyword">in</span> <span class="token number">2</span><span class="token operator">:</span><span class="token number">250</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
  combined <span class="token operator">&lt;-</span> image_append<span class="token punctuation">(</span>c<span class="token punctuation">(</span>a_mgif<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> b_mgif<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> stack <span class="token operator">=</span> <span class="token boolean">TRUE</span><span class="token punctuation">)</span>
  new_gif <span class="token operator">&lt;-</span> c<span class="token punctuation">(</span>new_gif<span class="token punctuation">,</span> combined<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code>`}<!-- HTML_TAG_END --></pre>
<p>What\u2019s happening here? Essentially, we\u2019re using the power of <code>magick</code> to:</p>
<ol><li>Read in all of the <em>individual images</em> (<code>image_read</code>) from each GIF (after all, a GIF is just a series of images!).</li>
<li>For the first frame, stack the two images on top of each other (<code>image_append</code>), so plot 1 is above plot 2.</li>
<li>For the rest of the frames (in my case, the next 249, because my GIF had 250 frames), replicate this and combine it with the first frame (this is the <code>for</code> loop).</li></ol>
<p>Here, we specify <code>stack = TRUE</code> so that one plot is <strong>above</strong> the other. If you\u2019d like to place them side-by-side, specify <code>stack = FALSE</code>.</p>
<p>In combination, the process results in our final output:</p>
${validate_component(Image, "Image").$$render($$result, {
      src: "../images/post/tidy-tuesday-powerlifting/unnamed-chunk-11-1.gif",
      alt: "A combination of the two aforementioned plots. The top plot is the animated dumbbell plot, and the bottom is a line chart. In combination, they allow the user to see the magnitude of differences between men and women, as well as how these differences have evolved over time."
    }, {}, {})}
<p>In this view, we can see the magnitude of the differences both relatively and absolutely (top chart), <em>and</em> we can see how these differences change over time (bottom chart). The power of an animated, combined chart!</p>`
  })}`;
});
var tidyTuesdayPowerlifting = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Tidy_tuesday_powerlifting,
  metadata: metadata$g
});
var metadata$f = {
  "layout": "blog",
  "title": "Using Shiny to Replicate a Bloomberg Graphic",
  "description": "Leveraging the power of {shiny} for static graphics",
  "date": "2019-12-10",
  "image": "tidy-tuesday-replication/header.png",
  "archived": true,
  "tags": ["r", "tutorial"]
};
var Tidy_tuesday_replication = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${validate_component(Layout, "Layout_MDSVEX_DEFAULT").$$render($$result, Object.assign($$props, metadata$f), {}, {
    default: () => `<p>This weeks\u2019s installment of <a href="${"https://t.co/sElb4fcv3u?amp=1"}" rel="${"nofollow"}">Tidy
Tuesday</a> is all about replicating
professional plots in R. Inspired by Rafael Irizarry\u2019s post <a href="${"https://simplystatistics.org/2019/08/28/you-can-replicate-almost-any-plot-with-ggplot2/"}" rel="${"nofollow"}">\u201CYou can
replicate almost any plot with
R\u201D</a>,
the goal is to take otherwise professional publication-ready plots and
make them in R (usually ggplot2).</p>
<p>I was interested in this Tidy Tuesday because some of my <a href="${"https://connorrothschild.github.io/r/introducing-tpltheme/"}" rel="${"nofollow"}">past
work</a> has
been dedicated to creating publication-ready plots. Because <a href="${"https://connorrothschild.github.io/r/automation/"}" rel="${"nofollow"}">the first
visualization I ever
created</a> was inspired
by (a replication of?) <a href="${"https://www.bloomberg.com/graphics/2017-job-risk/"}" rel="${"nofollow"}">this
visualization</a> from
Bloomberg graphics, I decided to set out on a journey to make that plot
as close as possible to the real thing.</p>
${validate_component(Image, "Image").$$render($$result, {
      alt: "A scatterplot by Bloomberg Graphics, showing automation risk compared to median income.",
      src: "../images/post/tidy-tuesday-replication/bloomberg.png"
    }, {}, {})}
<p>The real goal of this week\u2019s Tidy Tuesday is using <strong>the data that
Rafael posted</strong> to create other cool visualizations; I took a slightly
different approach to try to recreate another visualization entirely.
What follows is an interactive recreation of the visualization above,
using <a href="${"https://shiny.rstudio.com/"}" rel="${"nofollow"}">Shiny</a> and
<a href="${"https://plot.ly/r/"}" rel="${"nofollow"}">plotly</a>.</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">library<span class="token punctuation">(</span>ggplot2<span class="token punctuation">)</span>
library<span class="token punctuation">(</span>ggthemes<span class="token punctuation">)</span>
library<span class="token punctuation">(</span>dplyr<span class="token punctuation">)</span>
library<span class="token punctuation">(</span>ggrepel<span class="token punctuation">)</span>
library<span class="token punctuation">(</span>tools<span class="token punctuation">)</span>
library<span class="token punctuation">(</span>readxl<span class="token punctuation">)</span>
library<span class="token punctuation">(</span>tidyverse<span class="token punctuation">)</span>
library<span class="token punctuation">(</span>knitr<span class="token punctuation">)</span>
library<span class="token punctuation">(</span>shiny<span class="token punctuation">)</span>
library<span class="token punctuation">(</span>plotly<span class="token punctuation">)</span>

theme_set<span class="token punctuation">(</span>theme_minimal<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>
<h1 id="${"load-and-clean-data"}"><a href="${"#load-and-clean-data"}">Load and clean data</a></h1>
<p>First, we read in the data. This process was a bit complicated as I kind
of had to guess where Bloomberg pulled their data from.</p>
<p>I relied on three datasets:</p>
<ol><li>Educational attainment broke down by occupation, provided by BLS
<a href="${"https://www.bls.gov/emp/ep_education_training_system.htm"}" rel="${"nofollow"}">here</a></li>
<li>Salaries, median hourly/annual wages broke down by occupation,
provided by BLS
<a href="${"https://www.bls.gov/oes/current/oes_nat.htm#11-0000"}" rel="${"nofollow"}">here</a></li>
<li>Risk of automation broken down by occupation, provided by Carl
Benedikt Frey and Michael A. Osborne (but compiled
<a href="${"https://data.world/wnedds/occupations-by-state-and-likelihood-of-automation"}" rel="${"nofollow"}">here</a>)</li></ol>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">education <span class="token operator">&lt;-</span> read_excel<span class="token punctuation">(</span><span class="token string">"data/education.xlsx"</span><span class="token punctuation">,</span> skip<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>
salary <span class="token operator">&lt;-</span> read_excel<span class="token punctuation">(</span><span class="token string">"data/national_M2017_dl.xlsx"</span><span class="token punctuation">)</span>
automation <span class="token operator">&lt;-</span> read_excel<span class="token punctuation">(</span><span class="token string">"data/raw_state_automation_data.xlsx"</span><span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>
<p>In <a href="${"https://connorrothschild.github.io/r/automation/"}" rel="${"nofollow"}">another post</a>, I
detail the data cleaning process. I\u2019ll spare you the details here.</p>
<h1 id="${"create-the-ui"}"><a href="${"#create-the-ui"}">Create the UI</a></h1>
<p>Now we create the UI, as is the case for any Shiny app. This is pretty
simple: first, we add the title panel and beautify it with some CSS.</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">ui <span class="token operator">&lt;-</span> fluidPage<span class="token punctuation">(</span>

    titlePanel<span class="token punctuation">(</span>
      h1<span class="token punctuation">(</span><span class="token string">"A College Degree Lowers Job Automation Risk"</span><span class="token punctuation">,</span>
        style <span class="token operator">=</span> "font<span class="token operator">-</span>family<span class="token operator">:</span> <span class="token string">'Helvetica Neue'</span><span class="token punctuation">;</span>
        font<span class="token operator">-</span>size<span class="token operator">:</span> <span class="token number">20</span>px<span class="token punctuation">;</span> font<span class="token operator">-</span>weight<span class="token operator">:</span> <span class="token number">400</span><span class="token punctuation">;</span> line<span class="token operator">-</span>height<span class="token operator">:</span> <span class="token number">1.1</span><span class="token punctuation">;</span>"<span class="token punctuation">)</span><span class="token punctuation">,</span>
      windowTitle <span class="token operator">=</span> <span class="token string">"Find Out If Your Job Will Be Automated"</span>
      <span class="token punctuation">)</span><span class="token punctuation">,</span></code>`}<!-- HTML_TAG_END --></pre>
<p>Next, we add the main panel, which includes a) the plot object, b) the
footnote, and c) some CSS.</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">mainPanel<span class="token punctuation">(</span>
      fluidRow<span class="token punctuation">(</span>
        div<span class="token punctuation">(</span>
           plotlyOutput<span class="token punctuation">(</span><span class="token string">"plot"</span><span class="token punctuation">,</span> height <span class="token operator">=</span> <span class="token string">'600px'</span><span class="token punctuation">,</span> width <span class="token operator">=</span> <span class="token string">'850px'</span><span class="token punctuation">)</span>
           <span class="token punctuation">)</span><span class="token punctuation">,</span>align<span class="token operator">=</span><span class="token string">"left"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
           p<span class="token punctuation">(</span><span class="token string">"DATA: FREY &amp; OSBORNE, BUREAU OF LABOR STATISTICS"</span><span class="token punctuation">,</span>
           style <span class="token operator">=</span> "font<span class="token operator">-</span>family<span class="token operator">:</span> <span class="token string">'Helvetica Neue'</span><span class="token punctuation">;</span>
        font<span class="token operator">-</span>size<span class="token operator">:</span> <span class="token number">8</span>px<span class="token punctuation">;</span> font<span class="token operator">-</span>weight<span class="token operator">:</span> <span class="token number">500</span><span class="token punctuation">;</span> line<span class="token operator">-</span>height<span class="token operator">:</span> <span class="token number">1.1</span><span class="token punctuation">;</span>"<span class="token punctuation">)</span>
           <span class="token punctuation">)</span>

<span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>
<p>That\u2019s it!</p>
<h1 id="${"server"}"><a href="${"#server"}">Server</a></h1>
<p>Now we can define the <code>server()</code> function, where the real magic of this
visualization happens.</p>
<p>All of the following takes place in the
<code>server &lt;- function(input, output, session) {}</code> function.</p>
<h2 id="${"create-a-ggplot-object"}"><a href="${"#create-a-ggplot-object"}">Create a <code>ggplot</code> object</a></h2>
<p>We know we\u2019re going to need a ggplot object. In my case, we\u2019ll need a
plot object which relies on <em>probability, median income,</em> and <em>risk of
automation</em>.</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">ggplot<span class="token punctuation">(</span>aes<span class="token punctuation">(</span>x<span class="token operator">=</span>probability<span class="token punctuation">,</span> y<span class="token operator">=</span>A_MEDIAN<span class="token punctuation">,</span> size<span class="token operator">=</span>TOT_EMP<span class="token punctuation">,</span> fill<span class="token operator">=</span>typicaled<span class="token punctuation">,</span> text <span class="token operator">=</span> text<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span>
    geom_point<span class="token punctuation">(</span>color <span class="token operator">=</span> <span class="token string">"black"</span><span class="token punctuation">,</span> alpha <span class="token operator">=</span> <span class="token number">.97</span><span class="token punctuation">,</span> stroke <span class="token operator">=</span> <span class="token number">.1</span><span class="token punctuation">)</span> <span class="token operator">+</span>
    scale_size<span class="token punctuation">(</span>range <span class="token operator">=</span> c<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> guide <span class="token operator">=</span> <span class="token string">'legend'</span><span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>
<p>This creates the base of the object.</p>
<h3 id="${"add-a-tooltip"}"><a href="${"#add-a-tooltip"}">Add a tooltip</a></h3>
<p>We also know that, like the Bloomberg visualization we\u2019re replicating,
we\u2019re going to want a tooltip.</p>
<p>That\u2019s why we included <code>text</code> in the above code, which we define here:</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">data <span class="token percent-operator operator">%>%</span>
    mutate<span class="token punctuation">(</span>text <span class="token operator">=</span> glue<span class="token operator">::</span>glue<span class="token punctuation">(</span><span class="token string">'&lt;span style="font-size:16px;font-weight:bold">&#123;data$occupation&#125;&lt;/span>'</span><span class="token punctuation">,</span>
                             <span class="token string">'&#92;n&lt;b>Number employed:&lt;/b> &#123;scales::comma(data$TOT_EMP)&#125;'</span><span class="token punctuation">,</span>
                             <span class="token string">'&#92;n&lt;b>Computerization prob:&lt;/b> &#123;data$probability&#125;%'</span><span class="token punctuation">,</span>
                             <span class="token string">'&#92;n&lt;b>Education:&lt;/b> &#123;data$typicaled&#125;'</span><span class="token punctuation">,</span>
                             sep <span class="token operator">=</span> <span class="token string">"&#92;n"</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>
<p>This tooltip takes in some CSS, some HTML, and creates a pretty tooltip!
The <code>glue</code> function is lovely.</p>
<h3 id="${"axes-and-labels"}"><a href="${"#axes-and-labels"}">Axes and labels</a></h3>
<p>The Bloomberg visualization is unique in that it has no axis lines. We
can replicate that in <code>ggplot2</code> via the following code:</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">theme<span class="token punctuation">(</span>axis.line.x <span class="token operator">=</span> ggplot2<span class="token operator">::</span>element_blank<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      axis.line.y <span class="token operator">=</span> ggplot2<span class="token operator">::</span>element_blank<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      axis.text <span class="token operator">=</span> element_text<span class="token punctuation">(</span>colour <span class="token operator">=</span> <span class="token string">"black"</span><span class="token punctuation">,</span> size <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>
<p>But that\u2019s not all!</p>
<p>The Bloomberg visualization is also unique in that it doesn\u2019t have axis
titles. Moreover, the axis labels are a bit unique; the x axis increases
sequentially by 10 until 90 where it transitions into \u201890%\u2019 (the % is
not present in the earlier numbers).</p>
<p>We can mimic that kind of styling with this code:</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">xlab<span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span> <span class="token operator">+</span>
ylab<span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span> <span class="token operator">+</span>
labs<span class="token punctuation">(</span>size<span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">,</span> alpha <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">,</span> fill <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">)</span> <span class="token operator">+</span>
scale_y_continuous<span class="token punctuation">(</span>limits <span class="token operator">=</span> c<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1000</span><span class="token punctuation">,</span><span class="token number">240000</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                   breaks <span class="token operator">=</span> c<span class="token punctuation">(</span><span class="token number">20000</span><span class="token punctuation">,</span> <span class="token number">40000</span><span class="token punctuation">,</span> <span class="token number">60000</span><span class="token punctuation">,</span> <span class="token number">80000</span><span class="token punctuation">,</span> <span class="token number">100000</span><span class="token punctuation">,</span> <span class="token number">120000</span><span class="token punctuation">,</span> <span class="token number">140000</span><span class="token punctuation">,</span> <span class="token number">160000</span><span class="token punctuation">,</span> <span class="token number">180000</span><span class="token punctuation">,</span> <span class="token number">200000</span><span class="token punctuation">,</span> <span class="token number">220000</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                   labels <span class="token operator">=</span> c<span class="token punctuation">(</span><span class="token string">"20K"</span><span class="token punctuation">,</span> <span class="token string">"40K"</span><span class="token punctuation">,</span> <span class="token string">"60K"</span><span class="token punctuation">,</span> <span class="token string">"80K"</span><span class="token punctuation">,</span> <span class="token string">"100K"</span><span class="token punctuation">,</span> <span class="token string">"120K"</span><span class="token punctuation">,</span> <span class="token string">"140K"</span><span class="token punctuation">,</span> <span class="token string">"160K"</span><span class="token punctuation">,</span> <span class="token string">"180K"</span><span class="token punctuation">,</span> <span class="token string">"200K"</span><span class="token punctuation">,</span> <span class="token string">"220K"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span>
scale_x_continuous<span class="token punctuation">(</span>limits <span class="token operator">=</span> c<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                   breaks <span class="token operator">=</span> c<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">,</span><span class="token number">40</span><span class="token punctuation">,</span><span class="token number">50</span><span class="token punctuation">,</span><span class="token number">60</span><span class="token punctuation">,</span><span class="token number">70</span><span class="token punctuation">,</span><span class="token number">80</span><span class="token punctuation">,</span><span class="token number">90</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                   labels <span class="token operator">=</span> c<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">,</span><span class="token number">40</span><span class="token punctuation">,</span><span class="token number">50</span><span class="token punctuation">,</span><span class="token number">60</span><span class="token punctuation">,</span><span class="token number">70</span><span class="token punctuation">,</span><span class="token number">80</span><span class="token punctuation">,</span><span class="token string">"90%"</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>
<p>We create a bit of a buffer on the <code>limits</code> argument so that we can add
annotations. We\u2019ll get to that later!</p>
<h3 id="${"colors"}"><a href="${"#colors"}">Colors</a></h3>
<p>To get as close as possible to Bloomberg\u2019s plot, I\u2019d also like to mimic
their color scheme. I pulled the colors from their dotplot with this
awesome <a href="${"https://chrome.google.com/webstore/detail/color-picker/ohcpnigalekghcmgcdcenkpelffpdolg"}" rel="${"nofollow"}">Chrome
plugin</a>;
then, I added them to R with the following:</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">colors <span class="token operator">&lt;-</span> c<span class="token punctuation">(</span><span class="token string">'No formal educational credential'</span> <span class="token operator">=</span> <span class="token string">'#FA1A48'</span><span class="token punctuation">,</span>
            <span class="token string">'High school diploma or equivalent'</span> <span class="token operator">=</span> <span class="token string">'#F79734'</span><span class="token punctuation">,</span>
            <span class="token string">'Postsecondary nondegree award'</span> <span class="token operator">=</span> <span class="token string">'#FDFF1C'</span><span class="token punctuation">,</span> 
            <span class="token string">"Associate's degree"</span> <span class="token operator">=</span> <span class="token string">'#1DDF50'</span><span class="token punctuation">,</span>
            <span class="token string">"Bachelor's degree"</span> <span class="token operator">=</span> <span class="token string">'#34D19D'</span><span class="token punctuation">,</span> 
            <span class="token string">"Master's degree"</span> <span class="token operator">=</span> <span class="token string">'#1BC0E9'</span><span class="token punctuation">,</span>
            <span class="token string">"Doctoral or professional degree"</span> <span class="token operator">=</span> <span class="token string">'#1B91FF'</span><span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>
<p>In the plot object, we reference this with the following:</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">scale_fill_manual<span class="token punctuation">(</span>values <span class="token operator">=</span> colors<span class="token punctuation">,</span> labels <span class="token operator">=</span> 
  c<span class="token punctuation">(</span><span class="token string">'No formal educational credential'</span><span class="token punctuation">,</span> 
    <span class="token string">'High school diploma or equivalent'</span><span class="token punctuation">,</span> 
    <span class="token string">"Some college, no degree"</span><span class="token punctuation">,</span>
    <span class="token string">"Associate's degree"</span><span class="token punctuation">,</span> 
    <span class="token string">"Postsecondary nondegree award"</span><span class="token punctuation">,</span>
    <span class="token string">"Bachelor's degree"</span><span class="token punctuation">,</span>
    <span class="token string">"Master's degree"</span><span class="token punctuation">,</span>
    <span class="token string">"Doctoral or professional degree"</span><span class="token punctuation">)</span>
    <span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>
<p>This essentially creates a fill scale (manually) with specified hex
codes for colors. I also tried to manipulate the order of the legend but
that didn\u2019t translate to plotly (a documented problem, I believe).</p>
<h3 id="${"final-touches-for-the-ggplot"}"><a href="${"#final-touches-for-the-ggplot"}">Final touches for the <code>ggplot</code></a></h3>
<p>Finally, we do something really hacky: add a regression line with
<code>geom_segment</code>. (I\u2019m so sorry)</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">geom_segment<span class="token punctuation">(</span>aes<span class="token punctuation">(</span>x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">54000</span><span class="token punctuation">,</span> xend <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">,</span> yend <span class="token operator">=</span> <span class="token number">58000</span><span class="token punctuation">)</span><span class="token punctuation">,</span> size <span class="token operator">=</span> <span class="token number">.1</span><span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>
<p>We now have the ggplot object created; let\u2019s convert it to a plotly
object.</p>
<h2 id="${"create-a-plotly-object"}"><a href="${"#create-a-plotly-object"}">Create a <code>plotly</code> object</a></h2>
<p>This process relies on the <code>ggplotly</code> function, which reads in a
previously defined <code>ggplot</code> object and converts into an interactive
plotly one.</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">introPlot <span class="token operator">&lt;-</span> ggplotly<span class="token punctuation">(</span>introggPlot<span class="token punctuation">,</span> tooltip <span class="token operator">=</span> <span class="token string">'text'</span><span class="token punctuation">,</span> sort <span class="token operator">=</span> <span class="token boolean">FALSE</span><span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>
<p>After creating the base plotly object, we move to some more complicated
steps:</p>
<h3 id="${"legend-orientation"}"><a href="${"#legend-orientation"}">Legend orientation</a></h3>
<p>We\u2019d like the legend to orient horizontally, right above the plot. We do
that with the following (inside the <code>layout</code> function):</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">introPlot <span class="token operator">&lt;-</span> ggplotly<span class="token punctuation">(</span>introggPlot<span class="token punctuation">,</span> tooltip <span class="token operator">=</span> <span class="token string">'text'</span><span class="token punctuation">,</span> sort <span class="token operator">=</span> <span class="token boolean">FALSE</span><span class="token punctuation">)</span> <span class="token percent-operator operator">%>%</span>
layout<span class="token punctuation">(</span>
  legend <span class="token operator">=</span> list<span class="token punctuation">(</span>orientation <span class="token operator">=</span> <span class="token string">"h"</span><span class="token punctuation">,</span>
              xanchor <span class="token operator">=</span> <span class="token string">"left"</span><span class="token punctuation">,</span>
              x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">,</span>
              traceorder <span class="token operator">=</span> <span class="token string">"normal"</span><span class="token punctuation">,</span>
              itemsizing <span class="token operator">=</span> <span class="token string">"constant"</span><span class="token punctuation">,</span>
              tracegroupgap <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
              font <span class="token operator">=</span> list<span class="token punctuation">(</span>size <span class="token operator">=</span> <span class="token number">13</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
              <span class="token comment"># ...</span></code>`}<!-- HTML_TAG_END --></pre>
<p>This does a few things. First, it orients the legend horizontally.
Second, it anchors the legend to the left. Third, it defines the
location (using x-y pairs) of the legend. <code>traceorder</code> is meant to
maintain the previous order from <code>ggplot</code>, but that didn\u2019t work in my
version. <code>itemsizing</code> is meant to keep the legend items with a constant
size, as opposed to dynamic relative to the plot objects themselves.
This also didn\u2019t work. The last two arguments define the spacing between
points and the font size of the legend text!</p>
<h3 id="${"axes-revisited"}"><a href="${"#axes-revisited"}">Axes Revisited</a></h3>
<p>We also see the Bloomberg viz has a right-aligned Y-axis. We can add
that to plotly via the following code:</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r"> <span class="token comment"># ... Layout continued</span>
yaxis <span class="token operator">=</span> list<span class="token punctuation">(</span>
          tickfont <span class="token operator">=</span> element_blank<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
          overlaying <span class="token operator">=</span> <span class="token string">"y"</span><span class="token punctuation">,</span>
          side <span class="token operator">=</span> <span class="token string">"right"</span><span class="token punctuation">,</span>
          title <span class="token operator">=</span> <span class="token string">""</span>
        <span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>
<h3 id="${"some-aesthetic-changes"}"><a href="${"#some-aesthetic-changes"}">Some aesthetic changes</a></h3>
<p>Finally, we add three commands to the <code>layout</code> function.</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r"> <span class="token comment"># ... Layout continued</span>
  font <span class="token operator">=</span> list<span class="token punctuation">(</span>family <span class="token operator">=</span> <span class="token string">'Helvetica Neue'</span><span class="token punctuation">,</span> color <span class="token operator">=</span> <span class="token string">"black"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  margin <span class="token operator">=</span> list<span class="token punctuation">(</span>r<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> l<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>t<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>b<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>pad <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  hoverlabel <span class="token operator">=</span> list<span class="token punctuation">(</span>bgcolor <span class="token operator">=</span> <span class="token string">'white'</span><span class="token punctuation">,</span> color <span class="token operator">=</span> <span class="token string">'black'</span><span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>
<p>This a) changes the font of the plot, b) adds a small margin, and c)
stylizes the tooltip on hover.</p>
<h3 id="${"annotations"}"><a href="${"#annotations"}">Annotations</a></h3>
<p>The last step is to mimic Bloomberg\u2019s annotations. This is a little
tough, specifically because it requires pretty specific x- and y-values.</p>
<p>First, we\u2019ll add their guiding annotations (that replace axis labels)
that you can find in each corner:</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r"><span class="token percent-operator operator">%>%</span> <span class="token comment"># After layout() closes</span>
add_annotations<span class="token punctuation">(</span>
      x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">7500</span><span class="token punctuation">,</span>
      xref <span class="token operator">=</span> <span class="token string">"x"</span><span class="token punctuation">,</span>
      yref <span class="token operator">=</span> <span class="token string">"y"</span><span class="token punctuation">,</span>
      text <span class="token operator">=</span> <span class="token string">"&lt;b>Low paid,&#92;nleast vulnerable&lt;/b>"</span><span class="token punctuation">,</span>
      xanchor <span class="token operator">=</span> <span class="token string">'center'</span><span class="token punctuation">,</span>
      align <span class="token operator">=</span> <span class="token string">'left'</span><span class="token punctuation">,</span>
      font <span class="token operator">=</span> list<span class="token punctuation">(</span>size <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      showarrow <span class="token operator">=</span> F
    <span class="token punctuation">)</span> <span class="token percent-operator operator">%>%</span>
    add_annotations<span class="token punctuation">(</span>
      x <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">7500</span><span class="token punctuation">,</span>
      xref <span class="token operator">=</span> <span class="token string">"x"</span><span class="token punctuation">,</span>
      yref <span class="token operator">=</span> <span class="token string">"y"</span><span class="token punctuation">,</span>
      text <span class="token operator">=</span> <span class="token string">"&lt;b>Low paid,&#92;nmost vulnerable&lt;/b>"</span><span class="token punctuation">,</span>
      xanchor <span class="token operator">=</span> <span class="token string">'center'</span><span class="token punctuation">,</span>
      align <span class="token operator">=</span> <span class="token string">'right'</span><span class="token punctuation">,</span>
      font <span class="token operator">=</span> list<span class="token punctuation">(</span>size <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      showarrow <span class="token operator">=</span> F
    <span class="token punctuation">)</span> <span class="token percent-operator operator">%>%</span>
    add_annotations<span class="token punctuation">(</span>
      x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">230000</span><span class="token punctuation">,</span>
      xref <span class="token operator">=</span> <span class="token string">"x"</span><span class="token punctuation">,</span>
      yref <span class="token operator">=</span> <span class="token string">"y"</span><span class="token punctuation">,</span>
      text <span class="token operator">=</span> <span class="token string">"&lt;b>Best paid,&#92;nleast vulnerable&lt;/b>"</span><span class="token punctuation">,</span>
      xanchor <span class="token operator">=</span> <span class="token string">'center'</span><span class="token punctuation">,</span>
      align <span class="token operator">=</span> <span class="token string">'left'</span><span class="token punctuation">,</span>
      font <span class="token operator">=</span> list<span class="token punctuation">(</span>size <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      showarrow <span class="token operator">=</span> F
    <span class="token punctuation">)</span> <span class="token percent-operator operator">%>%</span>
    add_annotations<span class="token punctuation">(</span>
      x <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">230000</span><span class="token punctuation">,</span>
      xref <span class="token operator">=</span> <span class="token string">"x"</span><span class="token punctuation">,</span>
      yref <span class="token operator">=</span> <span class="token string">"y"</span><span class="token punctuation">,</span>
      text <span class="token operator">=</span> <span class="token string">"&lt;b>Best paid,&#92;nmost vulnerable&lt;/b>"</span><span class="token punctuation">,</span>
      xanchor <span class="token operator">=</span> <span class="token string">'center'</span><span class="token punctuation">,</span>
      align <span class="token operator">=</span> <span class="token string">'right'</span><span class="token punctuation">,</span>
      font <span class="token operator">=</span> list<span class="token punctuation">(</span>size <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      showarrow <span class="token operator">=</span> F
    <span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>
<p>Next, we add annotations for \u2018most and least likely to be automated\u2019, as
well as the y axis label.</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">add_annotations<span class="token punctuation">(</span>
      x <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">5000</span><span class="token punctuation">,</span>
      xref <span class="token operator">=</span> <span class="token string">"x"</span><span class="token punctuation">,</span>
      yref <span class="token operator">=</span> <span class="token string">"y"</span><span class="token punctuation">,</span>
      text <span class="token operator">=</span> glue<span class="token operator">::</span>glue<span class="token punctuation">(</span>sprintf<span class="token punctuation">(</span><span class="token string">'\u2190'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"Least likely to be automated"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      xanchor <span class="token operator">=</span> <span class="token string">'left'</span><span class="token punctuation">,</span>
      align <span class="token operator">=</span> <span class="token string">'left'</span><span class="token punctuation">,</span>
      font <span class="token operator">=</span> list<span class="token punctuation">(</span>size <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      showarrow <span class="token operator">=</span> F
    <span class="token punctuation">)</span> <span class="token percent-operator operator">%>%</span>
    add_annotations<span class="token punctuation">(</span>
      x <span class="token operator">=</span> <span class="token number">105</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">5000</span><span class="token punctuation">,</span>
      xref <span class="token operator">=</span> <span class="token string">"x"</span><span class="token punctuation">,</span>
      yref <span class="token operator">=</span> <span class="token string">"y"</span><span class="token punctuation">,</span>
      text <span class="token operator">=</span> glue<span class="token operator">::</span>glue<span class="token punctuation">(</span><span class="token string">"Most likely to be automated"</span><span class="token punctuation">,</span> sprintf<span class="token punctuation">(</span><span class="token string">'\u2192'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      xanchor <span class="token operator">=</span> <span class="token string">'right'</span><span class="token punctuation">,</span>
      align <span class="token operator">=</span> <span class="token string">'right'</span><span class="token punctuation">,</span>
      font <span class="token operator">=</span> list<span class="token punctuation">(</span>size <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      showarrow <span class="token operator">=</span> F
    <span class="token punctuation">)</span> <span class="token percent-operator operator">%>%</span>
    add_annotations<span class="token punctuation">(</span>
      x <span class="token operator">=</span> <span class="token number">99</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">243000</span><span class="token punctuation">,</span>
      xref <span class="token operator">=</span> <span class="token string">"x"</span><span class="token punctuation">,</span>
      yref <span class="token operator">=</span> <span class="token string">"y"</span><span class="token punctuation">,</span>
      text <span class="token operator">=</span> <span class="token string">"Average annual wage"</span><span class="token punctuation">,</span>
      xanchor <span class="token operator">=</span> <span class="token string">'center'</span><span class="token punctuation">,</span>
      align <span class="token operator">=</span> <span class="token string">'right'</span><span class="token punctuation">,</span>
      font <span class="token operator">=</span> list<span class="token punctuation">(</span>size <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      showarrow <span class="token operator">=</span> F
    <span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>
<p>And finally, add a couple of plot annotations which label specific
points. (We are not labelling a hundred occupations like Bloomberg did.)</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">add_annotations<span class="token punctuation">(</span>
      x <span class="token operator">=</span> subset<span class="token punctuation">(</span>data<span class="token operator">$</span>probability<span class="token punctuation">,</span> data<span class="token operator">$</span>occupation <span class="token operator">==</span> <span class="token string">"Chief Executives"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      y <span class="token operator">=</span> subset<span class="token punctuation">(</span>data<span class="token operator">$</span>A_MEDIAN<span class="token punctuation">,</span> data<span class="token operator">$</span>occupation <span class="token operator">==</span> <span class="token string">"Chief Executives"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      text <span class="token operator">=</span> <span class="token string">"Chief Executives"</span><span class="token punctuation">,</span>
      xref <span class="token operator">=</span> <span class="token string">"x"</span><span class="token punctuation">,</span>
      yref <span class="token operator">=</span> <span class="token string">"y"</span><span class="token punctuation">,</span>
      xanchor <span class="token operator">=</span> <span class="token string">'center'</span><span class="token punctuation">,</span>
      align <span class="token operator">=</span> <span class="token string">'right'</span><span class="token punctuation">,</span>
      font <span class="token operator">=</span> list<span class="token punctuation">(</span>size <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      showarrow <span class="token operator">=</span> <span class="token boolean">TRUE</span><span class="token punctuation">,</span>
      arrowhead <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
      ax <span class="token operator">=</span> <span class="token number">50</span><span class="token punctuation">,</span>
      ay <span class="token operator">=</span> <span class="token number">25</span>
    <span class="token punctuation">)</span> <span class="token percent-operator operator">%>%</span>
    add_annotations<span class="token punctuation">(</span>
      x <span class="token operator">=</span> subset<span class="token punctuation">(</span>data<span class="token operator">$</span>probability<span class="token punctuation">,</span> data<span class="token operator">$</span>occupation <span class="token operator">==</span> <span class="token string">"Cashiers"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      y <span class="token operator">=</span> subset<span class="token punctuation">(</span>data<span class="token operator">$</span>A_MEDIAN<span class="token punctuation">,</span> data<span class="token operator">$</span>occupation <span class="token operator">==</span> <span class="token string">"Cashiers"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      text <span class="token operator">=</span> <span class="token string">"Cashiers"</span><span class="token punctuation">,</span>
      xref <span class="token operator">=</span> <span class="token string">"x"</span><span class="token punctuation">,</span>
      yref <span class="token operator">=</span> <span class="token string">"y"</span><span class="token punctuation">,</span>
      xanchor <span class="token operator">=</span> <span class="token string">'center'</span><span class="token punctuation">,</span>
      align <span class="token operator">=</span> <span class="token string">'right'</span><span class="token punctuation">,</span>
      font <span class="token operator">=</span> list<span class="token punctuation">(</span>size <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      showarrow <span class="token operator">=</span> <span class="token boolean">TRUE</span><span class="token punctuation">,</span>
      arrowhead <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
      ax <span class="token operator">=</span> <span class="token number">40</span><span class="token punctuation">,</span>
      ay <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">50</span>
    <span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>
<p>Finalize the plotly object with</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">config<span class="token punctuation">(</span>displaylogo <span class="token operator">=</span> F<span class="token punctuation">,</span> showSendToCloud <span class="token operator">=</span> F<span class="token punctuation">,</span> displayModeBar <span class="token operator">=</span> F<span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>
<p>We\u2019re done! Run the application with the following code:</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">shinyApp<span class="token punctuation">(</span>ui <span class="token operator">=</span> ui<span class="token punctuation">,</span> server <span class="token operator">=</span> server<span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>
<p>And we\u2019re done! Find my interactive visualization
<a href="${"https://connorrothschild.shinyapps.io/2019-12-10/"}" rel="${"nofollow"}">here</a>. Find the
code, uninterrupted and (hopefully) reproducible,
<em><a href="${"https://github.com/connorrothschild/tidytuesday/blob/master/2019-12-10/app.R"}" rel="${"nofollow"}">here</a></em>.</p>
<p>Here\u2019s the Bloomberg visualization:</p>
${validate_component(Image, "Image").$$render($$result, {
      alt: "A scatterplot by Bloomberg Graphics, showing automation risk compared to median income.",
      src: "../images/post/tidy-tuesday-replication/bloomberg.png"
    }, {}, {})}
<p>And here\u2019s mine:</p>
${validate_component(Image, "Image").$$render($$result, {
      alt: "A scatterplot recreation, showing automation risk compared to median income.",
      src: "../images/post/tidy-tuesday-replication/replication.png"
    }, {}, {})}
`
  })}`;
});
var tidyTuesdayReplication = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Tidy_tuesday_replication,
  metadata: metadata$f
});
var metadata$e = {
  "layout": "blog",
  "title": "How to Scrollytell in R",
  "description": "Because its easier than doing it in D3",
  "image": "automation-scrollytell/header.png",
  "date": "2019-10-02",
  "tags": ["r", "tutorial"]
};
var Automation_scrollytell = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${validate_component(Layout, "Layout_MDSVEX_DEFAULT").$$render($$result, Object.assign($$props, metadata$e), {}, {
    default: () => `<p>I\u2019ve always been interested in data visualization, and my most recent
sub-passion has been <em>scrollytelling</em>. I\u2019ve seen numerous examples of
amazing scrolling articles, from sites such as <a href="${"https://pudding.cool/"}" rel="${"nofollow"}">The
Pudding</a>, the <a href="${"https://www.nytimes.com/"}" rel="${"nofollow"}">New York
Times</a>, and
<a href="${"https://fivethirtyeight.com/"}" rel="${"nofollow"}">FiveThirtyEight</a>.</p>
<p>Although most of these sites rely on the same high-powered visualization
tools (such as <a href="${"https://d3js.org/"}" rel="${"nofollow"}">D3.js</a>) to create their stories, the
learning curve for those are a bit steep! Thankfully, I came across some examples of scrollytelling in my language
of choice, R.</p>
<p>Today, I\u2019ll walk you through a tutorial of scrollytelling in R. It\u2019s a bit complicated, and the output isn\u2019t as powerful as a full-fledged D3 project, but its a rough sketch, and it works. Here\u2019s the output:</p>
<iframe title="${"Automation and Its Impact on Jobs"}" src="${"https://connorrothschild.shinyapps.io/automation/"}" width="${"100%"}" height="${"800px"}"></iframe>
<h3 id="${"load-libraries"}"><a href="${"#load-libraries"}">Load libraries</a></h3>
<p>We begin by loading the libraries required for our project:</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">library<span class="token punctuation">(</span>shiny<span class="token punctuation">)</span>
library<span class="token punctuation">(</span>scrollytell<span class="token punctuation">)</span>
library<span class="token punctuation">(</span>shinyjs<span class="token punctuation">)</span>
library<span class="token punctuation">(</span>ggvis<span class="token punctuation">)</span>
library<span class="token punctuation">(</span>plotly<span class="token punctuation">)</span>

theme_set<span class="token punctuation">(</span>theme_minimal<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>
<h2 id="${"construct-an-updating-plot-object"}"><a href="${"#construct-an-updating-plot-object"}">Construct an updating plot object</a></h2>
<p>Once the data (<a href="${"https://github.com/connorrothschild/shiny-scrollytell/tree/master/data"}" rel="${"nofollow"}">which can be found
here</a>)
is already <a href="${"https://github.com/connorrothschild/shiny-scrollytell/blob/master/scripts/merge_data.R"}" rel="${"nofollow"}">loaded and
cleaned</a>,
we construct a plot object that will update as the user scrolls. (<a href="${"https://github.com/scottyd22/dream_team"}" rel="${"nofollow"}">Other
R users</a> make multiple plots;
either way is fine.)</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">plot <span class="token operator">&lt;-</span> data <span class="token percent-operator operator">%>%</span>
  filter<span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span>add <span class="token operator">!=</span> <span class="token number">8</span><span class="token punctuation">)</span> add <span class="token operator">>=</span> reveal <span class="token keyword">else</span> reveal <span class="token percent-operator operator">%in%</span> c<span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token percent-operator operator">%>%</span>
  ggplot<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  geom_point<span class="token punctuation">(</span>mapping<span class="token operator">=</span>aes<span class="token punctuation">(</span>x<span class="token operator">=</span>A_MEDIAN<span class="token punctuation">,</span> y<span class="token operator">=</span>probability<span class="token punctuation">,</span> size<span class="token operator">=</span>TOT_EMP<span class="token punctuation">,</span>
                         alpha<span class="token operator">=</span>ifelse<span class="token punctuation">(</span>add <span class="token operator">==</span> reveal<span class="token punctuation">,</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> col<span class="token operator">=</span>typicaled<span class="token punctuation">,</span>
                         text <span class="token operator">=</span> glue<span class="token operator">::</span>glue<span class="token punctuation">(</span>'<span class="token operator">&lt;</span>b<span class="token operator">></span>Occupation<span class="token operator">&lt;</span><span class="token operator">/</span>b<span class="token operator">></span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>occupation<span class="token punctuation">&#125;</span>
                                            <span class="token operator">&lt;</span>b<span class="token operator">></span>Probability of Automation<span class="token operator">&lt;</span><span class="token operator">/</span>b<span class="token operator">></span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>probability<span class="token punctuation">&#125;</span>%
                                            <span class="token operator">&lt;</span>b<span class="token operator">></span>Median Income<span class="token operator">&lt;</span><span class="token operator">/</span>b<span class="token operator">></span><span class="token operator">:</span> <span class="token operator">$</span><span class="token punctuation">&#123;</span>A_MEDIAN<span class="token punctuation">&#125;</span>
                                            <span class="token operator">&lt;</span>b<span class="token operator">></span>Number of Workers<span class="token operator">&lt;</span><span class="token operator">/</span>b<span class="token operator">></span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>TOT_EMP<span class="token punctuation">&#125;</span>'<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  scale_size<span class="token punctuation">(</span>range <span class="token operator">=</span> c<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  xlab<span class="token punctuation">(</span><span class="token string">"&#92;nMedian Income"</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  ylab<span class="token punctuation">(</span><span class="token string">"Probability of Automation"</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  labs<span class="token punctuation">(</span>size <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">,</span> col <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">,</span> alpha <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  scale_color_manual<span class="token punctuation">(</span>values <span class="token operator">=</span> cols<span class="token punctuation">,</span> breaks <span class="token operator">=</span> legend_ord<span class="token punctuation">)</span> <span class="token operator">+</span>
  scale_x_continuous<span class="token punctuation">(</span>labels <span class="token operator">=</span> scales<span class="token operator">::</span>dollar_format<span class="token punctuation">(</span>prefix<span class="token operator">=</span><span class="token string">"$"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> limits <span class="token operator">=</span> c<span class="token punctuation">(</span><span class="token number">25000</span><span class="token punctuation">,</span><span class="token number">200000</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  scale_y_continuous<span class="token punctuation">(</span>labels <span class="token operator">=</span> scales<span class="token operator">::</span>number_format<span class="token punctuation">(</span>suffix<span class="token operator">=</span><span class="token string">"%"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> limits <span class="token operator">=</span> c<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  theme<span class="token punctuation">(</span>axis.line.x <span class="token operator">=</span> ggplot2<span class="token operator">::</span>element_line<span class="token punctuation">(</span>colour <span class="token operator">=</span> <span class="token keyword">NULL</span><span class="token punctuation">,</span>
                                            size <span class="token operator">=</span> <span class="token keyword">NULL</span><span class="token punctuation">,</span> linetype <span class="token operator">=</span> <span class="token keyword">NULL</span><span class="token punctuation">,</span> lineend <span class="token operator">=</span> <span class="token keyword">NULL</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        axis.line.y <span class="token operator">=</span> ggplot2<span class="token operator">::</span>element_blank<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        panel.grid.major.x <span class="token operator">=</span> element_blank<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>
<p>But wait, what\u2019s that second line of code?</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">filter<span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span>add <span class="token operator">!=</span> <span class="token number">8</span><span class="token punctuation">)</span> add <span class="token operator">>=</span> reveal <span class="token keyword">else</span> reveal <span class="token percent-operator operator">%in%</span> c<span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>
<p>This may make <em>0 sense</em> right now, but here\u2019s why we have it.</p>
<p>The important part (and somewhat difficult thing to understand) about
this step is that your plot object has some <strong>data which corresponds to
an updating variable</strong>. For me, I added a variable called <code>reveal</code> for
each step of the visualization. For me, this meant having <code>reveal</code>
correspond to a typical level of education for a given job.</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">data <span class="token operator">&lt;-</span> data <span class="token percent-operator operator">%>%</span>
  mutate<span class="token punctuation">(</span>reveal <span class="token operator">=</span> case_when<span class="token punctuation">(</span>
    typicaled <span class="token operator">==</span> <span class="token string">"No formal educational credential"</span> <span class="token operator">~</span> <span class="token number">1</span><span class="token punctuation">,</span>
    typicaled <span class="token operator">==</span> <span class="token string">"High school diploma or equivalent"</span> <span class="token operator">~</span> <span class="token number">2</span><span class="token punctuation">,</span>
    typicaled <span class="token operator">==</span> <span class="token string">"Postsecondary nondegree award"</span> <span class="token operator">~</span> <span class="token number">3</span><span class="token punctuation">,</span>
    typicaled <span class="token operator">==</span> <span class="token string">"Some college, no degree"</span> <span class="token operator">~</span> <span class="token number">0</span><span class="token punctuation">,</span>
    typicaled <span class="token operator">==</span> <span class="token string">"Associate's degree"</span> <span class="token operator">~</span> <span class="token number">4</span><span class="token punctuation">,</span>
    typicaled <span class="token operator">==</span> <span class="token string">"Bachelor's degree"</span> <span class="token operator">~</span> <span class="token number">5</span><span class="token punctuation">,</span>
    typicaled <span class="token operator">==</span> <span class="token string">"Master's degree"</span> <span class="token operator">~</span> <span class="token number">6</span><span class="token punctuation">,</span>
    typicaled <span class="token operator">==</span> <span class="token string">"Doctoral or professional degree"</span> <span class="token operator">~</span> <span class="token number">7</span><span class="token punctuation">,</span>
  <span class="token punctuation">)</span><span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>
<p>What this means is that every time the post observes an event (a
scroll), it will update according to the number in the <code>reveal</code> column.</p>
<p>So, when my plot object has a line of code which says:</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">filter<span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span>add <span class="token operator">!=</span> <span class="token number">8</span><span class="token punctuation">)</span> add <span class="token operator">>=</span> reveal <span class="token keyword">else</span> reveal <span class="token percent-operator operator">%in%</span> c<span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>
<p>That can be read as \u201CUpdate the plot object to include all data points
<strong>up until the current point</strong> encoded in <code>reveal</code>.\u201D</p>
<p>But, it also depends on what level of <code>add</code> we are at; if <code>add</code> == 8
(the last data point, e.g.\xA0the concluding plot), then we want to show
<em>all data points</em>.</p>
<p>\u201COkay, okay. But what is <code>add</code>???\u201D</p>
<p>Good question. <code>add</code> is the variable I constructed to correspond to the
user\u2019s input (in this case, the scroll!). When we put it all together,
we\u2019re going to wrap our plot object into a rendering function <em>inside</em>
the server function. Confusing? It looks like this:</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">server <span class="token operator">&lt;-</span> <span class="token keyword">function</span><span class="token punctuation">(</span>input<span class="token punctuation">,</span> output<span class="token punctuation">,</span> session<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

  output<span class="token operator">$</span>plot <span class="token operator">&lt;-</span> renderPlotly<span class="token punctuation">(</span><span class="token punctuation">&#123;</span>

    add <span class="token operator">&lt;-</span> input<span class="token operator">$</span>scr

    plot <span class="token operator">&lt;-</span>
      <span class="token comment"># static ggplot goes here</span>

      ggplotly<span class="token punctuation">(</span>plot<span class="token punctuation">)</span> <span class="token percent-operator operator">%>%</span>
      <span class="token comment"># other ggplotly parameters go here</span>

  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>

  <span class="token comment"># render the plot here</span>
  output<span class="token operator">$</span>scr <span class="token operator">&lt;-</span> renderScrollytell<span class="token punctuation">(</span><span class="token punctuation">&#123;</span>scrollytell<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
  renderText<span class="token punctuation">(</span>paste0<span class="token punctuation">(</span><span class="token string">"Section: "</span><span class="token punctuation">,</span> input<span class="token operator">$</span>scr<span class="token punctuation">)</span><span class="token punctuation">)</span>
  observe<span class="token punctuation">(</span><span class="token punctuation">&#123;</span>cat<span class="token punctuation">(</span><span class="token string">"section:"</span><span class="token punctuation">,</span> input<span class="token operator">$</span>scr<span class="token punctuation">,</span> <span class="token string">"&#92;n"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>

<span class="token punctuation">&#125;</span></code>`}<!-- HTML_TAG_END --></pre>
<p>What\u2019s happening here? Within the server function, we\u2019re doing two
things:</p>
<p>First, we\u2019re creating the plot object. Because we have the command <code>add &lt;- input$scr</code> <strong>inside</strong> the function <code>renderPlotly</code>, our plot object will be dynamically updated along with <code>input$scr</code>.</p>
<p>This makes more sense when you connect it to the ui. In our ui function,
we include a <code>scrolly_container</code> from the scrollytell package. Within
that, we make our <code>outputId</code> correspond to the name of our updating
input (in this case, <em>scr</em>).</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">ui <span class="token operator">&lt;-</span> fluidPage<span class="token punctuation">(</span>

  <span class="token comment"># a bunch of introductory stuff, css stuff</span>

  <span class="token comment"># scrollytelling plot</span>
  scrolly_container<span class="token punctuation">(</span>outputId <span class="token operator">=</span> <span class="token string">"scr"</span><span class="token punctuation">,</span>
                       scrolly_graph<span class="token punctuation">(</span>
                                     <span class="token comment">## this is the plot object that we made earlier:</span>
                                     plotlyOutput<span class="token punctuation">(</span><span class="token string">"plot"</span><span class="token punctuation">,</span> height <span class="token operator">=</span> <span class="token string">'600px'</span><span class="token punctuation">)</span>

                    <span class="token punctuation">)</span><span class="token punctuation">,</span>
                    scrolly_sections<span class="token punctuation">(</span>
                      <span class="token comment">## each of these sections corresponds to an update</span>
                      <span class="token comment">## the number after id = corresponds to the &#96;scr&#96; update</span>
                      <span class="token comment">## the render_text() function will be discussed later</span>
                      scrolly_section<span class="token punctuation">(</span>id <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> render_text<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                      scrolly_section<span class="token punctuation">(</span>id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> render_text<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                      scrolly_section<span class="token punctuation">(</span>id <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> render_text<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                      scrolly_section<span class="token punctuation">(</span>id <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span> render_text<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                      scrolly_section<span class="token punctuation">(</span>id <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">,</span> render_text<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                      scrolly_section<span class="token punctuation">(</span>id <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">,</span> render_text<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                      scrolly_section<span class="token punctuation">(</span>id <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">,</span> render_text<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                      scrolly_section<span class="token punctuation">(</span>id <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">,</span> render_text<span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                      scrolly_section<span class="token punctuation">(</span>id <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">,</span> render_text<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                      <span class="token comment"># add a scrolly_section with nothing in it;</span>
                      <span class="token comment"># this buffer prevents the plot from disappearing while reading last section</span>
                      scrolly_section<span class="token punctuation">(</span>id <span class="token operator">=</span> <span class="token string">"buffer"</span><span class="token punctuation">,</span> br<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                    <span class="token punctuation">)</span>

  <span class="token punctuation">)</span><span class="token punctuation">,</span>

  <span class="token comment"># a bunch of concluding stuff, other html</span>

<span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>
<p>So, the simplest way to think about this so far is:</p>
<p>Construct a plot object with some updating variable (in my case, <code>reveal</code>).</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">filter<span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span>add <span class="token operator">!=</span> <span class="token number">8</span><span class="token punctuation">)</span> add <span class="token operator">>=</span> reveal <span class="token keyword">else</span> reveal <span class="token percent-operator operator">%in%</span> c<span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>
<p>Make that variable correspond with some input variable (in my case <code>add</code>, which is created from the <code>input$scr</code>).</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">server <span class="token operator">&lt;-</span> <span class="token keyword">function</span><span class="token punctuation">(</span>input<span class="token punctuation">,</span> output<span class="token punctuation">,</span> session<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

  output<span class="token operator">$</span>plot <span class="token operator">&lt;-</span> renderPlotly<span class="token punctuation">(</span><span class="token punctuation">&#123;</span>

    add <span class="token operator">&lt;-</span> input<span class="token operator">$</span>scr
    <span class="token comment">#...</span></code>`}<!-- HTML_TAG_END --></pre>
<p>Render your plot object in <code>scrolly_graph</code>, and provide input updates
via each <code>scrolly_section</code>.</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">ui <span class="token operator">&lt;-</span> fluidPage<span class="token punctuation">(</span>

  <span class="token comment"># a bunch of introductory stuff, css stuff</span>

  <span class="token comment"># scrollytelling plot</span>
  scrolly_container<span class="token punctuation">(</span>outputId <span class="token operator">=</span> <span class="token string">"scr"</span><span class="token punctuation">,</span>
                       scrolly_graph<span class="token punctuation">(</span>plotlyOutput<span class="token punctuation">(</span><span class="token string">"plot"</span><span class="token punctuation">,</span> height <span class="token operator">=</span> <span class="token string">'600px'</span><span class="token punctuation">)</span>

                    <span class="token punctuation">)</span><span class="token punctuation">,</span>
                    scrolly_sections<span class="token punctuation">(</span>
                      scrolly_section<span class="token punctuation">(</span>id <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> render_text<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                      scrolly_section<span class="token punctuation">(</span>id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> render_text<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>

                      <span class="token comment"># ...</span></code>`}<!-- HTML_TAG_END --></pre>
<p>Render your plots in your server function.</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">server <span class="token operator">&lt;-</span> <span class="token keyword">function</span><span class="token punctuation">(</span>input<span class="token punctuation">,</span> output<span class="token punctuation">,</span> session<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

  output<span class="token operator">$</span>plot <span class="token operator">&lt;-</span>
    <span class="token comment">#...</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>

  output<span class="token operator">$</span>scr <span class="token operator">&lt;-</span> renderScrollytell<span class="token punctuation">(</span><span class="token punctuation">&#123;</span>scrollytell<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
  renderText<span class="token punctuation">(</span>paste0<span class="token punctuation">(</span><span class="token string">"Section: "</span><span class="token punctuation">,</span> input<span class="token operator">$</span>scr<span class="token punctuation">)</span><span class="token punctuation">)</span>
  observe<span class="token punctuation">(</span><span class="token punctuation">&#123;</span>cat<span class="token punctuation">(</span><span class="token string">"section:"</span><span class="token punctuation">,</span> input<span class="token operator">$</span>scr<span class="token punctuation">,</span> <span class="token string">"&#92;n"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>

<span class="token punctuation">&#125;</span></code>`}<!-- HTML_TAG_END --></pre>
<p>That\u2019s (most of) it for the plot section. You can play around with other
customizations too (for example, the alphas for my circles correspond to
an <code>ifelse</code> around <code>reveal</code>, so old circles are faded out compared to
new ones).</p>
<h3 id="${"create-a-series-of-text-reveals"}"><a href="${"#create-a-series-of-text-reveals"}">Create a series of text reveals</a></h3>
<p>Next, we create text sections using <code>HTML</code> and some helper functions
which beautify them.</p>
<p>First, we create the text boxes for each section following a similar
naming convention:</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">text1 <span class="token operator">&lt;-</span> HTML<span class="token punctuation">(</span>"<span class="token operator">&lt;</span>H2<span class="token operator">></span> No education credentials <span class="token operator">&lt;</span><span class="token operator">/</span>H2<span class="token operator">></span>
              <span class="token operator">&lt;</span>br<span class="token operator">></span> <span class="token operator">&lt;</span>p<span class="token operator">></span> Workers with <span class="token operator">&lt;</span>font color<span class="token operator">=</span><span class="token string">'#A00042'</span><span class="token operator">></span>no formal education credential<span class="token operator">&lt;</span><span class="token operator">/</span>font<span class="token operator">></span> have a median income of <span class="token operator">$</span><span class="token number">25</span><span class="token punctuation">,</span><span class="token number">636.</span>
              <span class="token operator">&lt;</span>br<span class="token operator">></span> On average<span class="token punctuation">,</span> those occupations have a <span class="token operator">&lt;</span>b<span class="token operator">></span><span class="token number">90</span>% chance<span class="token operator">&lt;</span><span class="token operator">/</span>b<span class="token operator">></span> of job automation.
              <span class="token operator">&lt;</span>br<span class="token operator">></span><span class="token operator">&lt;</span>br<span class="token operator">></span> There are <span class="token number">23</span><span class="token punctuation">,</span><span class="token number">765</span><span class="token punctuation">,</span><span class="token number">700</span> workers with <span class="token operator">&lt;</span>font color<span class="token operator">=</span><span class="token string">'#A00042'</span><span class="token operator">></span>no formal education credential<span class="token operator">&lt;</span><span class="token operator">/</span>font<span class="token operator">></span>.<span class="token operator">&lt;</span>p<span class="token operator">></span>"<span class="token punctuation">)</span>

text2 <span class="token operator">&lt;-</span> HTML<span class="token punctuation">(</span>"<span class="token operator">&lt;</span>H2<span class="token operator">></span> High school diplomas <span class="token operator">&lt;</span><span class="token operator">/</span>H2<span class="token operator">></span>
              <span class="token operator">&lt;</span>br<span class="token operator">></span> <span class="token operator">&lt;</span>p<span class="token operator">></span>Workers with <span class="token operator">&lt;</span>font color<span class="token operator">=</span><span class="token string">'#F56C42'</span><span class="token operator">></span>high school diplomas<span class="token operator">&lt;</span><span class="token operator">/</span>font<span class="token operator">></span> have a median income of <span class="token operator">$</span><span class="token number">25</span><span class="token punctuation">,</span><span class="token number">636.</span>
              <span class="token operator">&lt;</span>br<span class="token operator">></span> On average<span class="token punctuation">,</span> those occupations have a <span class="token operator">&lt;</span>b<span class="token operator">></span><span class="token number">60</span>% chance<span class="token operator">&lt;</span><span class="token operator">/</span>b<span class="token operator">></span> of job automation.
              <span class="token operator">&lt;</span>br<span class="token operator">></span><span class="token operator">&lt;</span>br<span class="token operator">></span> There are <span class="token number">33</span><span class="token punctuation">,</span><span class="token number">129</span><span class="token punctuation">,</span><span class="token number">910</span> workers with a <span class="token operator">&lt;</span>font color<span class="token operator">=</span><span class="token string">'#F56C42'</span><span class="token operator">></span>high school diploma<span class="token operator">&lt;</span><span class="token operator">/</span>font<span class="token operator">></span>.<span class="token operator">&lt;</span>p<span class="token operator">></span>"<span class="token punctuation">)</span>

<span class="token comment"># ...</span></code>`}<!-- HTML_TAG_END --></pre>
<p>Then, we create a function <code>render_text</code> which beautifies that HTML with
CSS:</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">text <span class="token operator">&lt;-</span> <span class="token keyword">function</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
  p<span class="token punctuation">(</span>
    switch<span class="token punctuation">(</span>num<span class="token punctuation">,</span>
           text1<span class="token punctuation">,</span>
           text2<span class="token punctuation">,</span>
           text3<span class="token punctuation">,</span>
           text4<span class="token punctuation">,</span>
           text5<span class="token punctuation">,</span>
           text6<span class="token punctuation">,</span>
           text7<span class="token punctuation">,</span>
           text8
    <span class="token punctuation">)</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

render_text <span class="token operator">&lt;-</span> <span class="token keyword">function</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
  div<span class="token punctuation">(</span>
    text<span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">,</span> class <span class="token operator">=</span> <span class="token string">"text"</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code>`}<!-- HTML_TAG_END --></pre>
<p>For all 8 of the above <code>text</code>s, we\u2019ve created a switch function which
calls them depending on the number passed to <code>render_text</code>. Then, we
apply paragraph format, put them in their own div, and apply the <em>text</em>
class in our CSS sheet.</p>
<p>How does this work?</p>
<p>Recall that above, in our ui section, we had the following:</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">scrolly_sections<span class="token punctuation">(</span>
  HTML<span class="token punctuation">(</span><span class="token string">'&lt;center>'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  scrolly_section<span class="token punctuation">(</span>id <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> render_text<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  scrolly_section<span class="token punctuation">(</span>id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> render_text<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token comment"># ... continued</span>
<span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>
<p>Here, our <code>scrolly_section</code>s take two inputs: our ID and our
corresponding text. Rather than write out lengthy text boxes in each
<code>scrolly_section</code>, we can construct them in a single file and then knit
them all into the same format using <code>render_text</code>. This makes life a lot
easier.</p>
<p>So, on each scroll (or observation), the app will update 1) the plot
object, by adding <code>add</code> and updating according to <code>reveal</code>, and 2) the
text, by running <code>render_text</code> which calls <code>text</code> which beautifies our
HTML text.</p>
<h3 id="${"final-touches"}"><a href="${"#final-touches"}">Final touches</a></h3>
<p>The rest of the app is built via
<code>fluidPage</code>, and organizing via rows and columns in your shiny app. Your
app should have a CSS style sheet (in the <a href="${"https://shiny.rstudio.com/articles/css.html"}" rel="${"nofollow"}">www
folder</a>). You may also
include other plots (for my post, I have an introductory plot with a bit
more context), which you will have to separately create and render in
your server function.</p>
<p>All in all, my UI code looks like this:</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">ui <span class="token operator">&lt;-</span> fluidPage<span class="token punctuation">(</span>

  <span class="token comment"># suppress warning messages while data is loading on-screen</span>
  tags<span class="token operator">$</span>style<span class="token punctuation">(</span>type<span class="token operator">=</span><span class="token string">"text/css"</span><span class="token punctuation">,</span>
             <span class="token string">".shiny-output-error &#123; visibility: hidden; &#125;"</span><span class="token punctuation">,</span>
             <span class="token string">".shiny-output-error:before &#123; visibility: hidden; &#125;"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  tags<span class="token operator">$</span>head<span class="token punctuation">(</span>
    includeCSS<span class="token punctuation">(</span><span class="token string">"www/style.css"</span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span><span class="token punctuation">,</span>

  <span class="token comment"># article title &amp; name</span>
  fluidRow<span class="token punctuation">(</span>HTML<span class="token punctuation">(</span>"<span class="token operator">&lt;</span>center<span class="token operator">></span>
                <span class="token operator">&lt;</span>h1<span class="token operator">></span>Automation and Its Impact on Jobs<span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">></span>
                <span class="token operator">&lt;</span>p style<span class="token operator">=</span><span class="token string">'font-size:26px'</span><span class="token operator">></span> by <span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">'https://connorrothschild.github.io/'</span> target<span class="token operator">=</span><span class="token string">'_blank'</span><span class="token operator">></span>Connor Rothschild<span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span>
                <span class="token operator">&lt;</span><span class="token operator">/</span>center<span class="token operator">></span>"<span class="token punctuation">)</span>
  <span class="token punctuation">)</span><span class="token punctuation">,</span>

  br<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>

  fluidRow<span class="token punctuation">(</span>
    column<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>

    column<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span>
           <span class="token comment"># intro text</span>
           fluidRow<span class="token punctuation">(</span>id<span class="token operator">=</span><span class="token string">'text'</span><span class="token punctuation">,</span>
                    column<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                    column<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span>
                           br<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                           text0<span class="token punctuation">,</span>
                           hr<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                           h1<span class="token punctuation">(</span>
                             class <span class="token operator">=</span> <span class="token string">"instructions"</span><span class="token punctuation">,</span>
                             <span class="token string">"How to read this chart:"</span><span class="token punctuation">,</span>
                             br<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                             br<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                             <span class="token string">"The size of each"</span><span class="token punctuation">,</span> icon<span class="token punctuation">(</span><span class="token string">"circle"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"corresponds to the number of workers in that job."</span><span class="token punctuation">,</span>
                             br<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                             <span class="token string">"Hover over each"</span><span class="token punctuation">,</span> icon<span class="token punctuation">(</span><span class="token string">"circle"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"to see details on the occupation's income and probability of automation."</span><span class="token punctuation">,</span>
                             br<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                             <span class="token string">"Double click on a"</span><span class="token punctuation">,</span> icon<span class="token punctuation">(</span><span class="token string">"circle"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"in the legend to focus on a specific level of education."</span>
                           <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                    column<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
           <span class="token comment"># plot object for intro</span>
           plotlyOutput<span class="token punctuation">(</span><span class="token string">"introPlot"</span><span class="token punctuation">,</span> height <span class="token operator">=</span> <span class="token string">'400px'</span><span class="token punctuation">)</span>
           <span class="token punctuation">)</span><span class="token punctuation">,</span>

    column<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>

           <span class="token punctuation">)</span><span class="token punctuation">,</span>

  <span class="token comment"># scrollytelling plot</span>
  scrolly_container<span class="token punctuation">(</span><span class="token string">"scr"</span>
                    <span class="token punctuation">,</span> scrolly_graph<span class="token punctuation">(</span> br<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                                     br<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                                     textOutput<span class="token punctuation">(</span><span class="token string">"section"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                                     br<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                                     HTML<span class="token punctuation">(</span><span class="token string">'&lt;center>'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                                     plotlyOutput<span class="token punctuation">(</span><span class="token string">"plot"</span><span class="token punctuation">,</span> height <span class="token operator">=</span> <span class="token string">'600px'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                                     HTML<span class="token punctuation">(</span><span class="token string">'&lt;/center>'</span><span class="token punctuation">)</span>

                    <span class="token punctuation">)</span>
                    <span class="token punctuation">,</span> scrolly_sections<span class="token punctuation">(</span>
                      HTML<span class="token punctuation">(</span><span class="token string">'&lt;center>'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                      scrolly_section<span class="token punctuation">(</span>id <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> render_text<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                      scrolly_section<span class="token punctuation">(</span>id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> render_text<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                      scrolly_section<span class="token punctuation">(</span>id <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> render_text<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                      scrolly_section<span class="token punctuation">(</span>id <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span> render_text<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                      scrolly_section<span class="token punctuation">(</span>id <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">,</span> render_text<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                      scrolly_section<span class="token punctuation">(</span>id <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">,</span> render_text<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                      scrolly_section<span class="token punctuation">(</span>id <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">,</span> render_text<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                      scrolly_section<span class="token punctuation">(</span>id <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">,</span> render_text<span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                      scrolly_section<span class="token punctuation">(</span>id <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">,</span> render_text<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                      <span class="token comment"># add a scrolly_section with nothing in it;</span>
                      <span class="token comment"># this buffer prevents the plot from disappearing while reading last section</span>
                      scrolly_section<span class="token punctuation">(</span>id <span class="token operator">=</span> <span class="token string">"buffer"</span><span class="token punctuation">,</span> br<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                      HTML<span class="token punctuation">(</span><span class="token string">'&lt;/center>'</span><span class="token punctuation">)</span>
                    <span class="token punctuation">)</span>

  <span class="token punctuation">)</span><span class="token punctuation">,</span>

  <span class="token comment"># concluding text</span>
  div<span class="token punctuation">(</span>fluidRow<span class="token punctuation">(</span>id <span class="token operator">=</span> <span class="token string">'text'</span><span class="token punctuation">,</span>
               column<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
               column<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span>
                      concludingtext<span class="token punctuation">,</span>
                      br<span class="token punctuation">(</span><span class="token punctuation">)</span>
               <span class="token punctuation">)</span><span class="token punctuation">,</span>
               column<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span><span class="token punctuation">,</span> style <span class="token operator">=</span> <span class="token string">'margin-top: -300px;'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>

  br<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  br<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  br<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  hr<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>

  fluidRow<span class="token punctuation">(</span>
    column<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    column<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span>
           technicalnotes
    <span class="token punctuation">)</span><span class="token punctuation">,</span>
    column<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span><span class="token punctuation">,</span>
  br<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  br<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
column<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>

<span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>
<p>And the server looks like this:</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">server <span class="token operator">&lt;-</span> <span class="token keyword">function</span><span class="token punctuation">(</span>input<span class="token punctuation">,</span> output<span class="token punctuation">,</span> session<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

  output<span class="token operator">$</span>plot <span class="token operator">&lt;-</span> renderPlotly<span class="token punctuation">(</span><span class="token punctuation">&#123;</span>

    add <span class="token operator">&lt;-</span> input<span class="token operator">$</span>scr

    plot <span class="token operator">&lt;-</span> data <span class="token percent-operator operator">%>%</span>
      filter<span class="token punctuation">(</span>typicaled <span class="token operator">!=</span> <span class="token string">"Some college, no degree"</span><span class="token punctuation">)</span> <span class="token percent-operator operator">%>%</span>
      filter<span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span>add <span class="token operator">!=</span> <span class="token number">8</span><span class="token punctuation">)</span> add <span class="token operator">>=</span> reveal <span class="token keyword">else</span> reveal <span class="token percent-operator operator">%in%</span> c<span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token percent-operator operator">%>%</span>
      ggplot<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>
      geom_point<span class="token punctuation">(</span>mapping<span class="token operator">=</span>aes<span class="token punctuation">(</span>x<span class="token operator">=</span>A_MEDIAN<span class="token punctuation">,</span> y<span class="token operator">=</span>probability<span class="token punctuation">,</span> size<span class="token operator">=</span>TOT_EMP<span class="token punctuation">,</span>
                             alpha<span class="token operator">=</span>ifelse<span class="token punctuation">(</span>add <span class="token operator">==</span> reveal<span class="token punctuation">,</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> col<span class="token operator">=</span>typicaled<span class="token punctuation">,</span>
                             text <span class="token operator">=</span> glue<span class="token operator">::</span>glue<span class="token punctuation">(</span>'<span class="token operator">&lt;</span>b<span class="token operator">></span>Occupation<span class="token operator">&lt;</span><span class="token operator">/</span>b<span class="token operator">></span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>occupation<span class="token punctuation">&#125;</span>
                                                <span class="token operator">&lt;</span>b<span class="token operator">></span>Probability of Automation<span class="token operator">&lt;</span><span class="token operator">/</span>b<span class="token operator">></span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>probability<span class="token punctuation">&#125;</span>%
                                                <span class="token operator">&lt;</span>b<span class="token operator">></span>Median Income<span class="token operator">&lt;</span><span class="token operator">/</span>b<span class="token operator">></span><span class="token operator">:</span> <span class="token operator">$</span><span class="token punctuation">&#123;</span>A_MEDIAN<span class="token punctuation">&#125;</span>
                                                <span class="token operator">&lt;</span>b<span class="token operator">></span>Number of Workers<span class="token operator">&lt;</span><span class="token operator">/</span>b<span class="token operator">></span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>TOT_EMP<span class="token punctuation">&#125;</span>'<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span>
      scale_size<span class="token punctuation">(</span>range <span class="token operator">=</span> c<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span>
      xlab<span class="token punctuation">(</span><span class="token string">"&#92;nMedian Income"</span><span class="token punctuation">)</span> <span class="token operator">+</span>
      ylab<span class="token punctuation">(</span><span class="token string">"Probability of Automation"</span><span class="token punctuation">)</span> <span class="token operator">+</span>
      labs<span class="token punctuation">(</span>size<span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">,</span> col<span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">,</span> alpha <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">)</span> <span class="token operator">+</span>
      scale_color_manual<span class="token punctuation">(</span>values <span class="token operator">=</span> cols<span class="token punctuation">,</span> breaks <span class="token operator">=</span> legend_ord<span class="token punctuation">)</span> <span class="token operator">+</span>
      scale_x_continuous<span class="token punctuation">(</span>labels<span class="token operator">=</span>scales<span class="token operator">::</span>dollar_format<span class="token punctuation">(</span>prefix<span class="token operator">=</span><span class="token string">"$"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> limits <span class="token operator">=</span> c<span class="token punctuation">(</span><span class="token number">25000</span><span class="token punctuation">,</span><span class="token number">200000</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span>
      scale_y_continuous<span class="token punctuation">(</span>labels<span class="token operator">=</span>scales<span class="token operator">::</span>number_format<span class="token punctuation">(</span>suffix<span class="token operator">=</span><span class="token string">"%"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> limits <span class="token operator">=</span> c<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span>
      <span class="token comment"># cr::drop_axis(axis = "y") +</span>
      theme<span class="token punctuation">(</span>axis.line.x <span class="token operator">=</span> ggplot2<span class="token operator">::</span>element_line<span class="token punctuation">(</span>colour <span class="token operator">=</span> <span class="token keyword">NULL</span><span class="token punctuation">,</span>
                                                size <span class="token operator">=</span> <span class="token keyword">NULL</span><span class="token punctuation">,</span> linetype <span class="token operator">=</span> <span class="token keyword">NULL</span><span class="token punctuation">,</span> lineend <span class="token operator">=</span> <span class="token keyword">NULL</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            axis.line.y <span class="token operator">=</span> ggplot2<span class="token operator">::</span>element_blank<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            panel.grid.major.x <span class="token operator">=</span> element_blank<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

    ggplotly<span class="token punctuation">(</span>plot<span class="token punctuation">,</span> tooltip <span class="token operator">=</span> <span class="token string">'text'</span><span class="token punctuation">)</span> <span class="token percent-operator operator">%>%</span>
    layout<span class="token punctuation">(</span>
      title <span class="token operator">=</span> list<span class="token punctuation">(</span>element_blank<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      legend <span class="token operator">=</span> list<span class="token punctuation">(</span>x <span class="token operator">=</span> <span class="token number">0.65</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">0.925</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      font <span class="token operator">=</span> list<span class="token punctuation">(</span>family <span class="token operator">=</span> <span class="token string">'Lato'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      margin<span class="token operator">=</span>list<span class="token punctuation">(</span>t<span class="token operator">=</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      hoverlabel <span class="token operator">=</span> list<span class="token punctuation">(</span>bgcolor <span class="token operator">=</span> <span class="token string">'whitesmoke'</span><span class="token punctuation">,</span> color <span class="token operator">=</span> <span class="token string">'DarkGray'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token percent-operator operator">%>%</span>
    config<span class="token punctuation">(</span>displaylogo <span class="token operator">=</span> F<span class="token punctuation">,</span> showSendToCloud <span class="token operator">=</span> F<span class="token punctuation">,</span> displayModeBar <span class="token operator">=</span> F<span class="token punctuation">)</span>

  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>

  output<span class="token operator">$</span>introPlot <span class="token operator">&lt;-</span> renderPlotly<span class="token punctuation">(</span><span class="token punctuation">&#123;</span>introPlot<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
  output<span class="token operator">$</span>scr <span class="token operator">&lt;-</span> renderScrollytell<span class="token punctuation">(</span><span class="token punctuation">&#123;</span>scrollytell<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
  renderText<span class="token punctuation">(</span>paste0<span class="token punctuation">(</span><span class="token string">"Section: "</span><span class="token punctuation">,</span> input<span class="token operator">$</span>scr<span class="token punctuation">)</span><span class="token punctuation">)</span>
  observe<span class="token punctuation">(</span><span class="token punctuation">&#123;</span>cat<span class="token punctuation">(</span><span class="token string">"section:"</span><span class="token punctuation">,</span> input<span class="token operator">$</span>scr<span class="token punctuation">,</span> <span class="token string">"&#92;n"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>

<span class="token punctuation">&#125;</span></code>`}<!-- HTML_TAG_END --></pre>
<h2 id="${"the-output"}"><a href="${"#the-output"}">The output</a></h2>
<p>You can look at the code and all of its context on GitHub
<a href="${"https://github.com/connorrothschild/shiny-scrollytell"}" rel="${"nofollow"}">here</a>. Want to visit the live page? You can access it <a href="${"https://connorrothschild.shinyapps.io/automation/"}" rel="${"nofollow"}">here</a>, or embedded below!</p>
<iframe title="${"Automation and Its Impact on Jobs"}" src="${"https://connorrothschild.shinyapps.io/automation/"}" width="${"100%"}" height="${"800px"}"></iframe>`
  })}`;
});
var automationScrollytell = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Automation_scrollytell,
  metadata: metadata$e
});
var metadata$d = {
  "layout": "blog",
  "title": "Animating Your Hugo Academic Site",
  "description": "Make your Hugo Academic homepage more engaging with a few lines of code",
  "date": "2020-07-02",
  "image": "animate-hugo-academic/header.png",
  "tags": ["html", "r", "tutorial"]
};
var Animate_hugo_academic = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${validate_component(Layout, "Layout_MDSVEX_DEFAULT").$$render($$result, Object.assign($$props, metadata$d), {}, {
    default: () => `${validate_component(Image, "Image").$$render($$result, {
      src: "../images/post/animate-hugo-academic/final.gif",
      alt: "A GIF showcasing the final version of my animated homepage."
    }, {}, {})}
<p>The R package <code>blogdown</code> is an incredibly powerful tool\u2014it allows R users with little to no familiarity in web development to build a fully functional, content-oriented, beautiful website using a language they\u2019re already familiar with. It\u2019s built on top of <a href="${"https://gohugo.io/"}" rel="${"nofollow"}">Hugo</a>, the world\u2019s (self-proclaimed) \u2018fastest framework for building websites,\u2019 which comes with a <a href="${"https://themes.gohugo.io/"}" rel="${"nofollow"}">variety of themes</a> suitable for a variety of different uses.</p>
<p>Within the R community, perhaps one of the most popular themes is <a href="${"https://themes.gohugo.io/academic/"}" rel="${"nofollow"}">Hugo Academic</a>. As the name implies, the theme is geared toward those working academia\u2014more generally, it provides a great starter kit for those interested in showcasing blog posts, projects, and other media on a minimalist site.</p>
<p>Given its popularity, the Hugo Academic landing page is far-too-familiar. Although not unattractive, no one is particularly surprised or engaged by the standard Academic homepage.</p>
<p>One way to spice up Hugo Academic is to use animations on our home pages. In this post, I outline three simple steps and a few lines of code to create a fully functional, beautifully-animated landing page. By leveraging the flexibility of Hugo\u2019s framework, and introducing a little bit of HTML and CSS, we can take our Hugo Academic home pages from zero to hero (at least, in terms of animation!).</p>
${validate_component(Info, "Info").$$render($$result, {}, {}, {
      default: () => `<p>This tutorial assumes you are starting a Hugo Academic site from scratch. If you already have a Hugo Academic website up and running, you should be able to <a href="${"#step-1-create-abouthtml"}">skip step 0</a> and modify the remaining steps slightly.</p>
<p>It also assumes that you have little to no knowledge about HTML and CSS (which is fine!). If that\u2019s <em>not</em> the case, you can likely go ahead and skip to <a href="${"#step-3-add-css"}">step 3</a>.</p>
<p>If you\u2019d like to skip this tutorial and just start a Hugo Academic site that\u2019s animated, feel free to <a href="${"https://github.com/connorrothschild/animate-hugo-academic"}" rel="${"nofollow"}">fork my repository</a> which includes all the code you need for an animated homepage. The repo includes my <a href="${"https://github.com/connorrothschild/animate-hugo-academic/blob/master/layouts/partials/widgets/about.html"}" rel="${"nofollow"}"><code>about.html</code> page</a> and a <a href="${"https://github.com/connorrothschild/animate-hugo-academic/blob/master/assets/scss/custom.scss"}" rel="${"nofollow"}">custom SCSS file</a>!</p>`
    })}
<h2 id="${"step-0-make-your-about-page-your-actual-homepage"}"><a href="${"#step-0-make-your-about-page-your-actual-homepage"}">Step 0) Make your \u2018about\u2019 page your actual homepage</a></h2>
<p>By default, the Hugo Academic theme\u2019s first section is a grandiose self-introduction (I guess the creators of the theme do deserve such credit). Before we incorporate any of our animations, lets go ahead and make our \u2018about\u2019 page the landing page users first see when they visit our site. This requires us to find the files <code>hero.md</code> and <code>demo.md</code>, and in each of those files, set <code>active</code> equal to <code>false</code>. That takes our home page from this:</p>
${validate_component(Image, "Image").$$render($$result, {
      src: "../images/post/animate-hugo-academic/before-demo-hero-remove.png",
      alt: "A GIF showcasing the initial version of my homepage, before any edits."
    }, {}, {})}
<p>to this:</p>
${validate_component(Image, "Image").$$render($$result, {
      src: "../images/post/animate-hugo-academic/after-demo-hero-remove.png",
      alt: "A GIF showcasing a version of my homepage where I replace \u2018hero' with \u2018about\u2019."
    }, {}, {})}
<p>(As you progress, you might have to make additional small changes, such as removing \u2018Demo\u2019 from the navbar menu.)</p>
<h2 id="${"step-1-create-abouthtml"}"><a href="${"#step-1-create-abouthtml"}">Step 1) Create <code>about.html</code></a></h2>
<p>The first <em>real</em> step in our process is modifying the default layout of our about page. More specifically, our animations will rely on CSS selectors which our about page currently doesn\u2019t have. In order to animate certain elements, we will need unique identifiers, such as CSS classes and IDs, to target.</p>
<p>To play around with our about page, we take advantage of Hugo\u2019s flexibility toward structural changes. As they <a href="${"https://bwaycer.github.io/hugo_tutorial.hugo/themes/customizing/"}" rel="${"nofollow"}">say</a> on their website:</p>
<blockquote><p>Hugo permits you to <strong>supplement or override</strong> any theme template or static file, with files in your working directory.</p></blockquote>
<p>In order to override Hugo Academic\u2019s about page, we need to copy their existing structure into our own folder and modify it there. To do so, navigate to <code>themes/hugo-academic/layouts/partials/widgets/</code> and copy the file titled <code>about.html</code>.</p>
<p>Now, create <em>a new file path</em> in your root directory titled <code>layouts/partials/widgets/</code>. Copy your <code>about.html</code> file here. (Look familiar? All we\u2019re doing is recreating <code>about.html</code> in a <em>personal</em> version of our project, thus overriding the <code>about.html</code> that Hugo Academic provides.)</p>
${validate_component(Info, "Info").$$render($$result, {}, {}, {
      default: () => `Alternatively, you can copy the about.html file that I used for this project and paste it into <code>layouts/partials/widgets/</code>. <a href="${"https://github.com/connorrothschild/animate-hugo-academic/blob/master/layouts/partials/widgets/about.html"}" target="${"_blank"}">You can find my file here</a>. This will also allow you to skip step 2 and move on to <a href="${"#step-3-add-css"}">step 3</a>!
`
    })}
<h2 id="${"step-2-customize-your-file"}"><a href="${"#step-2-customize-your-file"}">Step 2) Customize your file</a></h2>
<p>With that newly created <code>about.html</code> living in <code>layouts/partials/widgets/</code>, you may notice that your homepage looks the exact same. This is correct! In this step, we\u2019ll customize that html file so that it can be animated.</p>
<p>Within <code>about.html</code>, you\u2019ll notice all of your page\u2019s elements in order of appearance, despite a lot of extra characters that don\u2019t make much sense. It should look like this (don\u2019t read into this code, just verify it looks the same):</p>
${validate_component(Image, "Image").$$render($$result, {
      src: "../images/post/animate-hugo-academic/about.png",
      alt: "A screenshot of complicated code that is initially used to render the homepage."
    }, {}, {})}
<p>Throughout step 3, we\u2019ll use each element\u2019s class to target it for animations. In the above screenshot (and in your <code>about.html</code> page), you\u2019ll see classes scattered throughout. Although learning everything about CSS and CSS selectors is beyond the scope of this tutorial, I would recommend reading a brief primer on classes and selectors in CSS, which can be found <a href="${"https://www.w3schools.com/cssref/sel_class.asp"}" rel="${"nofollow"}">here</a>.</p>
<p>In this step, we\u2019ll add classes to the elements we want to animate. (Again, if this seems to be overwhelming, feel free to copy <a href="${"https://github.com/connorrothschild/animate-hugo-academic/blob/master/layouts/partials/widgets/about.html"}" rel="${"nofollow"}">my HTML file.</a>) Specifically, we\u2019ll make three changes. (For each, feel free to just control-F the content and add the class right before.)</p>
<p>First, we\u2019ll add a class of <code>biography-title</code> to our h1 (header 1) element. Here, we will change</p>
${validate_component(Code, "Code").$$render($$result, { language: "html", filename: "about.html" }, {}, {
      default: () => `<pre class="${"language-undefined"}"><!-- HTML_TAG_START -->${`<code class="language-undefined">&lt;h1&gt;&#123;&#123; $page.Title | markdownify | emojify &#125;&#125;&lt;/h1&gt;
&#123;&#123; end &#125;&#125;</code>`}<!-- HTML_TAG_END --></pre>`
    })}
<p>to</p>
${validate_component(Code, "Code").$$render($$result, { language: "html", filename: "about.html" }, {}, {
      default: () => `<pre class="${"language-undefined"}"><!-- HTML_TAG_START -->${`<code class="language-undefined">&lt;h1 class=&quot;biography-title&quot;&gt;&#123;&#123; $page.Title | markdownify | emojify &#125;&#125;&lt;/h1&gt;
&#123;&#123; end &#125;&#125;</code>`}<!-- HTML_TAG_END --></pre>`
    })}
<p>Next, we need to wrap the main content, aka the big text blocks in the middle of the page, in their own class too. Here, we take</p>
${validate_component(Code, "Code").$$render($$result, { language: "html", filename: "about.html" }, {}, {
      default: () => `<pre class="${"language-undefined"}"><!-- HTML_TAG_START -->${`<code class="language-undefined">&#123;&#123; $person_page.Content &#125;&#125;</code>`}<!-- HTML_TAG_END --></pre>`
    })}
<p>and wrap it in a <code>div</code>, so it looks like this:</p>
${validate_component(Code, "Code").$$render($$result, { language: "html", filename: "about.html" }, {}, {
      default: () => `<pre class="${"language-undefined"}"><!-- HTML_TAG_START -->${`<code class="language-undefined">&lt;div class=&quot;main-content&quot;&gt;&#123;&#123; $person_page.Content &#125;&#125;&lt;/div&gt;</code>`}<!-- HTML_TAG_END --></pre>`
    })}
<p>Finally, we\u2019ll add a class to our interests and and education blocks. We can take this row:</p>
${validate_component(Code, "Code").$$render($$result, { language: "html", filename: "about.html" }, {}, {
      default: () => `<pre class="${"language-undefined"}"><!-- HTML_TAG_START -->${`<code class="language-undefined">&lt;div class=&quot;row&quot;&gt;
  &#123;&#123; with $person.interests &#125;&#125;
  &lt;div class=&quot;col-md-5&quot;&gt;
    &lt;h3&gt;&#123;&#123; i18n &quot;interests&quot; | markdownify &#125;&#125;&lt;/h3&gt;
    &lt;ul class=&quot;ul-interests&quot;&gt;
      &#123;&#123; range . &#125;&#125;
      &lt;li&gt;&#123;&#123; . | markdownify | emojify &#125;&#125;&lt;/li&gt;
      &#123;&#123; end &#125;&#125;
    &lt;/ul&gt;
  &lt;/div&gt;
  &#123;&#123; end &#125;&#125; &#123;&#123; with $person.education &#125;&#125;
  &lt;div class=&quot;col-md-7&quot;&gt;
    &lt;h3&gt;&#123;&#123; i18n &quot;education&quot; | markdownify &#125;&#125;&lt;/h3&gt;
    &lt;ul class=&quot;ul-edu fa-ul&quot;&gt;
      &#123;&#123; range .courses &#125;&#125;
      &lt;li&gt;
        &lt;i class=&quot;fa-li fas fa-graduation-cap&quot;&gt;&lt;/i&gt;
        &lt;div class=&quot;description&quot;&gt;
          &lt;p class=&quot;course&quot;&gt;&#123;&#123; .course &#125;&#125;&#123;&#123; with .year &#125;&#125;, &#123;&#123; . &#125;&#125;&#123;&#123; end &#125;&#125;&lt;/p&gt;
          &lt;p class=&quot;institution&quot;&gt;&#123;&#123; .institution &#125;&#125;&lt;/p&gt;
        &lt;/div&gt;
      &lt;/li&gt;
      &#123;&#123; end &#125;&#125;
    &lt;/ul&gt;
  &lt;/div&gt;
  &#123;&#123; end &#125;&#125;
&lt;/div&gt;</code>`}<!-- HTML_TAG_END --></pre>`
    })}
<p>and replace it with this:</p>
${validate_component(Code, "Code").$$render($$result, { language: "html", filename: "about.html" }, {}, {
      default: () => `<pre class="${"language-undefined"}"><!-- HTML_TAG_START -->${`<code class="language-undefined">&lt;div class=&quot;row&quot;&gt;
  &#123;&#123; with $person.interests &#125;&#125;
  &lt;div class=&quot;interests-div col-md-5&quot;&gt;
    &lt;h3&gt;&#123;&#123; i18n &quot;interests&quot; | markdownify &#125;&#125;&lt;/h3&gt;
    &lt;ul class=&quot;ul-interests&quot;&gt;
      &#123;&#123; range . &#125;&#125;
      &lt;li&gt;&#123;&#123; . | markdownify | emojify &#125;&#125;&lt;/li&gt;
      &#123;&#123; end &#125;&#125;
    &lt;/ul&gt;
  &lt;/div&gt;
  &#123;&#123; end &#125;&#125; &#123;&#123; with $person.education &#125;&#125;
  &lt;div class=&quot;education-div col-md-7&quot;&gt;
    &lt;h3&gt;&#123;&#123; i18n &quot;education&quot; | markdownify &#125;&#125;&lt;/h3&gt;
    &lt;ul class=&quot;ul-edu fa-ul&quot;&gt;
      &#123;&#123; range .courses &#125;&#125;
      &lt;li&gt;
        &lt;i class=&quot;fa-li fas fa-graduation-cap&quot;&gt;&lt;/i&gt;
        &lt;div class=&quot;description&quot;&gt;
          &lt;p class=&quot;course&quot;&gt;&#123;&#123; .course &#125;&#125;&#123;&#123; with .year &#125;&#125;, &#123;&#123; . &#125;&#125;&#123;&#123; end &#125;&#125;&lt;/p&gt;
          &lt;p class=&quot;institution&quot;&gt;&#123;&#123; .institution &#125;&#125;&lt;/p&gt;
        &lt;/div&gt;
      &lt;/li&gt;
      &#123;&#123; end &#125;&#125;
    &lt;/ul&gt;
  &lt;/div&gt;
  &#123;&#123; end &#125;&#125;
&lt;/div&gt;</code>`}<!-- HTML_TAG_END --></pre>`
    })}
${validate_component(Info, "Info").$$render($$result, {}, {}, {
      default: () => `<p>A quick tip to identify the classes and IDs of individual elements is to use the browser\u2019s <strong>inspect element</strong> tool. To do so, right click on the element you\u2019re interested in and click inspect element; what you\u2019ll see is a highlighted box that tells you that object\u2019s class and/or ID. For more on inspect element and your browser, <a href="${"https://blog.devmountain.com/how-to-use-inspect-element-jump-into-what-makes-a-web-page-tick/"}" rel="${"nofollow"}">see this page</a>.</p>`
    })}
<p>Now, we can reference the existing CSS classes, and our new ones, in our pretty animation in Step 3!</p>
<h2 id="${"step-3-add-css"}"><a href="${"#step-3-add-css"}">Step 3) Add CSS</a></h2>
<p>Now that we\u2019ve created our classes, we can target them in a CSS file and tell them exactly <em>how</em> to animate.</p>
<p>But first, you\u2019ll need to create a custom CSS file in your root directly. In your <code>assets/</code> folder, create a <em>new</em> folder called <code>scss/</code> and within this folder, create a <em>new</em> file called <code>custom.scss</code>.</p>
${validate_component(Info, "Info").$$render($$result, {}, {}, {
      default: () => `<p>An SCSS file is essentially a CSS file but extended with Sass, which describes <a href="${"https://sass-lang.com/"}" rel="${"nofollow"}">itself</a> as \u2018CSS with superpowers.\u2019 For an overview of the intricacies of Sass, like nesting selectors, visit <a href="${"https://sass-lang.com/guide"}" rel="${"nofollow"}">their guide</a>.</p>`
    })}
<p>Within <code>custom.scss</code>, we\u2019re going to target everything <em>within our about section</em>. In order to do so, we create a selector that targets everything within the ID of <code>about</code>.</p>
${validate_component(Code, "Code").$$render($$result, { language: "css", filename: "custom.scss" }, {}, {
      default: () => `<pre class="${"language-undefined"}"><!-- HTML_TAG_START -->${`<code class="language-undefined">#about &#123;
  /* Some CSS will go here soon! */
  /* This is a comment, by the way. */
&#125;</code>`}<!-- HTML_TAG_END --></pre>`
    })}
<p>To ensure that we\u2019ve targeted the right section, we can go ahead and add the property <code>background-color: red</code> to that element. As the name implies, this will make the section \u2728 red. \u2728</p>
${validate_component(Code, "Code").$$render($$result, { language: "css", filename: "custom.scss" }, {}, {
      default: () => `<pre class="${"language-undefined"}"><!-- HTML_TAG_START -->${`<code class="language-undefined">#about &#123;
  background-color: red;
&#125;</code>`}<!-- HTML_TAG_END --></pre>`
    })}
<p>As we expected, our section background is now an (unbelievably ugly shade of) red.</p>
${validate_component(Image, "Image").$$render($$result, {
      src: "../images/post/animate-hugo-academic/bg-red.png",
      alt: "An example of turning the background color of the page red."
    }, {}, {})}
<p>(Now remove that property immediately! This is not quite the welcome we want for our visitors.) We can also target elements <em>within</em> the section by nesting new selectors inside of <code>#about</code>. For example, if we wanted to change the color of our \u2018biography\u2019 title text, we could do so with the following code. (This is because we created a class named <code>biography-title</code> in step 1):</p>
${validate_component(Code, "Code").$$render($$result, { language: "css", filename: "custom.scss" }, {}, {
      default: () => `<pre class="${"language-undefined"}"><!-- HTML_TAG_START -->${`<code class="language-undefined">#about &#123;
  .biography-title &#123;
    color: red;
  &#125;
&#125;</code>`}<!-- HTML_TAG_END --></pre>`
    })}
${validate_component(Image, "Image").$$render($$result, {
      src: "../images/post/animate-hugo-academic/font-red.png",
      alt: "An example of turning the font color  red."
    }, {}, {})}
${validate_component(Info, "Info").$$render($$result, {}, {}, {
      default: () => `<p>You may notice that <code>about</code> is targeted with a pound (#) and <code>biography-title</code> is targeted with a period (.). This is the difference between CSS <em>IDs</em> and <em>classes</em>. If you\u2019re curious about the distinction, here\u2019s a <a href="${"https://www.htmldog.com/guides/css/intermediate/classid/"}" rel="${"nofollow"}">helpful guide</a>.</p>`
    })}
<p>Now that we know how to target specific objects within our <code>about</code> section, we can animate our first element!</p>
<h3 id="${"step-3a-your-first-animation"}"><a href="${"#step-3a-your-first-animation"}">Step 3A) Your first animation!</a></h3>
<p>Creating your first animation is as simple as a few lines of code. To illustrate, we\u2019ll test out an animation which changes our text from red and invisible to black and visible. In the code, we\u2019ll have to do two things:</p>
<ol><li>Create an animation with <code>@keyframes</code></li></ol>
${validate_component(Code, "Code").$$render($$result, { language: "css", filename: "custom.scss" }, {}, {
      default: () => `<pre class="${"language-undefined"}"><!-- HTML_TAG_START -->${`<code class="language-undefined">@keyframes yourfirstanimation &#123;
  from &#123;
    opacity: 0;
    color: red;
  &#125;
  to &#123;
    opacity: 1;
    color: black;
  &#125;
&#125;</code>`}<!-- HTML_TAG_END --></pre>`
    })}
<ol start="${"2"}"><li>Bind the animation to an element</li></ol>
${validate_component(Code, "Code").$$render($$result, { language: "css", filename: "custom.scss" }, {}, {
      default: () => `<pre class="${"language-undefined"}"><!-- HTML_TAG_START -->${`<code class="language-undefined">.biography-title &#123;
  animation: yourfirstanimation 5s forwards;
&#125;</code>`}<!-- HTML_TAG_END --></pre>`
    })}
<p>To break down the above code, we create an animation that has a <em>start point</em> (<code>0%</code>) and an <em>end point</em> (<code>100%</code>). At both of these points, we define CSS properties, such as color and opacity, seen above. When we bind the animation to an element, which is as simple as <code>animation: &lt;animation_name&gt; &lt;duration&gt; &lt;fill_mode&gt;</code>, CSS deals with all the inbetween and automatically creates a smooth transition! (Fill mode is the most complicated of these three properties, but for our purposes we will always be using <code>forwards</code>. For more information, visit <a href="${"https://developer.mozilla.org/en-US/docs/Web/CSS/animation-fill-mode"}" rel="${"nofollow"}">this page</a>.)</p>
<p>Altogether, this code creates this output:</p>
${validate_component(Code, "Code").$$render($$result, { language: "css", filename: "custom.scss" }, {}, {
      default: () => `<pre class="${"language-undefined"}"><!-- HTML_TAG_START -->${`<code class="language-undefined">#about &#123;
  @keyframes yourfirstanimation &#123;
    0% &#123;
      opacity: 0;
      color: red;
    &#125;
    100% &#123;
      opacity: 1;
      color: black;
    &#125;
  &#125;

  .biography-title &#123;
    animation: yourfirstanimation 5s forwards;
  &#125;
&#125;</code>`}<!-- HTML_TAG_END --></pre>`
    })}
${validate_component(Image, "Image").$$render($$result, {
      src: "../images/post/animate-hugo-academic/red.gif",
      alt: "An example transition, turning the font color to red over a 5 second duration."
    }, {}, {})}
<p>Of course, we don\u2019t want a 5 second animation, nor do we want our text to start off as red. A cleaner animation might leverage the power of CSS to modify an element\u2019s <em>position</em>. In our case, we want an element to <strong>slide in from the right side of the screen</strong>, and so we make a few tweaks to the code above. Let\u2019s make a new animation called <code>slide-from-right</code> which starts (at keyframe 0%) with our element 150% to the right of its original position (therefore off the screen) and ends (at keyframe 100%) with it at its original position. This involves the use of <code>translateX</code>, which you can read about <a href="${"https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/translateX"}" rel="${"nofollow"}">here</a>.</p>
${validate_component(Code, "Code").$$render($$result, { language: "css", filename: "custom.scss" }, {}, {
      default: () => `<pre class="${"language-undefined"}"><!-- HTML_TAG_START -->${`<code class="language-undefined">@keyframes slide-from-right &#123;
  0% &#123;
    transform: translateX(150%);
  &#125;
  100% &#123;
    transform: translateX(0%);
  &#125;
&#125;

.biography-title &#123;
  animation: slide-from-right 1s forwards;
&#125;</code>`}<!-- HTML_TAG_END --></pre>`
    })}
${validate_component(Image, "Image").$$render($$result, {
      src: "../images/post/animate-hugo-academic/slide-from-right.gif",
      alt: "A gif of the content sliding in from the right side of the page"
    }, {}, {})}
<p>There is one slight improvement we can make on the above transition. Specifically, we can call an <em>easing function</em> on our animation. <a href="${"https://developer.mozilla.org/en-US/docs/Web/CSS/easing-function"}" rel="${"nofollow"}">Easing functions</a> give a more natural feel to a transition\u2019s flow\u2014rather than our object flying in at a perfectly linear rate, we can add some personality by specifying its speed at different points in the transition. To find an easing function, visit <a href="${"https://easings.net/en#"}" rel="${"nofollow"}">easings.net</a>, which allows you to visualize all of the different ways to modify your transition\u2019s ease. (For this tutorial, I chose a clean-looking \u201C<em>easeInOutQuint</em>\u201C function, which looks like this: <code>cubic-bezier(0.83, 0, 0.17, 1)</code>.)</p>
<hr>
<h3 id="${"step-3b-dont-wait-to-delay"}"><a href="${"#step-3b-dont-wait-to-delay"}">Step 3B) Don\u2019t Wait to Delay</a></h3>
<p>We want our homepage to have more than just one title animation. We might also want to <strong>animate the paragraphs below it</strong>, with the same \u2019slide from right\u2019 transition we defined earlier. While doing this, we can add one property to our element to make the overall transition seem more fluid: <code>animation-delay</code>. As the name suggests, this property defines how long the browser should wait before it <em>begins</em> the transition you\u2019ve specified. Animating our <code>main-content</code> div is as simple as copying the above code and adding a 100 millisecond animation delay.</p>
${validate_component(Code, "Code").$$render($$result, { language: "css", filename: "custom.scss" }, {}, {
      default: () => `<pre class="${"language-undefined"}"><!-- HTML_TAG_START -->${`<code class="language-undefined">.main-content &#123;
  animation: slide-from-right 1s cubic-bezier(0.87, 0, 0.13, 1) forwards;
  animation-delay: 100ms;
&#125;</code>`}<!-- HTML_TAG_END --></pre>`
    })}
<p>In combination with above, this creates a transition that looks like this:</p>
${validate_component(Image, "Image").$$render($$result, {
      src: "../images/post/animate-hugo-academic/double-slide.gif",
      alt: "A gif of two pieces of content sliding in, one after another (with a 100ms delay)"
    }, {}, {})}
<p>Nice! That looks clean. It looks like those two text blocks are racing to greet your new site visitor :)</p>
<hr>
<h3 id="${"step-3c-to-the-left"}"><a href="${"#step-3c-to-the-left"}">Step 3C) To the Left!</a></h3>
<p>Let\u2019s go ahead and replicate that \u2019slide in\u2019 transition for our profile on the left side of our webpage. As you could probably gather, this is as simple as copying the above code and changing the value in <code>translateX</code> from 150% to -150% (from just outside the right side of our webpage <a href="${"https://www.youtube.com/watch?v=2EwViQxSJJQ&feature=youtu.be&t=25"}" rel="${"nofollow"}">to the left!</a>). As above, we\u2019ll define this transition in a <code>@keyframes</code> rule and apply it to our CSS transition afterward.</p>
${validate_component(Code, "Code").$$render($$result, { language: "css", filename: "custom.scss" }, {}, {
      default: () => `<pre class="${"language-undefined"}"><!-- HTML_TAG_START -->${`<code class="language-undefined">@keyframes slide-from-left &#123;
  0% &#123;
    transform: translateX(-150%);
  &#125;
  100% &#123;
    transform: translateX(0%);
  &#125;
&#125;

#profile &#123;
  animation: slide-from-left 1s cubic-bezier(0.87, 0, 0.13, 1) forwards;
&#125;</code>`}<!-- HTML_TAG_END --></pre>`
    })}
${validate_component(Image, "Image").$$render($$result, {
      src: "../images/post/animate-hugo-academic/left-and-right.gif",
      alt: "Two paragraphs of content sliding in from opposite directions."
    }, {}, {})}
<h3 id="${"step-3d-finally-the-fade"}"><a href="${"#step-3d-finally-the-fade"}">Step 3D) Finally, the Fade</a></h3>
<p>The only thing not yet animated on our page are the \u2018interests\u2019 and \u2018education\u2019 content blocks. Of course, you might not want these on your homepage (my educational journey isn\u2019t yet formidable enough to warrant its own section on my homepage!). But for the sake of animating the homepage <em>as its configured by default</em>, let\u2019s go ahead and have those content blocks fade in <em>once the sliding transitions complete</em>.</p>
<p>If you\u2019ve been paying attention to the prior <code>@keyframes</code> rules, you might have guessed that the code would look like this:</p>
${validate_component(Code, "Code").$$render($$result, { language: "css", filename: "custom.scss" }, {}, {
      default: () => `<pre class="${"language-undefined"}"><!-- HTML_TAG_START -->${`<code class="language-undefined">@keyframes fade-in &#123;
  0% &#123;
    opacity: 0;
  &#125;
  100% &#123;
    opacity: 1;
  &#125;
&#125;</code>`}<!-- HTML_TAG_END --></pre>`
    })}
<p>\u2026 and you would be correct!</p>
<p>Now, we apply this <code>fade-in</code> rule to both our <code>interests-div</code> and our <code>education-div</code>, which we created in step 1. But notably, we want to wait to fade in each of these divs until <em>after our content has slid in from either side of the webpage.</em> And so, we\u2019ll once again use the <code>animation-delay</code> property. Because our slide-in animations take one second to complete, we can begin our fade-in animations after a one-second delay. To make the transition a little more visually appealling, we can also stagger them, so the <code>education-div</code> fades in half a second <em>after</em> <code>interests-div</code>.</p>
${validate_component(Code, "Code").$$render($$result, { language: "css", filename: "custom.scss" }, {}, {
      default: () => `<pre class="${"language-undefined"}"><!-- HTML_TAG_START -->${`<code class="language-undefined">.interests-div &#123;
  opacity: 0;
  animation: fade-in 1s forwards;
  animation-delay: 1s;
&#125;

.education-div &#123;
  opacity: 0;
  animation: fade-in 1s forwards;
  animation-delay: 1.5s;
&#125;</code>`}<!-- HTML_TAG_END --></pre>`
    })}
<p>Now, we have a final homepage that looks like this:</p>
${validate_component(Image, "Image").$$render($$result, {
      src: "../images/post/animate-hugo-academic/final.gif",
      alt: "A GIF showing the final iteration of a homepage, with animations."
    }, {}, {})}
<p>To make our SCSS file more robust across different browsers, we can take our completed file and put it into the <a href="${"https://autoprefixer.github.io/"}" rel="${"nofollow"}">CSS Autoprefixer</a>. This adds additional lines of code to our CSS file so that all browsers render the same animations upon page load. Your completed SCSS file should look like <a href="${"https://github.com/connorrothschild/animate-hugo-academic/blob/master/assets/scss/custom.scss"}" rel="${"nofollow"}">this</a>.</p>
<h2 id="${"extending-animations"}"><a href="${"#extending-animations"}">Extending Animations</a></h2>
<p>This tutorial is meant to teach you the essentials of <em>how</em> to animate your homepage (for any Hugo site, not just Academic). Specifically, you should be able to 1) create and identify CSS elements via their classes and IDs, 2) target them using CSS, and 3) animate them using <code>@keyframes</code> rules. Although easier said then done, applying these three rules will go a long way in making your homepage much more appealling to new visitors.</p>
<p>The complete power of CSS animations is not covered in this tutorial. Further applications of animations could do <strong>much</strong> more than just animate an object\u2019s position. I leave that to you!</p>
<p>For those that are interested, <a href="${"https://connorrothschild.github.io/v2/"}" rel="${"nofollow"}">my old homepage</a> is chock-full of CSS properties which make it unique from most; some visitors are surprised to hear that my site is Hugo Academic at all!</p>
<p>For those interested, the code for my Hugo Academic personal site (now archived) can be found <a href="${"https://github.com/connorrothschild/v2"}" rel="${"nofollow"}">here</a>. I look forward to seeing your animated homepages!</p>`
  })}`;
});
var animateHugoAcademic = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Animate_hugo_academic,
  metadata: metadata$d
});
var metadata$c = {
  "layout": "blog",
  "title": "My First Package! Introducing tpltheme",
  "description": "Introducing {tpltheme}, a toolkit to create publication-ready plots in the style of the Texas Policy Lab.",
  "image": "introducing-tpltheme/header.png",
  "date": "2019-07-02",
  "archived": true,
  "tags": ["r"]
};
var Introducing_tpltheme = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${validate_component(Layout, "Layout_MDSVEX_DEFAULT").$$render($$result, Object.assign($$props, metadata$c), {}, {
    default: () => `<p>I\u2019ve spent the majority of the summer as an
<a href="${"https://www.texaspolicylab.org/profile/connor-rothschild/"}" rel="${"nofollow"}">intern</a> with
the Texas Policy Lab, working on primarily data science-related matters
such as data cleaning and visualization. Most recently, I sought to
create a custom theme in <code>ggplot2</code> for TPL.</p>
<p>The project was my first experience in developing my own R package.
Prior to this project, the most familiarity I had with packages were
from the <code>install.packages()</code> and <code>library()</code> commands.</p>
<p>Hadley Wickham\u2019s book <strong><a href="${"http://r-pkgs.had.co.nz/"}" rel="${"nofollow"}">R Packages</a></strong> was
enormously helpful in introducing package development to me. I ran into
(a lot of) issues in building the package, specifically encountering
problems related to local file paths and logo placement on plots.</p>
<p>Creating your own package is a great exercise in trial and error, and
taught me a lot about programming in R that I wouldn\u2019t have learned
otherwise. I was also struck by how remarkably easy it was to create
one\u2019s own package (seriously, it requires the same amount of clicks as
starting a new R project), and how thorough online resources were.</p>
<h2 id="${"inspiration"}"><a href="${"#inspiration"}">Inspiration</a></h2>
<p>The catalyst for creating this package was coming across the Urban
Institute\u2019s <a href="${"https://github.com/UrbanInstitute/urbnthemes"}" rel="${"nofollow"}">urbnthemes</a>
package on GitHub. I also gathered a lot of inspiration (and borrowed
some code) from <a href="${"https://github.com/jrnold/ggthemes"}" rel="${"nofollow"}">ggthemes</a> (Jeffrey
Arnold), <a href="${"https://github.com/bbc/bbplot"}" rel="${"nofollow"}">bbplot</a> (BBC News), and
<a href="${"https://github.com/hrbrmstr/hrbrthemes"}" rel="${"nofollow"}">hrbrthemes</a> (Bob Rudis). I was
impressed by the fact that these organizations were able to use R to
create publication-ready plots despite the fact that base ggplot figures
can look rather ugly (if we\u2019re being honest).</p>
<p>Because the organization I intern with is still in its infancy, I
thought it would be a perfect time to create a standardized theme for
figures made in the future. So long as future employees adopt the theme,
this package has the potential to create figures specific to our
publications, lending TPL organizational credibility and creating
cross-report consistency.</p>
<p>I thought a lot about some basic tenets of design, such as font
readability, text size, and color contrast. I learned a lot about visual
and aesthetic design I wouldn\u2019t know otherwise (Kieran Healy\u2019s section
on how graphs can deceive the reader\u2013intentionally or not\u2013opened my eyes
to a lot of important visual concepts.</p>
<h1 id="${"overview"}"><a href="${"#overview"}">Overview</a></h1>
<p>Here\u2019s an overview of some of the packages key features:</p>
<h2 id="${"installation-and-usage"}"><a href="${"#installation-and-usage"}">Installation and Usage</a></h2>
<p>You can install the package via GitHub:</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">library<span class="token punctuation">(</span>ggplot2<span class="token punctuation">)</span>
library<span class="token punctuation">(</span>tidyverse<span class="token punctuation">)</span>

<span class="token comment">#devtools::install_github("connorrothschild/tpltheme")</span>
library<span class="token punctuation">(</span>tpltheme<span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>
<p>Always load <code>library(tpltheme)</code> <strong>after</strong> <code>library(ggplot2)</code> and/or
<code>library(tidyverse)</code>.</p>
<p>The package creates a standardized formats for plots to be used in
reports created by the Texas Policy Lab. It primarily relies on
<code>set_tpl_theme()</code>, which allows the user to specify whether the plot
theme should align with a standard plot (<code>style = &quot;print&quot;</code>), or one
specially created for plotting geographical data (<code>style = &quot;Texas&quot;</code>).
Calling <code>set_tpl_theme()</code> after <code>library(tpltheme)</code> does most of the
work for this package!</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">set_tpl_theme<span class="token punctuation">(</span>font <span class="token operator">=</span> <span class="token string">'IBM Plex Sans'</span><span class="token punctuation">)</span>

ggplot<span class="token punctuation">(</span>iris<span class="token punctuation">,</span> aes<span class="token punctuation">(</span>x<span class="token operator">=</span>Species<span class="token punctuation">,</span> y<span class="token operator">=</span>Sepal.Width<span class="token punctuation">,</span> fill<span class="token operator">=</span>Species<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span>
    geom_bar<span class="token punctuation">(</span>stat<span class="token operator">=</span><span class="token string">"summary"</span><span class="token punctuation">,</span> fun.y<span class="token operator">=</span><span class="token string">"mean"</span><span class="token punctuation">,</span> show.legend <span class="token operator">=</span> <span class="token boolean">FALSE</span><span class="token punctuation">)</span> <span class="token operator">+</span>
    scale_y_continuous<span class="token punctuation">(</span>expand <span class="token operator">=</span> expand_scale<span class="token punctuation">(</span>mult <span class="token operator">=</span> c<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0.001</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span>
    labs<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token string">"Species"</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token string">"Mean Sepal Width (cm)"</span><span class="token punctuation">,</span> fill<span class="token operator">=</span><span class="token string">"Species"</span><span class="token punctuation">,</span> title<span class="token operator">=</span><span class="token string">"Iris Dataset"</span><span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>
${validate_component(Image, "Image").$$render($$result, {
      alt: "An example of a plot in the TPL theme.",
      src: "../images/post/introducing-tpltheme/unnamed-chunk-3-1.png"
    }, {}, {})}
<h3 id="${"fonts"}"><a href="${"#fonts"}">Fonts</a></h3>
<p>The user is able to specify whether they want to use <em>Lato</em> or <em>Adobe
Caslon Pro</em> in their figures.</p>
<p>To ensure that these fonts are installed and registered, use
<code>tpl_font_test()</code>. If fonts are not properly installed, install both
fonts online and then run <code>tpl_font_install()</code>.</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">tpl_font_test<span class="token punctuation">(</span><span class="token punctuation">)</span>
tpl_font_install<span class="token punctuation">(</span><span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>
<p>Here are some examples of sample TPL plots with different specifications
for <code>style</code> and <code>font</code>.</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">set_tpl_theme<span class="token punctuation">(</span>style <span class="token operator">=</span> <span class="token string">"print"</span><span class="token punctuation">,</span> font <span class="token operator">=</span> <span class="token string">"lato"</span><span class="token punctuation">)</span>

ggplot<span class="token punctuation">(</span>iris<span class="token punctuation">,</span> aes<span class="token punctuation">(</span>x<span class="token operator">=</span>jitter<span class="token punctuation">(</span>Sepal.Width<span class="token punctuation">)</span><span class="token punctuation">,</span> y<span class="token operator">=</span>jitter<span class="token punctuation">(</span>Sepal.Length<span class="token punctuation">)</span><span class="token punctuation">,</span> col<span class="token operator">=</span>Species<span class="token punctuation">,</span> size <span class="token operator">=</span> Petal.Length<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span>
    geom_point<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>
    labs<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token string">"Sepal Width (cm)"</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token string">"Sepal Length (cm)"</span><span class="token punctuation">,</span> col<span class="token operator">=</span><span class="token string">"Species"</span><span class="token punctuation">,</span> size <span class="token operator">=</span> <span class="token string">"Petal Length"</span><span class="token punctuation">,</span> title<span class="token operator">=</span><span class="token string">"Iris Dataset"</span><span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>
${validate_component(Image, "Image").$$render($$result, {
      alt: "An example of a plot in the TPL theme.",
      src: "../images/post/introducing-tpltheme/unnamed-chunk-5-1.png"
    }, {}, {})}
<p>By specifying <code>style = &quot;Texas&quot;</code> within <code>set_tpl_theme</code>, the user may
also create Texas-specific plots.</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">tx_vac <span class="token operator">&lt;-</span> readr<span class="token operator">::</span>read_csv<span class="token punctuation">(</span><span class="token string">"https://raw.githubusercontent.com/connorrothschild/tpltheme/master/data/tx_vac_example.csv"</span><span class="token punctuation">)</span>
set_tpl_theme<span class="token punctuation">(</span>style <span class="token operator">=</span> <span class="token string">"Texas"</span><span class="token punctuation">,</span> font <span class="token operator">=</span> <span class="token string">"adobe"</span><span class="token punctuation">)</span>

ggplot<span class="token punctuation">(</span>data <span class="token operator">=</span> tx_vac<span class="token punctuation">,</span> mapping <span class="token operator">=</span> aes<span class="token punctuation">(</span>x <span class="token operator">=</span> long<span class="token punctuation">,</span> y <span class="token operator">=</span> lat<span class="token punctuation">,</span> group <span class="token operator">=</span> group<span class="token punctuation">,</span> fill <span class="token operator">=</span> avgvac<span class="token operator">*</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  coord_fixed<span class="token punctuation">(</span><span class="token number">1.3</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  scale_fill_continuous<span class="token punctuation">(</span>limits <span class="token operator">=</span> c<span class="token punctuation">(</span><span class="token number">78.3</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  geom_polygon<span class="token punctuation">(</span>color <span class="token operator">=</span> <span class="token string">"black"</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  labs<span class="token punctuation">(</span>title <span class="token operator">=</span> <span class="token string">"Texas Vaccination Rate by County"</span><span class="token punctuation">,</span>
       subtitle <span class="token operator">=</span> <span class="token string">"Among Kindergarteners"</span><span class="token punctuation">,</span>
       fill <span class="token operator">=</span> <span class="token string">"Percent&#92;nVaccinated"</span><span class="token punctuation">,</span>
       caption <span class="token operator">=</span> <span class="token string">"Source: Texas DSHS"</span><span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>
${validate_component(Image, "Image").$$render($$result, {
      alt: "An example of a plot in the TPL theme.",
      src: "../images/post/introducing-tpltheme/unnamed-chunk-6-1.png"
    }, {}, {})}
<p>And it also works for categorical variables:</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">set_tpl_theme<span class="token punctuation">(</span>style <span class="token operator">=</span> <span class="token string">"Texas"</span><span class="token punctuation">,</span> font <span class="token operator">=</span> <span class="token string">"lato"</span><span class="token punctuation">)</span>

tx_vac <span class="token percent-operator operator">%>%</span>
  dplyr<span class="token operator">::</span>mutate<span class="token punctuation">(</span>cat <span class="token operator">=</span> factor<span class="token punctuation">(</span>dplyr<span class="token operator">::</span>case_when<span class="token punctuation">(</span>avgvac<span class="token operator">*</span><span class="token number">100</span> <span class="token operator">></span> <span class="token number">99</span> <span class="token operator">~</span> <span class="token string">"Great"</span><span class="token punctuation">,</span>
                         avgvac<span class="token operator">*</span><span class="token number">100</span> <span class="token operator">></span> <span class="token number">90</span> <span class="token operator">~</span> <span class="token string">"Average"</span><span class="token punctuation">,</span>
                         avgvac<span class="token operator">*</span><span class="token number">100</span> <span class="token operator">&lt;</span> <span class="token number">90</span> <span class="token operator">~</span> <span class="token string">"Bad"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token percent-operator operator">%>%</span>
  ggplot<span class="token punctuation">(</span>mapping <span class="token operator">=</span> aes<span class="token punctuation">(</span>x <span class="token operator">=</span> long<span class="token punctuation">,</span> y <span class="token operator">=</span> lat<span class="token punctuation">,</span> group <span class="token operator">=</span> group<span class="token punctuation">,</span> fill <span class="token operator">=</span> cat<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  coord_fixed<span class="token punctuation">(</span><span class="token number">1.3</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  geom_polygon<span class="token punctuation">(</span>color <span class="token operator">=</span> <span class="token string">"black"</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  labs<span class="token punctuation">(</span>title <span class="token operator">=</span> <span class="token string">"Texas Vaccination Rate by County"</span><span class="token punctuation">,</span>
       subtitle <span class="token operator">=</span> <span class="token string">"Among Kindergarteners"</span><span class="token punctuation">,</span>
       fill <span class="token operator">=</span> <span class="token string">"Vaccination Rating"</span><span class="token punctuation">,</span>
       caption <span class="token operator">=</span> <span class="token string">"Source: Texas DSHS"</span><span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>
${validate_component(Image, "Image").$$render($$result, {
      alt: "An example of a plot in the TPL theme.",
      src: "../images/post/introducing-tpltheme/unnamed-chunk-7-1.png"
    }, {}, {})}
<p>If the number of colors exceeds the number of colors in the TPL palette
(9), the function <code>tpl_color_pal()</code> will drop the TPL color palette and
return the greatest number of unique colors possible within the
RColorBrewer\u2019s \u201CPaired\u201D palette (for more information on the use of
RColorBrewer palettes, see <a href="${"https://bookdown.org/rdpeng/exdata/plotting-and-color-in-r.html#using-the-rcolorbrewer-palettes"}" rel="${"nofollow"}">this
chapter</a>).</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">tx_vac <span class="token percent-operator operator">%>%</span>
  ggplot<span class="token punctuation">(</span>mapping <span class="token operator">=</span> aes<span class="token punctuation">(</span>x <span class="token operator">=</span> long<span class="token punctuation">,</span> y <span class="token operator">=</span> lat<span class="token punctuation">,</span> group <span class="token operator">=</span> group<span class="token punctuation">,</span> fill <span class="token operator">=</span> subregion<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  coord_fixed<span class="token punctuation">(</span><span class="token number">1.3</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  geom_polygon<span class="token punctuation">(</span>color <span class="token operator">=</span> <span class="token string">"black"</span><span class="token punctuation">,</span> show.legend <span class="token operator">=</span> <span class="token boolean">FALSE</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  labs<span class="token punctuation">(</span>title <span class="token operator">=</span> <span class="token string">"Texas Counties"</span><span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>
${validate_component(Image, "Image").$$render($$result, {
      alt: "An example of a plot in the TPL theme.",
      src: "../images/post/introducing-tpltheme/unnamed-chunk-8-1.png"
    }, {}, {})}
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r"><span class="token comment"># default to print afterwards</span>
set_tpl_theme<span class="token punctuation">(</span>style <span class="token operator">=</span> <span class="token string">"print"</span><span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>
<h3 id="${"tpl-branding"}"><a href="${"#tpl-branding"}">TPL Branding</a></h3>
<h4 id="${"logo"}"><a href="${"#logo"}">Logo</a></h4>
<p>The user also has the option to include the TPL logo in single plots.
This may be preferred for those reports being made especially public, or
to serve as a pseudo-watermark in proprietary plots.</p>
<p>The user can specify the <code>position</code> of the logo as well as its <code>scale</code>.
The scale argument refers to the size of the logo object, with the
specified number corresponding to a multiplication with the normal logo
size. In other words, <code>scale = 2</code> will <em>double</em> the size of the logo.
The logo defaults to 1/7th of the size of the plot.</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">plot <span class="token operator">&lt;-</span> ggplot<span class="token punctuation">(</span>iris<span class="token punctuation">,</span> aes<span class="token punctuation">(</span>x<span class="token operator">=</span>Species<span class="token punctuation">,</span> y<span class="token operator">=</span>Sepal.Width<span class="token punctuation">,</span> fill<span class="token operator">=</span>Species<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span>
    geom_bar<span class="token punctuation">(</span>stat<span class="token operator">=</span><span class="token string">"summary"</span><span class="token punctuation">,</span> fun.y<span class="token operator">=</span><span class="token string">"mean"</span><span class="token punctuation">,</span> show.legend <span class="token operator">=</span> <span class="token boolean">FALSE</span><span class="token punctuation">)</span> <span class="token operator">+</span>
    scale_y_continuous<span class="token punctuation">(</span>expand <span class="token operator">=</span> expand_scale<span class="token punctuation">(</span>mult <span class="token operator">=</span> c<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0.001</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span>
    labs<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token string">"Species"</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token string">"Mean Sepal Width (cm)"</span><span class="token punctuation">,</span> fill<span class="token operator">=</span><span class="token string">"Species"</span><span class="token punctuation">,</span> title<span class="token operator">=</span><span class="token string">"Iris Dataset"</span><span class="token punctuation">)</span>

add_tpl_logo<span class="token punctuation">(</span>plot<span class="token punctuation">,</span> position <span class="token operator">=</span> <span class="token string">"top right"</span><span class="token punctuation">,</span> scale <span class="token operator">=</span> <span class="token number">1.5</span><span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>
${validate_component(Image, "Image").$$render($$result, {
      alt: "An example of a plot in the TPL theme.",
      src: "../images/post/introducing-tpltheme/unnamed-chunk-9-1.png"
    }, {}, {})}
<h4 id="${"logo-text"}"><a href="${"#logo-text"}">Logo text</a></h4>
<p>There may be some instances when an all-out logo is not warranted or
preferred. If that is the case and the user would still like to
watermark their figures, they can use the function <code>add_tpl_logo_text()</code>
to add text to an existing plot object:</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">plot <span class="token operator">&lt;-</span> ggplot<span class="token punctuation">(</span>iris<span class="token punctuation">,</span> aes<span class="token punctuation">(</span>x<span class="token operator">=</span>jitter<span class="token punctuation">(</span>Sepal.Width<span class="token punctuation">)</span><span class="token punctuation">,</span> y<span class="token operator">=</span>jitter<span class="token punctuation">(</span>Sepal.Length<span class="token punctuation">)</span><span class="token punctuation">,</span> col<span class="token operator">=</span>Species<span class="token punctuation">,</span> size <span class="token operator">=</span> Petal.Length<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span>
    geom_point<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>
    labs<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token string">"Sepal Width (cm)"</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token string">"Sepal Length (cm)"</span><span class="token punctuation">,</span> col<span class="token operator">=</span><span class="token string">"Species"</span><span class="token punctuation">,</span> size <span class="token operator">=</span> <span class="token string">"Petal Length"</span><span class="token punctuation">,</span> title<span class="token operator">=</span><span class="token string">"Iris Dataset"</span><span class="token punctuation">)</span>

add_tpl_logo_text<span class="token punctuation">(</span>plot<span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>
${validate_component(Image, "Image").$$render($$result, {
      alt: "An example of a plot in the TPL theme.",
      src: "../images/post/introducing-tpltheme/unnamed-chunk-10-1.png"
    }, {}, {})}
<p>The user may also need to specify <code>align</code>, which moves the plot
horizontally across the bottom of the page.</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">plot <span class="token operator">&lt;-</span> ggplot<span class="token punctuation">(</span>iris<span class="token punctuation">,</span> aes<span class="token punctuation">(</span>x<span class="token operator">=</span>Species<span class="token punctuation">,</span> y<span class="token operator">=</span>Sepal.Width<span class="token punctuation">,</span> fill<span class="token operator">=</span>Species<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span>
    geom_boxplot<span class="token punctuation">(</span>show.legend <span class="token operator">=</span> <span class="token boolean">FALSE</span><span class="token punctuation">)</span> <span class="token operator">+</span>
    labs<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token string">"Species"</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token string">"Sepal Width (cm)"</span><span class="token punctuation">,</span> fill<span class="token operator">=</span><span class="token string">"Species"</span><span class="token punctuation">,</span> title<span class="token operator">=</span><span class="token string">"Iris Dataset"</span><span class="token punctuation">,</span> subtitle <span class="token operator">=</span><span class="token string">"When specifying align = 1"</span><span class="token punctuation">)</span>

add_tpl_logo_text<span class="token punctuation">(</span>plot<span class="token punctuation">,</span> align <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>
${validate_component(Image, "Image").$$render($$result, {
      alt: "An example of a plot in the TPL theme.",
      src: "../images/post/introducing-tpltheme/unnamed-chunk-11-1.png"
    }, {}, {})}
<h3 id="${"additional-functions"}"><a href="${"#additional-functions"}">Additional functions</a></h3>
<h4 id="${"drop-axes"}"><a href="${"#drop-axes"}">Drop axes</a></h4>
<p>In the event that the user wishes to drop an axis, they may do so with
<code>drop_axis()</code>. The function may drop any combination of axes depending
on the user\u2019s input (<code>drop = &quot;x&quot;</code>, <code>drop = &quot;y&quot;</code>, <code>drop = &quot;both&quot;</code>,
<code>drop = &quot;neither&quot;</code>).</p>
<p>Unlike <code>add_tpl_logo()</code>, <code>drop_axis()</code> should be <em>added</em> to an existing
plot object:</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">ggplot<span class="token punctuation">(</span>iris<span class="token punctuation">,</span> aes<span class="token punctuation">(</span>x<span class="token operator">=</span>jitter<span class="token punctuation">(</span>Sepal.Width<span class="token punctuation">)</span><span class="token punctuation">,</span> y<span class="token operator">=</span>jitter<span class="token punctuation">(</span>Sepal.Length<span class="token punctuation">)</span><span class="token punctuation">,</span> col<span class="token operator">=</span>Species<span class="token punctuation">,</span> size <span class="token operator">=</span> Petal.Length<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span>
    geom_point<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>
    labs<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token string">"Sepal Width (cm)"</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token string">"Sepal Length (cm)"</span><span class="token punctuation">,</span> col<span class="token operator">=</span><span class="token string">"Species"</span><span class="token punctuation">,</span> size <span class="token operator">=</span> <span class="token string">"Petal Length"</span><span class="token punctuation">,</span> title<span class="token operator">=</span><span class="token string">"Iris Dataset"</span><span class="token punctuation">)</span> <span class="token operator">+</span>
    drop_axis<span class="token punctuation">(</span>axis <span class="token operator">=</span> <span class="token string">"y"</span><span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>
${validate_component(Image, "Image").$$render($$result, {
      alt: "An example of a plot in the TPL theme.",
      src: "../images/post/introducing-tpltheme/unnamed-chunk-12-1.png"
    }, {}, {})}
<h3 id="${"colors"}"><a href="${"#colors"}">Colors</a></h3>
<p>I also put a lot of time into creating a color palette which was both
aesthetically pleasing and accessible to color-blind viewers. This was
somewhat difficult because there are <a href="${"https://nei.nih.gov/learn-about-eye-health/eye-conditions-and-diseases/color-blindness"}" rel="${"nofollow"}">quite a few types of
colorblindness</a>.
Thankfully, my boss is colorblind, making test cases a lot more
accessible!</p>
<p>The function <code>view_palette</code> plots base color palettes included in
<code>tpltheme</code>. All TPL color palettes are led by the notation
<code>palette_tpl_*</code> and therefore can be easily autocompleted within
RStudio.</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">p1 <span class="token operator">&lt;-</span> view_palette<span class="token punctuation">(</span>palette <span class="token operator">=</span> palette_tpl_main<span class="token punctuation">)</span> <span class="token operator">+</span> ggtitle<span class="token punctuation">(</span><span class="token string">"Categorical"</span><span class="token punctuation">)</span>
p2 <span class="token operator">&lt;-</span> view_palette<span class="token punctuation">(</span>palette <span class="token operator">=</span> palette_tpl_diverging<span class="token punctuation">)</span> <span class="token operator">+</span> ggtitle<span class="token punctuation">(</span><span class="token string">"Diverging"</span><span class="token punctuation">)</span>
p3 <span class="token operator">&lt;-</span> view_palette<span class="token punctuation">(</span>palette <span class="token operator">=</span> palette_tpl_sequential<span class="token punctuation">)</span> <span class="token operator">+</span> ggtitle<span class="token punctuation">(</span><span class="token string">"Sequential"</span><span class="token punctuation">)</span>

gridExtra<span class="token operator">::</span>grid.arrange<span class="token punctuation">(</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">,</span> p3<span class="token punctuation">,</span> nrow <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>
${validate_component(Image, "Image").$$render($$result, {
      alt: "An example of a plot in the TPL theme.",
      src: "../images/post/introducing-tpltheme/unnamed-chunk-13-1.png"
    }, {}, {})}
<p>These palettes were created using <a href="${"http://colorbrewer2.org"}" rel="${"nofollow"}">http://colorbrewer2.org</a> and
<a href="${"http://coloors.co"}" rel="${"nofollow"}">http://coloors.co</a> and are colorblind friendly.</p>
<p>The diverging and sequential color palettes are from
<a href="${"http://colorbrewer2.org"}" rel="${"nofollow"}">http://colorbrewer2.org</a> and the categorical palette is composed of a
variety of colors from <a href="${"https://coolors.co/"}" rel="${"nofollow"}">https://coolors.co/</a> and the TPL website.</p>
<p>In action, the color palette looks like this:</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">normal <span class="token operator">&lt;-</span> diamonds <span class="token percent-operator operator">%>%</span>
  group_by<span class="token punctuation">(</span>clarity<span class="token punctuation">)</span> <span class="token percent-operator operator">%>%</span>
  summarise<span class="token punctuation">(</span>price <span class="token operator">=</span> mean<span class="token punctuation">(</span>price<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token percent-operator operator">%>%</span>
  mutate<span class="token punctuation">(</span>clarity <span class="token operator">=</span> forcats<span class="token operator">::</span>fct_reorder<span class="token punctuation">(</span>clarity<span class="token punctuation">,</span> price<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token percent-operator operator">%>%</span>
  ggplot<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  geom_col<span class="token punctuation">(</span>aes<span class="token punctuation">(</span>x <span class="token operator">=</span> clarity<span class="token punctuation">,</span> y <span class="token operator">=</span> price<span class="token punctuation">,</span> fill <span class="token operator">=</span> clarity<span class="token punctuation">)</span><span class="token punctuation">,</span> show.legend <span class="token operator">=</span> <span class="token boolean">FALSE</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  labs<span class="token punctuation">(</span>title <span class="token operator">=</span> <span class="token string">"TPL Color Palette"</span><span class="token punctuation">,</span>
       subtitle <span class="token operator">=</span> <span class="token string">"in action"</span><span class="token punctuation">,</span>
       x <span class="token operator">=</span> <span class="token string">"Clarity"</span><span class="token punctuation">,</span>
       y <span class="token operator">=</span> <span class="token string">"Price"</span><span class="token punctuation">,</span>
       fill <span class="token operator">=</span> element_blank<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  theme<span class="token punctuation">(</span>axis.text.x <span class="token operator">=</span> element_text<span class="token punctuation">(</span>angle <span class="token operator">=</span> <span class="token number">45</span><span class="token punctuation">,</span> hjust <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  coord_flip<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  scale_fill_discrete<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  scale_y_continuous<span class="token punctuation">(</span>expand <span class="token operator">=</span> expand_scale<span class="token punctuation">(</span>mult <span class="token operator">=</span> c<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0.001</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  drop_axis<span class="token punctuation">(</span>axis <span class="token operator">=</span> <span class="token string">"x"</span><span class="token punctuation">)</span>

reversed <span class="token operator">&lt;-</span> normal <span class="token operator">+</span>
  labs<span class="token punctuation">(</span>subtitle <span class="token operator">=</span> <span class="token string">"(reversed)"</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  scale_fill_discrete<span class="token punctuation">(</span>reverse <span class="token operator">=</span> <span class="token boolean">TRUE</span><span class="token punctuation">)</span>

gridExtra<span class="token operator">::</span>grid.arrange<span class="token punctuation">(</span>normal<span class="token punctuation">,</span> reversed<span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>
${validate_component(Image, "Image").$$render($$result, {
      alt: "An example of a plot in the TPL theme.",
      src: "../images/post/introducing-tpltheme/unnamed-chunk-14-1.png"
    }, {}, {})}
<p>The user may specify the color palette in the <code>scale_fill_*</code> or
<code>scale_color_*</code> functions in a ggplot call. Specifically, the user can
specify the <code>palette</code> (categorical, diverging, sequential) and whether
the palette should be reversed.</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">set_tpl_theme<span class="token punctuation">(</span>style <span class="token operator">=</span> <span class="token string">"print"</span><span class="token punctuation">,</span> font <span class="token operator">=</span> <span class="token string">"lato"</span><span class="token punctuation">)</span>
normal <span class="token operator">&lt;-</span> ggplot<span class="token punctuation">(</span>diamonds<span class="token punctuation">)</span> <span class="token operator">+</span>
  geom_bar<span class="token punctuation">(</span>aes<span class="token punctuation">(</span>x <span class="token operator">=</span> cut<span class="token punctuation">,</span> fill <span class="token operator">=</span> clarity<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  labs<span class="token punctuation">(</span>title <span class="token operator">=</span> <span class="token string">"TPL Color Palette"</span><span class="token punctuation">,</span>
       subtitle <span class="token operator">=</span> <span class="token string">"On sample data"</span><span class="token punctuation">,</span>
       x <span class="token operator">=</span> <span class="token string">"Cut"</span><span class="token punctuation">,</span>
       y <span class="token operator">=</span> <span class="token string">"Count"</span><span class="token punctuation">,</span>
       fill <span class="token operator">=</span> <span class="token string">"Clarity"</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  scale_y_continuous<span class="token punctuation">(</span>expand <span class="token operator">=</span> expand_scale<span class="token punctuation">(</span>mult <span class="token operator">=</span> c<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0.001</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  theme<span class="token punctuation">(</span>axis.text.x <span class="token operator">=</span> element_text<span class="token punctuation">(</span>angle <span class="token operator">=</span> <span class="token number">45</span><span class="token punctuation">,</span> hjust <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

reversed <span class="token operator">&lt;-</span> normal <span class="token operator">+</span>
  labs<span class="token punctuation">(</span>subtitle <span class="token operator">=</span> <span class="token string">"(reversed)"</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  scale_fill_discrete<span class="token punctuation">(</span>reverse <span class="token operator">=</span> <span class="token boolean">TRUE</span><span class="token punctuation">)</span>

gridExtra<span class="token operator">::</span>grid.arrange<span class="token punctuation">(</span>normal<span class="token punctuation">,</span> reversed<span class="token punctuation">,</span> nrow <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>
${validate_component(Image, "Image").$$render($$result, {
      alt: "An example of a plot in the TPL theme.",
      src: "../images/post/introducing-tpltheme/unnamed-chunk-15-1.png"
    }, {}, {})}
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">data <span class="token operator">&lt;-</span> gapminder<span class="token operator">::</span>gapminder <span class="token percent-operator operator">%>%</span>
  dplyr<span class="token operator">::</span>filter<span class="token punctuation">(</span>gapminder<span class="token operator">::</span>gapminder<span class="token operator">$</span>country <span class="token percent-operator operator">%in%</span> c<span class="token punctuation">(</span><span class="token string">"France"</span><span class="token punctuation">,</span> <span class="token string">"Germany"</span><span class="token punctuation">,</span> <span class="token string">"Ireland"</span><span class="token punctuation">,</span> <span class="token string">"Italy"</span><span class="token punctuation">,</span> <span class="token string">"Japan"</span><span class="token punctuation">,</span> <span class="token string">"Norway"</span><span class="token punctuation">,</span> <span class="token string">"Mexico"</span><span class="token punctuation">,</span> <span class="token string">"United States"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token percent-operator operator">%>%</span>
  dplyr<span class="token operator">::</span>mutate<span class="token punctuation">(</span>year <span class="token operator">=</span> as.Date<span class="token punctuation">(</span>paste<span class="token punctuation">(</span>year<span class="token punctuation">,</span> <span class="token string">"-01-01"</span><span class="token punctuation">,</span> sep <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">,</span> format<span class="token operator">=</span><span class="token string">'%Y-%b-%d'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

ggplot<span class="token punctuation">(</span>data <span class="token operator">=</span> data<span class="token punctuation">,</span> aes<span class="token punctuation">(</span>x <span class="token operator">=</span> year<span class="token punctuation">,</span> y <span class="token operator">=</span> gdpPercap<span class="token punctuation">,</span> fill <span class="token operator">=</span> country<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  geom_area<span class="token punctuation">(</span>alpha <span class="token operator">=</span> <span class="token number">0.8</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  scale_x_date<span class="token punctuation">(</span>expand <span class="token operator">=</span> c<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  scale_y_continuous<span class="token punctuation">(</span>expand <span class="token operator">=</span> c<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> labels <span class="token operator">=</span> scales<span class="token operator">::</span>dollar<span class="token punctuation">)</span> <span class="token operator">+</span>
  labs<span class="token punctuation">(</span>title <span class="token operator">=</span> <span class="token string">"GDP Per Capita Over Time"</span><span class="token punctuation">,</span>
       subtitle <span class="token operator">=</span> <span class="token string">"Using the TPL Color Palette"</span><span class="token punctuation">,</span>
       x <span class="token operator">=</span> element_blank<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
       y <span class="token operator">=</span> <span class="token string">"GDP Per Capita"</span><span class="token punctuation">,</span>
       fill <span class="token operator">=</span> <span class="token string">"Country"</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  theme<span class="token punctuation">(</span>axis.text.x <span class="token operator">=</span> element_text<span class="token punctuation">(</span>angle <span class="token operator">=</span> <span class="token number">45</span><span class="token punctuation">,</span> hjust <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>
${validate_component(Image, "Image").$$render($$result, {
      alt: "An example of a plot in the TPL theme.",
      src: "../images/post/introducing-tpltheme/unnamed-chunk-16-1.png"
    }, {}, {})}
<h3 id="${"restore-defaults"}"><a href="${"#restore-defaults"}">Restore Defaults</a></h3>
<p>By calling <code>undo_tpl_theme</code>, you are able to remove TPL-specific theme
settings and restores to ggplot defaults (but why would you want to do
that?).</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">undo_tpl_theme<span class="token punctuation">(</span><span class="token punctuation">)</span>

ggplot<span class="token punctuation">(</span>iris<span class="token punctuation">,</span> aes<span class="token punctuation">(</span>x<span class="token operator">=</span>jitter<span class="token punctuation">(</span>Sepal.Width<span class="token punctuation">)</span><span class="token punctuation">,</span> y<span class="token operator">=</span>jitter<span class="token punctuation">(</span>Sepal.Length<span class="token punctuation">)</span><span class="token punctuation">,</span> col<span class="token operator">=</span>Species<span class="token punctuation">,</span> size <span class="token operator">=</span> Petal.Length<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span>
    geom_point<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>
    labs<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token string">"Sepal Width (cm)"</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token string">"Sepal Length (cm)"</span><span class="token punctuation">,</span> col<span class="token operator">=</span><span class="token string">"Species"</span><span class="token punctuation">,</span> size <span class="token operator">=</span> <span class="token string">"Petal Length"</span><span class="token punctuation">,</span> title<span class="token operator">=</span><span class="token string">"Iris Dataset"</span><span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>
<p>This results in the following plot:</p>
${validate_component(Image, "Image").$$render($$result, {
      alt: "An example of a plot in the TPL theme.",
      src: "../images/post/introducing-tpltheme/unnamed-chunk-17-1.png"
    }, {}, {})}
<p>To restore the TPL theme, simply call <code>set_tpl_theme()</code>:</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">set_tpl_theme<span class="token punctuation">(</span><span class="token punctuation">)</span>
last_plot<span class="token punctuation">(</span><span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>
${validate_component(Image, "Image").$$render($$result, {
      alt: "An example of a plot in the TPL theme.",
      src: "../images/post/introducing-tpltheme/unnamed-chunk-18-1.png"
    }, {}, {})}`
  })}`;
});
var introducingTpltheme = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Introducing_tpltheme,
  metadata: metadata$c
});
var metadata$b = {
  "layout": "blog",
  "title": "Color in Data Visualization: Less How, More Why",
  "description": "An overview of the use of color in data visualization",
  "image": "color-in-data-vis/header.png",
  "date": "2020-01-02",
  "tags": ["color", "theory"]
};
var Color_in_data_vis = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${validate_component(Layout, "Layout_MDSVEX_DEFAULT").$$render($$result, Object.assign($$props, metadata$b), {}, {
    default: () => `<p>If our use of color in visualizations follows the <a href="${"https://en.wikipedia.org/wiki/Five_Ws"}" rel="${"nofollow"}">Five Ws (and one H)</a>, we\u2019re spending too much time on <em>how</em>, and not enough time on <em>why</em>. Color is too often seen as a tool to make pretty pictures, when it should be used to inform our audiences.</p>
<p>For one example, look at this \u201CColor Emotion Guide\u201D from marketing site <a href="${"https://www.tapclicks.com/resources/post/the-influence-of-color-in-data-visualization/"}" rel="${"nofollow"}">TapClicks</a> (one of the top results when you Google \u201Ccolor in data visualization\u201D \u{1F9D0}).</p>
${validate_component(Image, "Image").$$render($$result, {
      alt: "Color guide that doesn\u2019t make any sense. Random emotions are assigned to different brand colors, with no apparent pattern.",
      src: "../images/post/color-in-data-vis/color-emotion-guide-lol.jpg"
    }, {}, {})}
<p>The implicit suggestion here is that we should use color\u2014whenever and however we can\u2014to capture some form of emotion. Not only is this specific categorization rather odd (Monster energy drinks are peaceful, Virgin Mobile embodies \u201Cbold excitement\u201D, and Harley Davidson motorcycles just scream \u201Ccheerful friendliness\u201D \u{1F929}), it leads novice practitioners to believe that color should be used just for the sake of using color.</p>
<p>Examples of gratuitous color use abound.</p>
${validate_component(Image, "Image").$$render($$result, {
      alt: "A pie chart with far too many colors.",
      src: "../images/post/color-in-data-vis/bad-color-use-1.jpg",
      width: "29.2%"
    }, {}, {})}
${validate_component(Image, "Image").$$render($$result, {
      alt: "Multiple pie charts, all with poor color usage.",
      src: "../images/post/color-in-data-vis/bad-color-use-2.jpg",
      width: "69%"
    }, {}, {})}
<p>These examples illustrate my thesis: <strong>Too often, we ask <em>how</em> we can use color in our visualizations when we should be asking <em>why</em> we are using it.</strong></p>
<p>Some combination of 1) default software settings, 2) an obsession with pretty color palettes, and 3) a lack of emphasis on careful color consideration has led to a sloppy use of color in some of our most popular data visualizations.</p>
<p>One of the most common errors I see is the <em>overuse</em> of color. In the charts above, for example, it\u2019s evident that there are far too many colors, with no apparent reason for the</p>
<p>Often times, those creating visualizations will argue that they <em>must</em> include a 14 colors in their chart because the dataset has 14 data points of interest! It doesn\u2019t help that the default settings of some of the most popular data viz tools (such as Excel) by default map categorical variables to colors.</p>
<p>The reality is, however, that if you need more than a handful of colors in your chart, you can probably present your data in a different way. Take <a href="${"https://blog.datawrapper.de/colors/"}" rel="${"nofollow"}">this example</a> from Datawrapper:</p>
${validate_component(Image, "Image").$$render($$result, {
      alt: "An example of a poor and better visualization. One has many colors sequentially, while the other breaks up each color into its own bar for clarity's sake.",
      src: "../images/post/color-in-data-vis/bad-and-better.jpg"
    }, {}, {})}
<p>The takeaway? When you emphasize <em>everything</em>, you end up emphasizing <em>nothing</em>. That\u2019s why its important that we stop uncritically asking <em>how</em> we can use color in our charts.</p>
<p>A data visualization is nothing more than a pretty picture if it does not <em>inform</em> its viewer. And if your chart presents 14 different data points all mapped to different colors, what kind of story is it telling? I really like this from Apple\u2019s data visualization practitioner <a href="${"https://medium.com/@Elijah_Meeks/viz-palette-for-data-visualization-color-8e678d996077?"}" rel="${"nofollow"}">Elijah Meeks</a>:</p>
<blockquote><p>Rather than trying to find that impossible 20-color palette, stop using color when you have so many dimensions. It\u2019s indistinguishable, it\u2019s confusing and you\u2019re just off-loading the complexity and decision-making to your reader.</p></blockquote>
<p>That\u2019s why color should be used <em>more sparingly</em> and <em>more thoughtfully</em>. Color is one of the most important parts of our visualizations, yet their current use is far too often gratuitous and overwhelming.</p>
<h2 id="${"so-how-should-you-use-color"}"><a href="${"#so-how-should-you-use-color"}">So, how <em>should</em> you use color?</a></h2>
<p>Color is not the enemy. Rather, the (far too frequent) abuse and misuse of color is. So, how can you use color correctly? It depends on the purpose of your visualization, and, as a corollary, the purpose of color. You should ask: <strong>why am I using color?</strong></p>
<h3 id="${"1-color-to-differentiate"}"><a href="${"#1-color-to-differentiate"}">1) Color to differentiate</a></h3>
<p>One use of color is to draw attention to a data point of interest. This kind of color use would fall into the category of <a href="${"https://www.oreilly.com/library/view/designing-data-visualizations/9781449314774/ch01.html"}" rel="${"nofollow"}">explanatory visualization</a>, as opposed to its exploratory counterpart. If you\u2019ve already explored, analyzed, and probed your data, you now need to deliver those insights to someone else (a supervisor, a client, or a curious friend). It would be a waste of time to present to them all of the exploratory work you did, which is why your presentation should make use of color to focus on your findings.</p>
<p>As practitioner Andy Kirk <a href="${"https://www.visualisingdata.com/2015/01/make-grey-best-friend/"}" rel="${"nofollow"}">puts it</a>, visualization practitioners in this stage of presentation should <strong>make grey their best friend</strong>. This is because the <em>absence of color</em>, not the excessive use of it, helps paint a picture and tell a story. By using grey as the primary color in a visualization, we automatically draw our viewers\u2019 eyes to <span style="${"background: #FF9B9B; color: black; padding: 3px; border-radius: 3px; box-decoration-break: clone;"}">whatever isn\u2019t grey</span>. That way, if we are interested in telling a story about <em>one data point</em>, we can do so quite easily.</p>
<p>Here\u2019s a quick <a href="${"https://github.com/connorrothschild/bbdata"}" rel="${"nofollow"}">example</a> I made in R a while back:</p>
${validate_component(Image, "Image").$$render($$result, {
      alt: "A barplot showcasing vaccination by county in Texas. All bars are grey except the lowest bar, representing Terry County (78% vaccinated), which is highlighted in a royal blue.",
      src: "../images/post/color-in-data-vis/color-emphasized.png"
    }, {}, {})}
<p>The point of the visualization is not to show our audience the kindergarten vaccination rate of <em>every county</em> in Texas. It is instead to highlight the lowest rate\u2014Terry County. This visualization leverages the grey fill of every other bar to immediately draw the audiences\u2019 eyes to Terry County. Because we used only two colors, we can also highlight text in the subtitle to make the connection even clearer for our audience. Color\u2014if used prudently\u2014makes our visualizations more digestible and more informative.</p>
<p>Now, imagine if I visualized that same data in the following way:</p>
${validate_component(Image, "Image").$$render($$result, {
      alt: "A barplot showcasing vaccination by county in Texas. All bars are grey.",
      src: "../images/post/color-in-data-vis/all-grey.jpg"
    }, {}, {})}
<p>Or, even worse:</p>
${validate_component(Image, "Image").$$render($$result, {
      alt: "A barplot showcasing vaccination by county in Texas. All bars are separate colors, with no pattern present.",
      src: "../images/post/color-in-data-vis/all-color.jpg"
    }, {}, {})}
<p>After seeing those eyesores, aren\u2019t you thankful that we used color sparingly in the initial plot?</p>
<p>Perhaps you\u2019re interested in a county-by-county overview of 2016 election results. Although you might be tempted to code all counties according to their Trump/Clinton split, that\u2019s prettier than it is insightful. What if, instead, we focused on those notable counties which flipped from one party to another between 2012 and 2016? From Kieran Healy\u2019s book <a href="${"https://socviz.co/refineplots.html#use-color-to-your-advantage"}" rel="${"nofollow"}">Data Visualization</a>:</p>
${validate_component(Image, "Image").$$render($$result, {
      alt: "A scatterplot where each point represents a county's voting between 2016 and 2020. Highlighted counties 'flipped' between 2016 and 2020, with Republicans highlighted in red and Democrats in blue.",
      src: "../images/post/color-in-data-vis/flipping-points-color.jpg",
      width: "80%",
      centered: "true"
    }, {}, {})}
<p>As we can see here, more counties flipped from majority-Democratic in 2012 to majority-Republican in 2016 than vice-versa. Because we\u2019re focusing on only a fraction of all of the data points, we can also observe trends: The majority of counties that flipped had a small black population. No county that had over a ~53% black population flipped in either direction (annotation my own):</p>
${validate_component(Image, "Image").$$render($$result, {
      alt: "A scatterplot where each point represents a county's voting between 2016 and 2020. Highlighted counties 'flipped' between 2016 and 2020, with Republicans highlighted in red and Democrats in blue. There is an annotation above 53% black to show that no counties with such a population flipped in either direction.",
      src: "../images/post/color-in-data-vis/flipping-points-color-annotate1.jpg",
      width: "80%",
      centered: "true"
    }, {}, {})}
<p>We also notice that flipping direction might be correlated with population size: nearly all of the flipping counties with a log population under 100,000 flipped to Republicans, while a greater proportion of all switching counties flipped toward the Democratic Party if their log population was greater than 100,000.</p>
${validate_component(Image, "Image").$$render($$result, {
      alt: "A scatterplot where each point represents a county's voting between 2016 and 2020. Highlighted counties 'flipped' between 2016 and 2020, with Republicans highlighted in red and Democrats in blue. There is an annotation past population 100,000 to show that more populous counties were more likely to flip Democratic.",
      src: "../images/post/color-in-data-vis/flipping-points-color-annotate2.jpg",
      width: "80%",
      centered: "true"
    }, {}, {})}
<p>Color can, and should, be used to focus on the key parts of your visualization that you want your audience to see. By using color strategically, we can reduce the cognitive load required to understand <em>what</em> a visualization is depicting. <a href="${"https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0183884#pone.0183884.ref008"}" rel="${"nofollow"}">Kalyuga et al.</a> found that color-coding \u201Cameliorated split-attention effects, resulting in lower perceived difficulty.\u201D <a href="${"https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0183884#pone.0183884.ref024"}" rel="${"nofollow"}">Other researchers</a> have reported reductions in cognitive load when experiment participants were provided color-coding.</p>
<p>The overuse of colors can have the opposite effect. In one <a href="${"https://journals-sagepub-com.ezproxy.rice.edu/doi/full/10.1177/1747021818781425"}" rel="${"nofollow"}">2019 paper</a>, researchers found \u201Ctask-irrelevant digit colour information hampers the learning process only in instances where it triggers a conflict with the semantic properties of the base-code words.\u201D What does this mean? If color encoding conflicts with the objects it represents, it impedes learning and weakens understanding. You don\u2019t have to understand what all this means (I don\u2019t dully understand all of it). This point is simply to illustrate: <em>we should care about color</em>. Color can be confusing and complicated, which is why its use should be intentional and minimal. It should be used to draw attention to the important parts of our charts.</p>
<h3 id="${"2-color-to-explore"}"><a href="${"#2-color-to-explore"}">2) Color to explore</a></h3>
<p>Color does not have to be used in contrast to plain old grey. It can also be used as a tool to showcase a variety of data points all mapped to different colors. The important note is that this usage should be sparing. Given our prior examples, we definitely don\u2019t want a plot like this one (from <a href="${"https://serialmentor.com/dataviz/color-pitfalls.html"}" rel="${"nofollow"}">Chapter 19 of Claus Wilke\u2019s <em>Fundamentals of Data Visualization</em></a>):</p>
${validate_component(Image, "Image").$$render($$result, {
      alt: "A scatterplot where each point represents a state, and the x and y axis position showcase population vs population growth. Each state is shaded to a separate color, with no pattern.",
      src: "../images/post/color-in-data-vis/bad-chart.jpg",
      width: "50%",
      centered: "true"
    }, {}, {})}
<p>A more appropriate alternative may look something like this:</p>
${validate_component(Image, "Image").$$render($$result, {
      alt: "A scatterplot where each point represents a state, and the x and y axis position showcase population vs population growth. Each state is shaded according to its region.",
      src: "../images/post/color-in-data-vis/betterchart-1.jpg",
      width: "70%",
      centered: "true"
    }, {}, {})}
<p>This way, the audience can still see general patterns in the data, but they don\u2019t have to treat the fill legend like a lookup table! Most ideally, this chart would have some interactivity, so that a user could hover over a point to see its respective data.</p>
<p>In examples like this, where we are <em>exploring</em> rather than <em>explaining</em>, we leave the exploration to our users; they can see what they want to see and we give them the information they need to do exactly that.</p>
<p>Another common use of color for exploratory purposes is showing data progression across a gradient (e.g. low to high, bad to good, cold to warm).</p>
<p>These examples are most commonly found in <a href="${"https://en.wikipedia.org/wiki/Choropleth_map"}" rel="${"nofollow"}">choropleth maps</a>, where the shade of color in a given state (or county, or region) corresponds to a value of interest. As an example, here\u2019s a <a href="${"https://connorrothschild.github.io/D3.js/map-overdoses/"}" rel="${"nofollow"}">choropleth map</a> I created using D3.js, which visualizes opioid-involved overdose deaths in the United States:</p>
${validate_component(Image, "Image").$$render($$result, {
      alt: "A choropleth chart wherein each state is shaded according to its opioid overdose rate.",
      src: "../images/post/color-in-data-vis/choropleth-ex.jpg",
      width: "70%",
      centered: "true"
    }, {}, {})}
<p>As we can see from the map, \u201Crust belt\u201D states are suffering from the opioid crisis to a much greater degree than those in western states. Choropleth maps utilize color to show regional variation and illustrate the power of color <em>shading</em> to represent the severity or extent of a given variable.</p>
<p>However, color in this context can also be misused. Data may be mapped according to a categorical color scale, or a rainbow scale which makes it difficult to see progression. This chart from <a href="${"https://serialmentor.com/dataviz/color-pitfalls.html"}" rel="${"nofollow"}">Claus O. Wilke</a> is a good (bad) example:</p>
${validate_component(Image, "Image").$$render($$result, {
      alt: "A map of Texas where each county is shaded according to its proportional white population. The color scale is rainbow, making it difficult to detect relative differences.",
      src: "../images/post/color-in-data-vis/map-Texas-rainbow-1.jpg",
      width: "70%",
      centered: "true"
    }, {}, {})}
<p>This chart is pretty! When rainbow scales are used in the media or elsewhere, it may be because their creator asked \u201CHow can I use color to make a pretty picture?\u201D But this use of a non-monotonic color scale means that the relative size of differences between data points are difficult to detect. As an illustration, see how long it takes you to answer this question: using the legend above, what is the percent difference between <span style="${"color:#FF6701;"}">this color </span>and <span style="${"color:#3736FF;"}">this color</span>? (The answer is ~70%.)</p>
<p>In 2019, <a href="${"https://ieeexplore.ieee.org/document/8494817"}" rel="${"nofollow"}">a group of researchers</a> asked climate scientists to evaluate maps depicting changes in climate, where maps were either rainbow (similar to the Texas map above) or monotonic (such as the opioid map earlier). The researchers found that evaluations of magnitude difference in these maps were significantly more accurate when they were encoded with monotonic luminance scales rather than traditional rainbow scales. Other research consistently finds that rainbow color scales are both <a href="${"http://people.renci.org/~borland/pdfs/RainbowColorMap_VisViewpoints.pdf"}" rel="${"nofollow"}">harmful and popular</a>. All this to say: color matters.</p>
<p>So, color can be used for exploratory purposes. That is to say, color doesn\u2019t have to be used exclusively for focus, and it can be used in charts that have colors other than just grey! But exploratory color usage (as with all use of color) requires caution.</p>
<h2 id="${"conclusion"}"><a href="${"#conclusion"}">Conclusion</a></h2>
<p>Color is tricky. While it can take your plot to the next level, it can also ruin it. The difference? The questions we ask. Are we questioning <em>how</em> we can use color; which of the many palettes to use, and how we can map them across variables? These are <a href="${"https://socviz.co/refineplots.html#use-color-to-your-advantage"}" rel="${"nofollow"}">important questions</a>, but they have to be preceded by the question of <em>why</em> we use color in the first place. If color doesn\u2019t serve the purpose of informing, clarifying, or guiding our audience, what purpose does it serve?</p>`
  })}`;
});
var colorInDataVis = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Color_in_data_vis,
  metadata: metadata$b
});
var metadata$a = {
  "layout": "blog",
  "title": 'Feel Free to Do "Something Else" After Graduation',
  "description": "Finding meaningful work",
  "image": "adding-a-chart-to-your-d3-tooltip/header.png",
  "date": "2021-05-02",
  "draft": true,
  "tags": ["personal"]
};
var Do_something_else = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${validate_component(Layout, "Layout_MDSVEX_DEFAULT").$$render($$result, Object.assign($$props, metadata$a), {}, {
    default: () => `<p><a href="${"https://angel.co/post/over-60-of-employees-are-happy-at-startups-far-outpacing-faang-and-msft"}" rel="${"nofollow"}">https://angel.co/post/over-60-of-employees-are-happy-at-startups-far-outpacing-faang-and-msft</a>
<a href="${"https://www.bizjournals.com/sanjose/news/2019/10/17/best-faang-companies-to-work-for-vs-startups.html"}" rel="${"nofollow"}">https://www.bizjournals.com/sanjose/news/2019/10/17/best-faang-companies-to-work-for-vs-startups.html</a>
<a href="${"https://ed.stanford.edu/news/stanford-education-study-provides-new-evidence-big-fish-little-pond-effect-students-globally"}" rel="${"nofollow"}">https://ed.stanford.edu/news/stanford-education-study-provides-new-evidence-big-fish-little-pond-effect-students-globally</a></p>
<p>I graduated college last week. I\u2019ve been thinking about what it means for a new graduate to find a career that they find <em>fulfilling</em>. In my view of things, it seems as if new grads\u2019 plans fall into one of a few categories, which you can usually split up by degree focus.</p>
<p><strong>Non-technical graduates</strong>:</p>
<ol><li>Big consulting (McKinsey, BCG, &amp; Bain, etc.)</li>
<li>Something else (fellowship, graduate school, journalism, government, etc.)</li></ol>
<p><strong>Technical graduates</strong>:</p>
<ol><li>Big tech (FAANG, etc.)</li>
<li>Something else (startup, civic tech, etc.)</li></ol>
<p>Is it reductive to categorize <em>all jobs</em> into these four categories? Check my LinkedIn feed, and you\u2019ll realize that enough graduates pursue the first option from each group (big consulting/big tech) that other jobs almost seem like an afterthought. (Apparently, <a href="${"https://medium.com/s/story/a-culture-of-prestige-98c8671ceade"}" rel="${"nofollow"}">~40% of Harvard grads</a> and <a href="${"https://yaledailynews.com/post/2019/11/01/mckinsey-and-the-fig-tree/"}" rel="${"nofollow"}">~29% of Yale grads</a> go into finance or consulting after college.)</p>
<p>Of course, these sets of options mirror one another. Most students who aren\u2019t set on a JD, PhD, or MD will ask themselves whether they want to pursue the safe, well-paying, \u201Cbig\u201D option after graduating, or something else. </p>
<p>When they do choose, there\u2019s not much enthusiasm\u2014it\u2019s a tradeoff. These bigger companies offer alluring signing bonuses, prestige, and exorbitant salaries. In return, they ask you to put up with longer-than-usual hours and more monotonous work.</p>
<p>I\u2019m writing about <em>taking the risk</em>\u2014doing the \u201Csomething else\u201D that isn\u2019t McKinsey or Microsoft. There\u2019s value in the something else, and I hope I can encourage you it\u2019s more than consolation, it\u2019s a career.</p>
${validate_component(Info, "Info").$$render($$result, {}, {}, {
      default: () => `<p>Please note that I\u2019m not dunking on my friends who take these impressive jobs, but instead writing to people who are doing something else, whether by their own choice or not. Microsoft friends, I love you</p>`
    })}
<h2 id="${"establishing-the-stakes"}"><a href="${"#establishing-the-stakes"}">Establishing the stakes</a></h2>
<p><strong>Work is the most important thing we do.</strong> Not in the late-capitalism/workaholic-father type of way, but in the sense that you spend the majority of your day doing it. Every (week)day, you spend between 8 and 10 hours on work, and so you <em>cannot overstate</em> how important work is. If you dislike your work, you\u2019re unlikely to enjoy your life.  All this to say, make the decisions you make about work <em>intentionally</em> and not because of pressure, prestige, or anything else.</p>
<h2 id="${"fulfillment"}"><a href="${"#fulfillment"}">Fulfillment</a></h2>
<p>In 2019, <a href="${"https://angel.co/"}" rel="${"nofollow"}">AngelList</a> and <a href="${"https://www.teamblind.com/"}" rel="${"nofollow"}">Blind</a> surveyed 11,000 employees across FAANG and various startups, asking about job satisfaction and the factors that influence it. Their findings? <strong>Employees at startups were much happier than their FAANG counterparts.</strong></p>
${validate_component(Image, "Image").$$render($$result, {
      src: "post/do-something-else/startup-faang-satisfaction.png",
      alt: "A bar graph showing higher rates of job satisfaction among startup employees compared to FAANG employees."
    }, {}, {})}
<p>Data on early-career consultants in non-technical fields is harder to come by, but generally employees are <a href="${"https://poetsandquants.com/2017/09/10/job-satisfaction-rates-at-top-consulting-firms/3/"}" rel="${"nofollow"}">relatively satisfied despite the long hours</a>. Many consultants, however, do quit their job and pursue <a href="${"https://hbr.org/2019/07/why-consultants-quit-their-jobs-to-go-independent"}" rel="${"nofollow"}">independent consulting</a>, where they tend to be <a href="${"https://www.consultancy.uk/news/12795/independent-management-consultants-are-happier-and-half-earn-more"}" rel="${"nofollow"}">happier</a>.</p>
<p>And so there might be a tradeoff between prestige and satisfaction within these high-profile organizations. Definitely in tech, and perhaps in other spaces, work can be <em>better paying</em> but <em>less fulfilling</em>.</p>
<p>There could be many reasons for this, but I suspect a large one is <strong>structure</strong>. Taking a job at a big tech or big consulting company means you\u2019re subject to their structure. More often than not, the organizations have narrowly defined roles due to their massive size. As such, you assume whatever role they give you, with perhaps a little wiggle room. Some like this scope of work. For others, it can be stifling. It can come at the expense of your creativity and feel as if you have little room to grow.</p>
<p>The \u201Csomething else\u201D jobs, by contrast, are probably more variegated. To feel fulfilled, I think a job needs two things: 1) work that is <em>in line with your passions</em>, and 2) work that is <em>commensurate with your capacity</em>.</p>
<h4 id="${"passion"}"><a href="${"#passion"}">Passion</a></h4>
<p>If you don\u2019t like the work you do, you won\u2019t feel fulfilled. If your values don\u2019t align with the mission of your organization, you feel tension at work. When graduating seniors talk about post-grad plans, they sometimes mention \u201Cselling their soul\u201D to work for organizations that they disagree with. (E.g. graduates working for McKinsey after news broke of their <a href="${"https://www.nytimes.com/2019/12/03/us/mckinsey-ICE-immigration.html"}" rel="${"nofollow"}">partnerships with ICE</a>, or working for Facebook amidst one of their many controversies.)</p>
<p>It\u2019s totally fine to disagree with some of the values of your employer. Many do it their entire life. But wouldn\u2019t it be nice to be passionate about the work you do on a daily basis? The \u201Csomething else\u201D jobs offer this kind of relief; depending on <em>what</em> you pursue, you can find a job that not only aligns with, but strengthens, your existing passions.</p>
<h4 id="${"capacity"}"><a href="${"#capacity"}">Capacity</a></h4>
<p>But perhaps the bigger component of fulfillment, on a day-to-day basis, is how challenged you are by your work. Material success and external validation make you feel good, but work has to be sufficiently <em>intellectually stimulating</em> to make you feel fulfilled on a daily basis.</p>
<p>The problem is, big consulting and big tech companies <strong>necessarily</strong> constrain the work you do to better meet the needs of their organization. Rarely can you work in such a behemoth of an organization and also do work that lines up well with your skillset, capacity, and interests. </p>
<p>As an incoming entry-level employee at Microsoft, you join 144,000 other employees. The organization is structured hierarchically, and you assume the role that you\u2019re given. Is there some level of matching at play? Definitely. But are you able to apply yourself as you would in a personal project, or as you could in a smaller, less rigid organization? Definitely not. </p>
<p>As an incoming entry-level employee at McKinsey, share a similar experience. Your job infamously requires you to travel often, sit through countless meetings, and work long hours. Peers in these positions joke about how their job responsibilities are 1) sending emails, 2) sitting through meetings, and 3) designing PowerPoints.</p>
<p>In both of these contexts, you have this much capacity and competence:</p>
<progress style="${"width: 80%;"}" value="${"100"}" max="${"100"}"></progress>
<p>But larger companies hire you <em>so that you can exercise this much of it</em>:</p>
<progress style="${"width: 80%;"}" value="${"30"}" max="${"100"}"></progress>
<p>To make matters worse, we start working in these rigid organizations right after we graduate, which (for most people) is the <em>most exhilarating, unique, and stimulting experience of our lives</em>. We\u2019re familiar with challenging work (often too challenging), and so the contrast between college and work becomes even more stark. </p>
<h2 id="${"conclusion"}"><a href="${"#conclusion"}">Conclusion</a></h2>
<p><em>Searching for jobs is stressful.</em> When we\u2019re anxious about where we\u2019ll be after graduation, the prospect of earning six figures with a hefty signing bonus is an appealing one. But how often does this mean exchanging passion, creativity &amp; fulfillment for money &amp; status?</p>
<p><strong>Please don\u2019t be scared to do \u201Csomething else.\u201D</strong> Find the job that makes you tick, even if its risky. Work is the most important thing we do, and if it <em>can be</em> fulfilling, make it so! </p>
<hr>
<h1 id="${"counterarguments"}"><a href="${"#counterarguments"}">Counterarguments</a></h1>
<p>Here are some valid counterarguments to my thinking:</p>
<h3 id="${"consultants-like-their-jobs"}"><a href="${"#consultants-like-their-jobs"}">Consultants like their jobs</a></h3>
<ul><li>A <a href="${"https://www.ft.com/content/2cc98fb4-049d-11e1-ac2a-00144feabdc0"}" rel="${"nofollow"}">2011 survey</a> from the Management Consultancies Association found that two thirds of young consultants ranked their job satisfaction as \u201Cgood\u201D or \u201Cvery good.\u201D</li>
<li>There seems to be great heterogeneity in job satisfaction; <a href="${"https://poetsandquants.com/2017/09/10/job-satisfaction-rates-at-top-consulting-firms/3/"}" rel="${"nofollow"}">Wall Street Oasis data</a> has McKinsey with a remarkable 98.6/100, compared to the lowest at Chatham Financial, with 57.7. (I have no idea what their methodology is.)</li></ul>
<h3 id="${"consultantsbig-tech-employees-are-only-there-for-a-short-period-of-time"}"><a href="${"#consultantsbig-tech-employees-are-only-there-for-a-short-period-of-time"}">Consultants/big tech employees are only there for a short period of time</a></h3>
<ul><li>Many recent graduates </li></ul>
<h3 id="${"something-else-jobs-arent-well-paying-enough"}"><a href="${"#something-else-jobs-arent-well-paying-enough"}">\u201CSomething else\u201D jobs aren\u2019t well-paying enough</a></h3>
<h3 id><a href="${"#"}"></a></h3>
<h1 id="${"appendix"}"><a href="${"#appendix"}">Appendix</a></h1>
<p>Consultants work <em>so much</em>. From <a href="${"https://poetsandquants.com/2017/09/10/job-satisfaction-rates-at-top-consulting-firms/3/"}" rel="${"nofollow"}">Poets and Quants</a>:</p>
<table><thead><tr><th>Firm</th>
<th>Average Weekly Hours Worked</th></tr></thead>
<tbody><tr><td>EVA Dimensions</td>
<td>75.0</td></tr>
<tr><td>Teneo</td>
<td>72.5</td></tr>
<tr><td>Galt and Company</td>
<td>70.0</td></tr>
<tr><td>McKinsey &amp; Co.</td>
<td>68.8</td></tr>
<tr><td>Strategy&amp;</td>
<td>67.2</td></tr>
<tr><td>Keystone Strategy</td>
<td>65.0</td></tr>
<tr><td>Bain &amp; Co.</td>
<td>64.7</td></tr>
<tr><td>Oliver Wyman</td>
<td>64.6</td></tr>
<tr><td>The Parthenon Group</td>
<td>63.9</td></tr>
<tr><td>BCG</td>
<td>63.6</td></tr>
<tr><td>A.T. Kearney</td>
<td>63.0</td></tr>
<tr><td>Mars &amp; Co.</td>
<td>63.0</td></tr>
<tr><td>LEK Consulting</td>
<td>62.6</td></tr>
<tr><td>OCC Strategy Consultants</td>
<td>62.5</td></tr>
<tr><td>Arthur D. Little</td>
<td>62.5</td></tr>
<tr><td>Roland Berger Strategy Consultants</td>
<td>62.0</td></tr>
<tr><td>The Cambridge Group</td>
<td>61.7</td></tr>
<tr><td>IMS Consulting Group</td>
<td>60.7</td></tr>
<tr><td>Public Consulting Group</td>
<td>60.0</td></tr>
<tr><td>Crowe Horwath</td>
<td>60.0</td></tr>
<tr><td>Simon Kucher Partners</td>
<td>60.0</td></tr>
<tr><td>Corporate Value Associates</td>
<td>60.0</td></tr>
<tr><td>Parthenon Group-EY</td>
<td>58.3</td></tr>
<tr><td>The Brattle Group</td>
<td>58.3</td></tr>
<tr><td>Innosight</td>
<td>58.3</td></tr>
<tr><td>Marakon</td>
<td>57.5</td></tr>
<tr><td>Accenture</td>
<td>55.8</td></tr>
<tr><td>ZS Associates</td>
<td>55.6</td></tr>
<tr><td>Deloitte</td>
<td>55.5</td></tr>
<tr><td>PwC</td>
<td>55.5</td></tr></tbody></table>
`
  })}`;
});
var doSomethingElse = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Do_something_else,
  metadata: metadata$a
});
var metadata$9 = {
  "layout": "blog",
  "title": "Announcing the Nuxt Blog Starter",
  "date": "2021-02-10",
  "description": "A minimal, content-focused blog site built with NuxtJS and Bulma.",
  "image": "nuxt-blog-starter/header.png",
  "featured": true,
  "tags": ["vue", "nuxt", "package"]
};
var Nuxt_blog_starter = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${validate_component(Layout, "Layout_MDSVEX_DEFAULT").$$render($$result, Object.assign($$props, metadata$9), {}, {
    default: () => `<p>I\u2019m happy to share a <a href="${"https://github.com/connorrothschild/nuxt-blog-starter"}" rel="${"nofollow"}">new starter template</a> for minimal, content-focused blogs using NuxtJS and Bulma for styling. The site is a more simplified version of <a href="${"https://www.connorrothschild.com/"}" rel="${"nofollow"}">my own site</a>.</p>
<h2 id="${"why-nuxt"}"><a href="${"#why-nuxt"}">Why Nuxt?</a></h2>
<p>I\u2019ve went through my fair share of blogs. See <a href="${"https://connorrothschild.github.io/v1/"}" rel="${"nofollow"}">version 1</a> and <a href="${"https://connorrothschild.github.io/v2/"}" rel="${"nofollow"}">version 2</a>. I moved to a site using Nuxt for three reasons:</p>
<h4 id="${"1-speed-and-user-experience"}"><a href="${"#1-speed-and-user-experience"}">1. Speed and user experience</a></h4>
<p>Nuxt is fast by default. It uses server-side rendering, rather than client-side rendering, which means that content is rendered before users visit your site. As explained on the <a href="${"https://nuxtjs.org/post/going-full-static/"}" rel="${"nofollow"}">Nuxt Blog</a>:</p>
<blockquote><p><code>nuxt generate</code> with <code>target: &#39;static&#39;</code> will pre-render all your pages to HTML and save a payload file in order to mock <code>asyncData</code> and <code>fetch</code> on client-side navigation, this means no more HTTP calls to your API on client-side navigation. By extracting the page payload to a js file, it also reduces the HTML size served as well as preloading it (from the in the header) for optimal performance.</p></blockquote>
<p>You can see the impact of SSR on performance by comparing my <a href="${"https://developers.google.com/speed/pagespeed/insights/?url=https%3A%2F%2Fconnorrothschild.github.io%2Fv2%2F&tab=desktop"}" rel="${"nofollow"}">last blog iteration</a> to <a href="${"https://developers.google.com/speed/pagespeed/insights/?url=https%3A%2F%2Fwww.connorrothschild.com%2F&tab=desktop"}" rel="${"nofollow"}">this one</a>.</p>
<p>The former, built using <a href="${"https://bookdown.org/yihui/blogdown/"}" rel="${"nofollow"}">R <code>blogdown</code></a> and <a href="${"https://themes.gohugo.io/academic/"}" rel="${"nofollow"}">Hugo Academic</a>, scored 72/100 on desktop performance, compared to a 100/100 on this version:</p>
${validate_component(Image, "Image").$$render($$result, {
      src: "../images/post/nuxt-blog-starter/old-site-perf.png",
      alt: "Old site performance. 72/100",
      width: "48%"
    }, {}, {})}
${validate_component(Image, "Image").$$render($$result, {
      src: "../images/post/nuxt-blog-starter/new-site-perf.png",
      alt: "New site performance. 100/100",
      width: "48%"
    }, {}, {})}
<h4 id="${"2-flexibility-and-power"}"><a href="${"#2-flexibility-and-power"}">2. Flexibility and power</a></h4>
<p>Too often, making \u2018fast\u2019 websites comes at the cost of flexibility and power. For example, the first version of my website was based on a <a href="${"https://github.com/katmh/point-theme"}" rel="${"nofollow"}">Jekyll theme</a> that was pretty, functional, and fast, but limited in its flexibility. That is, I was locked into the default appearance of the site, unless I wanted to really get into the weeds editing CSS and writing my own HTML markup. (At that point, I might as well had started a new blog or find another theme!)</p>
<p>I built this template because it is as performant as my V1 site (both receive over 95/100 on <a href="${"https://developers.google.com/speed/pagespeed/insights/"}" rel="${"nofollow"}">PageSpeed Insights</a>), but with much more flexibility. In my experience, modifying the appearance of this site\u2014whether thats through its constituent components in the <code>components/</code> folder, or globally in the <code>assets/scss/colors.scss</code> file\u2014is seamless while also allowing greater power than modifying the defaults in other, simpler blog templates.</p>
<p>Moreover, this kind of flexibility scales up with your knowledge of Vue and Nuxt. If you are already familiar with the technologies, this template should be ready for total transformation through whatever modifications you find necessary. Otherwise, all you need to do is follow the simple instructions in the template\u2019s <a href="${"https://github.com/connorrothschild/nuxt-blog-starter"}" rel="${"nofollow"}">README</a>. To test this, I\u2019ve helped a non-technical friend build out his <a href="${"https://dyllonschmehl.netlify.app/"}" rel="${"nofollow"}">own website</a> from this theme, and seen firsthand how intuitive getting started can really be.</p>
<h4 id="${"3-learning-new-tech"}"><a href="${"#3-learning-new-tech"}">3. Learning new tech</a></h4>
<p>A final reason to make this jump is to get familiar with <a href="${"https://www.javascript.com/"}" rel="${"nofollow"}">JavaScript</a>, <a href="${"https://vuejs.org/"}" rel="${"nofollow"}">Vue</a>, <a href="${"https://nuxtjs.org/"}" rel="${"nofollow"}">Nuxt</a>, and <a href="${"https://www.w3schools.com/css/"}" rel="${"nofollow"}">CSS</a>. Many of my readers come from a visualization-centric background, and are most proficient in R. (Awesome!) I learned Vue (and then Nuxt) from scratch, by building a <a href="${"https://connorrothschild.github.io/cudi-hums/"}" rel="${"nofollow"}">few</a> <a href="${"https://connorrothschild.github.io/how-many-people/"}" rel="${"nofollow"}">projects</a> and subsequently, my personal website!</p>
<p><strong>Learning new tech never hurts.</strong> You will almost never regret spending a few hours to have a basic handle of a new language or tool. Get started with this template, see how it feels, and see if you like it! (If not, ditch the site! I won\u2019t be offended.)</p>
<h2 id="${"why-this-template-specifically"}"><a href="${"#why-this-template-specifically"}">Why this template specifically?</a></h2>
<p>I didn\u2019t invent Nuxt, nor the portfolio site. There are a few other options for powerful, pretty starter templates using NuxtJS. In particular, I like <a href="${"https://github.com/marinaaisa/nuxt-markdown-blog-starter"}" rel="${"nofollow"}">Marina Aisa\u2019s</a> and <a href="${"https://templates.netlify.com/template/awake-blog-template-nuxt/"}" rel="${"nofollow"}">Daniel Kelly\u2019s</a>.</p>
<p>That being said, I think my site is pretty cool. In creating the template, I\u2019ve aimed for a mix of <strong>out-of-the-box features that \u201Cjust work\u201D</strong>, with the <strong>ability to customize as necessary.</strong> I want to allow new users, who have little to no experience with web development, to create a blog, and allow advanced users, who probably know this stuff better than me, to get started with a powerful and customizable template.</p>
<p>There are a few features I think make this starter template unique:</p>
<h3 id="${"easy-theming"}"><a href="${"#easy-theming"}">Easy theming</a></h3>
<p>The site relies on three colors: a primary (background), secondary (accent), and a primary-invert (text). These are all defined in Sass variables that live in <code>assets/scss/colors.scss</code>. To change the appearance of your site, simply modify the colors you\u2019d like to see as your background (<code>$primary</code>), your text (<code>$text</code>), and your accent (<code>$secondary</code>). Obviously, make sure your <code>$primary</code> and <code>$text</code> colors have sufficient contrast.</p>
<h4 id="${"dark-modelight-mode"}"><a href="${"#dark-modelight-mode"}">Dark mode/light mode</a></h4>
<p>An example of this can be seen below the Sass defaults that live within <code>assets/scss/colors.scss</code>. Simply uncomment those lines (preceded by the comment \u201CLIGHT MODE\u201D) to see your site with light mode defaults.</p>
${validate_component(Image, "Image").$$render($$result, {
      src: "../images/post/nuxt-blog-starter/dark.png",
      alt: "Dark mode",
      width: "49%"
    }, {}, {})}
${validate_component(Image, "Image").$$render($$result, {
      src: "../images/post/nuxt-blog-starter/light.png",
      alt: "Light mode",
      width: "49%"
    }, {}, {})}
<h3 id="${"dope-transitions"}"><a href="${"#dope-transitions"}">Dope transitions</a></h3>
<p>Nuxt makes transitions easy. This template expands upon Nuxt\u2019s powerful page transitions by using <a href="${"https://greensock.com/gsap/"}" rel="${"nofollow"}">Greensock\u2019s GSAP</a>. In particular, I define elements that should fade in nicely for each page, like this:</p>
${validate_component(Code, "Code").$$render($$result, { language: "js" }, {}, {
      default: () => `<pre class="${"language-js"}"><!-- HTML_TAG_START -->${`<code class="language-js">transition<span class="token operator">:</span> <span class="token punctuation">&#123;</span>
    mode<span class="token operator">:</span> <span class="token string">'out-in'</span><span class="token punctuation">,</span>
    css<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
    <span class="token function">enter</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        TweenMax<span class="token punctuation">.</span><span class="token function">fromTo</span><span class="token punctuation">(</span><span class="token string">".title"</span><span class="token punctuation">,</span> 
            <span class="token punctuation">&#123;</span>x<span class="token operator">:</span> <span class="token string">"10%"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>x<span class="token operator">:</span> <span class="token string">"0%"</span> <span class="token punctuation">,</span> duration<span class="token operator">:</span> <span class="token number">0.1</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        TweenMax<span class="token punctuation">.</span><span class="token function">fromTo</span><span class="token punctuation">(</span><span class="token string">".subtitle, .card, .img"</span><span class="token punctuation">,</span>
            <span class="token punctuation">&#123;</span>x<span class="token operator">:</span> <span class="token string">"10%"</span><span class="token punctuation">,</span> autoAlpha<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
            <span class="token punctuation">&#123;</span>x<span class="token operator">:</span> <span class="token string">"0%"</span><span class="token punctuation">,</span> autoAlpha<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> delay<span class="token operator">:</span> <span class="token number">0.25</span><span class="token punctuation">,</span> duration<span class="token operator">:</span> <span class="token number">0.5</span><span class="token punctuation">,</span> ease<span class="token operator">:</span> Power3<span class="token punctuation">.</span>easeOut<span class="token punctuation">&#125;</span>
        <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">,</span></code>`}<!-- HTML_TAG_END --></pre>`
    })}
<p>This creates some subtle yet attractive page transitions:</p>
${validate_component(Image, "Image").$$render($$result, {
      src: "../images/post/nuxt-blog-starter/transitions.gif",
      alt: "GIF showcasing transitions of home page, to blog post pagfe, to a single blog post."
    }, {}, {})}
<p>You can modify these transitions by adding and removing elements in the CSS selector parameters for each page\u2019s <code>enter()</code> property.</p>
<h3 id="${"meta-tagsseo"}"><a href="${"#meta-tagsseo"}">Meta tags/SEO</a></h3>
<p>The function <code>getSiteMeta()</code>, found in the <code>utils/</code> folder, allows for different meta tags for each page and for each blog post. The function allows the Twitter Cards for my home page and for a blog post to look different, like this:</p>
${validate_component(Image, "Image").$$render($$result, {
      src: "../images/post/nuxt-blog-starter/home-card.png",
      alt: "Twitter card of homepage",
      width: "47.2%"
    }, {}, {})}
${validate_component(Image, "Image").$$render($$result, {
      src: "../images/post/nuxt-blog-starter/blog-card.png",
      alt: "Twitter card of blog post page",
      width: "50%"
    }, {}, {})}
<p>The site is set up so that your cards will appear this way automatically! All you will have to do is edit <a href="${"https://github.com/connorrothschild/nuxt-blog-starter/blob/master/utils/getSiteMeta.js"}" rel="${"nofollow"}"><code>utils/getSiteMeta.js</code></a> with your specific information. Page-specific meta tags are also helpful for search engine optimization; your site might attract a larger number of visitors if it covers a wider variety of keywords.</p>
<h2 id="${"blog-features"}"><a href="${"#blog-features"}">Blog features</a></h2>
<p>This site comes with all the same blog capabilities as a normal site, such as syntax highlighting, images, HTML support, and Vue components. Read <a href="${"https://nuxtjs.org/post/creating-blog-with-nuxt-content/"}" rel="${"nofollow"}">this post</a> if you\u2019re curious about features.</p>
<p>You can also include a few custom components I\u2019ve made:</p>
<h3 id="${"info-boxes"}"><a href="${"#info-boxes"}">Info boxes</a></h3>
<p><strong><a href="${"https://github.com/connorrothschild/nuxt-blog-starter/blob/master/components/global/InfoBox.vue"}" rel="${"nofollow"}"><code>InfoBox.vue</code></a></strong> is a component that allows you to put notes/warnings/messages in your blog posts. Feel free to edit the component to adjust its styling.</p>
${validate_component(Info, "Info").$$render($$result, {}, {}, {
      default: () => `<p>Info boxes look like this!</p>`
    })}
<h3 id="${"images"}"><a href="${"#images"}">Images</a></h3>
<p><strong><a href="${"https://github.com/connorrothschild/nuxt-blog-starter/blob/master/components/global/InlineImage.vue"}" rel="${"nofollow"}"><code>InlineImage.vue</code></a></strong> optimizes and handles the messy parts of images.</p>
<p>In specific, it:</p>
<ul><li>Allows for fullscreen, gallery views via <a href="${"https://github.com/crowdbotics/v-img"}" rel="${"nofollow"}"><code>v-img</code></a>.</li>
<li>Optimizes images with <a href="${"https://github.com/juliomrqz/nuxt-optimized-images"}" rel="${"nofollow"}"><code>nuxt-optimized-images</code></a>.</li></ul>
<h3 id="${"videos"}"><a href="${"#videos"}">Videos</a></h3>
<p><strong><a href="${"https://github.com/connorrothschild/nuxt-blog-starter/blob/master/components/global/ResponsiveVideo.vue"}" rel="${"nofollow"}"><code>ResponsiveVideo.vue</code></a></strong> takes a YouTube url (or otherwise embeddable video link) and makes it responsive.</p>
<p>You can see all of these components in action in the <a href="${"https://nuxt-blog-starter.netlify.app/post/welcome"}" rel="${"nofollow"}">sample blog post</a>.</p>
<h2 id="${"get-started"}"><a href="${"#get-started"}">Get started</a></h2>
<p>Get started! <a href="${"https://github.com/connorrothschild/nuxt-blog-starter"}" rel="${"nofollow"}">Fork the repository here</a> and follow instructions in the README to get started. Please reach out with any questions, either through filing an issue or via <a href="${"mailto:connor@connorrothschild.com"}">email</a>.</p>`
  })}`;
});
var nuxtBlogStarter = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Nuxt_blog_starter,
  metadata: metadata$9
});
var css$1 = {
  code: "div.svelte-17u5tpa{margin:1.35rem auto}img.svelte-17u5tpa{margin-bottom:0.5rem}a.svelte-17u5tpa{font-weight:300;font-family:var(--font-sans);text-align:right;letter-spacing:0.64px;width:100%;margin-left:auto;display:block}@media screen and (max-width: 768px){div.svelte-17u5tpa{width:100% !important}}",
  map: '{"version":3,"file":"TableHandler.svelte","sources":["TableHandler.svelte"],"sourcesContent":["<script>\\n  export let src;\\n  export let alt;\\n  export let link;\\n  export let width = \\"100%\\";\\n<\/script>\\n\\n<div style=\\"width: {width};\\">\\n  <img {src} {alt} width=\\"100%\\" />\\n  <a href={link} target=\\"_blank\\" class=\\"no-underline\\"\\n    >The original, interactive table can be found here</a\\n  >\\n</div>\\n\\n<style>\\n  div {\\n    margin: 1.35rem auto;\\n  }\\n\\n  img {\\n    margin-bottom: 0.5rem;\\n  }\\n\\n  a {\\n    font-weight: 300;\\n    font-family: var(--font-sans);\\n    text-align: right;\\n    letter-spacing: 0.64px;\\n    width: 100%;\\n    margin-left: auto;\\n    display: block;\\n  }\\n\\n  @media screen and (max-width: 768px) {\\n    div {\\n      width: 100% !important;\\n    }\\n  }\\n</style>\\n"],"names":[],"mappings":"AAeE,GAAG,eAAC,CAAC,AACH,MAAM,CAAE,OAAO,CAAC,IAAI,AACtB,CAAC,AAED,GAAG,eAAC,CAAC,AACH,aAAa,CAAE,MAAM,AACvB,CAAC,AAED,CAAC,eAAC,CAAC,AACD,WAAW,CAAE,GAAG,CAChB,WAAW,CAAE,IAAI,WAAW,CAAC,CAC7B,UAAU,CAAE,KAAK,CACjB,cAAc,CAAE,MAAM,CACtB,KAAK,CAAE,IAAI,CACX,WAAW,CAAE,IAAI,CACjB,OAAO,CAAE,KAAK,AAChB,CAAC,AAED,OAAO,MAAM,CAAC,GAAG,CAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AACpC,GAAG,eAAC,CAAC,AACH,KAAK,CAAE,IAAI,CAAC,UAAU,AACxB,CAAC,AACH,CAAC"}'
};
var TableHandler = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { src: src2 } = $$props;
  let { alt } = $$props;
  let { link } = $$props;
  let { width = "100%" } = $$props;
  if ($$props.src === void 0 && $$bindings.src && src2 !== void 0)
    $$bindings.src(src2);
  if ($$props.alt === void 0 && $$bindings.alt && alt !== void 0)
    $$bindings.alt(alt);
  if ($$props.link === void 0 && $$bindings.link && link !== void 0)
    $$bindings.link(link);
  if ($$props.width === void 0 && $$bindings.width && width !== void 0)
    $$bindings.width(width);
  $$result.css.add(css$1);
  return `<div style="${"width: " + escape(width) + ";"}" class="${"svelte-17u5tpa"}"><img${add_attribute("src", src2, 0)}${add_attribute("alt", alt, 0)} width="${"100%"}" class="${"svelte-17u5tpa"}">
  <a${add_attribute("href", link, 0)} target="${"_blank"}" class="${"no-underline svelte-17u5tpa"}">The original, interactive table can be found here</a>
</div>`;
});
var metadata$8 = {
  "layout": "blog",
  "title": "Firearm Background Checks Are Spiking",
  "description": "Visualizing the precipitous rise in gun sales during COVID-19",
  "date": "2020-07-02",
  "image": "covid-gun-spikes/header.png",
  "featured": true,
  "tags": ["analysis", "r"]
};
var Covid_gun_spikes = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${validate_component(Layout, "Layout_MDSVEX_DEFAULT").$$render($$result, Object.assign($$props, metadata$8), {}, {
    default: () => `${validate_component(Image, "Image").$$render($$result, {
      src: "../images/post/covid-gun-spikes/featured.png",
      alt: "A small multiples map showing spikes in firearm background checks in 2020, compared to 1999-2019"
    }, {}, {})}
<p>So far in 2020, firearm background checks are happening <strong>significantly</strong> more frequently than they did during the first six months of the last 20 years. Some <a href="${"https://www.nytimes.com/interactive/2020/04/01/business/coronavirus-gun-sales.html"}" rel="${"nofollow"}">media reports</a> captured the gun-buying frenzy during its apparent peak in March, but according to data from the <a href="${"https://www.fbi.gov/file-repository/nics_firearm_checks_-_month_year_by_state_type.pdf/view"}" rel="${"nofollow"}">FBI NICS</a>, <em>the month of June saw the largest single month count of firearm background checks in the last 20 years.</em></p>
<p>The data, <a href="${"https://github.com/BuzzFeedNews/nics-firearm-background-checks"}" rel="${"nofollow"}">which is scraped and cleaned by BuzzFeed News</a>, shows a massive spike in firearm background checks in the last 5 months:</p>
${validate_component(Code, "Code").$$render($$result, { language: "r", showLineNumbers: false }, {}, {
      default: () => `<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">library<span class="token punctuation">(</span>reactable<span class="token punctuation">)</span>
library<span class="token punctuation">(</span>tidyverse<span class="token punctuation">)</span>
library<span class="token punctuation">(</span>geofacet<span class="token punctuation">)</span>
library<span class="token punctuation">(</span>scales<span class="token punctuation">)</span>
library<span class="token punctuation">(</span>cr<span class="token punctuation">)</span>

set_cr_theme<span class="token punctuation">(</span>font <span class="token operator">=</span> <span class="token string">"IBM Plex Sans"</span><span class="token punctuation">)</span>

data <span class="token operator">&lt;-</span> readr<span class="token operator">::</span>read_csv<span class="token punctuation">(</span><span class="token string">'data/data.csv'</span><span class="token punctuation">)</span>

data <span class="token operator">&lt;-</span> data <span class="token percent-operator operator">%>%</span>
  mutate<span class="token punctuation">(</span>month <span class="token operator">=</span> as.Date<span class="token punctuation">(</span>paste<span class="token punctuation">(</span>month<span class="token punctuation">,</span> <span class="token string">"-01"</span><span class="token punctuation">,</span> sep <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        year <span class="token operator">=</span> lubridate<span class="token operator">::</span>year<span class="token punctuation">(</span>month<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token percent-operator operator">%>%</span>
  filter<span class="token punctuation">(</span>year <span class="token operator">!=</span> <span class="token number">1998</span><span class="token punctuation">)</span>

data <span class="token percent-operator operator">%>%</span>
  mutate<span class="token punctuation">(</span>month <span class="token operator">=</span> lubridate<span class="token operator">::</span>month<span class="token punctuation">(</span>month<span class="token punctuation">)</span><span class="token punctuation">,</span>
        month <span class="token operator">=</span> month.abb<span class="token punctuation">[</span>month<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token percent-operator operator">%>%</span>
  group_by<span class="token punctuation">(</span>year<span class="token punctuation">,</span> month<span class="token punctuation">)</span> <span class="token percent-operator operator">%>%</span>
  summarise<span class="token punctuation">(</span>sum <span class="token operator">=</span> sum<span class="token punctuation">(</span>totals<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token percent-operator operator">%>%</span>
  reactable<span class="token punctuation">(</span>
    defaultSorted <span class="token operator">=</span> <span class="token string">'sum'</span><span class="token punctuation">,</span>
    defaultSortOrder <span class="token operator">=</span> <span class="token string">'desc'</span><span class="token punctuation">,</span>
    defaultColDef <span class="token operator">=</span> colDef<span class="token punctuation">(</span>headerClass <span class="token operator">=</span> <span class="token string">"header"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    compact <span class="token operator">=</span> <span class="token boolean">TRUE</span><span class="token punctuation">,</span>
    fullWidth <span class="token operator">=</span> <span class="token boolean">FALSE</span><span class="token punctuation">,</span>
    columns <span class="token operator">=</span> list<span class="token punctuation">(</span>
      month <span class="token operator">=</span> colDef<span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"Month"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      year <span class="token operator">=</span> colDef<span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"Year"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      sum <span class="token operator">=</span> colDef<span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"# of Firearm Background Checks"</span><span class="token punctuation">,</span>
                  format <span class="token operator">=</span> colFormat<span class="token punctuation">(</span>separators <span class="token operator">=</span> <span class="token boolean">TRUE</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">)</span><span class="token punctuation">,</span>
    rowStyle <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>.<span class="token punctuation">[</span>index<span class="token punctuation">,</span> <span class="token string">"year"</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">2020</span><span class="token punctuation">)</span>
        list<span class="token punctuation">(</span>fontWeight <span class="token operator">=</span> <span class="token string">"bold"</span><span class="token punctuation">,</span>
            background <span class="token operator">=</span> <span class="token string">"rgba(0, 0, 0, 0.05)"</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
  <span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>`
    })}
${validate_component(TableHandler, "TableHandler").$$render($$result, {
      src: "../images/post/covid-gun-spikes/table-replacement.png",
      alt: "A table showing the years and months with the greatest number of firearm background checks. Those in 2020 are among the highest.",
      link: "http://connorrothschild.github.io/v2/post/covid-gun-spikes/",
      width: "70%"
    }, {}, {})}
<p>As the table shows, the last 5 months have seen some of the greatest numbers of firearm background checks since the FBI has collected such data. It seems as if the only non-2020 entrants to the top 7 are from December 2015, and December 2019, which are (perhaps coincidentally) both the final months before new presidents took office.</p>
<p>Visually, we see that firearm background checks follow some seasonal trends, but by and large, have undergone unprecedented spikes in the last 5 months:</p>
${validate_component(Code, "Code").$$render($$result, { language: "r", showLineNumbers: false }, {}, {
      default: () => `<pre class="${"language-undefined"}"><!-- HTML_TAG_START -->${`<code class="language-undefined">data %&gt;%
  group_by(month) %&gt;%
  summarise(sum = sum(totals)) %&gt;%
  ggplot(aes(x = month, y = sum)) +
  geom_line() +
  geom_area(alpha = .7, fill = &#39;red&#39;) +
  labs(y = element_blank(), x = element_blank(),
       title = &#39;Firearm background checks, over time&#39;) +
  scale_x_date(expand = expansion(c(0, 0.001))) +
  scale_y_continuous(expand = expansion(c(0, 0.001)),
                     labels = unit_format(
                       unit = &quot;M&quot;,
                       scale = 1e-6,
                       sep = &quot;&quot;,
                       accuracy = 1
                     )) +
  drop_axis(&quot;y&quot;)</code>`}<!-- HTML_TAG_END --></pre>`
    })}
${validate_component(Image, "Image").$$render($$result, {
      src: "../images/post/covid-gun-spikes/unnamed-chunk-4-1.png",
      alt: "An area chart showing background checks over time. Despite some seasonaility, the trend is increasing over time, and is at its highest point at the end of the chart in 2020."
    }, {}, {})}
<p>And we can better understand the magnitude of these shifts by visualizing year-to-year changes:</p>
${validate_component(Code, "Code").$$render($$result, { language: "r" }, {}, {
      default: () => `<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">data <span class="token percent-operator operator">%>%</span>
  mutate<span class="token punctuation">(</span>month <span class="token operator">=</span> lubridate<span class="token operator">::</span>month<span class="token punctuation">(</span>month<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token percent-operator operator">%>%</span>
  filter<span class="token punctuation">(</span>month <span class="token operator">&lt;</span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token percent-operator operator">%>%</span>
  group_by<span class="token punctuation">(</span>year<span class="token punctuation">)</span> <span class="token percent-operator operator">%>%</span>
  summarise<span class="token punctuation">(</span>sum <span class="token operator">=</span> sum<span class="token punctuation">(</span>totals<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token percent-operator operator">%>%</span>
  ungroup<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token percent-operator operator">%>%</span>
  mutate<span class="token punctuation">(</span>last_year <span class="token operator">=</span> lag<span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">,</span>
         perc_change <span class="token operator">=</span>  <span class="token punctuation">(</span><span class="token punctuation">(</span>sum <span class="token operator">-</span> last_year<span class="token punctuation">)</span> <span class="token operator">/</span> last_year<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token percent-operator operator">%>%</span>
  ggplot<span class="token punctuation">(</span>aes<span class="token punctuation">(</span>x <span class="token operator">=</span> year<span class="token punctuation">,</span> y <span class="token operator">=</span> perc_change<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  geom_col<span class="token punctuation">(</span>alpha <span class="token operator">=</span> <span class="token number">.7</span><span class="token punctuation">,</span> fill <span class="token operator">=</span> <span class="token string">'red'</span><span class="token punctuation">,</span> color <span class="token operator">=</span> <span class="token string">'black'</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  geom_hline<span class="token punctuation">(</span>yintercept <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  scale_x_continuous<span class="token punctuation">(</span>expand <span class="token operator">=</span> expansion<span class="token punctuation">(</span>c<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0.001</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  scale_y_continuous<span class="token punctuation">(</span>labels <span class="token operator">=</span> percent_format<span class="token punctuation">(</span>accuracy <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  drop_axis<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  labs<span class="token punctuation">(</span>x <span class="token operator">=</span> element_blank<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> y <span class="token operator">=</span> element_blank<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
       title <span class="token operator">=</span> <span class="token string">"Year-on-year changes in firearm background checks, 1999-2020"</span><span class="token punctuation">,</span>
       subtitle <span class="token operator">=</span> <span class="token string">"January through June"</span><span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>`
    })}
${validate_component(Image, "Image").$$render($$result, {
      src: "../images/post/covid-gun-spikes/unnamed-chunk-5-1.png",
      alt: "A barchart showing the temporal year-on-year change in background checks for firearms over time. The last year, 2020, is the highest, meaning background checks have seen the greatest year on year growth this year."
    }, {}, {})}
<p>Visualized another way, we can explore the temporal change <strong>within each year</strong> for every year between 1999 and 2020, with 2020 <span style="${"color:red"}">highlighted in red.</span></p>
${validate_component(Code, "Code").$$render($$result, { language: "r" }, {}, {
      default: () => `<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">data <span class="token percent-operator operator">%>%</span>
  mutate<span class="token punctuation">(</span>month <span class="token operator">=</span> lubridate<span class="token operator">::</span>month<span class="token punctuation">(</span>month<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token percent-operator operator">%>%</span>
  filter<span class="token punctuation">(</span>month <span class="token operator">&lt;</span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token percent-operator operator">%>%</span>
  group_by<span class="token punctuation">(</span>month<span class="token punctuation">,</span> year<span class="token punctuation">)</span> <span class="token percent-operator operator">%>%</span>
  summarise<span class="token punctuation">(</span>sum <span class="token operator">=</span> sum<span class="token punctuation">(</span>totals<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token percent-operator operator">%>%</span>
  mutate<span class="token punctuation">(</span>fill <span class="token operator">=</span> ifelse<span class="token punctuation">(</span>year <span class="token operator">==</span> <span class="token number">2020</span><span class="token punctuation">,</span> <span class="token string">"2020"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token percent-operator operator">%>%</span>
  ggplot<span class="token punctuation">(</span>aes<span class="token punctuation">(</span>group <span class="token operator">=</span> year<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  geom_line<span class="token punctuation">(</span>aes<span class="token punctuation">(</span>x <span class="token operator">=</span> month<span class="token punctuation">,</span> y <span class="token operator">=</span> sum<span class="token punctuation">,</span> color <span class="token operator">=</span> fill<span class="token punctuation">,</span> alpha <span class="token operator">=</span> fill<span class="token punctuation">)</span><span class="token punctuation">,</span> show.legend <span class="token operator">=</span> <span class="token boolean">FALSE</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  scale_y_continuous<span class="token punctuation">(</span>limits <span class="token operator">=</span> c<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">4000000</span><span class="token punctuation">)</span><span class="token punctuation">,</span> labels <span class="token operator">=</span> unit_format<span class="token punctuation">(</span>unit <span class="token operator">=</span> <span class="token string">"M"</span><span class="token punctuation">,</span> sep <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">,</span> scale <span class="token operator">=</span> <span class="token number">1e-6</span><span class="token punctuation">,</span> accuracy <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  scale_x_continuous<span class="token punctuation">(</span>breaks <span class="token operator">=</span> c<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">,</span> labels <span class="token operator">=</span> c<span class="token punctuation">(</span><span class="token string">"Jan"</span><span class="token punctuation">,</span> <span class="token string">"Feb"</span><span class="token punctuation">,</span> <span class="token string">"Mar"</span><span class="token punctuation">,</span> <span class="token string">"April"</span><span class="token punctuation">,</span> <span class="token string">"May"</span><span class="token punctuation">,</span> <span class="token string">"June"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  scale_color_manual<span class="token punctuation">(</span>values <span class="token operator">=</span> c<span class="token punctuation">(</span><span class="token string">"gray"</span><span class="token punctuation">,</span> <span class="token string">"red"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  scale_alpha_manual<span class="token punctuation">(</span>values <span class="token operator">=</span> c<span class="token punctuation">(</span><span class="token number">.7</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  labs<span class="token punctuation">(</span>x <span class="token operator">=</span> element_blank<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> y <span class="token operator">=</span> element_blank<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      title <span class="token operator">=</span> "Firearm background checks <span class="token keyword">in</span> <span class="token operator">&lt;</span>span style <span class="token operator">=</span> <span class="token string">'color: red;'</span><span class="token operator">></span><span class="token number">2020</span><span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">></span>
      compared to <span class="token operator">&lt;</span>span style <span class="token operator">=</span> <span class="token string">'color: #343434'</span><span class="token operator">></span><span class="token number">1999</span> <span class="token operator">-</span> <span class="token number">2019</span><span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">></span>"<span class="token punctuation">,</span>
      subtitle <span class="token operator">=</span> <span class="token string">"January to June"</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  drop_axis<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  theme<span class="token punctuation">(</span>plot.title <span class="token operator">=</span> ggtext<span class="token operator">::</span>element_markdown<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>`
    })}
${validate_component(Image, "Image").$$render($$result, {
      src: "../images/post/covid-gun-spikes/unnamed-chunk-6-1.png",
      alt: "A line chart wherein each line shows a year, and the x axis corresponds to the month. The y axis represents the sum of background checks. The highest line is 2020, highlighted in red, indicating that across the entire year, 2020 has seen the greatest number of background checks."
    }, {}, {})}
<p>The FBI database also includes background check data for each U.S. state. This data allows us to compare trends <em>across</em> states and over time (using <code>geofacet</code>):</p>
${validate_component(Code, "Code").$$render($$result, { language: "r" }, {}, {
      default: () => `<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">data <span class="token percent-operator operator">%>%</span>
  mutate<span class="token punctuation">(</span>month <span class="token operator">=</span> lubridate<span class="token operator">::</span>month<span class="token punctuation">(</span>month<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token percent-operator operator">%>%</span>
  filter<span class="token punctuation">(</span>month <span class="token operator">&lt;</span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token percent-operator operator">%>%</span>
  group_by<span class="token punctuation">(</span>month<span class="token punctuation">,</span> year<span class="token punctuation">,</span> state<span class="token punctuation">)</span> <span class="token percent-operator operator">%>%</span>
  summarise<span class="token punctuation">(</span>sum <span class="token operator">=</span> sum<span class="token punctuation">(</span>totals<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token percent-operator operator">%>%</span>
  mutate<span class="token punctuation">(</span>fill <span class="token operator">=</span> ifelse<span class="token punctuation">(</span>year <span class="token operator">==</span> <span class="token number">2020</span><span class="token punctuation">,</span> <span class="token string">"2020"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token percent-operator operator">%>%</span>
  ggplot<span class="token punctuation">(</span>aes<span class="token punctuation">(</span>group <span class="token operator">=</span> year<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  geom_line<span class="token punctuation">(</span>aes<span class="token punctuation">(</span>x <span class="token operator">=</span> month<span class="token punctuation">,</span> y <span class="token operator">=</span> sum<span class="token punctuation">,</span> color <span class="token operator">=</span> fill<span class="token punctuation">,</span> alpha <span class="token operator">=</span> fill<span class="token punctuation">)</span><span class="token punctuation">,</span>
            size <span class="token operator">=</span> <span class="token number">.2</span><span class="token punctuation">,</span> show.legend <span class="token operator">=</span> <span class="token boolean">FALSE</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  scale_color_manual<span class="token punctuation">(</span>values <span class="token operator">=</span> c<span class="token punctuation">(</span><span class="token string">"gray"</span><span class="token punctuation">,</span> <span class="token string">"red"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  scale_alpha_manual<span class="token punctuation">(</span>values <span class="token operator">=</span> c<span class="token punctuation">(</span><span class="token number">.5</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  facet_geo<span class="token punctuation">(</span><span class="token operator">~</span> state<span class="token punctuation">,</span> scales <span class="token operator">=</span> <span class="token string">'free_y'</span><span class="token punctuation">,</span> grid <span class="token operator">=</span> <span class="token string">"us_state_grid1"</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  drop_axis<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  theme<span class="token punctuation">(</span>text <span class="token operator">=</span> element_text<span class="token punctuation">(</span>color <span class="token operator">=</span> <span class="token string">"white"</span><span class="token punctuation">,</span>
                            family <span class="token operator">=</span> <span class="token string">"IBM Plex Sans"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        axis.title<span class="token operator">=</span>element_blank<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        axis.text<span class="token operator">=</span>element_blank<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        axis.ticks<span class="token operator">=</span>element_blank<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        strip.background <span class="token operator">=</span> element_rect<span class="token punctuation">(</span>fill <span class="token operator">=</span> <span class="token string">'black'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        strip.text <span class="token operator">=</span> element_text<span class="token punctuation">(</span>size <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span> color <span class="token operator">=</span> <span class="token string">'white'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        panel.background <span class="token operator">=</span> element_rect<span class="token punctuation">(</span>fill <span class="token operator">=</span> <span class="token string">'black'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        plot.background <span class="token operator">=</span> element_rect<span class="token punctuation">(</span>fill <span class="token operator">=</span> <span class="token string">'black'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        panel.grid <span class="token operator">=</span> element_blank<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  labs<span class="token punctuation">(</span>x <span class="token operator">=</span> element_blank<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
       y <span class="token operator">=</span> element_blank<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
       title <span class="token operator">=</span> <span class="token string">"Spikes in gun ownership during COVID-19"</span><span class="token punctuation">,</span>
       subtitle <span class="token operator">=</span> <span class="token string">"How the first six months of 2020 compare to 1999-2019"</span><span class="token punctuation">)</span>

<span class="token comment">## With additional styling changes made in Illustrator!</span></code>`}<!-- HTML_TAG_END --></pre>`
    })}
${validate_component(Image, "Image").$$render($$result, {
      src: "../images/post/covid-gun-spikes/featured.png",
      alt: "A small multiples map showing spikes in firearm background checks in 2020, compared to 1999-2019"
    }, {}, {})}
<h2 id="${"the-impact"}"><a href="${"#the-impact"}">The impact</a></h2>
<p>Most obviously, background checks are a proxy for gun purchases and gun ownership; as such, this data informs us that more and more people are grabbing for guns during COVID-19, perhaps in anticipation of some post-COVID apocalypse or perceived government overreach during.</p>
<p>In addition, one risk is that more guns can lead to greater numbers of firearm suicides. <a href="${"https://everytownresearch.org/reports/covid-gun-violence/"}" rel="${"nofollow"}">One group of researchers</a> at the gun safety organization Everytown predicted that COVID-related unemployment would lead to a 20-30% increase in firearm suicides (5000 to 7000 people). As such, a rise in firearm-related background checks may signal an impending surge of gun violence in the forms of both homicide and suicide.</p>
<p>Firearm background check data, however, requires close scrutiny. The way that these data are acquired on a state-by-state basis means that we might not be able to safely make comparisons <em>across</em> states. Moreover, according to <a href="${"https://www.thetrace.org/2015/10/private-sale-loophole-background-check-harvard-research/"}" rel="${"nofollow"}">one group of Harvard researchers</a>, upwards of 40% of all gun owners report acquiring their most recent gun <em>without a background check.</em></p>
<p>Thus, these numbers may tell a different story than one of \u2018guns are being purchased more frequently.\u2019 Although not employed in this post, there are some novel ways to develop stories similar to that one, like using <a href="${"https://github.com/nytimes/gunsales#getting-gun-sales-estimates-from-background-checks"}" rel="${"nofollow"}">NYT\u2019s methodology</a> to estimate gun sales from background check data. I encourage those interested to pursue their work, alongside the <a href="${"https://github.com/BuzzFeedNews/nics-firearm-background-checks"}" rel="${"nofollow"}">BuzzFeed News repository</a> where this data came from, and analyze such questions yourself.</p>`
  })}`;
});
var covidGunSpikes = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Covid_gun_spikes,
  metadata: metadata$8
});
var metadata$7 = {
  "layout": "blog",
  "title": "An Analysis of COVID on Campus",
  "date": "2020-10-02",
  "description": "Where university reopenings led to spikes in COVID-19 case counts",
  "image": "covid-on-campus/header.png",
  "tags": ["analysis", "r"]
};
var Covid_on_campus = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${$$result.head += `<script async src="${"https://platform.twitter.com/widgets.js"}" charset="${"utf-8"}" data-svelte="svelte-13oycb1"><\/script>`, ""}
${validate_component(Layout, "Layout_MDSVEX_DEFAULT").$$render($$result, Object.assign($$props, metadata$7), {}, {
    default: () => `<p>On July 17, Rice University announced <a href="${"https://coronavirus.rice.edu/news/message-president-leebron-july-17"}" rel="${"nofollow"}">its
plan</a>
for the fall semester, which included a hybrid mode of instruction where
students could attend classes either virtually or in person. The
decision wasn\u2019t without controversy; in the weeks that followed,
<a href="${"https://www.ricethresher.org/article/2020/08/return-to-campus-but-to-what-end"}" rel="${"nofollow"}">multiple</a>
<a href="${"https://www.ricethresher.org/article/2020/07/letter-to-the-editor-on-returning-to-the-classroom"}" rel="${"nofollow"}">faculty</a>
<a href="${"https://www.ricethresher.org/article/2020/07/letter-to-the-editor-re-evaluate-return-to-campus"}" rel="${"nofollow"}">members</a>
at Rice wrote of their concerns with the plan to begin classes,
eventually culminating in a
<a href="${"https://www.ricethresher.org/article/2020/08/faculty-senate-will-meet-to-discuss-risks-and-benefits-of-returning-to-campus"}" rel="${"nofollow"}">petition</a>
to convene a campus-wide discussion regarding the risks and benefits of
opening campus. The petition garnered nearly 100 faculty signatures.</p>
<p>Despite such complaints, Rice opened its doors to in-person students on
August 11th. And despite all of the concerns, the university has done a
remarkable job at keeping COVID case counts relatively low.</p>
<blockquote class="${"twitter-tweet"}"><p lang="${"en"}" dir="${"ltr"}">A big part of <a href="${"https://twitter.com/RiceUniversity?ref_src=twsrc%5Etfw"}">@RiceUniversity</a>&#39;s approach to COVID-19: test often. Within the first two weeks of August, the university recorded over 4000 tests, with a total of 19 positive cases (0.41%). <a href="${"https://t.co/IDI3qtIE6f"}">pic.twitter.com/IDI3qtIE6f</a></p>\u2014 Connor Rothschild (@CL_Rothschild) <a href="${"https://twitter.com/CL_Rothschild/status/1296495845664272386?ref_src=twsrc%5Etfw"}">August 20, 2020</a></blockquote>
<p>Rice\u2019s success at maintaining low case
counts\u2013<a href="${"https://coronavirus.rice.edu/"}" rel="${"nofollow"}">recording</a> only 37 positive cases
across 36,183 tests as of October 10\u2013is not typical of most colleges. At
universities across the country, reopening was often accompanied by a
<a href="${"https://apnews.com/article/virus-outbreak-indiana-muncie-b62eacec9bd3fff89eeab1a8de72f819"}" rel="${"nofollow"}">surge</a>
in new COVID-19 cases; surges that, in many instances, forced those
universities to
<a href="${"https://www.jsonline.com/story/news/education/2020/09/09/uw-madison-pauses-person-classes-two-weeks/5766409002/"}" rel="${"nofollow"}">reverse</a>
their
<a href="${"https://www.nytimes.com/2020/08/17/us/unc-chapel-hill-covid.html"}" rel="${"nofollow"}">reopening</a>
<a href="${"https://www.usnews.com/news/education-news/articles/2020-09-08/facing-coronavirus-spikes-colleges-send-students-home-against-the-warnings-of-public-health-officials"}" rel="${"nofollow"}">decisions</a>
within just a few weeks.</p>
<p>The table below presents cumulative university-affiliated COVID cases,
broken down by college (from the <a href="${"https://github.com/nytimes/covid-19-data/tree/master/colleges"}" rel="${"nofollow"}">New York
Times</a>):</p>
${validate_component(TableHandler, "TableHandler").$$render($$result, {
      src: "../images/post/covid-on-campus/table1.png",
      alt: "A table showcasing universities that have the greatest number of COVID-19 cases. University of Georgia leads the pack at 3888 cases. Last updated October 11, 2020",
      link: "http://connorrothschild.github.io/v2/post/covid-on-campus/",
      width: "80%"
    }, {}, {})}
<p>In addition to the criticism leveled against university administrators
for jeopardizing the health and safety of their <em>students</em>, to what
extent have reopenings put the community at large at greater risk?</p>
<p>One way to answer this question is to analyze case counts attributable
to university students as a relative proportion of a county\u2019s overall
case counts. The New York Times offers data in both forms:
<a href="${"https://github.com/nytimes/covid-19-data/tree/master/colleges"}" rel="${"nofollow"}">college-affiliated
cases</a>
and <a href="${"https://github.com/nytimes/covid-19-data/blob/master/live/us-counties.csv"}" rel="${"nofollow"}">county
cases</a>
(cumulative). In combination, the data tells a story about which
colleges are struggling the most with COVID-19, which college towns saw
a COVID spike after university reopenings, and which cities have
problems much larger than students throwing fraternity parties.</p>
<p>Below, you can explore your county\u2019s case count relative to its
university-affiliated case counts.</p>
${validate_component(TableHandler, "TableHandler").$$render($$result, {
      src: "../images/post/covid-on-campus/table2.png",
      alt: "A table showcasing counties that have the greatest number of COVID-19 cases attributable to colleges. Pickens, South Carolina is expanded, showcasing two universities which account for 105% of the county's total cases. Last updated October 11, 2020",
      link: "http://connorrothschild.github.io/v2/post/covid-on-campus/",
      width: "80%"
    }, {}, {})}
<p>In two counties, Otsego County (New York) and Pickens County (South
Carolina), university-affiliated COVID-19 case counts actually <em>outpace</em>
officially recorded COVID-19 cases in their respective counties. This
might signal an issue with the data, or a unique way of treating
university students in county-wide case counts. According to one of the
investigative reporters who recorded this data at the New York Times,
county-wide case totals might not include out-of-state residents, such
as college students:</p>
<blockquote class="${"twitter-tweet"}"><p lang="${"en"}" dir="${"ltr"}">Coronavirus infections on campuses might go unnoticed if not for reporting by academic institutions themselves because they do not always show up in official state or countywide tallies, which generally exclude people who have permanent addresses elsewhere, as students often do.</p>\u2014 Danielle Ivory (@danielle_ivory) <a href="${"https://twitter.com/danielle_ivory/status/1314597852782489602?ref_src=twsrc%5Etfw"}">October 9, 2020</a></blockquote>
<p>In other counties, we see a more intuitive picture, where college cases
constitute a proportion of overall county cases. Even if the same issue
is present in these counties, you can understand generally where
university COVID case counts are high relative to their county-wide
totals, and where they are not.</p>
<h3 id="${"university-affiliated-covid-cases-across-states"}"><a href="${"#university-affiliated-covid-cases-across-states"}">University-affiliated COVID cases across states</a></h3>
<p>The data also tells a story about COVID case counts on a state-by-state
basis, and where college-affiliated cases make up a disproportionate
share of cases in the state overall.</p>
<p>Geographically, the data looks like this (note the x-axis runs from 0 to
10%):</p>
${validate_component(Image, "Image").$$render($$result, {
      src: "../images/post/covid-on-campus/geofacet_processed.png",
      alt: "A geofaceted map that shows percent of COVID cases attributable to colleges, by US state. Each state ranges between 0 and 10% of total cases attributable to colleges."
    }, {}, {})}
<p>In the table below, you can search for your state and drill down on
which counties within your state make up the greatest share of COVID-19
cases.</p>
${validate_component(TableHandler, "TableHandler").$$render($$result, {
      src: "../images/post/covid-on-campus/table3.png",
      alt: "A table showcasing states that have the greatest number of COVID-19 cases attributable to colleges. Wyoming (number 1) is expanded, showcasing three universities which account for 7% of the state's total cases. Last updated October 11, 2020",
      link: "http://connorrothschild.github.io/v2/post/covid-on-campus/",
      width: "80%"
    }, {}, {})}
<p>Thanks for reading. You can find the code that creates the tables and
graphics for this post <a href="${"https://github.com/connorrothschild/v2/tree/master/content/post/covid-on-campus/index.Rmd"}" rel="${"nofollow"}">on
GitHub</a>.
As always, feel free to message me on
<a href="${"https://twitter.com/CL_Rothschild"}" rel="${"nofollow"}">Twitter</a> with any questions,
comments, or just to say hi \u{1F642}</p>`
  })}`;
});
var covidOnCampus = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Covid_on_campus,
  metadata: metadata$7
});
var metadata$6 = {
  "layout": "blog",
  "title": "Create a Streetmap of Any City in R",
  "description": "Creating a beautiful streetmap of my hometown, exclusively in R",
  "date": "2019-11-21",
  "image": "map-springfield/header.png",
  "archived": true,
  "tags": ["r"]
};
var Map_springfield = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${validate_component(Layout, "Layout_MDSVEX_DEFAULT").$$render($$result, Object.assign($$props, metadata$6), {}, {
    default: () => `<p>In this post, I expand upon <a href="${"https://christianburkhart.de/"}" rel="${"nofollow"}">Christian
Burkhart</a>\u2019s wonderful <a href="${"https://ggplot2tutor.com/streetmaps/streetmaps/"}" rel="${"nofollow"}">ggplot2tor
tutorial</a> on streetmap
creation using ggplot2. My process differs slightly from his in that I
include text using <code>geom_label</code>, rather than PowerPoint, to create the
text annotations. (This was much more difficult!)</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">library<span class="token punctuation">(</span>tidyverse<span class="token punctuation">)</span>
library<span class="token punctuation">(</span>gridExtra<span class="token punctuation">)</span>
library<span class="token punctuation">(</span>grid<span class="token punctuation">)</span>
library<span class="token punctuation">(</span>ggplot2<span class="token punctuation">)</span>
library<span class="token punctuation">(</span>lattice<span class="token punctuation">)</span>
library<span class="token punctuation">(</span>osmdata<span class="token punctuation">)</span>
library<span class="token punctuation">(</span>sf<span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>
<p>First, per the tutorial, we load street (and river, etc). data:</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">streets <span class="token operator">&lt;-</span> getbb<span class="token punctuation">(</span><span class="token string">"Springfield Missouri"</span><span class="token punctuation">)</span><span class="token percent-operator operator">%>%</span>
  opq<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token percent-operator operator">%>%</span>
  add_osm_feature<span class="token punctuation">(</span>key <span class="token operator">=</span> <span class="token string">"highway"</span><span class="token punctuation">,</span>
                  value <span class="token operator">=</span> c<span class="token punctuation">(</span><span class="token string">"motorway"</span><span class="token punctuation">,</span> <span class="token string">"primary"</span><span class="token punctuation">,</span>
                            <span class="token string">"secondary"</span><span class="token punctuation">,</span> <span class="token string">"tertiary"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token percent-operator operator">%>%</span>
  osmdata_sf<span class="token punctuation">(</span><span class="token punctuation">)</span>

small_streets <span class="token operator">&lt;-</span> getbb<span class="token punctuation">(</span><span class="token string">"Springfield Missouri"</span><span class="token punctuation">)</span><span class="token percent-operator operator">%>%</span>
  opq<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token percent-operator operator">%>%</span>
  add_osm_feature<span class="token punctuation">(</span>key <span class="token operator">=</span> <span class="token string">"highway"</span><span class="token punctuation">,</span>
                  value <span class="token operator">=</span> c<span class="token punctuation">(</span><span class="token string">"residential"</span><span class="token punctuation">,</span> <span class="token string">"living_street"</span><span class="token punctuation">,</span>
                            <span class="token string">"unclassified"</span><span class="token punctuation">,</span>
                            <span class="token string">"service"</span><span class="token punctuation">,</span> <span class="token string">"footway"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token percent-operator operator">%>%</span>
  osmdata_sf<span class="token punctuation">(</span><span class="token punctuation">)</span>

river <span class="token operator">&lt;-</span> getbb<span class="token punctuation">(</span><span class="token string">"Springfield Missouri"</span><span class="token punctuation">)</span><span class="token percent-operator operator">%>%</span>
  opq<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token percent-operator operator">%>%</span>
  add_osm_feature<span class="token punctuation">(</span>key <span class="token operator">=</span> <span class="token string">"waterway"</span><span class="token punctuation">,</span> value <span class="token operator">=</span> <span class="token string">"river"</span><span class="token punctuation">)</span> <span class="token percent-operator operator">%>%</span>
  osmdata_sf<span class="token punctuation">(</span><span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>
<p>Next, we define the plot limits, using the lat-long found in the last
step.</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">right <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">93.175</span>
left <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">93.395</span>
bottom <span class="token operator">=</span> <span class="token number">37</span>
top <span class="token operator">=</span> <span class="token number">37.275</span></code>`}<!-- HTML_TAG_END --></pre>
<p>In my plot, I\u2019m going to create a text box to hold the city, state, and
lat/long combination.</p>
<p>We can create the parameters for this box through some manipulations of
the existing plot limits:</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">top_rect <span class="token operator">=</span> <span class="token punctuation">(</span>top <span class="token operator">+</span> bottom<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2.0035</span>
bot_rect <span class="token operator">=</span> bottom <span class="token operator">+</span> <span class="token number">.01</span>
box_height <span class="token operator">=</span> <span class="token punctuation">(</span>top_rect <span class="token operator">+</span> bot_rect<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span>
mid_box <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span></code>`}<!-- HTML_TAG_END --></pre>
<p>Finally, we can create a black and white plot. This follows the same
structure as the ggplot2tor tutorial:</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">plot_bw <span class="token operator">&lt;-</span> ggplot<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  geom_sf<span class="token punctuation">(</span>data <span class="token operator">=</span> streets<span class="token operator">$</span>osm_lines<span class="token punctuation">,</span>
          inherit.aes <span class="token operator">=</span> <span class="token boolean">FALSE</span><span class="token punctuation">,</span>
          color <span class="token operator">=</span> <span class="token string">"#000000"</span><span class="token punctuation">,</span>
          size <span class="token operator">=</span> <span class="token number">.3</span><span class="token punctuation">,</span>
          alpha <span class="token operator">=</span> <span class="token number">.8</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  geom_sf<span class="token punctuation">(</span>data <span class="token operator">=</span> small_streets<span class="token operator">$</span>osm_lines<span class="token punctuation">,</span>
          inherit.aes <span class="token operator">=</span> <span class="token boolean">FALSE</span><span class="token punctuation">,</span>
          color <span class="token operator">=</span> <span class="token string">"#000000"</span><span class="token punctuation">,</span>
          size <span class="token operator">=</span> <span class="token number">.1</span><span class="token punctuation">,</span>
          alpha <span class="token operator">=</span> <span class="token number">.6</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  geom_sf<span class="token punctuation">(</span>data <span class="token operator">=</span> river<span class="token operator">$</span>osm_lines<span class="token punctuation">,</span>
          inherit.aes <span class="token operator">=</span> <span class="token boolean">FALSE</span><span class="token punctuation">,</span>
          color <span class="token operator">=</span> <span class="token string">"#000000"</span><span class="token punctuation">,</span>
          size <span class="token operator">=</span> <span class="token number">.2</span><span class="token punctuation">,</span>
          alpha <span class="token operator">=</span> <span class="token number">.5</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  coord_sf<span class="token punctuation">(</span>xlim <span class="token operator">=</span> c<span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">,</span>
           ylim <span class="token operator">=</span> c<span class="token punctuation">(</span>bottom<span class="token punctuation">,</span> top<span class="token punctuation">)</span><span class="token punctuation">,</span>
           expand <span class="token operator">=</span> <span class="token boolean">FALSE</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  theme_void<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  theme<span class="token punctuation">(</span>
    plot.background <span class="token operator">=</span> element_rect<span class="token punctuation">(</span>fill <span class="token operator">=</span> <span class="token string">"#FFFFFF"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    panel.background <span class="token operator">=</span> element_rect<span class="token punctuation">(</span>fill <span class="token operator">=</span> <span class="token string">"#FFFFFF"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    plot.margin<span class="token operator">=</span>unit<span class="token punctuation">(</span>c<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">0.5</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"mm"</span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>
<p>Finally, we can introduce our text elements using <code>geom_text</code> (as well
as borders using <code>geom_rect</code>).</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">map_bw <span class="token operator">&lt;-</span> plot_bw <span class="token operator">+</span>
  <span class="token comment"># big box</span>
  geom_rect<span class="token punctuation">(</span>
    aes<span class="token punctuation">(</span>
      xmax <span class="token operator">=</span> right <span class="token operator">-</span> <span class="token number">.005</span><span class="token punctuation">,</span>
      xmin <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token number">.005</span><span class="token punctuation">,</span>
      ymin <span class="token operator">=</span> bottom <span class="token operator">+</span> <span class="token number">.005</span><span class="token punctuation">,</span>
      ymax <span class="token operator">=</span> top <span class="token operator">-</span> <span class="token number">.005</span>
    <span class="token punctuation">)</span><span class="token punctuation">,</span>
    alpha <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
    color <span class="token operator">=</span> <span class="token string">"black"</span><span class="token punctuation">,</span>
    size <span class="token operator">=</span> <span class="token number">1</span>
  <span class="token punctuation">)</span> <span class="token operator">+</span>
  <span class="token comment"># smaller, label box</span>
  geom_rect<span class="token punctuation">(</span>
    aes<span class="token punctuation">(</span>
      xmax <span class="token operator">=</span> right <span class="token operator">-</span> <span class="token number">.01</span><span class="token punctuation">,</span>
      xmin <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token number">.01</span><span class="token punctuation">,</span>
      ymin <span class="token operator">=</span> bot_rect<span class="token punctuation">,</span>
      ymax <span class="token operator">=</span> top_rect
    <span class="token punctuation">)</span><span class="token punctuation">,</span>
    alpha <span class="token operator">=</span> <span class="token number">.75</span><span class="token punctuation">,</span>
    color <span class="token operator">=</span> <span class="token string">"black"</span><span class="token punctuation">,</span>
    fill <span class="token operator">=</span> <span class="token string">"white"</span><span class="token punctuation">,</span>
    size <span class="token operator">=</span> <span class="token number">.6</span>
  <span class="token punctuation">)</span> <span class="token operator">+</span>
  <span class="token comment"># springfield</span>
  geom_text<span class="token punctuation">(</span>
    aes<span class="token punctuation">(</span>x <span class="token operator">=</span> mid_box<span class="token punctuation">,</span> y <span class="token operator">=</span> box_height <span class="token operator">+</span> <span class="token number">.002</span><span class="token punctuation">,</span>
        label <span class="token operator">=</span> <span class="token string">"SPRINGFIELD&#92;n"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    color <span class="token operator">=</span> <span class="token string">"black"</span><span class="token punctuation">,</span>
    family <span class="token operator">=</span> <span class="token string">"Lato"</span><span class="token punctuation">,</span>
    fontface <span class="token operator">=</span> <span class="token string">"bold"</span><span class="token punctuation">,</span>
    size <span class="token operator">=</span> <span class="token number">9</span>
  <span class="token punctuation">)</span> <span class="token operator">+</span>
  <span class="token comment"># a line that goes behind 'Missouri'</span>
  geom_segment<span class="token punctuation">(</span>aes<span class="token punctuation">(</span>
    x <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token number">.03</span><span class="token punctuation">,</span>
    y <span class="token operator">=</span> <span class="token punctuation">(</span>top_rect <span class="token operator">+</span> bottom<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">,</span>
    xend <span class="token operator">=</span> right <span class="token operator">-</span> <span class="token number">.03</span><span class="token punctuation">,</span>
    yend <span class="token operator">=</span> <span class="token punctuation">(</span>top_rect <span class="token operator">+</span> bottom<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span>
  <span class="token punctuation">)</span><span class="token punctuation">,</span> color <span class="token operator">=</span> <span class="token string">"black"</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  <span class="token comment"># Missouri label</span>
  geom_label<span class="token punctuation">(</span>
    aes<span class="token punctuation">(</span>x <span class="token operator">=</span> mid_box<span class="token punctuation">,</span> y <span class="token operator">=</span> box_height <span class="token operator">-</span> <span class="token number">.005</span><span class="token punctuation">,</span>
        label <span class="token operator">=</span> <span class="token string">"MISSOURI"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    color <span class="token operator">=</span> <span class="token string">"black"</span><span class="token punctuation">,</span>
    fill <span class="token operator">=</span> <span class="token string">"white"</span><span class="token punctuation">,</span>
    <span class="token comment"># alpha = .9,</span>
    label.size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
    family <span class="token operator">=</span> <span class="token string">"Lato"</span><span class="token punctuation">,</span>
    <span class="token comment"># fontface = "thin",</span>
    size <span class="token operator">=</span> <span class="token number">7</span>
  <span class="token punctuation">)</span> <span class="token operator">+</span>
  <span class="token comment"># coords</span>
  geom_text<span class="token punctuation">(</span>
    aes<span class="token punctuation">(</span>x <span class="token operator">=</span> mid_box<span class="token punctuation">,</span> y <span class="token operator">=</span> box_height <span class="token operator">-</span> <span class="token number">.02</span><span class="token punctuation">,</span>
        label <span class="token operator">=</span> <span class="token string">"37.2090\xB0 N / 93.2923\xB0 W"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    color <span class="token operator">=</span> <span class="token string">"black"</span><span class="token punctuation">,</span>
    family <span class="token operator">=</span> <span class="token string">"Lato"</span><span class="token punctuation">,</span>
    size <span class="token operator">=</span> <span class="token number">4</span>
  <span class="token punctuation">)</span> <span class="token operator">+</span>
  <span class="token comment"># me!</span>
  geom_label<span class="token punctuation">(</span>
    aes<span class="token punctuation">(</span>
      x <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token number">.035</span><span class="token punctuation">,</span>
      y <span class="token operator">=</span> top_rect <span class="token operator">+</span> <span class="token number">.005</span><span class="token punctuation">,</span>
      label <span class="token operator">=</span> <span class="token string">"Design: Connor Rothschild"</span>
    <span class="token punctuation">)</span><span class="token punctuation">,</span>
    size <span class="token operator">=</span> <span class="token number">1.5</span><span class="token punctuation">,</span>
    color <span class="token operator">=</span> <span class="token string">"black"</span><span class="token punctuation">,</span>
    fill <span class="token operator">=</span> <span class="token string">"white"</span><span class="token punctuation">,</span>
    label.size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
    family <span class="token operator">=</span> <span class="token string">"Lato"</span>
  <span class="token punctuation">)</span>

map_bw</code>`}<!-- HTML_TAG_END --></pre>
${validate_component(Image, "Image").$$render($$result, {
      alt: "A black and white map of Springfield, Missouri.",
      src: "../images/post/map-springfield/bw_map_springfield.png",
      width: "50%",
      centered: true
    }, {}, {})}
<p>And if we replicate that code with different colors, the possibilities are endless:</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">plot_gold <span class="token operator">&lt;-</span> ggplot<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  geom_sf<span class="token punctuation">(</span>
    data <span class="token operator">=</span> streets<span class="token operator">$</span>osm_lines<span class="token punctuation">,</span>
    inherit.aes <span class="token operator">=</span> <span class="token boolean">FALSE</span><span class="token punctuation">,</span>
    color <span class="token operator">=</span> <span class="token string">"steelblue"</span><span class="token punctuation">,</span>
    size <span class="token operator">=</span> <span class="token number">.3</span><span class="token punctuation">,</span>
    alpha <span class="token operator">=</span> <span class="token number">.8</span>
  <span class="token punctuation">)</span> <span class="token operator">+</span>
  geom_sf<span class="token punctuation">(</span>
    data <span class="token operator">=</span> small_streets<span class="token operator">$</span>osm_lines<span class="token punctuation">,</span>
    inherit.aes <span class="token operator">=</span> <span class="token boolean">FALSE</span><span class="token punctuation">,</span>
    color <span class="token operator">=</span> <span class="token string">"#ffbe7f"</span><span class="token punctuation">,</span>
    size <span class="token operator">=</span> <span class="token number">.1</span><span class="token punctuation">,</span>
    alpha <span class="token operator">=</span> <span class="token number">.6</span>
  <span class="token punctuation">)</span> <span class="token operator">+</span>
  geom_sf<span class="token punctuation">(</span>
    data <span class="token operator">=</span> river<span class="token operator">$</span>osm_lines<span class="token punctuation">,</span>
    inherit.aes <span class="token operator">=</span> <span class="token boolean">FALSE</span><span class="token punctuation">,</span>
    color <span class="token operator">=</span> <span class="token string">"#ffbe7f"</span><span class="token punctuation">,</span>
    size <span class="token operator">=</span> <span class="token number">.2</span><span class="token punctuation">,</span>
    alpha <span class="token operator">=</span> <span class="token number">.5</span>
  <span class="token punctuation">)</span> <span class="token operator">+</span>
  coord_sf<span class="token punctuation">(</span>
    xlim <span class="token operator">=</span> c<span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">,</span>
    ylim <span class="token operator">=</span> c<span class="token punctuation">(</span>bottom<span class="token punctuation">,</span> top<span class="token punctuation">)</span><span class="token punctuation">,</span>
    expand <span class="token operator">=</span> <span class="token boolean">FALSE</span>
  <span class="token punctuation">)</span> <span class="token operator">+</span>
  theme_void<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  theme<span class="token punctuation">(</span>
    plot.background <span class="token operator">=</span> element_rect<span class="token punctuation">(</span>fill <span class="token operator">=</span> <span class="token string">"#282828"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    panel.background <span class="token operator">=</span> element_rect<span class="token punctuation">(</span>fill <span class="token operator">=</span> <span class="token string">"#282828"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    plot.margin <span class="token operator">=</span> unit<span class="token punctuation">(</span>c<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"mm"</span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span>

map_gold <span class="token operator">&lt;-</span> plot_gold <span class="token operator">+</span>
  geom_rect<span class="token punctuation">(</span>
    aes<span class="token punctuation">(</span>
      xmax <span class="token operator">=</span> right <span class="token operator">-</span> <span class="token number">.005</span><span class="token punctuation">,</span>
      xmin <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token number">.005</span><span class="token punctuation">,</span>
      ymin <span class="token operator">=</span> bottom <span class="token operator">+</span> <span class="token number">.005</span><span class="token punctuation">,</span>
      ymax <span class="token operator">=</span> top <span class="token operator">-</span> <span class="token number">.005</span>
    <span class="token punctuation">)</span><span class="token punctuation">,</span>
    alpha <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
    color <span class="token operator">=</span> <span class="token string">"white"</span><span class="token punctuation">,</span>
    size <span class="token operator">=</span> <span class="token number">1</span>
  <span class="token punctuation">)</span> <span class="token operator">+</span>
  geom_rect<span class="token punctuation">(</span>
    aes<span class="token punctuation">(</span>
      xmax <span class="token operator">=</span> right <span class="token operator">-</span> <span class="token number">.01</span><span class="token punctuation">,</span>
      xmin <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token number">.01</span><span class="token punctuation">,</span>
      ymin <span class="token operator">=</span> bot_rect<span class="token punctuation">,</span>
      ymax <span class="token operator">=</span> top_rect
    <span class="token punctuation">)</span><span class="token punctuation">,</span>
    alpha <span class="token operator">=</span> <span class="token number">.5</span><span class="token punctuation">,</span>
    color <span class="token operator">=</span> <span class="token string">"#ffbe7f"</span><span class="token punctuation">,</span>
    fill <span class="token operator">=</span> <span class="token string">"#282828"</span><span class="token punctuation">,</span>
    size <span class="token operator">=</span> <span class="token number">.5</span>
  <span class="token punctuation">)</span> <span class="token operator">+</span>
  geom_text<span class="token punctuation">(</span>
    aes<span class="token punctuation">(</span>x <span class="token operator">=</span> mid_box<span class="token punctuation">,</span> y <span class="token operator">=</span> box_height <span class="token operator">+</span> <span class="token number">.002</span><span class="token punctuation">,</span>
        label <span class="token operator">=</span> <span class="token string">"SPRINGFIELD&#92;n"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    color <span class="token operator">=</span> <span class="token string">"white"</span><span class="token punctuation">,</span>
    family <span class="token operator">=</span> <span class="token string">"Lato"</span><span class="token punctuation">,</span>
    fontface <span class="token operator">=</span> <span class="token string">"bold"</span><span class="token punctuation">,</span>
    size <span class="token operator">=</span> <span class="token number">9</span>
  <span class="token punctuation">)</span> <span class="token operator">+</span>
  geom_segment<span class="token punctuation">(</span>aes<span class="token punctuation">(</span>
    x <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token number">.03</span><span class="token punctuation">,</span>
    y <span class="token operator">=</span> <span class="token punctuation">(</span>top_rect <span class="token operator">+</span> bottom<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">,</span>
    xend <span class="token operator">=</span> right <span class="token operator">-</span> <span class="token number">.03</span><span class="token punctuation">,</span>
    yend <span class="token operator">=</span> <span class="token punctuation">(</span>top_rect <span class="token operator">+</span> bottom<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span>
  <span class="token punctuation">)</span><span class="token punctuation">,</span>
  color <span class="token operator">=</span> <span class="token string">"#ffbe7f"</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  geom_label<span class="token punctuation">(</span>
    aes<span class="token punctuation">(</span>x <span class="token operator">=</span> mid_box<span class="token punctuation">,</span> y <span class="token operator">=</span> box_height <span class="token operator">-</span> <span class="token number">.005</span><span class="token punctuation">,</span>
        label <span class="token operator">=</span> <span class="token string">"MISSOURI"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    color <span class="token operator">=</span> <span class="token string">"white"</span><span class="token punctuation">,</span>
    fill <span class="token operator">=</span> <span class="token string">"#282828"</span><span class="token punctuation">,</span>
    <span class="token comment"># alpha = .9,</span>
    label.size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
    family <span class="token operator">=</span> <span class="token string">"Lato"</span><span class="token punctuation">,</span>
    <span class="token comment"># fontface = "thin",</span>
    size <span class="token operator">=</span> <span class="token number">7</span>
  <span class="token punctuation">)</span> <span class="token operator">+</span>
  geom_text<span class="token punctuation">(</span>
    aes<span class="token punctuation">(</span>x <span class="token operator">=</span> mid_box<span class="token punctuation">,</span> y <span class="token operator">=</span> box_height <span class="token operator">-</span> <span class="token number">.02</span><span class="token punctuation">,</span>
        label <span class="token operator">=</span> <span class="token string">"37.2090\xB0 N / 93.2923\xB0 W"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    color <span class="token operator">=</span> <span class="token string">"white"</span><span class="token punctuation">,</span>
    family <span class="token operator">=</span> <span class="token string">"Lato"</span><span class="token punctuation">,</span>
    size <span class="token operator">=</span> <span class="token number">4</span>
  <span class="token punctuation">)</span> <span class="token operator">+</span>
  geom_label<span class="token punctuation">(</span>
    aes<span class="token punctuation">(</span>
      x <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token number">.035</span><span class="token punctuation">,</span>
      y <span class="token operator">=</span> top_rect <span class="token operator">+</span> <span class="token number">.005</span><span class="token punctuation">,</span>
      label <span class="token operator">=</span> <span class="token string">"Design: Connor Rothschild"</span>
    <span class="token punctuation">)</span><span class="token punctuation">,</span>
    size <span class="token operator">=</span> <span class="token number">1.5</span><span class="token punctuation">,</span>
    color <span class="token operator">=</span> <span class="token string">"white"</span><span class="token punctuation">,</span>
    fill <span class="token operator">=</span> <span class="token string">"#282828"</span><span class="token punctuation">,</span>
    label.size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
    family <span class="token operator">=</span> <span class="token string">"Lato"</span>
  <span class="token punctuation">)</span>

map_gold</code>`}<!-- HTML_TAG_END --></pre>
${validate_component(Image, "Image").$$render($$result, {
      alt: "A gold map of Springfield, Missouri.",
      src: "../images/post/map-springfield/gold_map_springfield.png",
      width: "50%",
      centered: true
    }, {}, {})}`
  })}`;
});
var mapSpringfield = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Map_springfield,
  metadata: metadata$6
});
var metadata$5 = {
  "layout": "blog",
  "title": "Create Dumbbell Plots to Visualize Group Differences in R",
  "description": "How to create dumbbell plots in R, using {ggalt}",
  "date": "2020-03-02",
  "image": "dumbbell-plots/header.png",
  "archived": true,
  "tags": ["r", "tutorial"]
};
var Dumbbell_plots = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${validate_component(Layout, "Layout_MDSVEX_DEFAULT").$$render($$result, Object.assign($$props, metadata$5), {}, {
    default: () => `${validate_component(Image, "Image").$$render($$result, {
      alt: "A dumbbell plot depicting in-group differences between Republicans and Democrats' worry about the Coronavirus. It shows that Republicans are less worried than Democrats. The question text survey respondents answered is 'How concerned are you that you or someone you know will be infected with the Coronavirus?'",
      src: "../images/post/dumbbell-plots/featured.jpg"
    }, {}, {})}
<p>As of this writing, nearly <a href="${"https://www.worldometers.info/coronavirus/coronavirus-death-toll/"}" rel="${"nofollow"}">6000</a> people have died of COVID-19 and another <a href="${"https://www.worldometers.info/coronavirus/coronavirus-death-toll/"}" rel="${"nofollow"}">150,000</a> have been infected. All signs seem to show that the virus is only growing.</p>
<p>But some groups are less worried about COVID-19 than others. Recent <a href="${"https://poll.qu.edu/national/release-detail?ReleaseID=3657#.XmaSrM7okEs.twitter"}" rel="${"nofollow"}">polling</a> from Quinnipiac University suggests that worries about the coronavirus are related to one\u2019s partisan identity, age, and race.</p>
<p>Let\u2019s visualize that to see just how stark the differences are. I use dumbbell dot plots because they\u2019re some of the most powerful tools for visualizing differences between two groups (e.g. Republicans and Democrats).</p>
<h2 id="${"political-affiliation"}"><a href="${"#political-affiliation"}">Political affiliation</a></h2>
<p>Republicans tend to be significantly less worried about coronavirus than Democrats. This is true in two regards. First, with respect to <em>concern for becoming infected</em>:</p>
${validate_component(Image, "Image").$$render($$result, {
      alt: "A dumbbell plot depicting in-group differences between Republicans and Democrats' worry about the Coronavirus. It shows that Republicans are less worried than Democrats. The question text survey respondents answered is 'How concerned are you that you or someone you know will be infected with the Coronavirus?'",
      src: "../images/post/dumbbell-plots/partisan-worry.jpg"
    }, {}, {})}
<p>It\u2019s also true when we look at concern than COVID-19 will <em>disrupt an individual\u2019s life</em>:</p>
${validate_component(Image, "Image").$$render($$result, {
      alt: "A dumbbell plot depicting in-group differences between Republicans and Democrats' worry about the Coronavirus. It shows that Republicans are less worried than Democrats. The question text survey respondents answered is 'How concerned are you that the coronavirus will disrupt your daily life?'",
      src: "../images/post/dumbbell-plots/partisan-disrupt.jpg"
    }, {}, {})}
<p>Looking at the first plot, we notice that Republicans are <strong>3x more likely</strong> than Democrats to say that they are \u2019not concerned at all\u2019 by the prospect of coronavirus infecting them or someone they know. By contrast, Democrats are nearly <strong>3x as likely</strong> as Republicans to say that they are \u2018very concerned\u2019 by the same risk.</p>
<p>The second plot shows us similar trends for fears of disruption: 3 in 4 Democrats are concerned (very or somewhat) that COVID-19 will disrupt their daily lives, compared to only 38% of Republicans. While 26% of Democrats are not worried about disruption, the same is true for 61% of Republicans.</p>
<h2 id="${"age"}"><a href="${"#age"}">Age</a></h2>
<p>There is also a relationship between age and fears related to the coronavirus.</p>
${validate_component(Image, "Image").$$render($$result, {
      alt: "A dumbbell plot depicting in-group differences between different age groups' worry about the Coronavirus. It shows that older respondents are more concerned than younger ones. The question text survey respondents answered is 'How concerned are you that you or someone you know will be infected with the Coronavirus?'",
      src: "../images/post/dumbbell-plots/age-disrupt.jpg"
    }, {}, {})}
${validate_component(Image, "Image").$$render($$result, {
      alt: "A dumbbell plot depicting in-group differences between different age groups' worry about the Coronavirus. It shows that older respondents are more concerned than younger ones. The question text survey respondents answered is 'How concerned are you that you or someone you know will be infected with the Coronavirus?'",
      src: "../images/post/dumbbell-plots/age-worry.jpg"
    }, {}, {})}
<p>These plots show that there are significant differences in worry by age, but that fears of disruption are felt more universally than fears of infection. The first plot shows that <em>every age group</em> fears that COVID-19 will disrupt their daily lives; although younger people express this sentiment less frequently. The second plot <strong>the majority of people under age 50 are unconcerned by the prospect of COVID-19 infection</strong>. The opposite is true for older respondents; those aged 65 years and old are <strong>significantly</strong> more likely to be concerned by the risk of infection (62% vs 37%).</p>
<h2 id="${"why-dumbbell-plots"}"><a href="${"#why-dumbbell-plots"}">Why dumbbell plots?</a></h2>
<p>Dumbbell plots are an alternative to grouped barcharts. Like barcharts, they show differences between populations and they more powerfully represent the <em>distances between two groups</em>. They are frequently used by survey research firms such as the Pew Research Center, as seen in this <a href="${"https://twitter.com/pewresearch/status/1238345807348334593/photo/1"}" rel="${"nofollow"}">example</a>:</p>
${validate_component(Image, "Image").$$render($$result, {
      alt: "A dumbbell plot from the Pew Research Center, showcasing perceived importance of US military bases by the age of the respondent; older folks think overseas bases are more important.",
      src: "../images/post/dumbbell-plots/pew.jpg"
    }, {}, {})}
<p>While a barchart would require eight bars to visualize each datapoint above, a dumbbell dot plot shows eight dots <em>on four lines</em>, reducing clutter and emphasizing the differences <em>between groups</em>.</p>
<p>Here\u2019s another example, this time from <a href="${"https://www.axios.com/trumps-disapproval-rate-is-up-in-every-state-2495232720.html?utm_source=twitter&utm_medium=social&utm_campaign=organic&utm_content=infographic&utm_term=politics"}" rel="${"nofollow"}">Axios</a> (visualizing changes in presidential disapproval between January and October 2017):</p>
${validate_component(Image, "Image").$$render($$result, {
      alt: "A dumbbell plot from Axios, which showcases changes in approval ratings between January and October 2017, by state. Most states have become more disapproving of the President.",
      src: "../images/post/dumbbell-plots/axios.jpg"
    }, {}, {})}
<p>This pseudo-dumbbell plot (dumbbells with weird endpoints; don\u2019t pick up that side!) has 50 \u2018groups\u2019 (US states), but only two <em>outcomes</em> (January and October). A dumbbell plot is <em>far</em> superior to a grouped bar chart in this case because it emphasizes the difference is between two periods of time, and it does so with fewer objects (50 lines rather than 100 bars) than a barchart would use.</p>
<p>One key lesson from the examples above: If the <em>comparison</em> of interest is between two groups (e.g. Republicans and Democrats), or if the <em>outcome</em> of interest is two-fold (e.g. \u2018concerned\u2019 and \u2018not concerned\u2019), dot plots are a superior way to visualize your data.</p>
<h2 id="${"lets-make-it-in-r"}"><a href="${"#lets-make-it-in-r"}">Let\u2019s make it in R!</a></h2>
<p>Now it\u2019s time to make your own dumbbell dot plot. We\u2019ll be creating this viz:</p>
${validate_component(Image, "Image").$$render($$result, {
      alt: "A dumbbell plot depicting in-group differences between Republicans and Democrats' worry about the Coronavirus. It shows that Republicans are less worried than Democrats. The question text survey respondents answered is 'How concerned are you that you or someone you know will be infected with the Coronavirus?'",
      src: "../images/post/dumbbell-plots/partisan-worry.jpg"
    }, {}, {})}
<p>For reference, the data I\u2019m using looks like this:</p>
${validate_component(Image, "Image").$$render($$result, {
      alt: "A dumbbell plot depicting in-group differences between Republicans and Democrats' worry about the Coronavirus. It shows that Republicans are less worried than Democrats. The question text survey respondents answered is 'How concerned are you that the coronavirus will disrupt your daily life?'",
      src: "../images/post/dumbbell-plots/partisan-disrupt.jpg"
    }, {}, {})}
<p>Pretty simple, right? <a href="${"https://poll.qu.edu/national/release-detail?ReleaseID=3657#.XmaSrM7okEs.twitter"}" rel="${"nofollow"}">It comes from here, by the way.</a></p>
<p>The process relies on Bob Rudis\u2019s <code>ggalt</code> package and the <code>geom_dumbbell</code> function, which does most of the heavy lifting. This tutorial is mostly a step-by-step recreation of Rudis\u2019s code <a href="${"https://rud.is/b/2016/04/17/ggplot2-exercising-with-ggalt-dumbbells/"}" rel="${"nofollow"}">found here</a>.</p>
<p>For convenience, let\u2019s define a few things before we get started:</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">blue <span class="token operator">&lt;-</span> <span class="token string">"#0171CE"</span>
red <span class="token operator">&lt;-</span> <span class="token string">"#DE4433"</span></code>`}<!-- HTML_TAG_END --></pre>
<p>In addition to the colors, we create a hack-y function which allows us to selectively label points (thanks to Bob Rudis for <a href="${"https://rud.is/b/2016/04/17/ggplot2-exercising-with-ggalt-dumbbells/"}" rel="${"nofollow"}">this</a>, again):</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">percent_first <span class="token operator">&lt;-</span> <span class="token keyword">function</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  x <span class="token operator">&lt;-</span> sprintf<span class="token punctuation">(</span><span class="token string">"%d%%"</span><span class="token punctuation">,</span> round<span class="token punctuation">(</span>x<span class="token operator">*</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  x<span class="token punctuation">[</span><span class="token number">2</span><span class="token operator">:</span>length<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">&lt;-</span> sub<span class="token punctuation">(</span><span class="token string">"%$"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> x<span class="token punctuation">[</span><span class="token number">2</span><span class="token operator">:</span>length<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
  x
<span class="token punctuation">&#125;</span></code>`}<!-- HTML_TAG_END --></pre>
<h3 id="${"step-1-barebones"}"><a href="${"#step-1-barebones"}">Step 1: Barebones</a></h3>
<p>We begin with a basic <code>ggplot</code> object. In <code>geom_segment</code>, we define the pseudo-grid lines (one for each \u2018level\u2019 of concern).</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">library<span class="token punctuation">(</span>ggplot2<span class="token punctuation">)</span>
library<span class="token punctuation">(</span>ggalt<span class="token punctuation">)</span>
library<span class="token punctuation">(</span>tidyverse<span class="token punctuation">)</span>

ggplot<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  geom_segment<span class="token punctuation">(</span>data<span class="token operator">=</span>infected<span class="token punctuation">,</span> aes<span class="token punctuation">(</span>y<span class="token operator">=</span>concerned<span class="token punctuation">,</span> yend<span class="token operator">=</span>concerned<span class="token punctuation">,</span> x<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> xend<span class="token operator">=</span><span class="token number">.5</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
               color<span class="token operator">=</span><span class="token string">"#b2b2b2"</span><span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token number">0.15</span><span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>
<p>Here, <code>geom_segment</code> creates grey lines with a size of 0.15. The lines span from 0 to 0.5. This changes according to your data; because the largest number we are dealing with is .43 (representing 43% of Democrats), our bound on the right side can be 0.5; this also leaves room for the difference column which we create later.</p>
${validate_component(Image, "Image").$$render($$result, {
      alt: "A blank canvas with only plot bounds.",
      src: "../images/post/dumbbell-plots/process-0.jpg"
    }, {}, {})}
<p>Then, <code>geom_dumbbell</code> reads in our data and creates the dumbbells: we specify the <em>beginning</em> (<code>x</code>) of each dumbbell to represent Republicans and the <em>end</em> (<code>xend</code>) to correspond to Democrats. Other specifications affect the accompanying line and points.</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">geom_dumbbell<span class="token punctuation">(</span>data<span class="token operator">=</span>infected<span class="token punctuation">,</span> aes<span class="token punctuation">(</span>y<span class="token operator">=</span>concerned<span class="token punctuation">,</span> x<span class="token operator">=</span>rep<span class="token punctuation">,</span> xend<span class="token operator">=</span>dem<span class="token punctuation">)</span><span class="token punctuation">,</span>
                           size<span class="token operator">=</span><span class="token number">1.5</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">"#b2b2b2"</span><span class="token punctuation">,</span> size_x<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> size_xend <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span>
                           colour_x <span class="token operator">=</span> red<span class="token punctuation">,</span> colour_xend <span class="token operator">=</span> blue<span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>
<p>That code creates the following plot:</p>
${validate_component(Image, "Image").$$render($$result, {
      alt: "Four lines appear, each corresponding to the level of concern. The end of each line (signified with a blue or red dot) represents Democrats' and Republicans' level of concern. The x axis is percentage of respondents.",
      src: "../images/post/dumbbell-plots/process-1.jpg"
    }, {}, {})}
<p>Already, we can begin to see the barebones for the finished version: each dumbbell represents a level of concern, and visualizes Republicans and Democrats\u2019 proportions for that level.</p>
<h3 id="${"step-2-labels"}"><a href="${"#step-2-labels"}">Step 2: Labels</a></h3>
<p>The next step is creating the \u201CRepublican\u201D and \u201CDemocrat\u201D labels (in case colors aren\u2019t enough, or the image is seen in black and white!).</p>
<p>We can create labels with the following code:</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">geom_text<span class="token punctuation">(</span>data<span class="token operator">=</span>filter<span class="token punctuation">(</span>infected<span class="token punctuation">,</span> concerned<span class="token operator">==</span><span class="token string">"Very concerned"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
          aes<span class="token punctuation">(</span>x<span class="token operator">=</span>dem<span class="token punctuation">,</span> y<span class="token operator">=</span>concerned<span class="token punctuation">,</span> label<span class="token operator">=</span><span class="token string">"Democrats"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
          color<span class="token operator">=</span>blue<span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> vjust<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1.5</span><span class="token punctuation">,</span> fontface<span class="token operator">=</span><span class="token string">"bold"</span><span class="token punctuation">,</span> family<span class="token operator">=</span><span class="token string">"Lato"</span><span class="token punctuation">)</span> <span class="token operator">+</span>
geom_text<span class="token punctuation">(</span>data<span class="token operator">=</span>filter<span class="token punctuation">(</span>infected<span class="token punctuation">,</span> concerned<span class="token operator">==</span><span class="token string">"Very concerned"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
          aes<span class="token punctuation">(</span>x<span class="token operator">=</span>rep<span class="token punctuation">,</span> y<span class="token operator">=</span>concerned<span class="token punctuation">,</span> label<span class="token operator">=</span><span class="token string">"Republicans"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
          color<span class="token operator">=</span>red<span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> vjust<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1.5</span><span class="token punctuation">,</span> fontface<span class="token operator">=</span><span class="token string">"bold"</span><span class="token punctuation">,</span> family<span class="token operator">=</span><span class="token string">"Lato"</span><span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>
<p>This code is hopefully quite intuitive. Since we are only showing the labels once, we specify a filter in the <code>data</code> argument of <code>geom_text</code>. If we instead wanted to show the labels for only the bottom level of concern, we would specify <code>data=filter(infected, concerned==&quot;Not concerned at all\u201D)</code>.</p>
<p>We label each point at its respective political affiliation, and we specify color according to the point color. The rest is just minor beautification for the text.</p>
${validate_component(Image, "Image").$$render($$result, {
      alt: "In addition to the prior plot, there are now labels appended for each party.",
      src: "../images/post/dumbbell-plots/process-2.jpg"
    }, {}, {})}
<p>We also have to add direct labels for values, so that the exact percentages for each group are clear:</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">geom_text<span class="token punctuation">(</span>data<span class="token operator">=</span>infected<span class="token punctuation">,</span> aes<span class="token punctuation">(</span>x<span class="token operator">=</span>rep<span class="token punctuation">,</span> y<span class="token operator">=</span>concerned<span class="token punctuation">,</span> label<span class="token operator">=</span>percent_first<span class="token punctuation">(</span>rep<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
          color<span class="token operator">=</span>red<span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token number">2.75</span><span class="token punctuation">,</span> vjust<span class="token operator">=</span><span class="token number">2.5</span><span class="token punctuation">,</span> family<span class="token operator">=</span><span class="token string">"Lato"</span><span class="token punctuation">)</span> <span class="token operator">+</span>
geom_text<span class="token punctuation">(</span>data<span class="token operator">=</span>infected<span class="token punctuation">,</span> color<span class="token operator">=</span>blue<span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token number">2.75</span><span class="token punctuation">,</span> vjust<span class="token operator">=</span><span class="token number">2.5</span><span class="token punctuation">,</span> family<span class="token operator">=</span><span class="token string">"Lato"</span><span class="token punctuation">,</span>
          aes<span class="token punctuation">(</span>x<span class="token operator">=</span>dem<span class="token punctuation">,</span> y<span class="token operator">=</span>concerned<span class="token punctuation">,</span> label<span class="token operator">=</span>percent_first<span class="token punctuation">(</span>dem<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>
<p>Here, we utilize the function <code>percent_first</code> we defined earlier, because we only want percentages to appear on the first numbers (to reduce clutter). The rest of the labels are just numbers which represent percentages. The syntax here is simple syntax that should be familiar to <code>ggplot</code> users. It creates this output:</p>
${validate_component(Image, "Image").$$render($$result, {
      alt: "In addition to the prior plot, there are now direct labels for the percent of respondents represented by each point.",
      src: "../images/post/dumbbell-plots/process-3.jpg"
    }, {}, {})}
<h3 id="${"step-3-a-differences-column"}"><a href="${"#step-3-a-differences-column"}">Step 3: A differences column</a></h3>
<p>Finally, we want to help our viewers see <em>how stark</em> the differences between Democrats and Republicans really is. We do so with a differences column.</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">geom_rect<span class="token punctuation">(</span>data<span class="token operator">=</span>infected<span class="token punctuation">,</span> aes<span class="token punctuation">(</span>xmin<span class="token operator">=</span><span class="token number">.5</span><span class="token punctuation">,</span> xmax<span class="token operator">=</span><span class="token number">.6</span><span class="token punctuation">,</span> ymin<span class="token operator">=</span><span class="token operator">-</span><span class="token number">Inf</span><span class="token punctuation">,</span> ymax<span class="token operator">=</span><span class="token number">Inf</span><span class="token punctuation">)</span><span class="token punctuation">,</span> fill<span class="token operator">=</span><span class="token string">"grey"</span><span class="token punctuation">)</span> <span class="token operator">+</span>
geom_text<span class="token punctuation">(</span>data<span class="token operator">=</span>infected<span class="token punctuation">,</span> aes<span class="token punctuation">(</span>label<span class="token operator">=</span>paste0<span class="token punctuation">(</span>diff<span class="token operator">*</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token string">"%"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> y<span class="token operator">=</span>concerned<span class="token punctuation">,</span> x<span class="token operator">=</span><span class="token number">.55</span><span class="token punctuation">)</span><span class="token punctuation">,</span> fontface<span class="token operator">=</span><span class="token string">"bold"</span><span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> family<span class="token operator">=</span><span class="token string">"Lato"</span><span class="token punctuation">)</span> <span class="token operator">+</span>
geom_text<span class="token punctuation">(</span>data<span class="token operator">=</span>filter<span class="token punctuation">(</span>infected<span class="token punctuation">,</span> concerned<span class="token operator">==</span><span class="token string">"Very concerned"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            aes<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token number">.55</span><span class="token punctuation">,</span> y<span class="token operator">=</span>concerned<span class="token punctuation">,</span> label<span class="token operator">=</span><span class="token string">"Difference"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            color<span class="token operator">=</span><span class="token string">"black"</span><span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token number">3.1</span><span class="token punctuation">,</span> vjust<span class="token operator">=</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span> fontface<span class="token operator">=</span><span class="token string">"bold"</span><span class="token punctuation">,</span> family<span class="token operator">=</span><span class="token string">"Lato"</span><span class="token punctuation">)</span> <span class="token operator">+</span>
scale_x_continuous<span class="token punctuation">(</span>expand<span class="token operator">=</span>c<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> limits<span class="token operator">=</span>c<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">.625</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span>
scale_y_discrete<span class="token punctuation">(</span>expand<span class="token operator">=</span>c<span class="token punctuation">(</span><span class="token number">0.2</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>
<p>Here, we first create a grey rectangle with <code>geom_rect</code>. It spans the entire chart vertically, hence why <code>ymin</code> and <code>ymax</code> range from negative to positive infinity. Next, we create labels according to the differences column. We position each of them according to the degree of concern (our y-axis). Finally, we expand the bounds of the chart so its a bit prettier:</p>
${validate_component(Image, "Image").$$render($$result, {
      alt: "In addition to the prior plot, there is now a 'differences' column which has the difference between Republican and Democrat proportions added as a percent.",
      src: "../images/post/dumbbell-plots/process-4.jpg"
    }, {}, {})}
<h3 id="${"step-4-titles-labels--captions"}"><a href="${"#step-4-titles-labels--captions"}">Step 4: Titles, labels &amp; captions</a></h3>
<p>Finally, let\u2019s add our title, subtitle, caption, and axis labels:</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">labs<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token keyword">NULL</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token keyword">NULL</span><span class="token punctuation">,</span> title<span class="token operator">=</span><span class="token string">"Republicans are less worried about COVID-19"</span><span class="token punctuation">,</span>
       subtitle<span class="token operator">=</span>"How concerned are you that you or someone
								 you know will be infected with the coronavirus?"<span class="token punctuation">,</span>
       caption<span class="token operator">=</span>"Source<span class="token operator">:</span> Quinnipiac University Poll<span class="token punctuation">,</span> March <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">2020.</span> Q27
								&#92;n&#92;nDesign<span class="token operator">:</span> Connor Rothschild"<span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>
${validate_component(Image, "Image").$$render($$result, {
      alt: "In addition to the prior plot, there are now axis labels and a title.",
      src: "../images/post/dumbbell-plots/process-5.jpg"
    }, {}, {})}
<p>That\u2019s our plot! Too bad its kinda ugly. Let\u2019s fix that in our final step.</p>
<h3 id="${"step-5-beautification"}"><a href="${"#step-5-beautification"}">Step 5: Beautification</a></h3>
<p>Beautification occurs using the <code>theme</code> argument.</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">theme_bw<span class="token punctuation">(</span>base_family<span class="token operator">=</span><span class="token string">"Lato"</span><span class="token punctuation">)</span> <span class="token operator">+</span>
theme<span class="token punctuation">(</span>
  panel.grid.major<span class="token operator">=</span>element_blank<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  panel.grid.minor<span class="token operator">=</span>element_blank<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  panel.border<span class="token operator">=</span>element_blank<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  axis.ticks<span class="token operator">=</span>element_blank<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  axis.text.x<span class="token operator">=</span>element_blank<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  plot.title<span class="token operator">=</span>element_text<span class="token punctuation">(</span>size <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">,</span> face<span class="token operator">=</span><span class="token string">"bold"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  plot.title.position <span class="token operator">=</span> <span class="token string">"plot"</span><span class="token punctuation">,</span>
  plot.subtitle<span class="token operator">=</span>element_text<span class="token punctuation">(</span>face<span class="token operator">=</span><span class="token string">"italic"</span><span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token number">12</span><span class="token punctuation">,</span> margin<span class="token operator">=</span>margin<span class="token punctuation">(</span>b<span class="token operator">=</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  plot.caption<span class="token operator">=</span>element_text<span class="token punctuation">(</span>size<span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">,</span> margin<span class="token operator">=</span>margin<span class="token punctuation">(</span>t<span class="token operator">=</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">"#7a7d7e"</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>
<p>After specifying our base <code>ggplot</code> theme, <code>theme_bw</code>, we use <code>theme()</code> to specify a whole host of arguments.</p>
<p>To simplify, the above code:</p>
<ul><li>Removes grid lines (<code>panel.grid.major</code>, <code>panel.grid.minor</code>)</li>
<li>Removes the panel border (<code>panel.border</code>)</li>
<li>Removes axis ticks and axis text (<code>axis.ticks</code>, <code>axis.text.x</code>)</li>
<li>Positions the axis plot, subtitle, and caption, and styles them as well (<code>plot.title</code>, <code>plot.title.position</code>,<code>plot.subtitle</code>,<code>plot.caption</code>).</li></ul>
<p>Our final output:</p>
${validate_component(Image, "Image").$$render($$result, {
      alt: "Stylization is added to the chart. There is now a white background, Lato font, and better typography rules are followed.",
      src: "../images/post/dumbbell-plots/process-6.jpg"
    }, {}, {})}
<h2 id="${"to-summarize"}"><a href="${"#to-summarize"}">To summarize</a></h2>
<p>Our process looked like this:</p>
${validate_component(Image, "Image").$$render($$result, {
      alt: "A GIF showcasing the prior six steps outlined in this blog post; the GIF shows the chart going from a blank canvas to a full visual.",
      src: "../images/post/dumbbell-plots/process-gif.gif"
    }, {}, {})}
<p>The code for the above visualizations, as well as the underlying datasets and outputs, can be found <a href="${"https://github.com/connorrothschild/R/tree/master/covid"}" rel="${"nofollow"}">here</a>.</p>
<p>Thanks for reading!</p>`
  })}`;
});
var dumbbellPlots = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Dumbbell_plots,
  metadata: metadata$5
});
var metadata$4 = {
  "layout": "blog",
  "title": "Trends in Refugee Acceptance, 2002 to 2019",
  "description": "Or, how a single line of code can create a beautiful small multiples US map.",
  "date": "2020-02-02",
  "image": "refugee-trends/header.png",
  "archived": true,
  "tags": ["analysis", "r"]
};
var Refugee_trends = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${validate_component(Layout, "Layout_MDSVEX_DEFAULT").$$render($$result, Object.assign($$props, metadata$4), {}, {
    default: () => `${validate_component(Image, "Image").$$render($$result, {
      alt: "A small multiples map of refugee acceptance over time, across states",
      src: "../images/post/refugee-trends/featured.png"
    }, {}, {})}
<p>In <a href="${"https://connorrothschild.github.io/map-missing-migrants/"}" rel="${"nofollow"}">previous projects</a>, I\u2019ve explored how migration has unfolded across <em>places</em>: where migrants travel, where they go missing, and where their journeys come to a fatal end.</p>
<p>Next, I wanted to see how <em>host countries</em> have approached the migrant and refugee crisis, with a particular focus on the United States. In my mind, an effective visualization of the U.S.\u2019s response to an increasing number of refugees needs to present two things: how refugee acceptance has changed <em>over time</em> and how refugee acceptance differs <em>across states.</em></p>
<p>An effective way to present both of these trends is with a map of <a href="${"https://en.wikipedia.org/wiki/Small_multiple"}" rel="${"nofollow"}">small multiple</a> line charts. For aesthetic purposes, it would also be nice to arrange these multiples in a shape that vaguely resembles the United States. (This also makes it easier for readers to find their state of interest.)</p>
<p>There are examples of these types of small multiple maps across the internet. The Washington Post\u2019s <a href="${"https://www.washingtonpost.com/graphics/politics/how-fair-is-the-electoral-college/"}" rel="${"nofollow"}">overview of the electoral college</a> was visualized in the following way:</p>
${validate_component(Image, "Image").$$render($$result, {
      alt: "Washington Post small multiples map of electoral college data",
      src: "../images/post/refugee-trends/wapo.png"
    }, {}, {})}
<p>You can also find an overview of <em>why</em> they work, and some additional examples, on the <a href="${"https://policyviz.com/2016/05/19/small-multiple-tile-grid-map/"}" rel="${"nofollow"}">PolicyViz</a> blog:</p>
${validate_component(Image, "Image").$$render($$result, {
      alt: "Policy Viz's small multiples of overall voting results over time",
      src: "../images/post/refugee-trends/policyviz.jpg"
    }, {}, {})}
<h2 id="${"making-it-in-r"}"><a href="${"#making-it-in-r"}">Making it in R</a></h2>
<p>The process of creating a small multiple tile grid map is relatively easy in R (like most things done in R). It is considerably more difficult in D3.js; if you\u2019re interested in that type of thing, you can take a look at <a href="${"https://bl.ocks.org/jinniluo/a95b27b1f4ea65ae94ab6ca3fcfb5934#index.html"}" rel="${"nofollow"}">this code</a> for inspiration.</p>
<h4 id="${"step-1-build-the-basic-line-chart"}"><a href="${"#step-1-build-the-basic-line-chart"}">Step 1: Build the basic line chart</a></h4>
<p>The first step (after obnoxious data <a href="${"https://raw.githubusercontent.com/connorrothschild/R/master/refugee-trends/merge.R"}" rel="${"nofollow"}">merging</a> and cleaning) is getting a feel for the basic line chart. To do so, we can visualize the macro-level trends of refugee acceptance across <em>all states</em> combined.</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">data <span class="token percent-operator operator">%>%</span>
  group_by<span class="token punctuation">(</span>region_name_3<span class="token punctuation">)</span> <span class="token percent-operator operator">%>%</span>
  summarise<span class="token punctuation">(</span>textbox37 <span class="token operator">=</span> sum<span class="token punctuation">(</span>textbox37<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token percent-operator operator">%>%</span>
  ggplot<span class="token punctuation">(</span>aes<span class="token punctuation">(</span>x <span class="token operator">=</span> region_name_3<span class="token punctuation">,</span> y <span class="token operator">=</span> textbox37<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  geom_line<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  labs<span class="token punctuation">(</span>title <span class="token operator">=</span> <span class="token string">"Refugee Acceptance on the Decline"</span><span class="token punctuation">,</span>
       subtitle <span class="token operator">=</span> <span class="token string">"Number of refugees accepted annually, 2002 - 2019"</span><span class="token punctuation">,</span>
       x <span class="token operator">=</span> element_blank<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
       y <span class="token operator">=</span> element_blank<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  scale_y_continuous<span class="token punctuation">(</span>labels <span class="token operator">=</span> scales<span class="token operator">::</span>comma_format<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  scale_x_continuous<span class="token punctuation">(</span>breaks <span class="token operator">=</span> c<span class="token punctuation">(</span><span class="token number">2002</span><span class="token punctuation">,</span> <span class="token number">2019</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>
${validate_component(Image, "Image").$$render($$result, {
      alt: "A small multiples map of refugee acceptance over time, across states",
      src: "../images/post/refugee-trends/macro.jpg"
    }, {}, {})}
<p>Now we have the answer to our first question: <strong>how has refugee acceptance changed over time?</strong> The answer: pretty drastically. The US accepted nearly 100,000 refugees in 2016; 2 years later, that number was barely over 20,000.</p>
<h4 id="${"step-2-make-small-multiples"}"><a href="${"#step-2-make-small-multiples"}">Step 2: Make small multiples</a></h4>
<p>Next, we make 50 of these lines: one for each US state. We do so using Ryan Hafen\u2019s <code>geofacet</code> <a href="${"https://hafen.github.io/geofacet/rd.html"}" rel="${"nofollow"}">package</a>.</p>
<p>It\u2019s as simple as adding one line of code to our previous plot:</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">facet_geo<span class="token punctuation">(</span><span class="token operator">~</span> state<span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>
<p>This makes a plot that looks like this:</p>
${validate_component(Image, "Image").$$render($$result, {
      alt: "first try",
      src: "../images/post/refugee-trends/firsttry.jpg"
    }, {}, {})}
<p>It\u2019s alright, but not perfect! There are a few improvements we can definitely make.</p>
<p>For one, the axis labels overlap. We already know the range of years is between 2002 and 2019 (its in our subtitle!). So we can remove our x axis labels.</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">theme<span class="token punctuation">(</span>
  axis.text.x <span class="token operator">=</span> element_blank<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  axis.ticks.x <span class="token operator">=</span> element_blank<span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>
<p>Second, The axis lines (on both axes) seem unnecessary and (the x-axis specifically) can sometimes conceal trends for those states with lower values. Let\u2019s remove those too!</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">theme<span class="token punctuation">(</span>
  axis.line.x <span class="token operator">=</span> element_blank<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  axis.line.y <span class="token operator">=</span> element_blank<span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>
<p>Finally, I don\u2019t like huge gray boxes around my axis labels. Could we make those transparent?</p>
<pre class="${"language-undefined"}"><!-- HTML_TAG_START -->${`<code class="language-undefined">theme(
    strip.background = element_rect(color = &quot;white&quot;)
)</code>`}<!-- HTML_TAG_END --></pre>
<p>Add it all together (and tweak the font size), and we get this:</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">data <span class="token percent-operator operator">%>%</span>
  group_by<span class="token punctuation">(</span>region_name_3<span class="token punctuation">,</span> state<span class="token punctuation">)</span> <span class="token percent-operator operator">%>%</span>
  summarise<span class="token punctuation">(</span>textbox37 <span class="token operator">=</span> sum<span class="token punctuation">(</span>textbox37<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token percent-operator operator">%>%</span>
  ggplot<span class="token punctuation">(</span>aes<span class="token punctuation">(</span>x <span class="token operator">=</span> region_name_3<span class="token punctuation">,</span> y <span class="token operator">=</span> textbox37<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  geom_line<span class="token punctuation">(</span>color <span class="token operator">=</span> <span class="token string">"black"</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  scale_x_continuous<span class="token punctuation">(</span>breaks <span class="token operator">=</span> c<span class="token punctuation">(</span><span class="token number">2002</span><span class="token punctuation">,</span><span class="token number">2019</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  scale_y_continuous<span class="token punctuation">(</span>breaks <span class="token operator">=</span> c<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">12000</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  facet_geo<span class="token punctuation">(</span><span class="token operator">~</span> state<span class="token punctuation">,</span> grid <span class="token operator">=</span> <span class="token string">"us_state_grid1"</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  labs<span class="token punctuation">(</span>title <span class="token operator">=</span> <span class="token string">"Refugee Acceptance on the Decline"</span><span class="token punctuation">,</span>
       subtitle <span class="token operator">=</span> <span class="token string">"Number of refugees accepted annually, 2002 - 2019"</span><span class="token punctuation">,</span>
       x <span class="token operator">=</span> element_blank<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
       y <span class="token operator">=</span> element_blank<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  theme<span class="token punctuation">(</span>
    axis.text.x <span class="token operator">=</span> element_blank<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    axis.ticks.x <span class="token operator">=</span> element_blank<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    axis.line.x <span class="token operator">=</span> element_blank<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    axis.line.y <span class="token operator">=</span> element_blank<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    plot.title <span class="token operator">=</span> element_text<span class="token punctuation">(</span>size <span class="token operator">=</span> <span class="token number">24</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    plot.subtitle <span class="token operator">=</span> element_text<span class="token punctuation">(</span>size <span class="token operator">=</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    strip.background <span class="token operator">=</span> element_rect<span class="token punctuation">(</span>color <span class="token operator">=</span> <span class="token string">"white"</span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>
${validate_component(Image, "Image").$$render($$result, {
      alt: "secondtry",
      src: "../images/post/refugee-trends/secondtry.jpg"
    }, {}, {})}
<p>Pretty good! Much better. But we can add some elements to take our visualization to the next level.</p>
<p>Because our data spans nearly 20 years (2002 to 2019), we can overlay our small multiples with other variables of interest, such as who was President during a given period.</p>
<p>We do so using <code>geom_rect</code>:</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">geom_rect<span class="token punctuation">(</span>mapping<span class="token operator">=</span>aes<span class="token punctuation">(</span>xmin<span class="token operator">=</span><span class="token number">2009</span><span class="token punctuation">,</span> xmax<span class="token operator">=</span><span class="token number">2017</span><span class="token punctuation">,</span> ymin<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> ymax<span class="token operator">=</span><span class="token number">12000</span><span class="token punctuation">)</span><span class="token punctuation">,</span> fill <span class="token operator">=</span> <span class="token string">"#ADD8E6"</span><span class="token punctuation">,</span> alpha <span class="token operator">=</span> <span class="token number">.05</span><span class="token punctuation">)</span> <span class="token operator">+</span>
geom_rect<span class="token punctuation">(</span>mapping<span class="token operator">=</span>aes<span class="token punctuation">(</span>xmin<span class="token operator">=</span><span class="token number">2017</span><span class="token punctuation">,</span> xmax<span class="token operator">=</span><span class="token number">2019</span><span class="token punctuation">,</span> ymin<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> ymax<span class="token operator">=</span><span class="token number">12000</span><span class="token punctuation">)</span><span class="token punctuation">,</span> fill <span class="token operator">=</span> <span class="token string">"#FF9999"</span><span class="token punctuation">,</span> alpha <span class="token operator">=</span> <span class="token number">.05</span><span class="token punctuation">)</span> <span class="token operator">+</span></code>`}<!-- HTML_TAG_END --></pre>
<p>The first line of code creates a blue box which spans 2009 to 2017 (Obama\u2019s tenure). The second line creates a red box for Trump\u2019s presidency (so far).</p>
<p>Bringing it all together, the code and output look like this:</p>
<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r">data <span class="token percent-operator operator">%>%</span>
  group_by<span class="token punctuation">(</span>region_name_3<span class="token punctuation">,</span> state<span class="token punctuation">)</span> <span class="token percent-operator operator">%>%</span>
  summarise<span class="token punctuation">(</span>textbox37 <span class="token operator">=</span> sum<span class="token punctuation">(</span>textbox37<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token percent-operator operator">%>%</span>
  ggplot<span class="token punctuation">(</span>aes<span class="token punctuation">(</span>x <span class="token operator">=</span> region_name_3<span class="token punctuation">,</span> y <span class="token operator">=</span> textbox37<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  geom_line<span class="token punctuation">(</span>color <span class="token operator">=</span> <span class="token string">"black"</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  geom_rect<span class="token punctuation">(</span>mapping<span class="token operator">=</span>aes<span class="token punctuation">(</span>xmin<span class="token operator">=</span><span class="token number">2009</span><span class="token punctuation">,</span> xmax<span class="token operator">=</span><span class="token number">2017</span><span class="token punctuation">,</span> ymin<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> ymax<span class="token operator">=</span><span class="token number">12000</span><span class="token punctuation">)</span><span class="token punctuation">,</span> fill <span class="token operator">=</span> <span class="token string">"#ADD8E6"</span><span class="token punctuation">,</span> alpha <span class="token operator">=</span> <span class="token number">.05</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  geom_rect<span class="token punctuation">(</span>mapping<span class="token operator">=</span>aes<span class="token punctuation">(</span>xmin<span class="token operator">=</span><span class="token number">2017</span><span class="token punctuation">,</span> xmax<span class="token operator">=</span><span class="token number">2019</span><span class="token punctuation">,</span> ymin<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> ymax<span class="token operator">=</span><span class="token number">12000</span><span class="token punctuation">)</span><span class="token punctuation">,</span> fill <span class="token operator">=</span> <span class="token string">"#FF9999"</span><span class="token punctuation">,</span> alpha <span class="token operator">=</span> <span class="token number">.05</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  scale_x_continuous<span class="token punctuation">(</span>breaks <span class="token operator">=</span> c<span class="token punctuation">(</span><span class="token number">2002</span><span class="token punctuation">,</span><span class="token number">2019</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  scale_y_continuous<span class="token punctuation">(</span>breaks <span class="token operator">=</span> c<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">12000</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  facet_geo<span class="token punctuation">(</span><span class="token operator">~</span> state<span class="token punctuation">,</span> grid <span class="token operator">=</span> <span class="token string">"us_state_grid1"</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  labs<span class="token punctuation">(</span>title <span class="token operator">=</span> <span class="token string">"Refugee Acceptance on the Decline"</span><span class="token punctuation">,</span>
       subtitle <span class="token operator">=</span> <span class="token string">"Number of refugees accepted annually, 2002 - 2019"</span><span class="token punctuation">,</span>
       x <span class="token operator">=</span> element_blank<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
       y <span class="token operator">=</span> element_blank<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span>
  theme<span class="token punctuation">(</span>
    axis.text.x <span class="token operator">=</span> element_blank<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    axis.ticks.x <span class="token operator">=</span> element_blank<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    axis.line.x <span class="token operator">=</span> element_blank<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    axis.line.y <span class="token operator">=</span> element_blank<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    plot.title <span class="token operator">=</span> element_text<span class="token punctuation">(</span>size <span class="token operator">=</span> <span class="token number">24</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    plot.subtitle <span class="token operator">=</span> element_text<span class="token punctuation">(</span>size <span class="token operator">=</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    strip.background <span class="token operator">=</span> element_rect<span class="token punctuation">(</span>color <span class="token operator">=</span> <span class="token string">"white"</span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>
${validate_component(Image, "Image").$$render($$result, {
      alt: "r version",
      src: "../images/post/refugee-trends/ref.png"
    }, {}, {})}
<p>I brought that plot to Illustrator and made it a lot prettier. Here\u2019s the final version:</p>
${validate_component(Image, "Image").$$render($$result, {
      alt: "A small multiples map of refugee acceptance over time, across states",
      src: "../images/post/refugee-trends/featured.png"
    }, {}, {})}
<p>What do we notice? A few key states (Texas, California, Florida, and Michigan) make up the vast majority of refugee acceptance, while other accept almost <em>no</em> <em>refugees</em>. Nearly every state has reduced their refugee acceptance since 2017, but the bulk of this decline has come from these larger states.</p>
<p>While you\u2019re here, take a look at my project <a href="${"https://connorrothschild.github.io/map-missing-migrants/"}" rel="${"nofollow"}"><em>Mapping Missing Migrants.</em></a></p>`
  })}`;
});
var refugeeTrends = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Refugee_trends,
  metadata: metadata$4
});
var metadata$3 = {
  "layout": "blog",
  "title": "Creating the ultimate scatterplot in Svelte",
  "description": "Svelte + D3, in action",
  "date": "2021-07-09",
  "image": "svelte-and-d3/header.png",
  "draft": true,
  "tags": ["svelte", "d3", "tutorial"]
};
var Svelte_scatter = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${validate_component(Layout, "Layout_MDSVEX_DEFAULT").$$render($$result, Object.assign($$props, metadata$3), {}, {
    default: () => `

<p>Earlier this year, I wrote about how I use Svelte to compose beautiful, powerful data visualizations. In that post, I documented how Svelte has gradually replaced D3 as the key tool for creating graphics. </p>
<p>Here, I\u2019ll talk less <em>why</em> and more <em>how</em>. That is, I\u2019ll explain how to create <strong>the ultimate scatterplot</strong> using Svelte.</p>
<p>We\u2019ll be taking <a href="${"https://observablehq.com/@d3/scatterplot"}" rel="${"nofollow"}">this scatterplot</a>, from the team at Observable, and recreating it (sort of). Then, we\u2019ll make it (hopefully) better.</p>
<iframe title="${"An Observable chart of cars data"}" width="${"100%"}" height="${"684"}" frameborder="${"0"}" style="${"background: white"}" src="${"https://observablehq.com/embed/@d3/scatterplot?cells=chart"}"></iframe>
<p>In specific, we\u2019ll be doing the following:</p>
<ol><li>Decide upon and record our chart dimensions</li>
<li>Create a <code>&lt;Scatterplot /&gt;</code> component</li>
<li>Create a <code>&lt;Circle /&gt;</code> component</li>
<li>Create an <code>&lt;XAxis /&gt;</code> and <code>&lt;YAxis /&gt;</code> component</li>
<li>Add interactivity via voronoi hovering</li></ol>
<h2 id="${"chart-dimensions"}"><a href="${"#chart-dimensions"}">Chart dimensions</a></h2>
<p>Our first step is to decide upon and record our chart dimensions. For the sake of our example, lets make our chart\u2019s width <code>100%</code> of its container\u2019s width, and its height <code>600px</code>. In Svelte, we can bind a variable (in our case, <code>containerWidth</code>) to the <code>offsetWidth</code> of a container.</p>
<pre class="${"language-svelte"}"><!-- HTML_TAG_START -->${`<code class="language-svelte"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">
  <span class="token keyword">let</span> containerWidth<span class="token punctuation">;</span>
  <span class="token keyword">let</span> containerHeight <span class="token operator">=</span> <span class="token number">600</span><span class="token punctuation">;</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">'</span>chart-container<span class="token punctuation">'</span></span> <span class="token attr-name"><span class="token namespace">bind:</span>offsetWidth=</span><span class="token language-javascript"><span class="token punctuation">&#123;</span>containerWidth<span class="token punctuation">&#125;</span></span><span class="token punctuation">></span></span>
  <span class="token comment">&lt;!-- Chart will go here --></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code>`}<!-- HTML_TAG_END --></pre>
<p>Above, we\u2019re binding <code>containerWidth</code> to constantly equal the <a href="${"https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetWidth"}" rel="${"nofollow"}"><code>offsetWidth</code></a> of our <code>chart-container</code> div. This is generally a good decision because it binds the chart width to its <em>container</em>, rather than the <em>window</em>. This allows for the chart to be embedded in any sort of complex layout, and still remain properly sized.</p>
<p>More realistically, we want our <em>chart width</em> to be slightly smaller than our <em>container width</em>, so that we have room for things like axis ticks and labels. </p>
<p>We can record the exact number of pixels we want \u201Con the sides\u201D in an object called <code>margin</code>. Then, we can set a new variable, <code>chartWidth</code> to equal the container width, minus our horizontal margins.</p>
<pre class="${"language-svelte"}"><!-- HTML_TAG_START -->${`<code class="language-svelte"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">
  <span class="token keyword">let</span> containerWidth<span class="token punctuation">;</span>
  <span class="token keyword">let</span> containerHeight <span class="token operator">=</span> <span class="token number">600</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> margin <span class="token operator">=</span> <span class="token punctuation">&#123;</span>top<span class="token operator">:</span> <span class="token number">30</span><span class="token punctuation">,</span> right<span class="token operator">:</span> <span class="token number">20</span><span class="token punctuation">,</span> bottom<span class="token operator">:</span> <span class="token number">50</span><span class="token punctuation">,</span> left<span class="token operator">:</span> <span class="token number">50</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

  $<span class="token operator">:</span> chartWidth <span class="token operator">=</span> containerWidth <span class="token operator">-</span> margin<span class="token punctuation">.</span>left <span class="token operator">-</span> margin<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
  $<span class="token operator">:</span> chartHeight <span class="token operator">=</span> containerHeight <span class="token operator">-</span> margin<span class="token punctuation">.</span>top <span class="token operator">-</span> margin<span class="token punctuation">.</span>bottom<span class="token punctuation">;</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">'</span>chart-container<span class="token punctuation">'</span></span> <span class="token attr-name"><span class="token namespace">bind:</span>offsetWidth=</span><span class="token language-javascript"><span class="token punctuation">&#123;</span>containerWidth<span class="token punctuation">&#125;</span></span><span class="token punctuation">></span></span>
  <span class="token comment">&lt;!-- Chart will go here --></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code>`}<!-- HTML_TAG_END --></pre>
${validate_component(Info, "Info").$$render($$result, {}, {}, {
      default: () => `<p>We\u2019re using the <code>$</code> notation here because <code>chartWidth</code> is <em>reactive</em>; that is, it updates according to another variable, <code>containerWidth</code>, which updates on resize.</p>`
    })}
<p>To see our reactive chart dimensions in action, play around with the width of the playground below:</p>
<iframe src="${"https://svelte.dev/repl/060a2a7847bc479eb4e456c966f096e9?version=3.38.3"}" width="${"100%"}" height="${"600"}" title="${"Responsive chart container"}"></iframe>
<h2 id="${"create-a-ltscatterplot-gt-component"}"><a href="${"#create-a-ltscatterplot-gt-component"}">Create a <code>&lt;Scatterplot /&gt;</code> component</a></h2>
<p>Now that we have our chart dimensions, we can pass those dimensions into a component<more-info content="${"A component is a reusable file that includes integrated markup, styles and functionality."}" href="${"https://v2.svelte.dev/guide"}"></more-info> that will handle the visualization itself.</p>
<p>We\u2019ll want our scatterplot component to receive four properties.<more-info content="${"Props are values passed from one component to another."}" href="${"https://svelte.dev/tutorial/declaring-props"}"></more-info></p>
<ol><li>The data (<code>data</code>)</li>
<li>Our chart width (<code>chartWidth</code>)</li>
<li>Our chart height (<code>chartHeight</code>)</li>
<li>The margins surrounding our chart (<code>margin</code>)</li></ol>
<p>In code, that looks like this:</p>
<pre class="${"language-svelte"}"><!-- HTML_TAG_START -->${`<code class="language-svelte"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">'</span>chart-container<span class="token punctuation">'</span></span> <span class="token attr-name"><span class="token namespace">bind:</span>offsetWidth=</span><span class="token language-javascript"><span class="token punctuation">&#123;</span>containerWidth<span class="token punctuation">&#125;</span></span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Scatterplot</span> <span class="token language-javascript"><span class="token punctuation">&#123;</span>data<span class="token punctuation">&#125;</span></span> <span class="token attr-name">width=</span><span class="token language-javascript"><span class="token punctuation">&#123;</span>chartWidth<span class="token punctuation">&#125;</span></span> <span class="token attr-name">height=</span><span class="token language-javascript"><span class="token punctuation">&#123;</span>chartHeight<span class="token punctuation">&#125;</span></span> <span class="token language-javascript"><span class="token punctuation">&#123;</span>margin<span class="token punctuation">&#125;</span></span> <span class="token punctuation">/></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code>`}<!-- HTML_TAG_END --></pre>
<p>And in <code>Scatterplot.svelte</code>, we receive our props like this:</p>
<pre class="${"language-svelte"}"><!-- HTML_TAG_START -->${`<code class="language-svelte"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">
  <span class="token keyword">export</span> <span class="token keyword">let</span> data<span class="token punctuation">;</span>
  <span class="token keyword">export</span> <span class="token keyword">let</span> width<span class="token punctuation">;</span>
  <span class="token keyword">export</span> <span class="token keyword">let</span> height<span class="token punctuation">;</span>
  <span class="token keyword">export</span> <span class="token keyword">let</span> margin<span class="token punctuation">;</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code>`}<!-- HTML_TAG_END --></pre>
<p>Now that we have our dimensions, we\u2019ll want to create <em>scales</em> with them.<more-info content="${"Scales map datapoints to positions on the canvas."}" href="${"https://www.d3indepth.com/scales/"}"></more-info></p>
<p>Here, we will leverage the power of D3\u2014in particular, <a href="${"https://github.com/d3/d3-scale"}" rel="${"nofollow"}"><code>d3-scale</code></a>\u2014to map our data\u2019s values to points on our canvas.</p>
<p>We\u2019ll want to make our scales reactive according to our dynamic size variables we referenced earlier. Here, notice how we use <code>$</code> to denote reactivity, and notice how we reference <code>width</code>.</p>
<pre class="${"language-svelte"}"><!-- HTML_TAG_START -->${`<code class="language-svelte"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">
<span class="token comment">// Import props...</span>
<span class="token keyword">import</span> <span class="token punctuation">&#123;</span> scaleLinear <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">"d3-scale"</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">&#123;</span> extent <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">"d3-array"</span><span class="token punctuation">;</span>

$<span class="token operator">:</span> xScale <span class="token operator">=</span> <span class="token function">scaleLinear</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">domain</span><span class="token punctuation">(</span><span class="token function">extent</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">d</span><span class="token punctuation">)</span> <span class="token operator">=></span> d<span class="token punctuation">.</span>mpg<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">range</span><span class="token punctuation">(</span><span class="token punctuation">[</span>margin<span class="token punctuation">.</span>left<span class="token punctuation">,</span> width <span class="token operator">-</span> margin<span class="token punctuation">.</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

$<span class="token operator">:</span> yScale <span class="token operator">=</span> <span class="token function">scaleLinear</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">domain</span><span class="token punctuation">(</span><span class="token function">extent</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">d</span><span class="token punctuation">)</span> <span class="token operator">=></span> d<span class="token punctuation">.</span>hp<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">range</span><span class="token punctuation">(</span><span class="token punctuation">[</span>height <span class="token operator">-</span> margin<span class="token punctuation">.</span>top<span class="token punctuation">,</span> margin<span class="token punctuation">.</span>bottom<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code>`}<!-- HTML_TAG_END --></pre>
<p>In the above code, we\u2019re defining the domain <more-info content="${"A domain accepts the range of values to map data from."}" href="${"https://observablehq.com/@d3/introduction-to-d3s-scales#cell-104"}"></more-info> according to each cars\u2019 miles per gallon (<code>mpg</code>) and horsepower (<code>hp</code>). We set the parameters for our range <more-info content="${"A range converts the values from our domain into a specified 'range' of positions."}" href="${"https://observablehq.com/@d3/introduction-to-d3s-scales#cell-104"}"></more-info> to span the starting position (the left/bottom margin) to our chart width/height (minus our right/top margin value).</p>
<p>Now, when we pass a number into a scale, it will result in a point on the canvas. For example, the code <code>xScale(25)</code> would result in a value of <code>__</code>. </p>
<p>We\u2019ll use these scales to define the <code>cx</code> and <code>cy</code> values for each of our circles. To do so, we\u2019ll need to iterate on each datapoint and render something. </p>
<h2 id="${"iterate-with-an-123each125-block"}"><a href="${"#iterate-with-an-123each125-block"}">Iterate with an <code>{#each}</code> block</a></h2>
<p>In Svelte, an <code>{#each}</code> block<more-info content="${"These blocks of code function similarly to a for loop, but in our markup."}" href="${"https://svelte.dev/tutorial/each-blocks"}"></more-info> enables us to render listed content programatically, and include multiple attributes in the resulting markup.</p>
<p>For our data, we\u2019ll want to iterate over each <em>row</em> of our data, and pass each <em>row\u2019</em>s <code>mpg</code> and <code>hp</code> (or whatever value you want to pass to the scatterplot) into a component that will eventually render some SVG.</p>
<p>Lets learn by doing. If we simply iterated on each row and wrote out our MPG and HP values, it would look like this:</p>
<iframe src="${"https://svelte.dev/repl/7e3ec27da41440e880a49f83068fd97a?version=3.42.1\n"}" width="${"100%"}" height="${"600"}" title="${"Simple each block"}"></iframe>
<p>But we don\u2019t want to write out our values, we want to:</p>
<ol><li>Transform those values into points on the canvas</li>
<li>Pass them to a component that will render SVG elements</li></ol>
<p>To transform \u2026</p>

<h2 id="${"create-a-ltcircle-gt-component"}"><a href="${"#create-a-ltcircle-gt-component"}">Create a <code>&lt;Circle /&gt;</code> component</a></h2>
<p>Next, we want to create a <code>&lt;Circle /&gt;</code> component that will take in our mapped data, and display an SVG with the appropriate attributes. We first import our props, like so:</p>
<pre class="${"language-svelte"}"><!-- HTML_TAG_START -->${`<code class="language-svelte"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">
  <span class="token keyword">export</span> <span class="token keyword">let</span> cx<span class="token punctuation">;</span>
  <span class="token keyword">export</span> <span class="token keyword">let</span> cy<span class="token punctuation">;</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code>`}<!-- HTML_TAG_END --></pre>`
  })}`;
});
var svelteScatter = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Svelte_scatter,
  metadata: metadata$3
});
var css = {
  code: "svg.svelte-1ijjfyd{width:100%;margin:0.5rem 0 1.5rem 0;border-radius:6px}rect.svelte-1ijjfyd{width:100%;height:100%}circle.svelte-1ijjfyd{cursor:crosshair}",
  map: `{"version":3,"file":"svelte-and-d3.md","sources":["svelte-and-d3.md"],"sourcesContent":["<script context=\\"module\\">\\n\\texport const metadata = {\\"layout\\":\\"blog\\",\\"title\\":\\"Making visualizations literally using Svelte + D3\\",\\"description\\":\\"Why Svelte has replaced (and complemented) D3 as my go-to tool for powerful visualizations\\",\\"image\\":\\"lorem\\",\\"date\\":\\"2021-07-02\\",\\"featured\\":true,\\"tags\\":[\\"svelte\\",\\"d3\\",\\"tutorial\\"]};\\n\\tconst { layout, title, description, image, date, featured, tags } = metadata;\\n<\/script>\\n<script>\\n\\timport Layout_MDSVEX_DEFAULT from '/Users/connorrothschild/Desktop/Projects/Svelte/new-site/src/routes/post/layout.svelte';\\n  import Code from \\"$lib/global/Code.svelte\\"\\n  import CodeMirror from '$lib/global/CodeMirror.svelte';\\n  import Image from \\"$lib/global/Image.svelte\\"\\n  import Info from \\"$lib/global/Info.svelte\\"\\n<\/script>\\n<style>\\nhtml {\\n    scroll-behavior: smooth;\\n}\\n\\nsvg {\\n  width: 100%;\\n  margin: 0.5rem 0 1.5rem 0;\\n  border-radius: 6px;\\n}\\n\\nrect {\\n  width: 100%; \\n  height: 100%;\\n  /* fill: rgb(var(--primary), .5); */\\n}\\n\\ncircle {\\n  cursor: crosshair;\\n}\\n</style>\\n<Layout_MDSVEX_DEFAULT {...$$props} {...metadata}>\\n\\n<p>When I started making data visualizations, I considered <a\\n  href=\\"https://d3js.org/\\"\\n  rel=\\"nofollow\\"\\n>D3</a>\u2014Data Driven Documents\u2014to be the gold standard programming language required to create beautiful graphics on the web.</p>\\n<p>As I progress in my career, I\u2019m realizing that D3 has a more particular (and smaller) role in the visualization lifecycle than I initially envisioned. As I design more visualizations, I\u2019m learning that my most efficient and intuitive development comes when I <strong>program literally</strong>. </p>\\n<p>What does that mean? (To be honest, I\u2019m making up the term.) It means that I\u2019m moving away from <em>pseudo-declarative</em> data visualization in D3, and starting to make my visualizations <em>literally</em>, by simply writing markup in <a\\n  href=\\"https://svelte.dev/\\"\\n  rel=\\"nofollow\\"\\n>Svelte</a>. </p>\\n<p>Although D3 <a href=\\"https://d3js.org/#selections\\" rel=\\"nofollow\\">claims</a> to be declarative, it still uses <a\\n  href=\\"https://www.carlosrendon.me/unfinished_d3_book/d3_method_chaining.html\\"\\n  rel=\\"nofollow\\"\\n>method chaining</a> to provide instructions to render visuals. In Svelte, we don\u2019t provide instructions but instead render our SVG elements directly, using <code>&#123;#each&#125;</code> blocks. By writing my markup literally and appending data inline, my code makes more sense and causes fewer headaches.</p>\\n<h3 id=\\"what-youll-find-in-this-post\\"><a href=\\"#what-youll-find-in-this-post\\">What you\u2019ll find in this post</a></h3>\\n<p>In this post, I\u2019ll <a href=\\"#what-d3-does-3%EF%B8%8F%E2%83%A3\\">1)</a> provide an overview of D3, and how it made the process of creating visualizations so much easier; <a\\n  href=\\"#literal-programming-with-svelte-\\"\\n>2)</a> explain why I\u2019m moving away from D3 for DOM manipulation, and instead using Svelte \u201Cliterally\u201D; and <a\\n  href=\\"#bringing-it-home-with-burgers-\\"\\n>3)</a> provide a funky burger \u{1F354} example to explain my logic.</p>\\n <Info>\\n<p>This is not a comprehensive tutorial about <strong>how to</strong> use D3 and Svelte together. I\u2019ll cover that in the <a\\n  href=\\"https://twitter.com/CL_Rothschild\\"\\n  rel=\\"nofollow\\"\\n>future</a>. In the meantime, check out tutorials from <a\\n  href=\\"https://www.youtube.com/watch?v=bnd64ZrHC0U\\"\\n  rel=\\"nofollow\\"\\n>Matthias Stahl</a>, examples of Svelte and D3 in action on The Pudding\u2019s <a\\n  href=\\"https://github.com/the-pudding/\\"\\n  rel=\\"nofollow\\"\\n>GitHub</a>, and an example of similar framework-driven logic on Amelia Wattenberger\u2019s <a\\n  href=\\"https://wattenberger.com/post/react-and-d3\\"\\n  rel=\\"nofollow\\"\\n>blog</a>. </p>\\n<p>Want an immediate example? Here\u2019s an (admittedly verbose) <a\\n  href=\\"https://github.com/connorrothschild/bob-ross-art-gallery/blob/master/src/components/ColorViz.svelte\\"\\n  rel=\\"nofollow\\"\\n>Svelte component</a> I used in a recent project about Bob Ross.</p>\\n</Info> \\n<h2 id=\\"what-d3-does-3\uFE0F\u20E3\\"><a href=\\"#what-d3-does-3\uFE0F\u20E3\\">What D3 does 3\uFE0F\u20E3</a></h2>\\n<p>D3 allows for intuitive transformations of the DOM by leveraging easy-to-understand selection syntax. Sound confusing? Let\u2019s learn through an example (adapted from the <a\\n  href=\\"https://d3js.org/#selections\\"\\n  rel=\\"nofollow\\"\\n>D3 homepage</a>). Imagine we had 5 circles and wanted to change the fill of each. </p>\\n<svg>\\n  <rect width=\\"100%\\" height=\\"100%\\"></rect>\\n  <circle cx=\\"10%\\" cy=\\"50%\\" r=\\"10\\" fill=\\"steelblue\\"><title>Hello from the circle!</title></circle>\\n  <circle cx=\\"30%\\" cy=\\"50%\\" r=\\"10\\" fill=\\"steelblue\\"><title>Hello from the circle!</title></circle>\\n  <circle cx=\\"50%\\" cy=\\"50%\\" r=\\"10\\" fill=\\"steelblue\\"><title>Hello from the circle!</title></circle>\\n  <circle cx=\\"70%\\" cy=\\"50%\\" r=\\"10\\" fill=\\"steelblue\\"><title>Hello from the circle!</title></circle>\\n  <circle cx=\\"90%\\" cy=\\"50%\\" r=\\"10\\" fill=\\"steelblue\\"><title>Hello from the circle!</title></circle>\\n</svg>\\n<p>In the traditional <a\\n  href=\\"https://www.w3schools.com/js/js_htmldom.asp\\"\\n  rel=\\"nofollow\\"\\n>HTML DOM model</a>, we would 1) select all circles, 2) loop through each one, and 3) redefine its fill. In code, that would look like this:</p>\\n<Code language='js'>\\n<pre class=\\"language-undefined\\">{@html \`<code class=\\"language-undefined\\">var circles = document.getElementsByTagName(&quot;circle&quot;);\\nfor (var i = 0; i &lt; circles.length; i++) &#123;\\n  var circle = circles.item(i);\\n  circle.setAttribute(&quot;fill&quot;, &quot;white&quot;, null);\\n&#125;</code>\`}</pre>\\n</Code>\\n<p>Doing this in D3 would reduce the length of our code by a factor of 5, and allows us to write in a way that <em>just makes sense</em>. Here, we select every circle and change its fill.</p>\\n<Code language='js'>\\nd3.selectAll(\\"circle\\").style(\\"fill\\", \\"white\\")\\n</Code>\\n<svg>\\n  <rect width=\\"100%\\" height=\\"100%\\"/>\\n  <circle cx=\\"10%\\" cy=\\"50%\\" r=\\"10\\" fill=\\"white\\"><title>Hello from the circle!</title></circle>\\n  <circle cx=\\"30%\\" cy=\\"50%\\" r=\\"10\\" fill=\\"white\\"><title>Hello from the circle!</title></circle>\\n  <circle cx=\\"50%\\" cy=\\"50%\\" r=\\"10\\" fill=\\"white\\"><title>Hello from the circle!</title></circle>\\n  <circle cx=\\"70%\\" cy=\\"50%\\" r=\\"10\\" fill=\\"white\\"><title>Hello from the circle!</title></circle>\\n  <circle cx=\\"90%\\" cy=\\"50%\\" r=\\"10\\" fill=\\"white\\"><title>Hello from the circle!</title></circle>\\n</svg>\\n<p>Imagine if you also wanted to bind data to those circles. That is, you wanted to fill the circle according to some attribute, or size its radius according to some datapoint. In traditional JavaScript, that might look something like this:</p>\\n<Code language='js'>\\n<pre class=\\"language-undefined\\">{@html \`<code class=\\"language-undefined\\">let data = [5, 10, 15, 20, 25];\\n\\nvar circles = document.getElementsByTagName(&quot;circle&quot;);\\nfor (var i = 0; i &lt; circles.length; i++) &#123;\\n  var circle = circles.item(i);\\n  circle.style.setProperty(&quot;r&quot;, data[i], null);\\n&#125;</code>\`}</pre>\\n</Code>\\n<p>Not too hard\u2014but also, not too easy. D3 simplifies this logic by removing the need for a loop and iterating on your selection for you:</p>\\n<Code language='js'>\\n<pre class=\\"language-js\\">{@html \`<code class=\\"language-js\\"><span class=\\"token keyword\\">let</span> data <span class=\\"token operator\\">=</span> <span class=\\"token punctuation\\">[</span><span class=\\"token number\\">5</span><span class=\\"token punctuation\\">,</span> <span class=\\"token number\\">10</span><span class=\\"token punctuation\\">,</span> <span class=\\"token number\\">15</span><span class=\\"token punctuation\\">,</span> <span class=\\"token number\\">20</span><span class=\\"token punctuation\\">,</span> <span class=\\"token number\\">25</span><span class=\\"token punctuation\\">]</span><span class=\\"token punctuation\\">;</span>\\n\\nd3<span class=\\"token punctuation\\">.</span><span class=\\"token function\\">selectAll</span><span class=\\"token punctuation\\">(</span><span class=\\"token string\\">\\"circle\\"</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">.</span><span class=\\"token function\\">data</span><span class=\\"token punctuation\\">(</span>data<span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">.</span><span class=\\"token function\\">attr</span><span class=\\"token punctuation\\">(</span><span class=\\"token string\\">\\"r\\"</span><span class=\\"token punctuation\\">,</span> <span class=\\"token parameter\\">d</span> <span class=\\"token operator\\">=></span> d<span class=\\"token punctuation\\">)</span></code>\`}</pre>\\n</Code>\\n<svg>\\n  <rect width=\\"100%\\" height=\\"100%\\" />\\n  <circle cx=\\"10%\\" cy=\\"50%\\" r=\\"5\\"  fill=\\"white\\"><title>Hello from the circle!</title></circle>\\n  <circle cx=\\"30%\\" cy=\\"50%\\" r=\\"10\\" fill=\\"white\\"><title>Hello from the circle!</title></circle>\\n  <circle cx=\\"50%\\" cy=\\"50%\\" r=\\"15\\" fill=\\"white\\"><title>Hello from the circle!</title></circle>\\n  <circle cx=\\"70%\\" cy=\\"50%\\" r=\\"20\\" fill=\\"white\\"><title>Hello from the circle!</title></circle>\\n  <circle cx=\\"90%\\" cy=\\"50%\\" r=\\"25\\" fill=\\"white\\"><title>Hello from the circle!</title></circle>\\n</svg>\\n<p>Again, we reduce the length of our code nearly 5x, and the code just <strong>makes sense</strong>.</p>\\n<p>All that to say, D3 is great. It works, and it works wonderfully. By removing the need to write highly imperative code that is unintuitive in nature, D3 saves developers time and allows for more powerful visualizations.</p>\\n<p>But I\u2019m hardly using it at all recently. Increasingly, I\u2019ve been using the JavaScript <del>framework</del> compiler <a href=\\"https://svelte.dev/\\" rel=\\"nofollow\\">Svelte</a> to <em>write SVG directly</em> rather than <em>tell JavaScript to write SVG</em>. How? Let\u2019s see below.</p>\\n<h2 id=\\"literal-programming-with-svelte-\\"><a href=\\"#literal-programming-with-svelte-\\">\u201CLiteral\u201D programming with Svelte \u{1F5E3}</a></h2>\\n<p>Going back to the above circles, imagine if we could simply bind our data to our app\u2019s markup <strong>directly</strong>, without any intermediate code serving as instructions.</p>\\n<p><strong>We can!</strong> Svelte (and Vue, React and other frameworks) allow for seamless interactions between our app\u2019s logic, data, and markup, so that we can embed data directly into our SVG elements. In this new paradigm, we could replace the set of D3 instructions from earlier with the following Svelte code:</p>\\n<Code language='svelte'>\\n<pre class=\\"language-undefined\\">{@html \`<code class=\\"language-undefined\\">&lt;script&gt;\\n  let data = [&#123;x: 10, r: 5 &#125;, \\n              &#123;x: 30, r: 10&#125;, \\n              &#123;x: 50, r: 15&#125;, \\n              &#123;x: 70, r: 20&#125;, \\n              &#123;x: 90, r: 25&#125;]\\n&lt;/script&gt;\\n\\n&lt;p&gt;&#123;data.map(x =&gt; x)&#125;&lt;/p&gt;</code>\`}</pre>\\n</Code>\\n<!-- <svg>\\n  <rect width=\\"100%\\" height=\\"100%\\"/>\\n  <circle cx=\\"10%\\" cy=\\"50%\\" r=\\"5\\"  fill=\\"white\\"><title>Hello from the circle with a radius of 5!</title></circle>\\n  <circle cx=\\"30%\\" cy=\\"50%\\" r=\\"10\\" fill=\\"white\\"><title>Hello from the circle with a radius of 10!</title></circle>\\n  <circle cx=\\"50%\\" cy=\\"50%\\" r=\\"15\\" fill=\\"white\\"><title>Hello from the circle with a radius of 15!</title></circle>\\n  <circle cx=\\"70%\\" cy=\\"50%\\" r=\\"20\\" fill=\\"white\\"><title>Hello from the circle with a radius of 20!</title></circle>\\n  <circle cx=\\"90%\\" cy=\\"50%\\" r=\\"25\\" fill=\\"white\\"><title>Hello from the circle with a radius of 25!</title></circle>\\n</svg> -->\\n<p>In my view, there are three benefits to writing our code this way:</p>\\n<ol>\\n<li><strong>More intuitive authoring.</strong> It feels much more natural to write our SVG elements <em>directly</em> rather than provide D3 instructions on how to do so.</li>\\n<li><strong>Less friction in translating D3 to the DOM.</strong> By writing SVG directly, we could copy an SVG element from the <a\\n  href=\\"https://developer.mozilla.org/en-US/docs/Web/SVG/Element/circle\\"\\n  rel=\\"nofollow\\"\\n>MDN docs</a>, paste in our values, and see immediate results. Fewer handoffs results in fewer errors.</li>\\n<li><strong>Reusability.</strong> Creating a robust and flexible <code>&lt;Circle /&gt;</code>, <code>&lt;Bar /&gt;</code>, or <code>&lt;Axis /&gt;</code> component permits consistent reuse within and across projects. D3 code is usually written as a series of blocks which lacks a natural structure and becomes difficult to reuse effectively.</li>\\n</ol>\\n<p>The only downside (which is actually just an adjustment) is that this new approach requires you to learn how to <a\\n  href=\\"https://www.w3schools.com/graphics/svg_intro.asp\\"\\n  rel=\\"nofollow\\"\\n>write SVG</a>. But isn\u2019t it a good exercise to learn the anatomy of what we\u2019re actually creating? Having knowledge of SVG elements and attributes will benefit any developer who creates visuals, no matter how they eventually do so.</p>\\n<p>Not convinced? Let me explain the logic one more time, with a tastier example:</p>\\n<h2 id=\\"bringing-it-home-with-burgers-\\"><a href=\\"#bringing-it-home-with-burgers-\\">Bringing it home with burgers \u{1F354}</a></h2>\\n<p>Imagine we want to prepare a burger. We have an array of objects, each with an ingredient and ingredient-specfic instructions. We want to 1) create each item (insert it into the DOM), and 2) carry out its instructions (execute some function).</p>\\n<Code language='js'>\\n<pre class=\\"language-undefined\\">{@html \`<code class=\\"language-undefined\\">let ingredients = [\\n  &#123;item: &quot;Top Bun&quot;, instruction: &quot;Place at top of burger.&quot;&#125;,\\n  &#123;item: &quot;Pickles&quot;, instruction: &quot;Three pickles, please.&quot;&#125;,\\n  &#123;item: &quot;Cheese&quot;, instruction: &quot;Cheese is optional, but it makes the burger better.&quot;&#125;,\\n  &#123;item: &quot;Patty&quot;, instruction: &quot;Cook to your satisfaction. Optionally, add two patties.&quot;&#125;,\\n  &#123;item: &quot;Tomato&quot;, instruction: &quot;Should be the same width as bun, and thinly sliced.&quot;&#125;,\\n  &#123;item: &quot;Lettuce&quot;, instruction: &quot;Should be the same width as bun.&quot;&#125;,\\n  &#123;item: &quot;Bottom Bun&quot;, instruction: &quot;Place at bottom of burger.&quot;&#125;,\\n]</code>\`}</pre>\\n</Code>\\n<p>There are three ways to make this burger (at least, in our fantasy world where we make burgers via code).</p>\\n<Info>\\n<p>Although I use the Svelte REPL to showcase these three examples, only the last one requires Svelte. The REPL is just a nice place to host (editable!) code \u{1F642}</p>\\n</Info>\\n<p><strong>The first option</strong> (old school) is to tell your app to loop through each ingredient, add it to the others, and stack the ingredients accordingly. For each ingredient in the loop, execute the burger-making according to our ingredient-specific instruction. This is how burgers would have been made, painfully, before D3.</p>\\n<iframe src=\\"https://svelte.dev/repl/4b4eee03981b4450aa08e402aa0ceeb6?version=3.38.3\\" width=\\"100%\\" height='600' title=\\"Old school burger building\\"></iframe>\\n<p><strong>The second option</strong> (new school) is to tell your app to read in each ingredient and instruction through D3 method chaining. We remove the need for our verbose <code>for</code> loop, and use the chain to give D3 a set of sequential instructions.</p>\\n<iframe src=\\"https://svelte.dev/repl/8198de15de314aee860932629370ed09?version=3.38.3\\" width=\\"100%\\" height='600' title=\\"New school burger building\\"></iframe>\\n<p>In <strong>our final option</strong> (new new school), we can simply append our instructions directly to the ingredient, <em>literally</em>. Here, we skip <code>for</code> loops and we skip D3 method chaining; instead, we componentize our general \u201Cburger item\u201D and pass each ingredient/instruction directly to that component. Only Svelte enables such burgers:</p>\\n<iframe src=\\"https://svelte.dev/repl/f64bd9dcface42a1a2d544b35638631e?version=3\\" width=\\"100%\\" height='600' title=\\"Literal burger building\\"></iframe>\\n<p>Which do you prefer? It\u2019s much easier to make a burger by <em>just making it</em>, rather than giving instructions, no matter what form they come in. Frameworks allow for the construction of burgers\u2014and visualizations\u2014<strong>literally</strong>. We write our ingredients (or DOM elements) directly, and include our instructions (or data) in our markup. Now that\u2019s a tasty burger.</p>\\n<h2 id=\\"the-big-picture-\\"><a href=\\"#the-big-picture-\\">The big picture \u{1F5BC}</a></h2>\\n<ol>\\n<li>Svelte allows visualization developers to <strong>write SVG directly</strong> (and avoid telling D3 what to do), while using Svelte syntax (<code>&#123;#each&#125;</code>, etc.) to avoid annoying and inefficient <code>for</code> loops. </li>\\n<li>Including logic directly in your markup (<code>&#123;#if&#125;</code>, etc.) removes the need for complex JavaScript/DOM interactions (more on that below). </li>\\n<li>Svelte works to <em>complement</em> D3, not replace it, by continuing to leverage the most powerful parts of its API: <code>d3-scale</code>, <code>d3-array</code>, <code>d3-shape</code>, etc.</li>\\n</ol>\\n<hr/>\\n<h2 id=\\"bonus-perks-\\"><a href=\\"#bonus-perks-\\">Bonus perks \u{1F3C6}</a></h2>\\n<p>Using Svelte to create visualizations has a few other perks:</p>\\n<h3 id=\\"responsiveness\\"><a href=\\"#responsiveness\\">Responsiveness</a></h3>\\n<p>By using Svelte\u2019s <a\\n  href=\\"https://svelte.dev/tutorial/reactive-declarations\\"\\n  rel=\\"nofollow\\"\\n>reactive declarations</a> (the dollar signs \u{1F4B0}), we can make certain variables  \u2018watch\u2019 for state changes and update automatically. One huge benefit of this is that we can bind our scales to updating values such as the window width, and write minimal code to make our charts update on resize.</p>\\n<Code language='svelte'>\\n<pre class=\\"language-undefined\\">{@html \`<code class=\\"language-undefined\\">&lt;script&gt;\\nimport  windowWidth from &quot;../stores/store.js&quot;;\\nimport  scaleLinear from &#39;d3-scale&#39;;\\n\\n$: xScale = scaleLinear\\n            .domain(data.map(d =&gt; d.value))\\n            .range([0, $windowWidth])\\n&lt;/script&gt;</code>\`}</pre>\\n</Code>\\n<p>With some other component watching and responding to resize events (such as <a\\n  href=\\"https://github.com/the-pudding/svelte-starter/blob/master/src/components/helpers/Window.svelte\\"\\n  rel=\\"nofollow\\"\\n>Window.svelte</a>), any SVG property depending on <code>xScale</code> will automatically update when your window resizes. You can also set the chart width itself to equal <code>$windowWidth</code> for a fully resizable, responsive chart.</p>\\n<Info>\\n<p>Another way to achieve easy responsiveness is to <a href=\\"https://svelte.dev/tutorial/dimensions\\" target=\\"_blank\\">bind the SVG\u2019s parent container\u2019s div width</a> to some variable (<code>width</code>) and set the SVG\u2019s width to match.</p>\\n</Info>\\n<h3 id=\\"ifelse-blocks\\"><a href=\\"#ifelse-blocks\\">If/else blocks</a></h3>\\n<p>In regular D3, we often use the <a\\n  href=\\"https://en.wikipedia.org/wiki/%3F:\\"\\n  rel=\\"nofollow\\"\\n>ternary operator</a> to define condition-specific attributes, like this:</p>\\n<Code language='js'>\\n<pre class=\\"language-js\\">{@html \`<code class=\\"language-js\\"><span class=\\"token comment\\">// Circles are filled green if positive, red if negative</span>\\nd3<span class=\\"token punctuation\\">.</span><span class=\\"token function\\">selectAll</span><span class=\\"token punctuation\\">(</span><span class=\\"token string\\">'circle'</span><span class=\\"token punctuation\\">)</span>\\n  <span class=\\"token punctuation\\">.</span><span class=\\"token function\\">style</span><span class=\\"token punctuation\\">(</span><span class=\\"token string\\">'fill'</span><span class=\\"token punctuation\\">,</span> <span class=\\"token parameter\\">d</span> <span class=\\"token operator\\">=></span> d<span class=\\"token punctuation\\">.</span>value <span class=\\"token operator\\">&lt;</span> <span class=\\"token number\\">0</span> <span class=\\"token operator\\">?</span> <span class=\\"token string\\">'red'</span> <span class=\\"token operator\\">:</span> <span class=\\"token string\\">'green'</span><span class=\\"token punctuation\\">)</span></code>\`}</pre>\\n</Code>\\n<p>This is great, but what if we want to make more significant changes based on app-wide state? For example, imagine we want to show three different types of the same visualization on different screen sizes: </p>\\n<ol>\\n<li>Desktop (over 1024px)</li>\\n<li>Tablet (520px to 1024px)</li>\\n<li>Mobile (under 520px)</li>\\n</ol>\\n<p>In D3, we would achieve this by adding a resize event listener, providing custom breakpoints, and rendering different visuals if the updated window width were within a certain range. The complicated part would be having to render a different visual at each breakpoint.</p>\\n<p>One key difference between relying on D3 and leveraging the power of Svelte is that Svelte allows for <a\\n  href=\\"https://svelte.dev/tutorial/if-blocks\\"\\n  rel=\\"nofollow\\"\\n>conditional rendering</a> <em>directly in our markup</em>, not just in our JavaScript logic. In other words, while vanilla JavaScript would approach our problem with the following:</p>\\n<Code language='js'>\\n<pre class=\\"language-js\\">{@html \`<code class=\\"language-js\\">window<span class=\\"token punctuation\\">.</span><span class=\\"token function\\">addEventListener</span><span class=\\"token punctuation\\">(</span><span class=\\"token string\\">'resize'</span><span class=\\"token punctuation\\">,</span> <span class=\\"token keyword\\">function</span><span class=\\"token punctuation\\">(</span><span class=\\"token parameter\\">event</span><span class=\\"token punctuation\\">)</span> <span class=\\"token punctuation\\">&#123;</span>\\n    <span class=\\"token keyword\\">let</span> newWidth <span class=\\"token operator\\">=</span> window<span class=\\"token punctuation\\">.</span>innerWidth<span class=\\"token punctuation\\">;</span>\\n\\n    <span class=\\"token keyword\\">if</span> <span class=\\"token punctuation\\">(</span>newWidth <span class=\\"token operator\\">&lt;</span> <span class=\\"token number\\">520</span><span class=\\"token punctuation\\">)</span> <span class=\\"token punctuation\\">&#123;</span> \\n      <span class=\\"token comment\\">// Hide tablet and desktop</span>\\n      document<span class=\\"token punctuation\\">.</span><span class=\\"token function\\">getElementById</span><span class=\\"token punctuation\\">(</span><span class=\\"token string\\">\\"tablet\\"</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">.</span>style<span class=\\"token punctuation\\">.</span>display <span class=\\"token operator\\">=</span> <span class=\\"token string\\">\\"none\\"</span><span class=\\"token punctuation\\">;</span>\\n      document<span class=\\"token punctuation\\">.</span><span class=\\"token function\\">getElementById</span><span class=\\"token punctuation\\">(</span><span class=\\"token string\\">\\"desktop\\"</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">.</span>style<span class=\\"token punctuation\\">.</span>display <span class=\\"token operator\\">=</span> <span class=\\"token string\\">\\"none\\"</span><span class=\\"token punctuation\\">;</span>\\n\\n      <span class=\\"token comment\\">// Show mobile</span>\\n      document<span class=\\"token punctuation\\">.</span><span class=\\"token function\\">getElementById</span><span class=\\"token punctuation\\">(</span><span class=\\"token string\\">\\"mobile\\"</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">.</span>style<span class=\\"token punctuation\\">.</span>display <span class=\\"token operator\\">=</span> <span class=\\"token string\\">\\"block\\"</span><span class=\\"token punctuation\\">;</span>\\n    <span class=\\"token punctuation\\">&#125;</span> <span class=\\"token keyword\\">else</span> <span class=\\"token keyword\\">if</span> <span class=\\"token punctuation\\">(</span>newWidth <span class=\\"token operator\\">&lt;</span> <span class=\\"token number\\">1024</span><span class=\\"token punctuation\\">)</span> <span class=\\"token punctuation\\">&#123;</span>\\n      <span class=\\"token comment\\">// Hide mobile and desktop</span>\\n      document<span class=\\"token punctuation\\">.</span><span class=\\"token function\\">getElementById</span><span class=\\"token punctuation\\">(</span><span class=\\"token string\\">\\"mobile\\"</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">.</span>style<span class=\\"token punctuation\\">.</span>display <span class=\\"token operator\\">=</span> <span class=\\"token string\\">\\"none\\"</span><span class=\\"token punctuation\\">;</span>\\n      document<span class=\\"token punctuation\\">.</span><span class=\\"token function\\">getElementById</span><span class=\\"token punctuation\\">(</span><span class=\\"token string\\">\\"desktop\\"</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">.</span>style<span class=\\"token punctuation\\">.</span>display <span class=\\"token operator\\">=</span> <span class=\\"token string\\">\\"none\\"</span><span class=\\"token punctuation\\">;</span>\\n\\n      <span class=\\"token comment\\">// Show tablet</span>\\n      document<span class=\\"token punctuation\\">.</span><span class=\\"token function\\">getElementById</span><span class=\\"token punctuation\\">(</span><span class=\\"token string\\">\\"tablet\\"</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">.</span>style<span class=\\"token punctuation\\">.</span>display <span class=\\"token operator\\">=</span> <span class=\\"token string\\">\\"block\\"</span><span class=\\"token punctuation\\">;</span>\\n    <span class=\\"token punctuation\\">&#125;</span> <span class=\\"token keyword\\">else</span> <span class=\\"token punctuation\\">&#123;</span>\\n      <span class=\\"token comment\\">// Hide mobile and tablet</span>\\n      document<span class=\\"token punctuation\\">.</span><span class=\\"token function\\">getElementById</span><span class=\\"token punctuation\\">(</span><span class=\\"token string\\">\\"mobile\\"</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">.</span>style<span class=\\"token punctuation\\">.</span>display <span class=\\"token operator\\">=</span> <span class=\\"token string\\">\\"none\\"</span><span class=\\"token punctuation\\">;</span>\\n      document<span class=\\"token punctuation\\">.</span><span class=\\"token function\\">getElementById</span><span class=\\"token punctuation\\">(</span><span class=\\"token string\\">\\"tablet\\"</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">.</span>style<span class=\\"token punctuation\\">.</span>display <span class=\\"token operator\\">=</span> <span class=\\"token string\\">\\"none\\"</span><span class=\\"token punctuation\\">;</span>\\n\\n      <span class=\\"token comment\\">// Show desktop</span>\\n      document<span class=\\"token punctuation\\">.</span><span class=\\"token function\\">getElementById</span><span class=\\"token punctuation\\">(</span><span class=\\"token string\\">\\"desktop\\"</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">.</span>style<span class=\\"token punctuation\\">.</span>display <span class=\\"token operator\\">=</span> <span class=\\"token string\\">\\"block\\"</span><span class=\\"token punctuation\\">;</span>\\n    <span class=\\"token punctuation\\">&#125;</span>\\n<span class=\\"token punctuation\\">&#125;</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span></code>\`}</pre>\\n</Code>\\n<p>Svelte simplifies our logic to:</p>\\n<Code language='svelte'>\\n<pre class=\\"language-svelte\\">{@html \`<code class=\\"language-svelte\\"><span class=\\"token language-javascript\\"><span class=\\"token punctuation\\">&#123;</span>#<span class=\\"token keyword\\">if</span> $windowWidth <span class=\\"token operator\\">&lt;</span> <span class=\\"token number\\">520</span><span class=\\"token punctuation\\">&#125;</span></span>\\n  <span class=\\"token tag\\"><span class=\\"token tag\\"><span class=\\"token punctuation\\">&lt;</span>Mobile</span> <span class=\\"token punctuation\\">/></span></span>\\n<span class=\\"token language-javascript\\"><span class=\\"token punctuation\\">&#123;</span><span class=\\"token operator\\">:</span><span class=\\"token keyword\\">else</span> <span class=\\"token keyword\\">if</span> $windowWidth <span class=\\"token operator\\">&lt;</span> <span class=\\"token number\\">1024</span><span class=\\"token punctuation\\">&#125;</span></span>\\n  <span class=\\"token tag\\"><span class=\\"token tag\\"><span class=\\"token punctuation\\">&lt;</span>Tablet</span> <span class=\\"token punctuation\\">/></span></span>\\n<span class=\\"token language-javascript\\"><span class=\\"token punctuation\\">&#123;</span><span class=\\"token operator\\">:</span><span class=\\"token keyword\\">else</span><span class=\\"token punctuation\\">&#125;</span></span>\\n  <span class=\\"token tag\\"><span class=\\"token tag\\"><span class=\\"token punctuation\\">&lt;</span>Desktop</span> <span class=\\"token punctuation\\">/></span></span>\\n<span class=\\"token language-javascript\\"><span class=\\"token punctuation\\">&#123;</span><span class=\\"token operator\\">/</span><span class=\\"token keyword\\">if</span><span class=\\"token punctuation\\">&#125;</span></span></code>\`}</pre>\\n</Code>\\n<p>Hey, thanks for reading. I appreciate you! In the event that you disagree with me or I got something wrong, please message me on <a\\n  href=\\"https://twitter.com/CL_Rothschild\\"\\n  rel=\\"nofollow\\"\\n>Twitter</a>.</p>\\n</Layout_MDSVEX_DEFAULT>"],"names":[],"mappings":"AAgBA,GAAG,eAAC,CAAC,AACH,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,MAAM,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CACzB,aAAa,CAAE,GAAG,AACpB,CAAC,AAED,IAAI,eAAC,CAAC,AACJ,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,AAEd,CAAC,AAED,MAAM,eAAC,CAAC,AACN,MAAM,CAAE,SAAS,AACnB,CAAC"}`
};
var metadata$2 = {
  "layout": "blog",
  "title": "Making visualizations literally using Svelte + D3",
  "description": "Why Svelte has replaced (and complemented) D3 as my go-to tool for powerful visualizations",
  "image": "lorem",
  "date": "2021-07-02",
  "featured": true,
  "tags": ["svelte", "d3", "tutorial"]
};
var Svelte_and_d3 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  $$result.css.add(css);
  return `${validate_component(Layout, "Layout_MDSVEX_DEFAULT").$$render($$result, Object.assign($$props, metadata$2), {}, {
    default: () => `<p>When I started making data visualizations, I considered <a href="${"https://d3js.org/"}" rel="${"nofollow"}">D3</a>\u2014Data Driven Documents\u2014to be the gold standard programming language required to create beautiful graphics on the web.</p>
<p>As I progress in my career, I\u2019m realizing that D3 has a more particular (and smaller) role in the visualization lifecycle than I initially envisioned. As I design more visualizations, I\u2019m learning that my most efficient and intuitive development comes when I <strong>program literally</strong>. </p>
<p>What does that mean? (To be honest, I\u2019m making up the term.) It means that I\u2019m moving away from <em>pseudo-declarative</em> data visualization in D3, and starting to make my visualizations <em>literally</em>, by simply writing markup in <a href="${"https://svelte.dev/"}" rel="${"nofollow"}">Svelte</a>. </p>
<p>Although D3 <a href="${"https://d3js.org/#selections"}" rel="${"nofollow"}">claims</a> to be declarative, it still uses <a href="${"https://www.carlosrendon.me/unfinished_d3_book/d3_method_chaining.html"}" rel="${"nofollow"}">method chaining</a> to provide instructions to render visuals. In Svelte, we don\u2019t provide instructions but instead render our SVG elements directly, using <code>{#each}</code> blocks. By writing my markup literally and appending data inline, my code makes more sense and causes fewer headaches.</p>
<h3 id="${"what-youll-find-in-this-post"}"><a href="${"#what-youll-find-in-this-post"}">What you\u2019ll find in this post</a></h3>
<p>In this post, I\u2019ll <a href="${"#what-d3-does-3%EF%B8%8F%E2%83%A3"}">1)</a> provide an overview of D3, and how it made the process of creating visualizations so much easier; <a href="${"#literal-programming-with-svelte-"}">2)</a> explain why I\u2019m moving away from D3 for DOM manipulation, and instead using Svelte \u201Cliterally\u201D; and <a href="${"#bringing-it-home-with-burgers-"}">3)</a> provide a funky burger \u{1F354} example to explain my logic.</p>
 ${validate_component(Info, "Info").$$render($$result, {}, {}, {
      default: () => `<p>This is not a comprehensive tutorial about <strong>how to</strong> use D3 and Svelte together. I\u2019ll cover that in the <a href="${"https://twitter.com/CL_Rothschild"}" rel="${"nofollow"}">future</a>. In the meantime, check out tutorials from <a href="${"https://www.youtube.com/watch?v=bnd64ZrHC0U"}" rel="${"nofollow"}">Matthias Stahl</a>, examples of Svelte and D3 in action on The Pudding\u2019s <a href="${"https://github.com/the-pudding/"}" rel="${"nofollow"}">GitHub</a>, and an example of similar framework-driven logic on Amelia Wattenberger\u2019s <a href="${"https://wattenberger.com/post/react-and-d3"}" rel="${"nofollow"}">blog</a>. </p>
<p>Want an immediate example? Here\u2019s an (admittedly verbose) <a href="${"https://github.com/connorrothschild/bob-ross-art-gallery/blob/master/src/components/ColorViz.svelte"}" rel="${"nofollow"}">Svelte component</a> I used in a recent project about Bob Ross.</p>`
    })} 
<h2 id="${"what-d3-does-3\uFE0F\u20E3"}"><a href="${"#what-d3-does-3\uFE0F\u20E3"}">What D3 does 3\uFE0F\u20E3</a></h2>
<p>D3 allows for intuitive transformations of the DOM by leveraging easy-to-understand selection syntax. Sound confusing? Let\u2019s learn through an example (adapted from the <a href="${"https://d3js.org/#selections"}" rel="${"nofollow"}">D3 homepage</a>). Imagine we had 5 circles and wanted to change the fill of each. </p>
<svg class="${"svelte-1ijjfyd"}"><rect width="${"100%"}" height="${"100%"}" class="${"svelte-1ijjfyd"}"></rect><circle cx="${"10%"}" cy="${"50%"}" r="${"10"}" fill="${"steelblue"}" class="${"svelte-1ijjfyd"}"><title>Hello from the circle!</title></circle><circle cx="${"30%"}" cy="${"50%"}" r="${"10"}" fill="${"steelblue"}" class="${"svelte-1ijjfyd"}"><title>Hello from the circle!</title></circle><circle cx="${"50%"}" cy="${"50%"}" r="${"10"}" fill="${"steelblue"}" class="${"svelte-1ijjfyd"}"><title>Hello from the circle!</title></circle><circle cx="${"70%"}" cy="${"50%"}" r="${"10"}" fill="${"steelblue"}" class="${"svelte-1ijjfyd"}"><title>Hello from the circle!</title></circle><circle cx="${"90%"}" cy="${"50%"}" r="${"10"}" fill="${"steelblue"}" class="${"svelte-1ijjfyd"}"><title>Hello from the circle!</title></circle></svg>
<p>In the traditional <a href="${"https://www.w3schools.com/js/js_htmldom.asp"}" rel="${"nofollow"}">HTML DOM model</a>, we would 1) select all circles, 2) loop through each one, and 3) redefine its fill. In code, that would look like this:</p>
${validate_component(Code, "Code").$$render($$result, { language: "js" }, {}, {
      default: () => `<pre class="${"language-undefined"}"><!-- HTML_TAG_START -->${`<code class="language-undefined">var circles = document.getElementsByTagName(&quot;circle&quot;);
for (var i = 0; i &lt; circles.length; i++) &#123;
  var circle = circles.item(i);
  circle.setAttribute(&quot;fill&quot;, &quot;white&quot;, null);
&#125;</code>`}<!-- HTML_TAG_END --></pre>`
    })}
<p>Doing this in D3 would reduce the length of our code by a factor of 5, and allows us to write in a way that <em>just makes sense</em>. Here, we select every circle and change its fill.</p>
${validate_component(Code, "Code").$$render($$result, { language: "js" }, {}, {
      default: () => `d3.selectAll(&quot;circle&quot;).style(&quot;fill&quot;, &quot;white&quot;)
`
    })}
<svg class="${"svelte-1ijjfyd"}"><rect width="${"100%"}" height="${"100%"}" class="${"svelte-1ijjfyd"}"></rect><circle cx="${"10%"}" cy="${"50%"}" r="${"10"}" fill="${"white"}" class="${"svelte-1ijjfyd"}"><title>Hello from the circle!</title></circle><circle cx="${"30%"}" cy="${"50%"}" r="${"10"}" fill="${"white"}" class="${"svelte-1ijjfyd"}"><title>Hello from the circle!</title></circle><circle cx="${"50%"}" cy="${"50%"}" r="${"10"}" fill="${"white"}" class="${"svelte-1ijjfyd"}"><title>Hello from the circle!</title></circle><circle cx="${"70%"}" cy="${"50%"}" r="${"10"}" fill="${"white"}" class="${"svelte-1ijjfyd"}"><title>Hello from the circle!</title></circle><circle cx="${"90%"}" cy="${"50%"}" r="${"10"}" fill="${"white"}" class="${"svelte-1ijjfyd"}"><title>Hello from the circle!</title></circle></svg>
<p>Imagine if you also wanted to bind data to those circles. That is, you wanted to fill the circle according to some attribute, or size its radius according to some datapoint. In traditional JavaScript, that might look something like this:</p>
${validate_component(Code, "Code").$$render($$result, { language: "js" }, {}, {
      default: () => `<pre class="${"language-undefined"}"><!-- HTML_TAG_START -->${`<code class="language-undefined">let data = [5, 10, 15, 20, 25];

var circles = document.getElementsByTagName(&quot;circle&quot;);
for (var i = 0; i &lt; circles.length; i++) &#123;
  var circle = circles.item(i);
  circle.style.setProperty(&quot;r&quot;, data[i], null);
&#125;</code>`}<!-- HTML_TAG_END --></pre>`
    })}
<p>Not too hard\u2014but also, not too easy. D3 simplifies this logic by removing the need for a loop and iterating on your selection for you:</p>
${validate_component(Code, "Code").$$render($$result, { language: "js" }, {}, {
      default: () => `<pre class="${"language-js"}"><!-- HTML_TAG_START -->${`<code class="language-js"><span class="token keyword">let</span> data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

d3<span class="token punctuation">.</span><span class="token function">selectAll</span><span class="token punctuation">(</span><span class="token string">"circle"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">"r"</span><span class="token punctuation">,</span> <span class="token parameter">d</span> <span class="token operator">=></span> d<span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>`
    })}
<svg class="${"svelte-1ijjfyd"}"><rect width="${"100%"}" height="${"100%"}" class="${"svelte-1ijjfyd"}"></rect><circle cx="${"10%"}" cy="${"50%"}" r="${"5"}" fill="${"white"}" class="${"svelte-1ijjfyd"}"><title>Hello from the circle!</title></circle><circle cx="${"30%"}" cy="${"50%"}" r="${"10"}" fill="${"white"}" class="${"svelte-1ijjfyd"}"><title>Hello from the circle!</title></circle><circle cx="${"50%"}" cy="${"50%"}" r="${"15"}" fill="${"white"}" class="${"svelte-1ijjfyd"}"><title>Hello from the circle!</title></circle><circle cx="${"70%"}" cy="${"50%"}" r="${"20"}" fill="${"white"}" class="${"svelte-1ijjfyd"}"><title>Hello from the circle!</title></circle><circle cx="${"90%"}" cy="${"50%"}" r="${"25"}" fill="${"white"}" class="${"svelte-1ijjfyd"}"><title>Hello from the circle!</title></circle></svg>
<p>Again, we reduce the length of our code nearly 5x, and the code just <strong>makes sense</strong>.</p>
<p>All that to say, D3 is great. It works, and it works wonderfully. By removing the need to write highly imperative code that is unintuitive in nature, D3 saves developers time and allows for more powerful visualizations.</p>
<p>But I\u2019m hardly using it at all recently. Increasingly, I\u2019ve been using the JavaScript <del>framework</del> compiler <a href="${"https://svelte.dev/"}" rel="${"nofollow"}">Svelte</a> to <em>write SVG directly</em> rather than <em>tell JavaScript to write SVG</em>. How? Let\u2019s see below.</p>
<h2 id="${"literal-programming-with-svelte-"}"><a href="${"#literal-programming-with-svelte-"}">\u201CLiteral\u201D programming with Svelte \u{1F5E3}</a></h2>
<p>Going back to the above circles, imagine if we could simply bind our data to our app\u2019s markup <strong>directly</strong>, without any intermediate code serving as instructions.</p>
<p><strong>We can!</strong> Svelte (and Vue, React and other frameworks) allow for seamless interactions between our app\u2019s logic, data, and markup, so that we can embed data directly into our SVG elements. In this new paradigm, we could replace the set of D3 instructions from earlier with the following Svelte code:</p>
${validate_component(Code, "Code").$$render($$result, { language: "svelte" }, {}, {
      default: () => `<pre class="${"language-undefined"}"><!-- HTML_TAG_START -->${`<code class="language-undefined">&lt;script&gt;
  let data = [&#123;x: 10, r: 5 &#125;, 
              &#123;x: 30, r: 10&#125;, 
              &#123;x: 50, r: 15&#125;, 
              &#123;x: 70, r: 20&#125;, 
              &#123;x: 90, r: 25&#125;]
&lt;/script&gt;

&lt;p&gt;&#123;data.map(x =&gt; x)&#125;&lt;/p&gt;</code>`}<!-- HTML_TAG_END --></pre>`
    })}

<p>In my view, there are three benefits to writing our code this way:</p>
<ol><li><strong>More intuitive authoring.</strong> It feels much more natural to write our SVG elements <em>directly</em> rather than provide D3 instructions on how to do so.</li>
<li><strong>Less friction in translating D3 to the DOM.</strong> By writing SVG directly, we could copy an SVG element from the <a href="${"https://developer.mozilla.org/en-US/docs/Web/SVG/Element/circle"}" rel="${"nofollow"}">MDN docs</a>, paste in our values, and see immediate results. Fewer handoffs results in fewer errors.</li>
<li><strong>Reusability.</strong> Creating a robust and flexible <code>&lt;Circle /&gt;</code>, <code>&lt;Bar /&gt;</code>, or <code>&lt;Axis /&gt;</code> component permits consistent reuse within and across projects. D3 code is usually written as a series of blocks which lacks a natural structure and becomes difficult to reuse effectively.</li></ol>
<p>The only downside (which is actually just an adjustment) is that this new approach requires you to learn how to <a href="${"https://www.w3schools.com/graphics/svg_intro.asp"}" rel="${"nofollow"}">write SVG</a>. But isn\u2019t it a good exercise to learn the anatomy of what we\u2019re actually creating? Having knowledge of SVG elements and attributes will benefit any developer who creates visuals, no matter how they eventually do so.</p>
<p>Not convinced? Let me explain the logic one more time, with a tastier example:</p>
<h2 id="${"bringing-it-home-with-burgers-"}"><a href="${"#bringing-it-home-with-burgers-"}">Bringing it home with burgers \u{1F354}</a></h2>
<p>Imagine we want to prepare a burger. We have an array of objects, each with an ingredient and ingredient-specfic instructions. We want to 1) create each item (insert it into the DOM), and 2) carry out its instructions (execute some function).</p>
${validate_component(Code, "Code").$$render($$result, { language: "js" }, {}, {
      default: () => `<pre class="${"language-undefined"}"><!-- HTML_TAG_START -->${`<code class="language-undefined">let ingredients = [
  &#123;item: &quot;Top Bun&quot;, instruction: &quot;Place at top of burger.&quot;&#125;,
  &#123;item: &quot;Pickles&quot;, instruction: &quot;Three pickles, please.&quot;&#125;,
  &#123;item: &quot;Cheese&quot;, instruction: &quot;Cheese is optional, but it makes the burger better.&quot;&#125;,
  &#123;item: &quot;Patty&quot;, instruction: &quot;Cook to your satisfaction. Optionally, add two patties.&quot;&#125;,
  &#123;item: &quot;Tomato&quot;, instruction: &quot;Should be the same width as bun, and thinly sliced.&quot;&#125;,
  &#123;item: &quot;Lettuce&quot;, instruction: &quot;Should be the same width as bun.&quot;&#125;,
  &#123;item: &quot;Bottom Bun&quot;, instruction: &quot;Place at bottom of burger.&quot;&#125;,
]</code>`}<!-- HTML_TAG_END --></pre>`
    })}
<p>There are three ways to make this burger (at least, in our fantasy world where we make burgers via code).</p>
${validate_component(Info, "Info").$$render($$result, {}, {}, {
      default: () => `<p>Although I use the Svelte REPL to showcase these three examples, only the last one requires Svelte. The REPL is just a nice place to host (editable!) code \u{1F642}</p>`
    })}
<p><strong>The first option</strong> (old school) is to tell your app to loop through each ingredient, add it to the others, and stack the ingredients accordingly. For each ingredient in the loop, execute the burger-making according to our ingredient-specific instruction. This is how burgers would have been made, painfully, before D3.</p>
<iframe src="${"https://svelte.dev/repl/4b4eee03981b4450aa08e402aa0ceeb6?version=3.38.3"}" width="${"100%"}" height="${"600"}" title="${"Old school burger building"}"></iframe>
<p><strong>The second option</strong> (new school) is to tell your app to read in each ingredient and instruction through D3 method chaining. We remove the need for our verbose <code>for</code> loop, and use the chain to give D3 a set of sequential instructions.</p>
<iframe src="${"https://svelte.dev/repl/8198de15de314aee860932629370ed09?version=3.38.3"}" width="${"100%"}" height="${"600"}" title="${"New school burger building"}"></iframe>
<p>In <strong>our final option</strong> (new new school), we can simply append our instructions directly to the ingredient, <em>literally</em>. Here, we skip <code>for</code> loops and we skip D3 method chaining; instead, we componentize our general \u201Cburger item\u201D and pass each ingredient/instruction directly to that component. Only Svelte enables such burgers:</p>
<iframe src="${"https://svelte.dev/repl/f64bd9dcface42a1a2d544b35638631e?version=3"}" width="${"100%"}" height="${"600"}" title="${"Literal burger building"}"></iframe>
<p>Which do you prefer? It\u2019s much easier to make a burger by <em>just making it</em>, rather than giving instructions, no matter what form they come in. Frameworks allow for the construction of burgers\u2014and visualizations\u2014<strong>literally</strong>. We write our ingredients (or DOM elements) directly, and include our instructions (or data) in our markup. Now that\u2019s a tasty burger.</p>
<h2 id="${"the-big-picture-"}"><a href="${"#the-big-picture-"}">The big picture \u{1F5BC}</a></h2>
<ol><li>Svelte allows visualization developers to <strong>write SVG directly</strong> (and avoid telling D3 what to do), while using Svelte syntax (<code>{#each}</code>, etc.) to avoid annoying and inefficient <code>for</code> loops. </li>
<li>Including logic directly in your markup (<code>{#if}</code>, etc.) removes the need for complex JavaScript/DOM interactions (more on that below). </li>
<li>Svelte works to <em>complement</em> D3, not replace it, by continuing to leverage the most powerful parts of its API: <code>d3-scale</code>, <code>d3-array</code>, <code>d3-shape</code>, etc.</li></ol>
<hr>
<h2 id="${"bonus-perks-"}"><a href="${"#bonus-perks-"}">Bonus perks \u{1F3C6}</a></h2>
<p>Using Svelte to create visualizations has a few other perks:</p>
<h3 id="${"responsiveness"}"><a href="${"#responsiveness"}">Responsiveness</a></h3>
<p>By using Svelte\u2019s <a href="${"https://svelte.dev/tutorial/reactive-declarations"}" rel="${"nofollow"}">reactive declarations</a> (the dollar signs \u{1F4B0}), we can make certain variables  \u2018watch\u2019 for state changes and update automatically. One huge benefit of this is that we can bind our scales to updating values such as the window width, and write minimal code to make our charts update on resize.</p>
${validate_component(Code, "Code").$$render($$result, { language: "svelte" }, {}, {
      default: () => `<pre class="${"language-undefined"}"><!-- HTML_TAG_START -->${`<code class="language-undefined">&lt;script&gt;
import  windowWidth from &quot;../stores/store.js&quot;;
import  scaleLinear from &#39;d3-scale&#39;;

$: xScale = scaleLinear
            .domain(data.map(d =&gt; d.value))
            .range([0, $windowWidth])
&lt;/script&gt;</code>`}<!-- HTML_TAG_END --></pre>`
    })}
<p>With some other component watching and responding to resize events (such as <a href="${"https://github.com/the-pudding/svelte-starter/blob/master/src/components/helpers/Window.svelte"}" rel="${"nofollow"}">Window.svelte</a>), any SVG property depending on <code>xScale</code> will automatically update when your window resizes. You can also set the chart width itself to equal <code>$windowWidth</code> for a fully resizable, responsive chart.</p>
${validate_component(Info, "Info").$$render($$result, {}, {}, {
      default: () => `<p>Another way to achieve easy responsiveness is to <a href="${"https://svelte.dev/tutorial/dimensions"}" target="${"_blank"}">bind the SVG\u2019s parent container\u2019s div width</a> to some variable (<code>width</code>) and set the SVG\u2019s width to match.</p>`
    })}
<h3 id="${"ifelse-blocks"}"><a href="${"#ifelse-blocks"}">If/else blocks</a></h3>
<p>In regular D3, we often use the <a href="${"https://en.wikipedia.org/wiki/%3F:"}" rel="${"nofollow"}">ternary operator</a> to define condition-specific attributes, like this:</p>
${validate_component(Code, "Code").$$render($$result, { language: "js" }, {}, {
      default: () => `<pre class="${"language-js"}"><!-- HTML_TAG_START -->${`<code class="language-js"><span class="token comment">// Circles are filled green if positive, red if negative</span>
d3<span class="token punctuation">.</span><span class="token function">selectAll</span><span class="token punctuation">(</span><span class="token string">'circle'</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">style</span><span class="token punctuation">(</span><span class="token string">'fill'</span><span class="token punctuation">,</span> <span class="token parameter">d</span> <span class="token operator">=></span> d<span class="token punctuation">.</span>value <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token string">'red'</span> <span class="token operator">:</span> <span class="token string">'green'</span><span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>`
    })}
<p>This is great, but what if we want to make more significant changes based on app-wide state? For example, imagine we want to show three different types of the same visualization on different screen sizes: </p>
<ol><li>Desktop (over 1024px)</li>
<li>Tablet (520px to 1024px)</li>
<li>Mobile (under 520px)</li></ol>
<p>In D3, we would achieve this by adding a resize event listener, providing custom breakpoints, and rendering different visuals if the updated window width were within a certain range. The complicated part would be having to render a different visual at each breakpoint.</p>
<p>One key difference between relying on D3 and leveraging the power of Svelte is that Svelte allows for <a href="${"https://svelte.dev/tutorial/if-blocks"}" rel="${"nofollow"}">conditional rendering</a> <em>directly in our markup</em>, not just in our JavaScript logic. In other words, while vanilla JavaScript would approach our problem with the following:</p>
${validate_component(Code, "Code").$$render($$result, { language: "js" }, {}, {
      default: () => `<pre class="${"language-js"}"><!-- HTML_TAG_START -->${`<code class="language-js">window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'resize'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">let</span> newWidth <span class="token operator">=</span> window<span class="token punctuation">.</span>innerWidth<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>newWidth <span class="token operator">&lt;</span> <span class="token number">520</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> 
      <span class="token comment">// Hide tablet and desktop</span>
      document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"tablet"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>style<span class="token punctuation">.</span>display <span class="token operator">=</span> <span class="token string">"none"</span><span class="token punctuation">;</span>
      document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"desktop"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>style<span class="token punctuation">.</span>display <span class="token operator">=</span> <span class="token string">"none"</span><span class="token punctuation">;</span>

      <span class="token comment">// Show mobile</span>
      document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"mobile"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>style<span class="token punctuation">.</span>display <span class="token operator">=</span> <span class="token string">"block"</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>newWidth <span class="token operator">&lt;</span> <span class="token number">1024</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token comment">// Hide mobile and desktop</span>
      document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"mobile"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>style<span class="token punctuation">.</span>display <span class="token operator">=</span> <span class="token string">"none"</span><span class="token punctuation">;</span>
      document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"desktop"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>style<span class="token punctuation">.</span>display <span class="token operator">=</span> <span class="token string">"none"</span><span class="token punctuation">;</span>

      <span class="token comment">// Show tablet</span>
      document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"tablet"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>style<span class="token punctuation">.</span>display <span class="token operator">=</span> <span class="token string">"block"</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
      <span class="token comment">// Hide mobile and tablet</span>
      document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"mobile"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>style<span class="token punctuation">.</span>display <span class="token operator">=</span> <span class="token string">"none"</span><span class="token punctuation">;</span>
      document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"tablet"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>style<span class="token punctuation">.</span>display <span class="token operator">=</span> <span class="token string">"none"</span><span class="token punctuation">;</span>

      <span class="token comment">// Show desktop</span>
      document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"desktop"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>style<span class="token punctuation">.</span>display <span class="token operator">=</span> <span class="token string">"block"</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code>`}<!-- HTML_TAG_END --></pre>`
    })}
<p>Svelte simplifies our logic to:</p>
${validate_component(Code, "Code").$$render($$result, { language: "svelte" }, {}, {
      default: () => `<pre class="${"language-svelte"}"><!-- HTML_TAG_START -->${`<code class="language-svelte"><span class="token language-javascript"><span class="token punctuation">&#123;</span>#<span class="token keyword">if</span> $windowWidth <span class="token operator">&lt;</span> <span class="token number">520</span><span class="token punctuation">&#125;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Mobile</span> <span class="token punctuation">/></span></span>
<span class="token language-javascript"><span class="token punctuation">&#123;</span><span class="token operator">:</span><span class="token keyword">else</span> <span class="token keyword">if</span> $windowWidth <span class="token operator">&lt;</span> <span class="token number">1024</span><span class="token punctuation">&#125;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Tablet</span> <span class="token punctuation">/></span></span>
<span class="token language-javascript"><span class="token punctuation">&#123;</span><span class="token operator">:</span><span class="token keyword">else</span><span class="token punctuation">&#125;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Desktop</span> <span class="token punctuation">/></span></span>
<span class="token language-javascript"><span class="token punctuation">&#123;</span><span class="token operator">/</span><span class="token keyword">if</span><span class="token punctuation">&#125;</span></span></code>`}<!-- HTML_TAG_END --></pre>`
    })}
<p>Hey, thanks for reading. I appreciate you! In the event that you disagree with me or I got something wrong, please message me on <a href="${"https://twitter.com/CL_Rothschild"}" rel="${"nofollow"}">Twitter</a>.</p>`
  })}`;
});
var svelteAndD3 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Svelte_and_d3,
  metadata: metadata$2
});
var metadata$1 = {
  "layout": "blog",
  "title": "COVID-19 Posts: A Novel Dataset",
  "description": "Making hundreds of COVID-19 blog posts from the R community available for public use",
  "date": "2020-11-02",
  "image": "covid-posts/header.png",
  "archived": true,
  "tags": ["analysis", "r"]
};
var Covid_posts = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${validate_component(Layout, "Layout_MDSVEX_DEFAULT").$$render($$result, Object.assign($$props, metadata$1), {}, {
    default: () => `<p>Over the last few months, we\u2019ve been collecting hundreds of COVID-19
blog posts from the R community. Today, we are excited to share this
dataset publicly, to help bloggers who want to analyze COVID-19 data by
unleashing R and the resources of its community by being able to
research such posts.</p>
<p>So far, we have found and recorded 423 COVID posts in English. In an
effort to encourage others to explore such posts, we\u2019ve published a <a href="${"https://connorrothschild.shinyapps.io/covid-posts/"}" target="${"_blank"}">Shiny web app</a>
which allow users to find the names of the 231 bloggers who wrote those
posts, their roles, and their country of focus. The app also lets users
interactively search the collection of posts by primary topic, post
title, date, and whether the post uses a particular mathematical
technique or data source. To learn more about the evolution of this
dataset, one of the authors (Rees) has published nine articles on
Medium, which you can find <a href="${"https://medium.com/@rees_32356"}" target="${"_blank"}">here</a>.</p>
<p>We encourage users to submit their own posts\u2013or others\u2019 posts\u2013for
inclusion, which can be done on this <a href="${"https://docs.google.com/forms/d/e/1FAIpQLScfob3uBoumXIRcSW83T0GhXCfi-KI_psGxIqtl_rQ5VHu9ZQ/viewform?usp=sf_link"}" target="${"_blank"}">Google Form</a>.
Our dataset, as well as the code for the Shiny app, is available on <a href="${"https://github.com/connorrothschild/covid-posts"}" target="${"_blank"}">GitHub</a>.
If anyone has corrections to the dataset, please write Rees (at)
ReesMorrison (dot) com.</p>
<p>The remainder of this post highlights some of the findings from the
dataset of COVID-19 posts. As will be made evident by the plots that
follow, this is by no means a comprehensive review of <em>every</em> COVID-19 R
blog post, but rather an overview of the data <em>that we have found</em>.</p>
<h3 id="${"posts-over-time"}"><a href="${"#posts-over-time"}">Posts over time</a></h3>
<p>As the pandemic has progressed, fewer bloggers have engaged with
COVID-related data, as we notice that blog posts peaked in March of 2020.</p>
${validate_component(Image, "Image").$$render($$result, {
      alt: "COVID-19 blog posts by week. There is a peak in mid March (40 posts).",
      src: "../images/post/covid-posts/weekly-1.png"
    }, {}, {})}
<p>Some bloggers have been prolific; many more have been one and done. The
plot below shows the names and posts of the 23 bloggers who have so far
published at least four posts. For an example of how to read the plot,
Tim Churches, at the bottom of the y-axis, has published a total of nine
posts, but none after early April.</p>
<p>The color of the points corresponds to the work role of the blogger as
explained in the legend at the bottom. It is immediately apparent that
professors and academic researchers predominate in this group of
bloggers. If you include the postgraduate students, universities writ
large account for nearly all of the prolific bloggers.</p>
${validate_component(Image, "Image").$$render($$result, {
      alt: "A dumbbell chart showcasing the timing of posts among 'prolific authors' (4 or more total posts). It shows temporally when these individuals post. ",
      src: "../images/post/covid-posts/prolificVer2-1.png"
    }, {}, {})}
<h3 id="${"roles-of-authors"}"><a href="${"#roles-of-authors"}">Roles of authors</a></h3>
<p>The bloggers in our dataset describe their work-day roles in a variety
of ways. One of the authors (Rees) standardized these job roles by
categorizing the multitude of terms and descriptions, but it is quite
possible that this effort misrepresented what some of these bloggers do
for a living. We welcome corrections.</p>
<p>We\u2019ve further categorized roles into a broad typology where professions
fall into one of five categories: <em>university</em>, <em>corporate</em>,
<em>professional</em>, <em>government</em>, and <em>nonprofit</em>. Those broader categories
are represented as columns in the following chart.</p>
${validate_component(Image, "Image").$$render($$result, {
      alt: "A barchart showcasing the roles of authors in our dataset. The most common is university (205) followed by corporate (140).",
      src: "../images/post/covid-posts/authorVer2-1.png"
    }, {}, {})}
<h3 id="${"data-sources"}"><a href="${"#data-sources"}">Data sources</a></h3>
<p>A greater number of data sources related to COVID-19 will yield richer
insights. Combining different datasets can shed new light on an issue,
yield improvements, and allow authors to contruct better indices and
measures. For that reason, one of the authors (Rees) extracted <em>dataset
information</em> from our collection of blog posts.</p>
<p>For the most part, bloggers identified the data source they drew on for
their analysis. On occasion, we had to apply some effort to standardize
the 140 data sources.</p>
<p>By far the most prevalent data source is Johns Hopkins University, who
early, comprehensively and consistently has set the standard for
COVID-19 data collection and dissemination to the public.</p>
${validate_component(Image, "Image").$$render($$result, {
      alt: "A barchart showcasing the most common data sources in our dataset. John Hopkins leads the pack at 51.",
      src: "../images/post/covid-posts/dataTable-1.png"
    }, {}, {})}
<p>Below, you can look at <em>all</em> data sources and how often they were
referenced in COVID-19 blog posts.</p>
<div class="${"table-container"}"><table><thead><tr><th align="${"left"}">Data Source</th>
<th align="${"right"}">Count</th></tr></thead>
<tbody><tr><td align="${"left"}">Johns Hopkins University</td>
<td align="${"right"}">51</td></tr>
<tr><td align="${"left"}">New York Times</td>
<td align="${"right"}">14</td></tr>
<tr><td align="${"left"}">Wikipedia</td>
<td align="${"right"}">13</td></tr>
<tr><td align="${"left"}">Apple Mobility</td>
<td align="${"right"}">8</td></tr>
<tr><td align="${"left"}">COVID Tracking Project</td>
<td align="${"right"}">8</td></tr>
<tr><td align="${"left"}">World Bank</td>
<td align="${"right"}">7</td></tr>
<tr><td align="${"left"}">European Centre for Disease Control (ECDC)</td>
<td align="${"right"}">6</td></tr>
<tr><td align="${"left"}">U.S. Census Bureau</td>
<td align="${"right"}">6</td></tr>
<tr><td align="${"left"}">Our World in Data</td>
<td align="${"right"}">5</td></tr>
<tr><td align="${"left"}">Twitter</td>
<td align="${"right"}">5</td></tr>
<tr><td align="${"left"}">Assessment Capacities Project (ACAPS)</td>
<td align="${"right"}">4</td></tr>
<tr><td align="${"left"}">COVID19 package</td>
<td align="${"right"}">4</td></tr></tbody></table></div>
<h3 id="${"blog-post-topics"}"><a href="${"#blog-post-topics"}">Blog post topics</a></h3>
<p>It may also be the case that readers want a summary of blogs, or to only
look at posts that pertain to a certain topic. Assigning each blog post
a primary topic introduces a fair amount of subjectivity, to be sure,
but the hope is that these broad topics will help researchers find
content and colleagues who share similar interests.</p>
<p>Here, a balloon plot shows various categories that the 423 posts address
as their primary topic. Topics fall on the y axis and the blogger\u2019s
category of employment is on the x axis. The size (and opacity) of each
bubble represents the count of posts that match that combination.
Epidemiology leads the way, as might be expected, but quite a few posts
seem to use COVID data to showcase something else, or apply R in novel
ways.</p>
${validate_component(Image, "Image").$$render($$result, {
      alt: "A balloon plot shows the number of posts by topic and employment category. The most common is university/epidemiology (107 posts).",
      src: "../images/post/covid-posts/topicsVer2-1.png"
    }, {}, {})}
<h2 id="${"concluding-thoughts"}"><a href="${"#concluding-thoughts"}">Concluding thoughts</a></h2>
<p>We encourage you to use our <a href="${"https://connorrothschild.shinyapps.io/covid-posts/"}" target="${"_blank"}">Shiny application</a>
to explore the data for yourself. If you\u2019d like to submit your post to
be included, fill out this <a href="${"https://docs.google.com/forms/d/e/1FAIpQLScfob3uBoumXIRcSW83T0GhXCfi-KI_psGxIqtl_rQ5VHu9ZQ/viewform?usp=sf_link"}" target="${"_blank"}">Google Form</a>.</p>
<p>As we note in the footer of the application, the R community is
intelligent and produces interesting content, but not all of us are
experts when it comes to COVID-19. Engaging with these posts will allow
you to better understand the application of R to our current moment, and
perhaps provide feedback to post authors. We do not endorse the findings
of any particular author and encourage you to find accurate, relevant,
and recent information from reputable sources such as the <a href="${"https://www.cdc.gov/"}" target="${"_blank"}">CDC</a> and the <a href="${"https://www.who.int/"}" target="${"_blank"}">WHO</a>.</p>
<p>As always, thanks for reading.</p>`
  })}`;
});
var covidPosts = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Covid_posts,
  metadata: metadata$1
});
var metadata = {
  "layout": "blog",
  "title": "Including R in your Flat Data Workflow",
  "description": "Fetch and clean data automatically with GitHub Actions + R",
  "image": "flat-data-r/header.png",
  "date": "2021-05-02",
  "featured": true,
  "tags": ["r", "github", "tutorial"]
};
var Flat_data_r = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${validate_component(Layout, "Layout_MDSVEX_DEFAULT").$$render($$result, Object.assign($$props, metadata), {}, {
    default: () => `<p>The <a href="${"https://octo.github.com/"}" rel="${"nofollow"}">GitHub OCTO team</a> recently released their first project: <a href="${"https://octo.github.com/project/flat-data"}" rel="${"nofollow"}"><strong>Flat Data</strong></a>. The project aims to offer \u201Ca simple pattern for bringing working datasets into your repositories and versioning them.\u201D And it succeeds in doing so! I recently incorporated Flat Data into <a href="${"https://github.com/connorrothschild/police-killings"}" rel="${"nofollow"}">one of my projects</a>, allowing me to finally stop manually updating the data on a semiregular basis (yikes!). While working, I couldn\u2019t find any documentation on using R with Flat Data. Here, I\u2019ll explain the steps I took to incorporate R scripts into a Flat Data pipeline.</p>
${validate_component(Info, "Info").$$render($$result, {}, {}, {
      default: () => `<p><strong>Note:</strong> If you want to follow along, the GitHub repo can be found <a href="${"https://github.com/connorrothschild/flat-demo-r-processing/"}" rel="${"nofollow"}">here</a>.</p>`
    })}
<h2 id="${"whats-flat-data"}"><a href="${"#whats-flat-data"}">What\u2019s Flat Data?</a></h2>
<p><a href="${"https://octo.github.com/project/flat-data"}" rel="${"nofollow"}">Flat Data</a> solves the problem of carrying out the same repetitive tasks\u2014retrieving, cleaning, and then republishing data\u2014that commonly affects developers who want to present rapidly updating data (for example, COVID-19 data that updates daily). And although alternative solutions exist, Flat Data is easy, intuitive, and integrated directly with your GitHub repository (via <a href="${"https://octo.github.com/project/flat-data"}" rel="${"nofollow"}">GitHub</a>):</p>
${validate_component(Image, "Image").$$render($$result, {
      src: "../images/post/flat-data-r/flat-diagram.png",
      alt: "A diagram showcasing a common Flat Data workflow"
    }, {}, {})}
<p>The idea, as seen above, is essentially to read in data (<em>data.json</em>), conduct some postprocessing (<em>process.js</em>), and output some better data (<em>processed-data.json</em>).</p>
<h2 id="${"doing-it-in-r"}"><a href="${"#doing-it-in-r"}">Doing it in R</a></h2>
<p>The most essential step of a Flat Data project is <em>postprocessing</em>. This occurs <strong>after data retrieval</strong> and <strong>before data output</strong>, and it can be done in a few different languages. By default, the OCTO team\u2019s <a href="${"https://github.com/githubocto/flat-postprocessing/tree/main/examples"}" rel="${"nofollow"}">examples</a> are done in JavaScript/TypeScript, and one user has given an example of postprocessing in <a href="${"https://github.com/pierrotsmnrd/flat_data_py_example"}" rel="${"nofollow"}">Python</a>. To the best of my knowledge, though, there aren\u2019t any examples of including R in the postprocessing stage, hence the reason for this post! </p>
<p><strong>Using R in a Flat Data pipeline is as simple as installing the necessary packages and then sourcing your R cleaning script from a postprocessing TypeScript file.</strong> Let\u2019s explore how that works.</p>
<p>We\u2019ll be grabbing data from the <a href="${"https://mappingpoliceviolence.org/"}" rel="${"nofollow"}">Mapping Police Violence</a> homepage, tidying it up, and then republishing it. (This cleaned data is the source for my <a href="${"https://connorrothschild.github.io/police-killings/"}" rel="${"nofollow"}">visualization</a> on police violence.)  Here\u2019s a sample of the final data output:</p>
<iframe title="${"Flat GitHub data table"}" src="${"https://flatgithub.com/connorrothschild/flat-demo-r-processing?filename=sample.csv&sha=585d7221d2712494195dea616bac68dc864025b1"}" loading="${"lazy"}" style="${"height: 90vh;"}" width="${"100%"}"></iframe>
<h3 id="${"01-setup-flatyml"}"><a href="${"#01-setup-flatyml"}">01. Setup <code>flat.yml</code></a></h3>
<p>The first step in any Flat Data pipeline is to create <code>.github/workflows/flat.yml</code>, which will include the configuration for your project. You can do so by using GitHub\u2019s <a href="${"https://marketplace.visualstudio.com/items?itemName=GitHubOCTO.flat"}" rel="${"nofollow"}">VSCode extension</a>, or by creating your own YAML file manually. The YAML file we use in this project is remarkably similar to the <a href="${"https://github.com/marketplace/actions/flat-data"}" rel="${"nofollow"}">boilerplate</a> file, with a few differences:</p>
${validate_component(Code, "Code").$$render($$result, { language: "yaml", filename: "flat.yml" }, {}, {
      default: () => `<pre class="${"language-undefined"}"><!-- HTML_TAG_START -->${`<code class="language-undefined">name: Update data
on:
  schedule:
    - cron: 0 0 * * * # Runs daily. See https://crontab.cronhub.io/
  workflow_dispatch: &#123;&#125;
  push:
    branches:
      - main # Or master, or whatever branch you&#39;d like to &#39;watch&#39;
jobs:
  scheduled:
    runs-on: ubuntu-latest
    steps:
      # This step installs Deno, which is a Javascript runtime
      - name: Setup deno
        uses: denoland/setup-deno@main
        with:
          deno-version: v1.x
      # Check out the repository so it can read the files inside of it and do other operations
      - name: Check out repo
        uses: actions/checkout@v2
      # The Flat Action step. We fetch the data in the http_url and save it as downloaded_filename
      - name: Fetch data
        uses: githubocto/flat@v2
        with:
          http_url: https://mappingpoliceviolence.org/s/MPVDatasetDownload.xlsx # File to download
          downloaded_filename: raw.xlsx # Name of downloaded file
          postprocess: ./postprocess.ts # Script to run upon download completion</code>`}<!-- HTML_TAG_END --></pre>`
    })}
<p>The tweaks you would make to this workflow are most likely in <code>http_url</code> and <code>schedule</code>. To confirm, visit GitHub\u2019s <a href="${"https://github.com/marketplace/actions/flat-data"}" rel="${"nofollow"}">documentation</a>. </p>
<h2 id="${"02-postprocess"}"><a href="${"#02-postprocess"}">02. Postprocess</a></h2>
<p>We pick up at the last line of code in the previous chunk:</p>
${validate_component(Code, "Code").$$render($$result, { language: "yaml", filename: "flat.yml" }, {}, {
      default: () => `<pre class="${"language-yaml"}"><!-- HTML_TAG_START -->${`<code class="language-yaml"><span class="token key atrule">postprocess</span><span class="token punctuation">:</span> ./postprocess.ts </code>`}<!-- HTML_TAG_END --></pre>`
    })}
<p>Here, we reference a TypeScript file titled <code>postprocess.ts</code>. Upon completion of the data download, GitHub will run <em>this script</em> for any additional processing steps. This file must be a <code>.js</code> or <code>.ts</code> file.</p>
<p>Those who are skilled in data wrangling with JavaScript might be able to write their additional processing <em>in JavaScript itself</em>, but few of us are skilled in data wrangling with JavaScript. Moreover, some users want to migrate their existing projects and workflows to Flat Data, and so including languages other than JavaScript (in this case, R) is essential. </p>
<p>The <code>postprocess.ts</code> file I use in my workflow looks like this (it might help to see how <a href="${"https://deno.land/manual@v1.10.2/examples/subprocess"}" rel="${"nofollow"}">Deno works</a>):</p>
${validate_component(Code, "Code").$$render($$result, {
      language: "javascript",
      filename: "postprocess.ts"
    }, {}, {
      default: () => `<pre class="${"language-js"}"><!-- HTML_TAG_START -->${`<code class="language-js"><span class="token comment">// 1. Install necessary packages</span>
<span class="token keyword">const</span> r_install <span class="token operator">=</span> Deno<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
    cmd<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'sudo'</span><span class="token punctuation">,</span> <span class="token string">'Rscript'</span><span class="token punctuation">,</span> <span class="token string">'-e'</span><span class="token punctuation">,</span> <span class="token string">"install.packages(c('dplyr', 'readxl', 'readr', 'lubridate', 'stringr'))"</span><span class="token punctuation">]</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">await</span> r_install<span class="token punctuation">.</span><span class="token function">status</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 2. Forward the execution to the R script</span>
<span class="token keyword">const</span> r_run <span class="token operator">=</span> Deno<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
    cmd<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'Rscript'</span><span class="token punctuation">,</span> <span class="token string">'./clean.R'</span><span class="token punctuation">]</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">await</span> r_run<span class="token punctuation">.</span><span class="token function">status</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code>`}<!-- HTML_TAG_END --></pre>`
    })}
<p>The above script is rather simple: it 1) installs packages, and 2) runs the processing script, titled <code>clean.R</code>.</p>
<p>The first step is important.  <strong>Package management was the biggest issue I ran into while setting up this workflow; if you\u2019re having issues, pay attention to this step.</strong> You\u2019ll need to identify all the packages that are required in your R processing script, but you can\u2019t install those packages <em>in the script itself</em>, due to virtual machine permissions. You instead have to run them via the command line, using <code>sudo Rscript -e</code>, as I do above (in step 1). </p>
<p>The command <code>sudo Rscript -e</code> precedes any regular function or command that you would run in an R script. It executes those commands via the command line, rather than within a script. (We add sudo to overcome system user permission problems.) For more, see <a href="${"https://stackoverflow.com/questions/18306362/run-r-script-from-command-line"}" rel="${"nofollow"}">this page</a>. </p>
<h2 id="${"03-clean-the-data"}"><a href="${"#03-clean-the-data"}">03. Clean the data!</a></h2>
<p>My <code>clean.R</code> script, which I reference at the bottom of <code>postprocess.ts</code> looks like this:</p>
${validate_component(Code, "Code").$$render($$result, { language: "r", filename: "clean.R" }, {}, {
      default: () => `<pre class="${"language-r"}"><!-- HTML_TAG_START -->${`<code class="language-r"><span class="token comment"># Load libraries</span>
library<span class="token punctuation">(</span>dplyr<span class="token punctuation">)</span>
library<span class="token punctuation">(</span>stringr<span class="token punctuation">)</span>

<span class="token comment"># Read in data, with the same name that we specified in &#96;flat.yml&#96;</span>
raw_data <span class="token operator">&lt;-</span> readxl<span class="token operator">::</span>read_excel<span class="token punctuation">(</span><span class="token string">"./raw.xlsx"</span><span class="token punctuation">)</span>

<span class="token comment"># All the processing!</span>
clean_data <span class="token operator">&lt;-</span> raw_data <span class="token percent-operator operator">%>%</span> 
  mutate<span class="token punctuation">(</span>Zipcode <span class="token operator">=</span> as.character<span class="token punctuation">(</span>Zipcode<span class="token punctuation">)</span><span class="token punctuation">,</span>
         Year <span class="token operator">=</span> lubridate<span class="token operator">::</span>year<span class="token punctuation">(</span>Date<span class="token punctuation">)</span><span class="token punctuation">,</span>
         Sex <span class="token operator">=</span> ifelse<span class="token punctuation">(</span>is.na<span class="token punctuation">(</span>Sex<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'Unknown'</span><span class="token punctuation">,</span> Sex<span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment">### Additional processing goes here...</span>

<span class="token comment"># Output data</span>
readr<span class="token operator">::</span>write_csv<span class="token punctuation">(</span>clean_data<span class="token punctuation">,</span> <span class="token string">"./output.csv"</span><span class="token punctuation">)</span></code>`}<!-- HTML_TAG_END --></pre>`
    })}
<p>Obviously, the content in the above cleaning script is irrelevant. It functions as any other R script would: it reads in data (based on the data we downloaded in <code>postprocess.ts</code>), does some cleaning, and then outputs the new data. The <a href="${"https://github.com/connorrothschild/flat-demo-r-processing/blob/master/clean.R"}" rel="${"nofollow"}">real script</a> is around 55 lines. Now you know why keeping the postprocessing in R was preferable!</p>
<h2 id="${"in-sum"}"><a href="${"#in-sum"}">In sum</a></h2>
<p>Upon completing these steps and pushing the above to a repository, GitHub will automatically set up the action and run it on a daily basis. You can then examine the logs for each run in the <strong>Actions</strong> tab. This tab will be helpful for debugging, and you can force workflow executions manually here as well. In sum, the process of carrying out a GitHub Flat Data workflow, with the addition of an R postprocessing script, looks something like this:</p>
${validate_component(Image, "Image").$$render($$result, {
      src: "../images/post/flat-data-r/header.png",
      alt: "Diagram of flat data processing in R"
    }, {}, {})}
<p>Thanks for reading! You might learn more by perusing the <a href="${"https://github.com/connorrothschild/flat-demo-r-processing"}" rel="${"nofollow"}">GitHub repository</a> that accompanies this post; otherwise, please send any questions via <a href="${"https://twitter.com/CL_Rothschild"}" rel="${"nofollow"}">Twitter</a> \u{1F642}</p>`
  })}`;
});
var flatDataR = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Flat_data_r,
  metadata
});

// .svelte-kit/netlify/entry.js
init();
async function handler(event) {
  const { path, httpMethod, headers, rawQuery, body, isBase64Encoded } = event;
  const query = new URLSearchParams(rawQuery);
  const encoding = isBase64Encoded ? "base64" : headers["content-encoding"] || "utf-8";
  const rawBody = typeof body === "string" ? Buffer.from(body, encoding) : body;
  const rendered = await render({
    method: httpMethod,
    headers,
    path,
    query,
    rawBody
  });
  if (rendered) {
    return {
      isBase64Encoded: false,
      statusCode: rendered.status,
      ...splitHeaders(rendered.headers),
      body: rendered.body
    };
  }
  return {
    statusCode: 404,
    body: "Not found"
  };
}
function splitHeaders(headers) {
  const h = {};
  const m = {};
  for (const key in headers) {
    const value = headers[key];
    const target = Array.isArray(value) ? m : h;
    target[key] = value;
  }
  return {
    headers: h,
    multiValueHeaders: m
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  handler
});
/*!
 * GSAP 3.8.0
 * https://greensock.com
 *
 * @license Copyright 2008-2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
/*!
 * MorphSVGPlugin 3.8.0
 * https://greensock.com
 *
 * @license Copyright 2008-2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
/**
 * Prism: Lightweight, robust, elegant syntax highlighting
 *
 * @license MIT <https://opensource.org/licenses/MIT>
 * @author Lea Verou <https://lea.verou.me>
 * @namespace
 * @public
 */
